(() => {
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };

  // node_modules/jquery/dist/jquery.js
  var require_jquery = __commonJS({
    "node_modules/jquery/dist/jquery.js"(exports, module) {
      (function(global2, factory) {
        "use strict";
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = global2.document ? factory(global2, true) : function(w) {
            if (!w.document) {
              throw new Error("jQuery requires a window with a document");
            }
            return factory(w);
          };
        } else {
          factory(global2);
        }
      })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
        "use strict";
        var arr = [];
        var getProto = Object.getPrototypeOf;
        var slice = arr.slice;
        var flat = arr.flat ? function(array) {
          return arr.flat.call(array);
        } : function(array) {
          return arr.concat.apply([], array);
        };
        var push = arr.push;
        var indexOf = arr.indexOf;
        var class2type = {};
        var toString = class2type.toString;
        var hasOwn = class2type.hasOwnProperty;
        var fnToString = hasOwn.toString;
        var ObjectFunctionString = fnToString.call(Object);
        var support = {};
        var isFunction = function isFunction2(obj) {
          return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
        };
        var isWindow = function isWindow2(obj) {
          return obj != null && obj === obj.window;
        };
        var document2 = window2.document;
        var preservedScriptAttributes = {
          type: true,
          src: true,
          nonce: true,
          noModule: true
        };
        function DOMEval(code, node, doc) {
          doc = doc || document2;
          var i, val, script = doc.createElement("script");
          script.text = code;
          if (node) {
            for (i in preservedScriptAttributes) {
              val = node[i] || node.getAttribute && node.getAttribute(i);
              if (val) {
                script.setAttribute(i, val);
              }
            }
          }
          doc.head.appendChild(script).parentNode.removeChild(script);
        }
        function toType(obj) {
          if (obj == null) {
            return obj + "";
          }
          return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
        }
        var version = "3.6.0", jQuery2 = function(selector, context) {
          return new jQuery2.fn.init(selector, context);
        };
        jQuery2.fn = jQuery2.prototype = {
          jquery: version,
          constructor: jQuery2,
          length: 0,
          toArray: function() {
            return slice.call(this);
          },
          get: function(num) {
            if (num == null) {
              return slice.call(this);
            }
            return num < 0 ? this[num + this.length] : this[num];
          },
          pushStack: function(elems) {
            var ret = jQuery2.merge(this.constructor(), elems);
            ret.prevObject = this;
            return ret;
          },
          each: function(callback) {
            return jQuery2.each(this, callback);
          },
          map: function(callback) {
            return this.pushStack(jQuery2.map(this, function(elem, i) {
              return callback.call(elem, i, elem);
            }));
          },
          slice: function() {
            return this.pushStack(slice.apply(this, arguments));
          },
          first: function() {
            return this.eq(0);
          },
          last: function() {
            return this.eq(-1);
          },
          even: function() {
            return this.pushStack(jQuery2.grep(this, function(_elem, i) {
              return (i + 1) % 2;
            }));
          },
          odd: function() {
            return this.pushStack(jQuery2.grep(this, function(_elem, i) {
              return i % 2;
            }));
          },
          eq: function(i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
          },
          end: function() {
            return this.prevObject || this.constructor();
          },
          push,
          sort: arr.sort,
          splice: arr.splice
        };
        jQuery2.extend = jQuery2.fn.extend = function() {
          var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
          if (typeof target === "boolean") {
            deep = target;
            target = arguments[i] || {};
            i++;
          }
          if (typeof target !== "object" && !isFunction(target)) {
            target = {};
          }
          if (i === length) {
            target = this;
            i--;
          }
          for (; i < length; i++) {
            if ((options = arguments[i]) != null) {
              for (name in options) {
                copy = options[name];
                if (name === "__proto__" || target === copy) {
                  continue;
                }
                if (deep && copy && (jQuery2.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                  src = target[name];
                  if (copyIsArray && !Array.isArray(src)) {
                    clone = [];
                  } else if (!copyIsArray && !jQuery2.isPlainObject(src)) {
                    clone = {};
                  } else {
                    clone = src;
                  }
                  copyIsArray = false;
                  target[name] = jQuery2.extend(deep, clone, copy);
                } else if (copy !== void 0) {
                  target[name] = copy;
                }
              }
            }
          }
          return target;
        };
        jQuery2.extend({
          expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
          isReady: true,
          error: function(msg) {
            throw new Error(msg);
          },
          noop: function() {
          },
          isPlainObject: function(obj) {
            var proto, Ctor;
            if (!obj || toString.call(obj) !== "[object Object]") {
              return false;
            }
            proto = getProto(obj);
            if (!proto) {
              return true;
            }
            Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
            return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
          },
          isEmptyObject: function(obj) {
            var name;
            for (name in obj) {
              return false;
            }
            return true;
          },
          globalEval: function(code, options, doc) {
            DOMEval(code, { nonce: options && options.nonce }, doc);
          },
          each: function(obj, callback) {
            var length, i = 0;
            if (isArrayLike(obj)) {
              length = obj.length;
              for (; i < length; i++) {
                if (callback.call(obj[i], i, obj[i]) === false) {
                  break;
                }
              }
            } else {
              for (i in obj) {
                if (callback.call(obj[i], i, obj[i]) === false) {
                  break;
                }
              }
            }
            return obj;
          },
          makeArray: function(arr2, results) {
            var ret = results || [];
            if (arr2 != null) {
              if (isArrayLike(Object(arr2))) {
                jQuery2.merge(
                  ret,
                  typeof arr2 === "string" ? [arr2] : arr2
                );
              } else {
                push.call(ret, arr2);
              }
            }
            return ret;
          },
          inArray: function(elem, arr2, i) {
            return arr2 == null ? -1 : indexOf.call(arr2, elem, i);
          },
          merge: function(first, second) {
            var len = +second.length, j = 0, i = first.length;
            for (; j < len; j++) {
              first[i++] = second[j];
            }
            first.length = i;
            return first;
          },
          grep: function(elems, callback, invert) {
            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
            for (; i < length; i++) {
              callbackInverse = !callback(elems[i], i);
              if (callbackInverse !== callbackExpect) {
                matches.push(elems[i]);
              }
            }
            return matches;
          },
          map: function(elems, callback, arg) {
            var length, value, i = 0, ret = [];
            if (isArrayLike(elems)) {
              length = elems.length;
              for (; i < length; i++) {
                value = callback(elems[i], i, arg);
                if (value != null) {
                  ret.push(value);
                }
              }
            } else {
              for (i in elems) {
                value = callback(elems[i], i, arg);
                if (value != null) {
                  ret.push(value);
                }
              }
            }
            return flat(ret);
          },
          guid: 1,
          support
        });
        if (typeof Symbol === "function") {
          jQuery2.fn[Symbol.iterator] = arr[Symbol.iterator];
        }
        jQuery2.each(
          "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
          function(_i, name) {
            class2type["[object " + name + "]"] = name.toLowerCase();
          }
        );
        function isArrayLike(obj) {
          var length = !!obj && "length" in obj && obj.length, type = toType(obj);
          if (isFunction(obj) || isWindow(obj)) {
            return false;
          }
          return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
        }
        var Sizzle = function(window3) {
          var i, support2, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document3, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date(), preferredDoc = window3.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a, b) {
            if (a === b) {
              hasDuplicate = true;
            }
            return 0;
          }, hasOwn2 = {}.hasOwnProperty, arr2 = [], pop = arr2.pop, pushNative = arr2.push, push2 = arr2.push, slice2 = arr2.slice, indexOf2 = function(list, elem) {
            var i2 = 0, len = list.length;
            for (; i2 < len; i2++) {
              if (list[i2] === elem) {
                return i2;
              }
            }
            return -1;
          }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rtrim2 = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rdescend = new RegExp(whitespace + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
            "ID": new RegExp("^#(" + identifier + ")"),
            "CLASS": new RegExp("^\\.(" + identifier + ")"),
            "TAG": new RegExp("^(" + identifier + "|[*])"),
            "ATTR": new RegExp("^" + attributes),
            "PSEUDO": new RegExp("^" + pseudos),
            "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
            "bool": new RegExp("^(?:" + booleans + ")$", "i"),
            "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
          }, rhtml2 = /HTML$/i, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape, nonHex) {
            var high = "0x" + escape.slice(1) - 65536;
            return nonHex ? nonHex : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
          }, rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function(ch, asCodePoint) {
            if (asCodePoint) {
              if (ch === "\0") {
                return "\uFFFD";
              }
              return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
            }
            return "\\" + ch;
          }, unloadHandler = function() {
            setDocument();
          }, inDisabledFieldset = addCombinator(
            function(elem) {
              return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
            },
            { dir: "parentNode", next: "legend" }
          );
          try {
            push2.apply(
              arr2 = slice2.call(preferredDoc.childNodes),
              preferredDoc.childNodes
            );
            arr2[preferredDoc.childNodes.length].nodeType;
          } catch (e) {
            push2 = {
              apply: arr2.length ? function(target, els) {
                pushNative.apply(target, slice2.call(els));
              } : function(target, els) {
                var j = target.length, i2 = 0;
                while (target[j++] = els[i2++]) {
                }
                target.length = j - 1;
              }
            };
          }
          function Sizzle2(selector, context, results, seed) {
            var m, i2, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
            results = results || [];
            if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
              return results;
            }
            if (!seed) {
              setDocument(context);
              context = context || document3;
              if (documentIsHTML) {
                if (nodeType !== 11 && (match = rquickExpr2.exec(selector))) {
                  if (m = match[1]) {
                    if (nodeType === 9) {
                      if (elem = context.getElementById(m)) {
                        if (elem.id === m) {
                          results.push(elem);
                          return results;
                        }
                      } else {
                        return results;
                      }
                    } else {
                      if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                        results.push(elem);
                        return results;
                      }
                    }
                  } else if (match[2]) {
                    push2.apply(results, context.getElementsByTagName(selector));
                    return results;
                  } else if ((m = match[3]) && support2.getElementsByClassName && context.getElementsByClassName) {
                    push2.apply(results, context.getElementsByClassName(m));
                    return results;
                  }
                }
                if (support2.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && (nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {
                  newSelector = selector;
                  newContext = context;
                  if (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {
                    newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                    if (newContext !== context || !support2.scope) {
                      if (nid = context.getAttribute("id")) {
                        nid = nid.replace(rcssescape, fcssescape);
                      } else {
                        context.setAttribute("id", nid = expando);
                      }
                    }
                    groups = tokenize(selector);
                    i2 = groups.length;
                    while (i2--) {
                      groups[i2] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i2]);
                    }
                    newSelector = groups.join(",");
                  }
                  try {
                    push2.apply(
                      results,
                      newContext.querySelectorAll(newSelector)
                    );
                    return results;
                  } catch (qsaError) {
                    nonnativeSelectorCache(selector, true);
                  } finally {
                    if (nid === expando) {
                      context.removeAttribute("id");
                    }
                  }
                }
              }
            }
            return select(selector.replace(rtrim2, "$1"), context, results, seed);
          }
          function createCache() {
            var keys = [];
            function cache(key, value) {
              if (keys.push(key + " ") > Expr.cacheLength) {
                delete cache[keys.shift()];
              }
              return cache[key + " "] = value;
            }
            return cache;
          }
          function markFunction(fn) {
            fn[expando] = true;
            return fn;
          }
          function assert(fn) {
            var el = document3.createElement("fieldset");
            try {
              return !!fn(el);
            } catch (e) {
              return false;
            } finally {
              if (el.parentNode) {
                el.parentNode.removeChild(el);
              }
              el = null;
            }
          }
          function addHandle(attrs, handler) {
            var arr3 = attrs.split("|"), i2 = arr3.length;
            while (i2--) {
              Expr.attrHandle[arr3[i2]] = handler;
            }
          }
          function siblingCheck(a, b) {
            var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
            if (diff) {
              return diff;
            }
            if (cur) {
              while (cur = cur.nextSibling) {
                if (cur === b) {
                  return -1;
                }
              }
            }
            return a ? 1 : -1;
          }
          function createInputPseudo(type) {
            return function(elem) {
              var name = elem.nodeName.toLowerCase();
              return name === "input" && elem.type === type;
            };
          }
          function createButtonPseudo(type) {
            return function(elem) {
              var name = elem.nodeName.toLowerCase();
              return (name === "input" || name === "button") && elem.type === type;
            };
          }
          function createDisabledPseudo(disabled) {
            return function(elem) {
              if ("form" in elem) {
                if (elem.parentNode && elem.disabled === false) {
                  if ("label" in elem) {
                    if ("label" in elem.parentNode) {
                      return elem.parentNode.disabled === disabled;
                    } else {
                      return elem.disabled === disabled;
                    }
                  }
                  return elem.isDisabled === disabled || elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
                }
                return elem.disabled === disabled;
              } else if ("label" in elem) {
                return elem.disabled === disabled;
              }
              return false;
            };
          }
          function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
              argument = +argument;
              return markFunction(function(seed, matches2) {
                var j, matchIndexes = fn([], seed.length, argument), i2 = matchIndexes.length;
                while (i2--) {
                  if (seed[j = matchIndexes[i2]]) {
                    seed[j] = !(matches2[j] = seed[j]);
                  }
                }
              });
            });
          }
          function testContext(context) {
            return context && typeof context.getElementsByTagName !== "undefined" && context;
          }
          support2 = Sizzle2.support = {};
          isXML = Sizzle2.isXML = function(elem) {
            var namespace = elem && elem.namespaceURI, docElem2 = elem && (elem.ownerDocument || elem).documentElement;
            return !rhtml2.test(namespace || docElem2 && docElem2.nodeName || "HTML");
          };
          setDocument = Sizzle2.setDocument = function(node) {
            var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
            if (doc == document3 || doc.nodeType !== 9 || !doc.documentElement) {
              return document3;
            }
            document3 = doc;
            docElem = document3.documentElement;
            documentIsHTML = !isXML(document3);
            if (preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
              if (subWindow.addEventListener) {
                subWindow.addEventListener("unload", unloadHandler, false);
              } else if (subWindow.attachEvent) {
                subWindow.attachEvent("onunload", unloadHandler);
              }
            }
            support2.scope = assert(function(el) {
              docElem.appendChild(el).appendChild(document3.createElement("div"));
              return typeof el.querySelectorAll !== "undefined" && !el.querySelectorAll(":scope fieldset div").length;
            });
            support2.attributes = assert(function(el) {
              el.className = "i";
              return !el.getAttribute("className");
            });
            support2.getElementsByTagName = assert(function(el) {
              el.appendChild(document3.createComment(""));
              return !el.getElementsByTagName("*").length;
            });
            support2.getElementsByClassName = rnative.test(document3.getElementsByClassName);
            support2.getById = assert(function(el) {
              docElem.appendChild(el).id = expando;
              return !document3.getElementsByName || !document3.getElementsByName(expando).length;
            });
            if (support2.getById) {
              Expr.filter["ID"] = function(id) {
                var attrId = id.replace(runescape, funescape);
                return function(elem) {
                  return elem.getAttribute("id") === attrId;
                };
              };
              Expr.find["ID"] = function(id, context) {
                if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                  var elem = context.getElementById(id);
                  return elem ? [elem] : [];
                }
              };
            } else {
              Expr.filter["ID"] = function(id) {
                var attrId = id.replace(runescape, funescape);
                return function(elem) {
                  var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                  return node2 && node2.value === attrId;
                };
              };
              Expr.find["ID"] = function(id, context) {
                if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                  var node2, i2, elems, elem = context.getElementById(id);
                  if (elem) {
                    node2 = elem.getAttributeNode("id");
                    if (node2 && node2.value === id) {
                      return [elem];
                    }
                    elems = context.getElementsByName(id);
                    i2 = 0;
                    while (elem = elems[i2++]) {
                      node2 = elem.getAttributeNode("id");
                      if (node2 && node2.value === id) {
                        return [elem];
                      }
                    }
                  }
                  return [];
                }
              };
            }
            Expr.find["TAG"] = support2.getElementsByTagName ? function(tag, context) {
              if (typeof context.getElementsByTagName !== "undefined") {
                return context.getElementsByTagName(tag);
              } else if (support2.qsa) {
                return context.querySelectorAll(tag);
              }
            } : function(tag, context) {
              var elem, tmp = [], i2 = 0, results = context.getElementsByTagName(tag);
              if (tag === "*") {
                while (elem = results[i2++]) {
                  if (elem.nodeType === 1) {
                    tmp.push(elem);
                  }
                }
                return tmp;
              }
              return results;
            };
            Expr.find["CLASS"] = support2.getElementsByClassName && function(className, context) {
              if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
                return context.getElementsByClassName(className);
              }
            };
            rbuggyMatches = [];
            rbuggyQSA = [];
            if (support2.qsa = rnative.test(document3.querySelectorAll)) {
              assert(function(el) {
                var input;
                docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\r\\' msallowcapture=''><option selected=''></option></select>";
                if (el.querySelectorAll("[msallowcapture^='']").length) {
                  rbuggyQSA.push("[*^$]=" + whitespace + `*(?:''|"")`);
                }
                if (!el.querySelectorAll("[selected]").length) {
                  rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                }
                if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
                  rbuggyQSA.push("~=");
                }
                input = document3.createElement("input");
                input.setAttribute("name", "");
                el.appendChild(input);
                if (!el.querySelectorAll("[name='']").length) {
                  rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + `*(?:''|"")`);
                }
                if (!el.querySelectorAll(":checked").length) {
                  rbuggyQSA.push(":checked");
                }
                if (!el.querySelectorAll("a#" + expando + "+*").length) {
                  rbuggyQSA.push(".#.+[+~]");
                }
                el.querySelectorAll("\\\f");
                rbuggyQSA.push("[\\r\\n\\f]");
              });
              assert(function(el) {
                el.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                var input = document3.createElement("input");
                input.setAttribute("type", "hidden");
                el.appendChild(input).setAttribute("name", "D");
                if (el.querySelectorAll("[name=d]").length) {
                  rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                }
                if (el.querySelectorAll(":enabled").length !== 2) {
                  rbuggyQSA.push(":enabled", ":disabled");
                }
                docElem.appendChild(el).disabled = true;
                if (el.querySelectorAll(":disabled").length !== 2) {
                  rbuggyQSA.push(":enabled", ":disabled");
                }
                el.querySelectorAll("*,:x");
                rbuggyQSA.push(",.*:");
              });
            }
            if (support2.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
              assert(function(el) {
                support2.disconnectedMatch = matches.call(el, "*");
                matches.call(el, "[s!='']:x");
                rbuggyMatches.push("!=", pseudos);
              });
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
            hasCompare = rnative.test(docElem.compareDocumentPosition);
            contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
              var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
              return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            } : function(a, b) {
              if (b) {
                while (b = b.parentNode) {
                  if (b === a) {
                    return true;
                  }
                }
              }
              return false;
            };
            sortOrder = hasCompare ? function(a, b) {
              if (a === b) {
                hasDuplicate = true;
                return 0;
              }
              var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
              if (compare) {
                return compare;
              }
              compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
              if (compare & 1 || !support2.sortDetached && b.compareDocumentPosition(a) === compare) {
                if (a == document3 || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) {
                  return -1;
                }
                if (b == document3 || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) {
                  return 1;
                }
                return sortInput ? indexOf2(sortInput, a) - indexOf2(sortInput, b) : 0;
              }
              return compare & 4 ? -1 : 1;
            } : function(a, b) {
              if (a === b) {
                hasDuplicate = true;
                return 0;
              }
              var cur, i2 = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
              if (!aup || !bup) {
                return a == document3 ? -1 : b == document3 ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf2(sortInput, a) - indexOf2(sortInput, b) : 0;
              } else if (aup === bup) {
                return siblingCheck(a, b);
              }
              cur = a;
              while (cur = cur.parentNode) {
                ap.unshift(cur);
              }
              cur = b;
              while (cur = cur.parentNode) {
                bp.unshift(cur);
              }
              while (ap[i2] === bp[i2]) {
                i2++;
              }
              return i2 ? siblingCheck(ap[i2], bp[i2]) : ap[i2] == preferredDoc ? -1 : bp[i2] == preferredDoc ? 1 : 0;
            };
            return document3;
          };
          Sizzle2.matches = function(expr, elements) {
            return Sizzle2(expr, null, null, elements);
          };
          Sizzle2.matchesSelector = function(elem, expr) {
            setDocument(elem);
            if (support2.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
              try {
                var ret = matches.call(elem, expr);
                if (ret || support2.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                  return ret;
                }
              } catch (e) {
                nonnativeSelectorCache(expr, true);
              }
            }
            return Sizzle2(expr, document3, null, [elem]).length > 0;
          };
          Sizzle2.contains = function(context, elem) {
            if ((context.ownerDocument || context) != document3) {
              setDocument(context);
            }
            return contains(context, elem);
          };
          Sizzle2.attr = function(elem, name) {
            if ((elem.ownerDocument || elem) != document3) {
              setDocument(elem);
            }
            var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn2.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
            return val !== void 0 ? val : support2.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
          };
          Sizzle2.escape = function(sel) {
            return (sel + "").replace(rcssescape, fcssescape);
          };
          Sizzle2.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
          };
          Sizzle2.uniqueSort = function(results) {
            var elem, duplicates = [], j = 0, i2 = 0;
            hasDuplicate = !support2.detectDuplicates;
            sortInput = !support2.sortStable && results.slice(0);
            results.sort(sortOrder);
            if (hasDuplicate) {
              while (elem = results[i2++]) {
                if (elem === results[i2]) {
                  j = duplicates.push(i2);
                }
              }
              while (j--) {
                results.splice(duplicates[j], 1);
              }
            }
            sortInput = null;
            return results;
          };
          getText = Sizzle2.getText = function(elem) {
            var node, ret = "", i2 = 0, nodeType = elem.nodeType;
            if (!nodeType) {
              while (node = elem[i2++]) {
                ret += getText(node);
              }
            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
              if (typeof elem.textContent === "string") {
                return elem.textContent;
              } else {
                for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                  ret += getText(elem);
                }
              }
            } else if (nodeType === 3 || nodeType === 4) {
              return elem.nodeValue;
            }
            return ret;
          };
          Expr = Sizzle2.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
              ">": { dir: "parentNode", first: true },
              " ": { dir: "parentNode" },
              "+": { dir: "previousSibling", first: true },
              "~": { dir: "previousSibling" }
            },
            preFilter: {
              "ATTR": function(match) {
                match[1] = match[1].replace(runescape, funescape);
                match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
                if (match[2] === "~=") {
                  match[3] = " " + match[3] + " ";
                }
                return match.slice(0, 4);
              },
              "CHILD": function(match) {
                match[1] = match[1].toLowerCase();
                if (match[1].slice(0, 3) === "nth") {
                  if (!match[3]) {
                    Sizzle2.error(match[0]);
                  }
                  match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                  match[5] = +(match[7] + match[8] || match[3] === "odd");
                } else if (match[3]) {
                  Sizzle2.error(match[0]);
                }
                return match;
              },
              "PSEUDO": function(match) {
                var excess, unquoted = !match[6] && match[2];
                if (matchExpr["CHILD"].test(match[0])) {
                  return null;
                }
                if (match[3]) {
                  match[2] = match[4] || match[5] || "";
                } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                  match[0] = match[0].slice(0, excess);
                  match[2] = unquoted.slice(0, excess);
                }
                return match.slice(0, 3);
              }
            },
            filter: {
              "TAG": function(nodeNameSelector) {
                var nodeName2 = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                return nodeNameSelector === "*" ? function() {
                  return true;
                } : function(elem) {
                  return elem.nodeName && elem.nodeName.toLowerCase() === nodeName2;
                };
              },
              "CLASS": function(className) {
                var pattern = classCache[className + " "];
                return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(
                  className,
                  function(elem) {
                    return pattern.test(
                      typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || ""
                    );
                  }
                );
              },
              "ATTR": function(name, operator, check) {
                return function(elem) {
                  var result = Sizzle2.attr(elem, name);
                  if (result == null) {
                    return operator === "!=";
                  }
                  if (!operator) {
                    return true;
                  }
                  result += "";
                  return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
                };
              },
              "CHILD": function(type, what, _argument, first, last) {
                var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                return first === 1 && last === 0 ? function(elem) {
                  return !!elem.parentNode;
                } : function(elem, _context, xml) {
                  var cache, uniqueCache, outerCache, node, nodeIndex, start, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                  if (parent) {
                    if (simple) {
                      while (dir2) {
                        node = elem;
                        while (node = node[dir2]) {
                          if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                            return false;
                          }
                        }
                        start = dir2 = type === "only" && !start && "nextSibling";
                      }
                      return true;
                    }
                    start = [forward ? parent.firstChild : parent.lastChild];
                    if (forward && useCache) {
                      node = parent;
                      outerCache = node[expando] || (node[expando] = {});
                      uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                      cache = uniqueCache[type] || [];
                      nodeIndex = cache[0] === dirruns && cache[1];
                      diff = nodeIndex && cache[2];
                      node = nodeIndex && parent.childNodes[nodeIndex];
                      while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start.pop()) {
                        if (node.nodeType === 1 && ++diff && node === elem) {
                          uniqueCache[type] = [dirruns, nodeIndex, diff];
                          break;
                        }
                      }
                    } else {
                      if (useCache) {
                        node = elem;
                        outerCache = node[expando] || (node[expando] = {});
                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                        cache = uniqueCache[type] || [];
                        nodeIndex = cache[0] === dirruns && cache[1];
                        diff = nodeIndex;
                      }
                      if (diff === false) {
                        while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start.pop()) {
                          if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                            if (useCache) {
                              outerCache = node[expando] || (node[expando] = {});
                              uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                              uniqueCache[type] = [dirruns, diff];
                            }
                            if (node === elem) {
                              break;
                            }
                          }
                        }
                      }
                    }
                    diff -= last;
                    return diff === first || diff % first === 0 && diff / first >= 0;
                  }
                };
              },
              "PSEUDO": function(pseudo, argument) {
                var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle2.error("unsupported pseudo: " + pseudo);
                if (fn[expando]) {
                  return fn(argument);
                }
                if (fn.length > 1) {
                  args = [pseudo, pseudo, "", argument];
                  return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches2) {
                    var idx, matched = fn(seed, argument), i2 = matched.length;
                    while (i2--) {
                      idx = indexOf2(seed, matched[i2]);
                      seed[idx] = !(matches2[idx] = matched[i2]);
                    }
                  }) : function(elem) {
                    return fn(elem, 0, args);
                  };
                }
                return fn;
              }
            },
            pseudos: {
              "not": markFunction(function(selector) {
                var input = [], results = [], matcher = compile(selector.replace(rtrim2, "$1"));
                return matcher[expando] ? markFunction(function(seed, matches2, _context, xml) {
                  var elem, unmatched = matcher(seed, null, xml, []), i2 = seed.length;
                  while (i2--) {
                    if (elem = unmatched[i2]) {
                      seed[i2] = !(matches2[i2] = elem);
                    }
                  }
                }) : function(elem, _context, xml) {
                  input[0] = elem;
                  matcher(input, null, xml, results);
                  input[0] = null;
                  return !results.pop();
                };
              }),
              "has": markFunction(function(selector) {
                return function(elem) {
                  return Sizzle2(selector, elem).length > 0;
                };
              }),
              "contains": markFunction(function(text) {
                text = text.replace(runescape, funescape);
                return function(elem) {
                  return (elem.textContent || getText(elem)).indexOf(text) > -1;
                };
              }),
              "lang": markFunction(function(lang) {
                if (!ridentifier.test(lang || "")) {
                  Sizzle2.error("unsupported lang: " + lang);
                }
                lang = lang.replace(runescape, funescape).toLowerCase();
                return function(elem) {
                  var elemLang;
                  do {
                    if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                      elemLang = elemLang.toLowerCase();
                      return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                    }
                  } while ((elem = elem.parentNode) && elem.nodeType === 1);
                  return false;
                };
              }),
              "target": function(elem) {
                var hash = window3.location && window3.location.hash;
                return hash && hash.slice(1) === elem.id;
              },
              "root": function(elem) {
                return elem === docElem;
              },
              "focus": function(elem) {
                return elem === document3.activeElement && (!document3.hasFocus || document3.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
              },
              "enabled": createDisabledPseudo(false),
              "disabled": createDisabledPseudo(true),
              "checked": function(elem) {
                var nodeName2 = elem.nodeName.toLowerCase();
                return nodeName2 === "input" && !!elem.checked || nodeName2 === "option" && !!elem.selected;
              },
              "selected": function(elem) {
                if (elem.parentNode) {
                  elem.parentNode.selectedIndex;
                }
                return elem.selected === true;
              },
              "empty": function(elem) {
                for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                  if (elem.nodeType < 6) {
                    return false;
                  }
                }
                return true;
              },
              "parent": function(elem) {
                return !Expr.pseudos["empty"](elem);
              },
              "header": function(elem) {
                return rheader.test(elem.nodeName);
              },
              "input": function(elem) {
                return rinputs.test(elem.nodeName);
              },
              "button": function(elem) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === "button" || name === "button";
              },
              "text": function(elem) {
                var attr;
                return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
              },
              "first": createPositionalPseudo(function() {
                return [0];
              }),
              "last": createPositionalPseudo(function(_matchIndexes, length) {
                return [length - 1];
              }),
              "eq": createPositionalPseudo(function(_matchIndexes, length, argument) {
                return [argument < 0 ? argument + length : argument];
              }),
              "even": createPositionalPseudo(function(matchIndexes, length) {
                var i2 = 0;
                for (; i2 < length; i2 += 2) {
                  matchIndexes.push(i2);
                }
                return matchIndexes;
              }),
              "odd": createPositionalPseudo(function(matchIndexes, length) {
                var i2 = 1;
                for (; i2 < length; i2 += 2) {
                  matchIndexes.push(i2);
                }
                return matchIndexes;
              }),
              "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
                var i2 = argument < 0 ? argument + length : argument > length ? length : argument;
                for (; --i2 >= 0; ) {
                  matchIndexes.push(i2);
                }
                return matchIndexes;
              }),
              "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
                var i2 = argument < 0 ? argument + length : argument;
                for (; ++i2 < length; ) {
                  matchIndexes.push(i2);
                }
                return matchIndexes;
              })
            }
          };
          Expr.pseudos["nth"] = Expr.pseudos["eq"];
          for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
            Expr.pseudos[i] = createInputPseudo(i);
          }
          for (i in { submit: true, reset: true }) {
            Expr.pseudos[i] = createButtonPseudo(i);
          }
          function setFilters() {
          }
          setFilters.prototype = Expr.filters = Expr.pseudos;
          Expr.setFilters = new setFilters();
          tokenize = Sizzle2.tokenize = function(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) {
              return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
              if (!matched || (match = rcomma.exec(soFar))) {
                if (match) {
                  soFar = soFar.slice(match[0].length) || soFar;
                }
                groups.push(tokens = []);
              }
              matched = false;
              if (match = rcombinators.exec(soFar)) {
                matched = match.shift();
                tokens.push({
                  value: matched,
                  type: match[0].replace(rtrim2, " ")
                });
                soFar = soFar.slice(matched.length);
              }
              for (type in Expr.filter) {
                if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                  matched = match.shift();
                  tokens.push({
                    value: matched,
                    type,
                    matches: match
                  });
                  soFar = soFar.slice(matched.length);
                }
              }
              if (!matched) {
                break;
              }
            }
            return parseOnly ? soFar.length : soFar ? Sizzle2.error(selector) : tokenCache(selector, groups).slice(0);
          };
          function toSelector(tokens) {
            var i2 = 0, len = tokens.length, selector = "";
            for (; i2 < len; i2++) {
              selector += tokens[i2].value;
            }
            return selector;
          }
          function addCombinator(matcher, combinator, base) {
            var dir2 = combinator.dir, skip = combinator.next, key = skip || dir2, checkNonElements = base && key === "parentNode", doneName = done++;
            return combinator.first ? function(elem, context, xml) {
              while (elem = elem[dir2]) {
                if (elem.nodeType === 1 || checkNonElements) {
                  return matcher(elem, context, xml);
                }
              }
              return false;
            } : function(elem, context, xml) {
              var oldCache, uniqueCache, outerCache, newCache = [dirruns, doneName];
              if (xml) {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    if (matcher(elem, context, xml)) {
                      return true;
                    }
                  }
                }
              } else {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    outerCache = elem[expando] || (elem[expando] = {});
                    uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
                    if (skip && skip === elem.nodeName.toLowerCase()) {
                      elem = elem[dir2] || elem;
                    } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                      return newCache[2] = oldCache[2];
                    } else {
                      uniqueCache[key] = newCache;
                      if (newCache[2] = matcher(elem, context, xml)) {
                        return true;
                      }
                    }
                  }
                }
              }
              return false;
            };
          }
          function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
              var i2 = matchers.length;
              while (i2--) {
                if (!matchers[i2](elem, context, xml)) {
                  return false;
                }
              }
              return true;
            } : matchers[0];
          }
          function multipleContexts(selector, contexts2, results) {
            var i2 = 0, len = contexts2.length;
            for (; i2 < len; i2++) {
              Sizzle2(selector, contexts2[i2], results);
            }
            return results;
          }
          function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i2 = 0, len = unmatched.length, mapped = map != null;
            for (; i2 < len; i2++) {
              if (elem = unmatched[i2]) {
                if (!filter || filter(elem, context, xml)) {
                  newUnmatched.push(elem);
                  if (mapped) {
                    map.push(i2);
                  }
                }
              }
            }
            return newUnmatched;
          }
          function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
              postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
              postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function(seed, results, context, xml) {
              var temp, i2, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(
                selector || "*",
                context.nodeType ? [context] : context,
                []
              ), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
              if (matcher) {
                matcher(matcherIn, matcherOut, context, xml);
              }
              if (postFilter) {
                temp = condense(matcherOut, postMap);
                postFilter(temp, [], context, xml);
                i2 = temp.length;
                while (i2--) {
                  if (elem = temp[i2]) {
                    matcherOut[postMap[i2]] = !(matcherIn[postMap[i2]] = elem);
                  }
                }
              }
              if (seed) {
                if (postFinder || preFilter) {
                  if (postFinder) {
                    temp = [];
                    i2 = matcherOut.length;
                    while (i2--) {
                      if (elem = matcherOut[i2]) {
                        temp.push(matcherIn[i2] = elem);
                      }
                    }
                    postFinder(null, matcherOut = [], temp, xml);
                  }
                  i2 = matcherOut.length;
                  while (i2--) {
                    if ((elem = matcherOut[i2]) && (temp = postFinder ? indexOf2(seed, elem) : preMap[i2]) > -1) {
                      seed[temp] = !(results[temp] = elem);
                    }
                  }
                }
              } else {
                matcherOut = condense(
                  matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
                );
                if (postFinder) {
                  postFinder(null, results, matcherOut, xml);
                } else {
                  push2.apply(results, matcherOut);
                }
              }
            });
          }
          function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i2 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
              return elem === checkContext;
            }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
              return indexOf2(checkContext, elem) > -1;
            }, implicitRelative, true), matchers = [function(elem, context, xml) {
              var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
              checkContext = null;
              return ret;
            }];
            for (; i2 < len; i2++) {
              if (matcher = Expr.relative[tokens[i2].type]) {
                matchers = [addCombinator(elementMatcher(matchers), matcher)];
              } else {
                matcher = Expr.filter[tokens[i2].type].apply(null, tokens[i2].matches);
                if (matcher[expando]) {
                  j = ++i2;
                  for (; j < len; j++) {
                    if (Expr.relative[tokens[j].type]) {
                      break;
                    }
                  }
                  return setMatcher(
                    i2 > 1 && elementMatcher(matchers),
                    i2 > 1 && toSelector(
                      tokens.slice(0, i2 - 1).concat({ value: tokens[i2 - 2].type === " " ? "*" : "" })
                    ).replace(rtrim2, "$1"),
                    matcher,
                    i2 < j && matcherFromTokens(tokens.slice(i2, j)),
                    j < len && matcherFromTokens(tokens = tokens.slice(j)),
                    j < len && toSelector(tokens)
                  );
                }
                matchers.push(matcher);
              }
            }
            return elementMatcher(matchers);
          }
          function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
              var elem, j, matcher, matchedCount = 0, i2 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find["TAG"]("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
              if (outermost) {
                outermostContext = context == document3 || context || outermost;
              }
              for (; i2 !== len && (elem = elems[i2]) != null; i2++) {
                if (byElement && elem) {
                  j = 0;
                  if (!context && elem.ownerDocument != document3) {
                    setDocument(elem);
                    xml = !documentIsHTML;
                  }
                  while (matcher = elementMatchers[j++]) {
                    if (matcher(elem, context || document3, xml)) {
                      results.push(elem);
                      break;
                    }
                  }
                  if (outermost) {
                    dirruns = dirrunsUnique;
                  }
                }
                if (bySet) {
                  if (elem = !matcher && elem) {
                    matchedCount--;
                  }
                  if (seed) {
                    unmatched.push(elem);
                  }
                }
              }
              matchedCount += i2;
              if (bySet && i2 !== matchedCount) {
                j = 0;
                while (matcher = setMatchers[j++]) {
                  matcher(unmatched, setMatched, context, xml);
                }
                if (seed) {
                  if (matchedCount > 0) {
                    while (i2--) {
                      if (!(unmatched[i2] || setMatched[i2])) {
                        setMatched[i2] = pop.call(results);
                      }
                    }
                  }
                  setMatched = condense(setMatched);
                }
                push2.apply(results, setMatched);
                if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                  Sizzle2.uniqueSort(results);
                }
              }
              if (outermost) {
                dirruns = dirrunsUnique;
                outermostContext = contextBackup;
              }
              return unmatched;
            };
            return bySet ? markFunction(superMatcher) : superMatcher;
          }
          compile = Sizzle2.compile = function(selector, match) {
            var i2, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
              if (!match) {
                match = tokenize(selector);
              }
              i2 = match.length;
              while (i2--) {
                cached = matcherFromTokens(match[i2]);
                if (cached[expando]) {
                  setMatchers.push(cached);
                } else {
                  elementMatchers.push(cached);
                }
              }
              cached = compilerCache(
                selector,
                matcherFromGroupMatchers(elementMatchers, setMatchers)
              );
              cached.selector = selector;
            }
            return cached;
          };
          select = Sizzle2.select = function(selector, context, results, seed) {
            var i2, tokens, token, type, find, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            results = results || [];
            if (match.length === 1) {
              tokens = match[0] = match[0].slice(0);
              if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                if (!context) {
                  return results;
                } else if (compiled) {
                  context = context.parentNode;
                }
                selector = selector.slice(tokens.shift().value.length);
              }
              i2 = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
              while (i2--) {
                token = tokens[i2];
                if (Expr.relative[type = token.type]) {
                  break;
                }
                if (find = Expr.find[type]) {
                  if (seed = find(
                    token.matches[0].replace(runescape, funescape),
                    rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                  )) {
                    tokens.splice(i2, 1);
                    selector = seed.length && toSelector(tokens);
                    if (!selector) {
                      push2.apply(results, seed);
                      return results;
                    }
                    break;
                  }
                }
              }
            }
            (compiled || compile(selector, match))(
              seed,
              context,
              !documentIsHTML,
              results,
              !context || rsibling.test(selector) && testContext(context.parentNode) || context
            );
            return results;
          };
          support2.sortStable = expando.split("").sort(sortOrder).join("") === expando;
          support2.detectDuplicates = !!hasDuplicate;
          setDocument();
          support2.sortDetached = assert(function(el) {
            return el.compareDocumentPosition(document3.createElement("fieldset")) & 1;
          });
          if (!assert(function(el) {
            el.innerHTML = "<a href='#'></a>";
            return el.firstChild.getAttribute("href") === "#";
          })) {
            addHandle("type|href|height|width", function(elem, name, isXML2) {
              if (!isXML2) {
                return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
              }
            });
          }
          if (!support2.attributes || !assert(function(el) {
            el.innerHTML = "<input/>";
            el.firstChild.setAttribute("value", "");
            return el.firstChild.getAttribute("value") === "";
          })) {
            addHandle("value", function(elem, _name, isXML2) {
              if (!isXML2 && elem.nodeName.toLowerCase() === "input") {
                return elem.defaultValue;
              }
            });
          }
          if (!assert(function(el) {
            return el.getAttribute("disabled") == null;
          })) {
            addHandle(booleans, function(elem, name, isXML2) {
              var val;
              if (!isXML2) {
                return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
              }
            });
          }
          return Sizzle2;
        }(window2);
        jQuery2.find = Sizzle;
        jQuery2.expr = Sizzle.selectors;
        jQuery2.expr[":"] = jQuery2.expr.pseudos;
        jQuery2.uniqueSort = jQuery2.unique = Sizzle.uniqueSort;
        jQuery2.text = Sizzle.getText;
        jQuery2.isXMLDoc = Sizzle.isXML;
        jQuery2.contains = Sizzle.contains;
        jQuery2.escapeSelector = Sizzle.escape;
        var dir = function(elem, dir2, until) {
          var matched = [], truncate = until !== void 0;
          while ((elem = elem[dir2]) && elem.nodeType !== 9) {
            if (elem.nodeType === 1) {
              if (truncate && jQuery2(elem).is(until)) {
                break;
              }
              matched.push(elem);
            }
          }
          return matched;
        };
        var siblings = function(n, elem) {
          var matched = [];
          for (; n; n = n.nextSibling) {
            if (n.nodeType === 1 && n !== elem) {
              matched.push(n);
            }
          }
          return matched;
        };
        var rneedsContext = jQuery2.expr.match.needsContext;
        function nodeName(elem, name) {
          return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        }
        var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
        function winnow(elements, qualifier, not) {
          if (isFunction(qualifier)) {
            return jQuery2.grep(elements, function(elem, i) {
              return !!qualifier.call(elem, i, elem) !== not;
            });
          }
          if (qualifier.nodeType) {
            return jQuery2.grep(elements, function(elem) {
              return elem === qualifier !== not;
            });
          }
          if (typeof qualifier !== "string") {
            return jQuery2.grep(elements, function(elem) {
              return indexOf.call(qualifier, elem) > -1 !== not;
            });
          }
          return jQuery2.filter(qualifier, elements, not);
        }
        jQuery2.filter = function(expr, elems, not) {
          var elem = elems[0];
          if (not) {
            expr = ":not(" + expr + ")";
          }
          if (elems.length === 1 && elem.nodeType === 1) {
            return jQuery2.find.matchesSelector(elem, expr) ? [elem] : [];
          }
          return jQuery2.find.matches(expr, jQuery2.grep(elems, function(elem2) {
            return elem2.nodeType === 1;
          }));
        };
        jQuery2.fn.extend({
          find: function(selector) {
            var i, ret, len = this.length, self2 = this;
            if (typeof selector !== "string") {
              return this.pushStack(jQuery2(selector).filter(function() {
                for (i = 0; i < len; i++) {
                  if (jQuery2.contains(self2[i], this)) {
                    return true;
                  }
                }
              }));
            }
            ret = this.pushStack([]);
            for (i = 0; i < len; i++) {
              jQuery2.find(selector, self2[i], ret);
            }
            return len > 1 ? jQuery2.uniqueSort(ret) : ret;
          },
          filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false));
          },
          not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true));
          },
          is: function(selector) {
            return !!winnow(
              this,
              typeof selector === "string" && rneedsContext.test(selector) ? jQuery2(selector) : selector || [],
              false
            ).length;
          }
        });
        var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery2.fn.init = function(selector, context, root) {
          var match, elem;
          if (!selector) {
            return this;
          }
          root = root || rootjQuery;
          if (typeof selector === "string") {
            if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
              match = [null, selector, null];
            } else {
              match = rquickExpr.exec(selector);
            }
            if (match && (match[1] || !context)) {
              if (match[1]) {
                context = context instanceof jQuery2 ? context[0] : context;
                jQuery2.merge(this, jQuery2.parseHTML(
                  match[1],
                  context && context.nodeType ? context.ownerDocument || context : document2,
                  true
                ));
                if (rsingleTag.test(match[1]) && jQuery2.isPlainObject(context)) {
                  for (match in context) {
                    if (isFunction(this[match])) {
                      this[match](context[match]);
                    } else {
                      this.attr(match, context[match]);
                    }
                  }
                }
                return this;
              } else {
                elem = document2.getElementById(match[2]);
                if (elem) {
                  this[0] = elem;
                  this.length = 1;
                }
                return this;
              }
            } else if (!context || context.jquery) {
              return (context || root).find(selector);
            } else {
              return this.constructor(context).find(selector);
            }
          } else if (selector.nodeType) {
            this[0] = selector;
            this.length = 1;
            return this;
          } else if (isFunction(selector)) {
            return root.ready !== void 0 ? root.ready(selector) : selector(jQuery2);
          }
          return jQuery2.makeArray(selector, this);
        };
        init.prototype = jQuery2.fn;
        rootjQuery = jQuery2(document2);
        var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
          children: true,
          contents: true,
          next: true,
          prev: true
        };
        jQuery2.fn.extend({
          has: function(target) {
            var targets = jQuery2(target, this), l = targets.length;
            return this.filter(function() {
              var i = 0;
              for (; i < l; i++) {
                if (jQuery2.contains(this, targets[i])) {
                  return true;
                }
              }
            });
          },
          closest: function(selectors, context) {
            var cur, i = 0, l = this.length, matched = [], targets = typeof selectors !== "string" && jQuery2(selectors);
            if (!rneedsContext.test(selectors)) {
              for (; i < l; i++) {
                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                  if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : cur.nodeType === 1 && jQuery2.find.matchesSelector(cur, selectors))) {
                    matched.push(cur);
                    break;
                  }
                }
              }
            }
            return this.pushStack(matched.length > 1 ? jQuery2.uniqueSort(matched) : matched);
          },
          index: function(elem) {
            if (!elem) {
              return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            if (typeof elem === "string") {
              return indexOf.call(jQuery2(elem), this[0]);
            }
            return indexOf.call(
              this,
              elem.jquery ? elem[0] : elem
            );
          },
          add: function(selector, context) {
            return this.pushStack(
              jQuery2.uniqueSort(
                jQuery2.merge(this.get(), jQuery2(selector, context))
              )
            );
          },
          addBack: function(selector) {
            return this.add(
              selector == null ? this.prevObject : this.prevObject.filter(selector)
            );
          }
        });
        function sibling(cur, dir2) {
          while ((cur = cur[dir2]) && cur.nodeType !== 1) {
          }
          return cur;
        }
        jQuery2.each({
          parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
          },
          parents: function(elem) {
            return dir(elem, "parentNode");
          },
          parentsUntil: function(elem, _i, until) {
            return dir(elem, "parentNode", until);
          },
          next: function(elem) {
            return sibling(elem, "nextSibling");
          },
          prev: function(elem) {
            return sibling(elem, "previousSibling");
          },
          nextAll: function(elem) {
            return dir(elem, "nextSibling");
          },
          prevAll: function(elem) {
            return dir(elem, "previousSibling");
          },
          nextUntil: function(elem, _i, until) {
            return dir(elem, "nextSibling", until);
          },
          prevUntil: function(elem, _i, until) {
            return dir(elem, "previousSibling", until);
          },
          siblings: function(elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
          },
          children: function(elem) {
            return siblings(elem.firstChild);
          },
          contents: function(elem) {
            if (elem.contentDocument != null && getProto(elem.contentDocument)) {
              return elem.contentDocument;
            }
            if (nodeName(elem, "template")) {
              elem = elem.content || elem;
            }
            return jQuery2.merge([], elem.childNodes);
          }
        }, function(name, fn) {
          jQuery2.fn[name] = function(until, selector) {
            var matched = jQuery2.map(this, fn, until);
            if (name.slice(-5) !== "Until") {
              selector = until;
            }
            if (selector && typeof selector === "string") {
              matched = jQuery2.filter(selector, matched);
            }
            if (this.length > 1) {
              if (!guaranteedUnique[name]) {
                jQuery2.uniqueSort(matched);
              }
              if (rparentsprev.test(name)) {
                matched.reverse();
              }
            }
            return this.pushStack(matched);
          };
        });
        var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
        function createOptions(options) {
          var object = {};
          jQuery2.each(options.match(rnothtmlwhite) || [], function(_, flag) {
            object[flag] = true;
          });
          return object;
        }
        jQuery2.Callbacks = function(options) {
          options = typeof options === "string" ? createOptions(options) : jQuery2.extend({}, options);
          var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
            locked = locked || options.once;
            fired = firing = true;
            for (; queue.length; firingIndex = -1) {
              memory = queue.shift();
              while (++firingIndex < list.length) {
                if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                  firingIndex = list.length;
                  memory = false;
                }
              }
            }
            if (!options.memory) {
              memory = false;
            }
            firing = false;
            if (locked) {
              if (memory) {
                list = [];
              } else {
                list = "";
              }
            }
          }, self2 = {
            add: function() {
              if (list) {
                if (memory && !firing) {
                  firingIndex = list.length - 1;
                  queue.push(memory);
                }
                (function add(args) {
                  jQuery2.each(args, function(_, arg) {
                    if (isFunction(arg)) {
                      if (!options.unique || !self2.has(arg)) {
                        list.push(arg);
                      }
                    } else if (arg && arg.length && toType(arg) !== "string") {
                      add(arg);
                    }
                  });
                })(arguments);
                if (memory && !firing) {
                  fire();
                }
              }
              return this;
            },
            remove: function() {
              jQuery2.each(arguments, function(_, arg) {
                var index;
                while ((index = jQuery2.inArray(arg, list, index)) > -1) {
                  list.splice(index, 1);
                  if (index <= firingIndex) {
                    firingIndex--;
                  }
                }
              });
              return this;
            },
            has: function(fn) {
              return fn ? jQuery2.inArray(fn, list) > -1 : list.length > 0;
            },
            empty: function() {
              if (list) {
                list = [];
              }
              return this;
            },
            disable: function() {
              locked = queue = [];
              list = memory = "";
              return this;
            },
            disabled: function() {
              return !list;
            },
            lock: function() {
              locked = queue = [];
              if (!memory && !firing) {
                list = memory = "";
              }
              return this;
            },
            locked: function() {
              return !!locked;
            },
            fireWith: function(context, args) {
              if (!locked) {
                args = args || [];
                args = [context, args.slice ? args.slice() : args];
                queue.push(args);
                if (!firing) {
                  fire();
                }
              }
              return this;
            },
            fire: function() {
              self2.fireWith(this, arguments);
              return this;
            },
            fired: function() {
              return !!fired;
            }
          };
          return self2;
        };
        function Identity(v) {
          return v;
        }
        function Thrower(ex) {
          throw ex;
        }
        function adoptValue(value, resolve, reject, noValue) {
          var method;
          try {
            if (value && isFunction(method = value.promise)) {
              method.call(value).done(resolve).fail(reject);
            } else if (value && isFunction(method = value.then)) {
              method.call(value, resolve, reject);
            } else {
              resolve.apply(void 0, [value].slice(noValue));
            }
          } catch (value2) {
            reject.apply(void 0, [value2]);
          }
        }
        jQuery2.extend({
          Deferred: function(func) {
            var tuples = [
              [
                "notify",
                "progress",
                jQuery2.Callbacks("memory"),
                jQuery2.Callbacks("memory"),
                2
              ],
              [
                "resolve",
                "done",
                jQuery2.Callbacks("once memory"),
                jQuery2.Callbacks("once memory"),
                0,
                "resolved"
              ],
              [
                "reject",
                "fail",
                jQuery2.Callbacks("once memory"),
                jQuery2.Callbacks("once memory"),
                1,
                "rejected"
              ]
            ], state = "pending", promise = {
              state: function() {
                return state;
              },
              always: function() {
                deferred.done(arguments).fail(arguments);
                return this;
              },
              "catch": function(fn) {
                return promise.then(null, fn);
              },
              pipe: function() {
                var fns = arguments;
                return jQuery2.Deferred(function(newDefer) {
                  jQuery2.each(tuples, function(_i, tuple) {
                    var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];
                    deferred[tuple[1]](function() {
                      var returned = fn && fn.apply(this, arguments);
                      if (returned && isFunction(returned.promise)) {
                        returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                      } else {
                        newDefer[tuple[0] + "With"](
                          this,
                          fn ? [returned] : arguments
                        );
                      }
                    });
                  });
                  fns = null;
                }).promise();
              },
              then: function(onFulfilled, onRejected, onProgress) {
                var maxDepth = 0;
                function resolve(depth, deferred2, handler, special) {
                  return function() {
                    var that = this, args = arguments, mightThrow = function() {
                      var returned, then;
                      if (depth < maxDepth) {
                        return;
                      }
                      returned = handler.apply(that, args);
                      if (returned === deferred2.promise()) {
                        throw new TypeError("Thenable self-resolution");
                      }
                      then = returned && (typeof returned === "object" || typeof returned === "function") && returned.then;
                      if (isFunction(then)) {
                        if (special) {
                          then.call(
                            returned,
                            resolve(maxDepth, deferred2, Identity, special),
                            resolve(maxDepth, deferred2, Thrower, special)
                          );
                        } else {
                          maxDepth++;
                          then.call(
                            returned,
                            resolve(maxDepth, deferred2, Identity, special),
                            resolve(maxDepth, deferred2, Thrower, special),
                            resolve(
                              maxDepth,
                              deferred2,
                              Identity,
                              deferred2.notifyWith
                            )
                          );
                        }
                      } else {
                        if (handler !== Identity) {
                          that = void 0;
                          args = [returned];
                        }
                        (special || deferred2.resolveWith)(that, args);
                      }
                    }, process2 = special ? mightThrow : function() {
                      try {
                        mightThrow();
                      } catch (e) {
                        if (jQuery2.Deferred.exceptionHook) {
                          jQuery2.Deferred.exceptionHook(
                            e,
                            process2.stackTrace
                          );
                        }
                        if (depth + 1 >= maxDepth) {
                          if (handler !== Thrower) {
                            that = void 0;
                            args = [e];
                          }
                          deferred2.rejectWith(that, args);
                        }
                      }
                    };
                    if (depth) {
                      process2();
                    } else {
                      if (jQuery2.Deferred.getStackHook) {
                        process2.stackTrace = jQuery2.Deferred.getStackHook();
                      }
                      window2.setTimeout(process2);
                    }
                  };
                }
                return jQuery2.Deferred(function(newDefer) {
                  tuples[0][3].add(
                    resolve(
                      0,
                      newDefer,
                      isFunction(onProgress) ? onProgress : Identity,
                      newDefer.notifyWith
                    )
                  );
                  tuples[1][3].add(
                    resolve(
                      0,
                      newDefer,
                      isFunction(onFulfilled) ? onFulfilled : Identity
                    )
                  );
                  tuples[2][3].add(
                    resolve(
                      0,
                      newDefer,
                      isFunction(onRejected) ? onRejected : Thrower
                    )
                  );
                }).promise();
              },
              promise: function(obj) {
                return obj != null ? jQuery2.extend(obj, promise) : promise;
              }
            }, deferred = {};
            jQuery2.each(tuples, function(i, tuple) {
              var list = tuple[2], stateString = tuple[5];
              promise[tuple[1]] = list.add;
              if (stateString) {
                list.add(
                  function() {
                    state = stateString;
                  },
                  tuples[3 - i][2].disable,
                  tuples[3 - i][3].disable,
                  tuples[0][2].lock,
                  tuples[0][3].lock
                );
              }
              list.add(tuple[3].fire);
              deferred[tuple[0]] = function() {
                deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
                return this;
              };
              deferred[tuple[0] + "With"] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
              func.call(deferred, deferred);
            }
            return deferred;
          },
          when: function(singleValue) {
            var remaining = arguments.length, i = remaining, resolveContexts = Array(i), resolveValues = slice.call(arguments), primary = jQuery2.Deferred(), updateFunc = function(i2) {
              return function(value) {
                resolveContexts[i2] = this;
                resolveValues[i2] = arguments.length > 1 ? slice.call(arguments) : value;
                if (!--remaining) {
                  primary.resolveWith(resolveContexts, resolveValues);
                }
              };
            };
            if (remaining <= 1) {
              adoptValue(
                singleValue,
                primary.done(updateFunc(i)).resolve,
                primary.reject,
                !remaining
              );
              if (primary.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
                return primary.then();
              }
            }
            while (i--) {
              adoptValue(resolveValues[i], updateFunc(i), primary.reject);
            }
            return primary.promise();
          }
        });
        var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
        jQuery2.Deferred.exceptionHook = function(error, stack) {
          if (window2.console && window2.console.warn && error && rerrorNames.test(error.name)) {
            window2.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
          }
        };
        jQuery2.readyException = function(error) {
          window2.setTimeout(function() {
            throw error;
          });
        };
        var readyList = jQuery2.Deferred();
        jQuery2.fn.ready = function(fn) {
          readyList.then(fn).catch(function(error) {
            jQuery2.readyException(error);
          });
          return this;
        };
        jQuery2.extend({
          isReady: false,
          readyWait: 1,
          ready: function(wait) {
            if (wait === true ? --jQuery2.readyWait : jQuery2.isReady) {
              return;
            }
            jQuery2.isReady = true;
            if (wait !== true && --jQuery2.readyWait > 0) {
              return;
            }
            readyList.resolveWith(document2, [jQuery2]);
          }
        });
        jQuery2.ready.then = readyList.then;
        function completed() {
          document2.removeEventListener("DOMContentLoaded", completed);
          window2.removeEventListener("load", completed);
          jQuery2.ready();
        }
        if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
          window2.setTimeout(jQuery2.ready);
        } else {
          document2.addEventListener("DOMContentLoaded", completed);
          window2.addEventListener("load", completed);
        }
        var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
          var i = 0, len = elems.length, bulk = key == null;
          if (toType(key) === "object") {
            chainable = true;
            for (i in key) {
              access(elems, fn, i, key[i], true, emptyGet, raw);
            }
          } else if (value !== void 0) {
            chainable = true;
            if (!isFunction(value)) {
              raw = true;
            }
            if (bulk) {
              if (raw) {
                fn.call(elems, value);
                fn = null;
              } else {
                bulk = fn;
                fn = function(elem, _key, value2) {
                  return bulk.call(jQuery2(elem), value2);
                };
              }
            }
            if (fn) {
              for (; i < len; i++) {
                fn(
                  elems[i],
                  key,
                  raw ? value : value.call(elems[i], i, fn(elems[i], key))
                );
              }
            }
          }
          if (chainable) {
            return elems;
          }
          if (bulk) {
            return fn.call(elems);
          }
          return len ? fn(elems[0], key) : emptyGet;
        };
        var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
        function fcamelCase(_all, letter) {
          return letter.toUpperCase();
        }
        function camelCase(string) {
          return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        }
        var acceptData = function(owner) {
          return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
        };
        function Data() {
          this.expando = jQuery2.expando + Data.uid++;
        }
        Data.uid = 1;
        Data.prototype = {
          cache: function(owner) {
            var value = owner[this.expando];
            if (!value) {
              value = {};
              if (acceptData(owner)) {
                if (owner.nodeType) {
                  owner[this.expando] = value;
                } else {
                  Object.defineProperty(owner, this.expando, {
                    value,
                    configurable: true
                  });
                }
              }
            }
            return value;
          },
          set: function(owner, data, value) {
            var prop, cache = this.cache(owner);
            if (typeof data === "string") {
              cache[camelCase(data)] = value;
            } else {
              for (prop in data) {
                cache[camelCase(prop)] = data[prop];
              }
            }
            return cache;
          },
          get: function(owner, key) {
            return key === void 0 ? this.cache(owner) : owner[this.expando] && owner[this.expando][camelCase(key)];
          },
          access: function(owner, key, value) {
            if (key === void 0 || key && typeof key === "string" && value === void 0) {
              return this.get(owner, key);
            }
            this.set(owner, key, value);
            return value !== void 0 ? value : key;
          },
          remove: function(owner, key) {
            var i, cache = owner[this.expando];
            if (cache === void 0) {
              return;
            }
            if (key !== void 0) {
              if (Array.isArray(key)) {
                key = key.map(camelCase);
              } else {
                key = camelCase(key);
                key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
              }
              i = key.length;
              while (i--) {
                delete cache[key[i]];
              }
            }
            if (key === void 0 || jQuery2.isEmptyObject(cache)) {
              if (owner.nodeType) {
                owner[this.expando] = void 0;
              } else {
                delete owner[this.expando];
              }
            }
          },
          hasData: function(owner) {
            var cache = owner[this.expando];
            return cache !== void 0 && !jQuery2.isEmptyObject(cache);
          }
        };
        var dataPriv = new Data();
        var dataUser = new Data();
        var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
        function getData(data) {
          if (data === "true") {
            return true;
          }
          if (data === "false") {
            return false;
          }
          if (data === "null") {
            return null;
          }
          if (data === +data + "") {
            return +data;
          }
          if (rbrace.test(data)) {
            return JSON.parse(data);
          }
          return data;
        }
        function dataAttr(elem, key, data) {
          var name;
          if (data === void 0 && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === "string") {
              try {
                data = getData(data);
              } catch (e) {
              }
              dataUser.set(elem, key, data);
            } else {
              data = void 0;
            }
          }
          return data;
        }
        jQuery2.extend({
          hasData: function(elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
          },
          data: function(elem, name, data) {
            return dataUser.access(elem, name, data);
          },
          removeData: function(elem, name) {
            dataUser.remove(elem, name);
          },
          _data: function(elem, name, data) {
            return dataPriv.access(elem, name, data);
          },
          _removeData: function(elem, name) {
            dataPriv.remove(elem, name);
          }
        });
        jQuery2.fn.extend({
          data: function(key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (key === void 0) {
              if (this.length) {
                data = dataUser.get(elem);
                if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                  i = attrs.length;
                  while (i--) {
                    if (attrs[i]) {
                      name = attrs[i].name;
                      if (name.indexOf("data-") === 0) {
                        name = camelCase(name.slice(5));
                        dataAttr(elem, name, data[name]);
                      }
                    }
                  }
                  dataPriv.set(elem, "hasDataAttrs", true);
                }
              }
              return data;
            }
            if (typeof key === "object") {
              return this.each(function() {
                dataUser.set(this, key);
              });
            }
            return access(this, function(value2) {
              var data2;
              if (elem && value2 === void 0) {
                data2 = dataUser.get(elem, key);
                if (data2 !== void 0) {
                  return data2;
                }
                data2 = dataAttr(elem, key);
                if (data2 !== void 0) {
                  return data2;
                }
                return;
              }
              this.each(function() {
                dataUser.set(this, key, value2);
              });
            }, null, value, arguments.length > 1, null, true);
          },
          removeData: function(key) {
            return this.each(function() {
              dataUser.remove(this, key);
            });
          }
        });
        jQuery2.extend({
          queue: function(elem, type, data) {
            var queue;
            if (elem) {
              type = (type || "fx") + "queue";
              queue = dataPriv.get(elem, type);
              if (data) {
                if (!queue || Array.isArray(data)) {
                  queue = dataPriv.access(elem, type, jQuery2.makeArray(data));
                } else {
                  queue.push(data);
                }
              }
              return queue || [];
            }
          },
          dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery2.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery2._queueHooks(elem, type), next = function() {
              jQuery2.dequeue(elem, type);
            };
            if (fn === "inprogress") {
              fn = queue.shift();
              startLength--;
            }
            if (fn) {
              if (type === "fx") {
                queue.unshift("inprogress");
              }
              delete hooks.stop;
              fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
              hooks.empty.fire();
            }
          },
          _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
              empty: jQuery2.Callbacks("once memory").add(function() {
                dataPriv.remove(elem, [type + "queue", key]);
              })
            });
          }
        });
        jQuery2.fn.extend({
          queue: function(type, data) {
            var setter = 2;
            if (typeof type !== "string") {
              data = type;
              type = "fx";
              setter--;
            }
            if (arguments.length < setter) {
              return jQuery2.queue(this[0], type);
            }
            return data === void 0 ? this : this.each(function() {
              var queue = jQuery2.queue(this, type, data);
              jQuery2._queueHooks(this, type);
              if (type === "fx" && queue[0] !== "inprogress") {
                jQuery2.dequeue(this, type);
              }
            });
          },
          dequeue: function(type) {
            return this.each(function() {
              jQuery2.dequeue(this, type);
            });
          },
          clearQueue: function(type) {
            return this.queue(type || "fx", []);
          },
          promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery2.Deferred(), elements = this, i = this.length, resolve = function() {
              if (!--count) {
                defer.resolveWith(elements, [elements]);
              }
            };
            if (typeof type !== "string") {
              obj = type;
              type = void 0;
            }
            type = type || "fx";
            while (i--) {
              tmp = dataPriv.get(elements[i], type + "queueHooks");
              if (tmp && tmp.empty) {
                count++;
                tmp.empty.add(resolve);
              }
            }
            resolve();
            return defer.promise(obj);
          }
        });
        var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
        var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
        var cssExpand = ["Top", "Right", "Bottom", "Left"];
        var documentElement = document2.documentElement;
        var isAttached = function(elem) {
          return jQuery2.contains(elem.ownerDocument, elem);
        }, composed = { composed: true };
        if (documentElement.getRootNode) {
          isAttached = function(elem) {
            return jQuery2.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
          };
        }
        var isHiddenWithinTree = function(elem, el) {
          elem = el || elem;
          return elem.style.display === "none" || elem.style.display === "" && isAttached(elem) && jQuery2.css(elem, "display") === "none";
        };
        function adjustCSS(elem, prop, valueParts, tween) {
          var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
            return tween.cur();
          } : function() {
            return jQuery2.css(elem, prop, "");
          }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery2.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery2.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery2.css(elem, prop));
          if (initialInUnit && initialInUnit[3] !== unit) {
            initial = initial / 2;
            unit = unit || initialInUnit[3];
            initialInUnit = +initial || 1;
            while (maxIterations--) {
              jQuery2.style(elem, prop, initialInUnit + unit);
              if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
                maxIterations = 0;
              }
              initialInUnit = initialInUnit / scale;
            }
            initialInUnit = initialInUnit * 2;
            jQuery2.style(elem, prop, initialInUnit + unit);
            valueParts = valueParts || [];
          }
          if (valueParts) {
            initialInUnit = +initialInUnit || +initial || 0;
            adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
            if (tween) {
              tween.unit = unit;
              tween.start = initialInUnit;
              tween.end = adjusted;
            }
          }
          return adjusted;
        }
        var defaultDisplayMap = {};
        function getDefaultDisplay(elem) {
          var temp, doc = elem.ownerDocument, nodeName2 = elem.nodeName, display = defaultDisplayMap[nodeName2];
          if (display) {
            return display;
          }
          temp = doc.body.appendChild(doc.createElement(nodeName2));
          display = jQuery2.css(temp, "display");
          temp.parentNode.removeChild(temp);
          if (display === "none") {
            display = "block";
          }
          defaultDisplayMap[nodeName2] = display;
          return display;
        }
        function showHide(elements, show) {
          var display, elem, values = [], index = 0, length = elements.length;
          for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
              continue;
            }
            display = elem.style.display;
            if (show) {
              if (display === "none") {
                values[index] = dataPriv.get(elem, "display") || null;
                if (!values[index]) {
                  elem.style.display = "";
                }
              }
              if (elem.style.display === "" && isHiddenWithinTree(elem)) {
                values[index] = getDefaultDisplay(elem);
              }
            } else {
              if (display !== "none") {
                values[index] = "none";
                dataPriv.set(elem, "display", display);
              }
            }
          }
          for (index = 0; index < length; index++) {
            if (values[index] != null) {
              elements[index].style.display = values[index];
            }
          }
          return elements;
        }
        jQuery2.fn.extend({
          show: function() {
            return showHide(this, true);
          },
          hide: function() {
            return showHide(this);
          },
          toggle: function(state) {
            if (typeof state === "boolean") {
              return state ? this.show() : this.hide();
            }
            return this.each(function() {
              if (isHiddenWithinTree(this)) {
                jQuery2(this).show();
              } else {
                jQuery2(this).hide();
              }
            });
          }
        });
        var rcheckableType = /^(?:checkbox|radio)$/i;
        var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
        var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
        (function() {
          var fragment = document2.createDocumentFragment(), div = fragment.appendChild(document2.createElement("div")), input = document2.createElement("input");
          input.setAttribute("type", "radio");
          input.setAttribute("checked", "checked");
          input.setAttribute("name", "t");
          div.appendChild(input);
          support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
          div.innerHTML = "<textarea>x</textarea>";
          support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
          div.innerHTML = "<option></option>";
          support.option = !!div.lastChild;
        })();
        var wrapMap = {
          thead: [1, "<table>", "</table>"],
          col: [2, "<table><colgroup>", "</colgroup></table>"],
          tr: [2, "<table><tbody>", "</tbody></table>"],
          td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
          _default: [0, "", ""]
        };
        wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
        wrapMap.th = wrapMap.td;
        if (!support.option) {
          wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
        }
        function getAll(context, tag) {
          var ret;
          if (typeof context.getElementsByTagName !== "undefined") {
            ret = context.getElementsByTagName(tag || "*");
          } else if (typeof context.querySelectorAll !== "undefined") {
            ret = context.querySelectorAll(tag || "*");
          } else {
            ret = [];
          }
          if (tag === void 0 || tag && nodeName(context, tag)) {
            return jQuery2.merge([context], ret);
          }
          return ret;
        }
        function setGlobalEval(elems, refElements) {
          var i = 0, l = elems.length;
          for (; i < l; i++) {
            dataPriv.set(
              elems[i],
              "globalEval",
              !refElements || dataPriv.get(refElements[i], "globalEval")
            );
          }
        }
        var rhtml = /<|&#?\w+;/;
        function buildFragment(elems, context, scripts, selection, ignored) {
          var elem, tmp, tag, wrap, attached, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
          for (; i < l; i++) {
            elem = elems[i];
            if (elem || elem === 0) {
              if (toType(elem) === "object") {
                jQuery2.merge(nodes, elem.nodeType ? [elem] : elem);
              } else if (!rhtml.test(elem)) {
                nodes.push(context.createTextNode(elem));
              } else {
                tmp = tmp || fragment.appendChild(context.createElement("div"));
                tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                wrap = wrapMap[tag] || wrapMap._default;
                tmp.innerHTML = wrap[1] + jQuery2.htmlPrefilter(elem) + wrap[2];
                j = wrap[0];
                while (j--) {
                  tmp = tmp.lastChild;
                }
                jQuery2.merge(nodes, tmp.childNodes);
                tmp = fragment.firstChild;
                tmp.textContent = "";
              }
            }
          }
          fragment.textContent = "";
          i = 0;
          while (elem = nodes[i++]) {
            if (selection && jQuery2.inArray(elem, selection) > -1) {
              if (ignored) {
                ignored.push(elem);
              }
              continue;
            }
            attached = isAttached(elem);
            tmp = getAll(fragment.appendChild(elem), "script");
            if (attached) {
              setGlobalEval(tmp);
            }
            if (scripts) {
              j = 0;
              while (elem = tmp[j++]) {
                if (rscriptType.test(elem.type || "")) {
                  scripts.push(elem);
                }
              }
            }
          }
          return fragment;
        }
        var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
        function returnTrue() {
          return true;
        }
        function returnFalse() {
          return false;
        }
        function expectSync(elem, type) {
          return elem === safeActiveElement() === (type === "focus");
        }
        function safeActiveElement() {
          try {
            return document2.activeElement;
          } catch (err) {
          }
        }
        function on(elem, types, selector, data, fn, one) {
          var origFn, type;
          if (typeof types === "object") {
            if (typeof selector !== "string") {
              data = data || selector;
              selector = void 0;
            }
            for (type in types) {
              on(elem, type, selector, data, types[type], one);
            }
            return elem;
          }
          if (data == null && fn == null) {
            fn = selector;
            data = selector = void 0;
          } else if (fn == null) {
            if (typeof selector === "string") {
              fn = data;
              data = void 0;
            } else {
              fn = data;
              data = selector;
              selector = void 0;
            }
          }
          if (fn === false) {
            fn = returnFalse;
          } else if (!fn) {
            return elem;
          }
          if (one === 1) {
            origFn = fn;
            fn = function(event) {
              jQuery2().off(event);
              return origFn.apply(this, arguments);
            };
            fn.guid = origFn.guid || (origFn.guid = jQuery2.guid++);
          }
          return elem.each(function() {
            jQuery2.event.add(this, types, fn, data, selector);
          });
        }
        jQuery2.event = {
          global: {},
          add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
            if (!acceptData(elem)) {
              return;
            }
            if (handler.handler) {
              handleObjIn = handler;
              handler = handleObjIn.handler;
              selector = handleObjIn.selector;
            }
            if (selector) {
              jQuery2.find.matchesSelector(documentElement, selector);
            }
            if (!handler.guid) {
              handler.guid = jQuery2.guid++;
            }
            if (!(events = elemData.events)) {
              events = elemData.events = /* @__PURE__ */ Object.create(null);
            }
            if (!(eventHandle = elemData.handle)) {
              eventHandle = elemData.handle = function(e) {
                return typeof jQuery2 !== "undefined" && jQuery2.event.triggered !== e.type ? jQuery2.event.dispatch.apply(elem, arguments) : void 0;
              };
            }
            types = (types || "").match(rnothtmlwhite) || [""];
            t = types.length;
            while (t--) {
              tmp = rtypenamespace.exec(types[t]) || [];
              type = origType = tmp[1];
              namespaces = (tmp[2] || "").split(".").sort();
              if (!type) {
                continue;
              }
              special = jQuery2.event.special[type] || {};
              type = (selector ? special.delegateType : special.bindType) || type;
              special = jQuery2.event.special[type] || {};
              handleObj = jQuery2.extend({
                type,
                origType,
                data,
                handler,
                guid: handler.guid,
                selector,
                needsContext: selector && jQuery2.expr.match.needsContext.test(selector),
                namespace: namespaces.join(".")
              }, handleObjIn);
              if (!(handlers = events[type])) {
                handlers = events[type] = [];
                handlers.delegateCount = 0;
                if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                  if (elem.addEventListener) {
                    elem.addEventListener(type, eventHandle);
                  }
                }
              }
              if (special.add) {
                special.add.call(elem, handleObj);
                if (!handleObj.handler.guid) {
                  handleObj.handler.guid = handler.guid;
                }
              }
              if (selector) {
                handlers.splice(handlers.delegateCount++, 0, handleObj);
              } else {
                handlers.push(handleObj);
              }
              jQuery2.event.global[type] = true;
            }
          },
          remove: function(elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
            if (!elemData || !(events = elemData.events)) {
              return;
            }
            types = (types || "").match(rnothtmlwhite) || [""];
            t = types.length;
            while (t--) {
              tmp = rtypenamespace.exec(types[t]) || [];
              type = origType = tmp[1];
              namespaces = (tmp[2] || "").split(".").sort();
              if (!type) {
                for (type in events) {
                  jQuery2.event.remove(elem, type + types[t], handler, selector, true);
                }
                continue;
              }
              special = jQuery2.event.special[type] || {};
              type = (selector ? special.delegateType : special.bindType) || type;
              handlers = events[type] || [];
              tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
              origCount = j = handlers.length;
              while (j--) {
                handleObj = handlers[j];
                if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                  handlers.splice(j, 1);
                  if (handleObj.selector) {
                    handlers.delegateCount--;
                  }
                  if (special.remove) {
                    special.remove.call(elem, handleObj);
                  }
                }
              }
              if (origCount && !handlers.length) {
                if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                  jQuery2.removeEvent(elem, type, elemData.handle);
                }
                delete events[type];
              }
            }
            if (jQuery2.isEmptyObject(events)) {
              dataPriv.remove(elem, "handle events");
            }
          },
          dispatch: function(nativeEvent) {
            var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), event = jQuery2.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event.type] || [], special = jQuery2.event.special[event.type] || {};
            args[0] = event;
            for (i = 1; i < arguments.length; i++) {
              args[i] = arguments[i];
            }
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
              return;
            }
            handlerQueue = jQuery2.event.handlers.call(this, event, handlers);
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
              event.currentTarget = matched.elem;
              j = 0;
              while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
                  event.handleObj = handleObj;
                  event.data = handleObj.data;
                  ret = ((jQuery2.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                  if (ret !== void 0) {
                    if ((event.result = ret) === false) {
                      event.preventDefault();
                      event.stopPropagation();
                    }
                  }
                }
              }
            }
            if (special.postDispatch) {
              special.postDispatch.call(this, event);
            }
            return event.result;
          },
          handlers: function(event, handlers) {
            var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && cur.nodeType && !(event.type === "click" && event.button >= 1)) {
              for (; cur !== this; cur = cur.parentNode || this) {
                if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                  matchedHandlers = [];
                  matchedSelectors = {};
                  for (i = 0; i < delegateCount; i++) {
                    handleObj = handlers[i];
                    sel = handleObj.selector + " ";
                    if (matchedSelectors[sel] === void 0) {
                      matchedSelectors[sel] = handleObj.needsContext ? jQuery2(sel, this).index(cur) > -1 : jQuery2.find(sel, this, null, [cur]).length;
                    }
                    if (matchedSelectors[sel]) {
                      matchedHandlers.push(handleObj);
                    }
                  }
                  if (matchedHandlers.length) {
                    handlerQueue.push({ elem: cur, handlers: matchedHandlers });
                  }
                }
              }
            }
            cur = this;
            if (delegateCount < handlers.length) {
              handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
            }
            return handlerQueue;
          },
          addProp: function(name, hook) {
            Object.defineProperty(jQuery2.Event.prototype, name, {
              enumerable: true,
              configurable: true,
              get: isFunction(hook) ? function() {
                if (this.originalEvent) {
                  return hook(this.originalEvent);
                }
              } : function() {
                if (this.originalEvent) {
                  return this.originalEvent[name];
                }
              },
              set: function(value) {
                Object.defineProperty(this, name, {
                  enumerable: true,
                  configurable: true,
                  writable: true,
                  value
                });
              }
            });
          },
          fix: function(originalEvent) {
            return originalEvent[jQuery2.expando] ? originalEvent : new jQuery2.Event(originalEvent);
          },
          special: {
            load: {
              noBubble: true
            },
            click: {
              setup: function(data) {
                var el = this || data;
                if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                  leverageNative(el, "click", returnTrue);
                }
                return false;
              },
              trigger: function(data) {
                var el = this || data;
                if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                  leverageNative(el, "click");
                }
                return true;
              },
              _default: function(event) {
                var target = event.target;
                return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
              }
            },
            beforeunload: {
              postDispatch: function(event) {
                if (event.result !== void 0 && event.originalEvent) {
                  event.originalEvent.returnValue = event.result;
                }
              }
            }
          }
        };
        function leverageNative(el, type, expectSync2) {
          if (!expectSync2) {
            if (dataPriv.get(el, type) === void 0) {
              jQuery2.event.add(el, type, returnTrue);
            }
            return;
          }
          dataPriv.set(el, type, false);
          jQuery2.event.add(el, type, {
            namespace: false,
            handler: function(event) {
              var notAsync, result, saved = dataPriv.get(this, type);
              if (event.isTrigger & 1 && this[type]) {
                if (!saved.length) {
                  saved = slice.call(arguments);
                  dataPriv.set(this, type, saved);
                  notAsync = expectSync2(this, type);
                  this[type]();
                  result = dataPriv.get(this, type);
                  if (saved !== result || notAsync) {
                    dataPriv.set(this, type, false);
                  } else {
                    result = {};
                  }
                  if (saved !== result) {
                    event.stopImmediatePropagation();
                    event.preventDefault();
                    return result && result.value;
                  }
                } else if ((jQuery2.event.special[type] || {}).delegateType) {
                  event.stopPropagation();
                }
              } else if (saved.length) {
                dataPriv.set(this, type, {
                  value: jQuery2.event.trigger(
                    jQuery2.extend(saved[0], jQuery2.Event.prototype),
                    saved.slice(1),
                    this
                  )
                });
                event.stopImmediatePropagation();
              }
            }
          });
        }
        jQuery2.removeEvent = function(elem, type, handle) {
          if (elem.removeEventListener) {
            elem.removeEventListener(type, handle);
          }
        };
        jQuery2.Event = function(src, props) {
          if (!(this instanceof jQuery2.Event)) {
            return new jQuery2.Event(src, props);
          }
          if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && src.returnValue === false ? returnTrue : returnFalse;
            this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
            this.currentTarget = src.currentTarget;
            this.relatedTarget = src.relatedTarget;
          } else {
            this.type = src;
          }
          if (props) {
            jQuery2.extend(this, props);
          }
          this.timeStamp = src && src.timeStamp || Date.now();
          this[jQuery2.expando] = true;
        };
        jQuery2.Event.prototype = {
          constructor: jQuery2.Event,
          isDefaultPrevented: returnFalse,
          isPropagationStopped: returnFalse,
          isImmediatePropagationStopped: returnFalse,
          isSimulated: false,
          preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e && !this.isSimulated) {
              e.preventDefault();
            }
          },
          stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e && !this.isSimulated) {
              e.stopPropagation();
            }
          },
          stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e && !this.isSimulated) {
              e.stopImmediatePropagation();
            }
            this.stopPropagation();
          }
        };
        jQuery2.each({
          altKey: true,
          bubbles: true,
          cancelable: true,
          changedTouches: true,
          ctrlKey: true,
          detail: true,
          eventPhase: true,
          metaKey: true,
          pageX: true,
          pageY: true,
          shiftKey: true,
          view: true,
          "char": true,
          code: true,
          charCode: true,
          key: true,
          keyCode: true,
          button: true,
          buttons: true,
          clientX: true,
          clientY: true,
          offsetX: true,
          offsetY: true,
          pointerId: true,
          pointerType: true,
          screenX: true,
          screenY: true,
          targetTouches: true,
          toElement: true,
          touches: true,
          which: true
        }, jQuery2.event.addProp);
        jQuery2.each({ focus: "focusin", blur: "focusout" }, function(type, delegateType) {
          jQuery2.event.special[type] = {
            setup: function() {
              leverageNative(this, type, expectSync);
              return false;
            },
            trigger: function() {
              leverageNative(this, type);
              return true;
            },
            _default: function() {
              return true;
            },
            delegateType
          };
        });
        jQuery2.each({
          mouseenter: "mouseover",
          mouseleave: "mouseout",
          pointerenter: "pointerover",
          pointerleave: "pointerout"
        }, function(orig, fix) {
          jQuery2.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
              var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
              if (!related || related !== target && !jQuery2.contains(target, related)) {
                event.type = handleObj.origType;
                ret = handleObj.handler.apply(this, arguments);
                event.type = fix;
              }
              return ret;
            }
          };
        });
        jQuery2.fn.extend({
          on: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn);
          },
          one: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn, 1);
          },
          off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
              handleObj = types.handleObj;
              jQuery2(types.delegateTarget).off(
                handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                handleObj.selector,
                handleObj.handler
              );
              return this;
            }
            if (typeof types === "object") {
              for (type in types) {
                this.off(type, selector, types[type]);
              }
              return this;
            }
            if (selector === false || typeof selector === "function") {
              fn = selector;
              selector = void 0;
            }
            if (fn === false) {
              fn = returnFalse;
            }
            return this.each(function() {
              jQuery2.event.remove(this, types, fn, selector);
            });
          }
        });
        var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
        function manipulationTarget(elem, content) {
          if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
            return jQuery2(elem).children("tbody")[0] || elem;
          }
          return elem;
        }
        function disableScript(elem) {
          elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
          return elem;
        }
        function restoreScript(elem) {
          if ((elem.type || "").slice(0, 5) === "true/") {
            elem.type = elem.type.slice(5);
          } else {
            elem.removeAttribute("type");
          }
          return elem;
        }
        function cloneCopyEvent(src, dest) {
          var i, l, type, pdataOld, udataOld, udataCur, events;
          if (dest.nodeType !== 1) {
            return;
          }
          if (dataPriv.hasData(src)) {
            pdataOld = dataPriv.get(src);
            events = pdataOld.events;
            if (events) {
              dataPriv.remove(dest, "handle events");
              for (type in events) {
                for (i = 0, l = events[type].length; i < l; i++) {
                  jQuery2.event.add(dest, type, events[type][i]);
                }
              }
            }
          }
          if (dataUser.hasData(src)) {
            udataOld = dataUser.access(src);
            udataCur = jQuery2.extend({}, udataOld);
            dataUser.set(dest, udataCur);
          }
        }
        function fixInput(src, dest) {
          var nodeName2 = dest.nodeName.toLowerCase();
          if (nodeName2 === "input" && rcheckableType.test(src.type)) {
            dest.checked = src.checked;
          } else if (nodeName2 === "input" || nodeName2 === "textarea") {
            dest.defaultValue = src.defaultValue;
          }
        }
        function domManip(collection, args, callback, ignored) {
          args = flat(args);
          var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], valueIsFunction = isFunction(value);
          if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
            return collection.each(function(index) {
              var self2 = collection.eq(index);
              if (valueIsFunction) {
                args[0] = value.call(this, index, self2.html());
              }
              domManip(self2, args, callback, ignored);
            });
          }
          if (l) {
            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
            first = fragment.firstChild;
            if (fragment.childNodes.length === 1) {
              fragment = first;
            }
            if (first || ignored) {
              scripts = jQuery2.map(getAll(fragment, "script"), disableScript);
              hasScripts = scripts.length;
              for (; i < l; i++) {
                node = fragment;
                if (i !== iNoClone) {
                  node = jQuery2.clone(node, true, true);
                  if (hasScripts) {
                    jQuery2.merge(scripts, getAll(node, "script"));
                  }
                }
                callback.call(collection[i], node, i);
              }
              if (hasScripts) {
                doc = scripts[scripts.length - 1].ownerDocument;
                jQuery2.map(scripts, restoreScript);
                for (i = 0; i < hasScripts; i++) {
                  node = scripts[i];
                  if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery2.contains(doc, node)) {
                    if (node.src && (node.type || "").toLowerCase() !== "module") {
                      if (jQuery2._evalUrl && !node.noModule) {
                        jQuery2._evalUrl(node.src, {
                          nonce: node.nonce || node.getAttribute("nonce")
                        }, doc);
                      }
                    } else {
                      DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                    }
                  }
                }
              }
            }
          }
          return collection;
        }
        function remove(elem, selector, keepData) {
          var node, nodes = selector ? jQuery2.filter(selector, elem) : elem, i = 0;
          for (; (node = nodes[i]) != null; i++) {
            if (!keepData && node.nodeType === 1) {
              jQuery2.cleanData(getAll(node));
            }
            if (node.parentNode) {
              if (keepData && isAttached(node)) {
                setGlobalEval(getAll(node, "script"));
              }
              node.parentNode.removeChild(node);
            }
          }
          return elem;
        }
        jQuery2.extend({
          htmlPrefilter: function(html) {
            return html;
          },
          clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = isAttached(elem);
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery2.isXMLDoc(elem)) {
              destElements = getAll(clone);
              srcElements = getAll(elem);
              for (i = 0, l = srcElements.length; i < l; i++) {
                fixInput(srcElements[i], destElements[i]);
              }
            }
            if (dataAndEvents) {
              if (deepDataAndEvents) {
                srcElements = srcElements || getAll(elem);
                destElements = destElements || getAll(clone);
                for (i = 0, l = srcElements.length; i < l; i++) {
                  cloneCopyEvent(srcElements[i], destElements[i]);
                }
              } else {
                cloneCopyEvent(elem, clone);
              }
            }
            destElements = getAll(clone, "script");
            if (destElements.length > 0) {
              setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            }
            return clone;
          },
          cleanData: function(elems) {
            var data, elem, type, special = jQuery2.event.special, i = 0;
            for (; (elem = elems[i]) !== void 0; i++) {
              if (acceptData(elem)) {
                if (data = elem[dataPriv.expando]) {
                  if (data.events) {
                    for (type in data.events) {
                      if (special[type]) {
                        jQuery2.event.remove(elem, type);
                      } else {
                        jQuery2.removeEvent(elem, type, data.handle);
                      }
                    }
                  }
                  elem[dataPriv.expando] = void 0;
                }
                if (elem[dataUser.expando]) {
                  elem[dataUser.expando] = void 0;
                }
              }
            }
          }
        });
        jQuery2.fn.extend({
          detach: function(selector) {
            return remove(this, selector, true);
          },
          remove: function(selector) {
            return remove(this, selector);
          },
          text: function(value) {
            return access(this, function(value2) {
              return value2 === void 0 ? jQuery2.text(this) : this.empty().each(function() {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                  this.textContent = value2;
                }
              });
            }, null, value, arguments.length);
          },
          append: function() {
            return domManip(this, arguments, function(elem) {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                var target = manipulationTarget(this, elem);
                target.appendChild(elem);
              }
            });
          },
          prepend: function() {
            return domManip(this, arguments, function(elem) {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                var target = manipulationTarget(this, elem);
                target.insertBefore(elem, target.firstChild);
              }
            });
          },
          before: function() {
            return domManip(this, arguments, function(elem) {
              if (this.parentNode) {
                this.parentNode.insertBefore(elem, this);
              }
            });
          },
          after: function() {
            return domManip(this, arguments, function(elem) {
              if (this.parentNode) {
                this.parentNode.insertBefore(elem, this.nextSibling);
              }
            });
          },
          empty: function() {
            var elem, i = 0;
            for (; (elem = this[i]) != null; i++) {
              if (elem.nodeType === 1) {
                jQuery2.cleanData(getAll(elem, false));
                elem.textContent = "";
              }
            }
            return this;
          },
          clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function() {
              return jQuery2.clone(this, dataAndEvents, deepDataAndEvents);
            });
          },
          html: function(value) {
            return access(this, function(value2) {
              var elem = this[0] || {}, i = 0, l = this.length;
              if (value2 === void 0 && elem.nodeType === 1) {
                return elem.innerHTML;
              }
              if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
                value2 = jQuery2.htmlPrefilter(value2);
                try {
                  for (; i < l; i++) {
                    elem = this[i] || {};
                    if (elem.nodeType === 1) {
                      jQuery2.cleanData(getAll(elem, false));
                      elem.innerHTML = value2;
                    }
                  }
                  elem = 0;
                } catch (e) {
                }
              }
              if (elem) {
                this.empty().append(value2);
              }
            }, null, value, arguments.length);
          },
          replaceWith: function() {
            var ignored = [];
            return domManip(this, arguments, function(elem) {
              var parent = this.parentNode;
              if (jQuery2.inArray(this, ignored) < 0) {
                jQuery2.cleanData(getAll(this));
                if (parent) {
                  parent.replaceChild(elem, this);
                }
              }
            }, ignored);
          }
        });
        jQuery2.each({
          appendTo: "append",
          prependTo: "prepend",
          insertBefore: "before",
          insertAfter: "after",
          replaceAll: "replaceWith"
        }, function(name, original) {
          jQuery2.fn[name] = function(selector) {
            var elems, ret = [], insert = jQuery2(selector), last = insert.length - 1, i = 0;
            for (; i <= last; i++) {
              elems = i === last ? this : this.clone(true);
              jQuery2(insert[i])[original](elems);
              push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
          };
        });
        var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
        var getStyles = function(elem) {
          var view = elem.ownerDocument.defaultView;
          if (!view || !view.opener) {
            view = window2;
          }
          return view.getComputedStyle(elem);
        };
        var swap = function(elem, options, callback) {
          var ret, name, old = {};
          for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
          }
          ret = callback.call(elem);
          for (name in options) {
            elem.style[name] = old[name];
          }
          return ret;
        };
        var rboxStyle = new RegExp(cssExpand.join("|"), "i");
        (function() {
          function computeStyleTests() {
            if (!div) {
              return;
            }
            container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
            div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
            documentElement.appendChild(container).appendChild(div);
            var divStyle = window2.getComputedStyle(div);
            pixelPositionVal = divStyle.top !== "1%";
            reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
            div.style.right = "60%";
            pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
            boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
            div.style.position = "absolute";
            scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
            documentElement.removeChild(container);
            div = null;
          }
          function roundPixelMeasures(measure) {
            return Math.round(parseFloat(measure));
          }
          var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document2.createElement("div"), div = document2.createElement("div");
          if (!div.style) {
            return;
          }
          div.style.backgroundClip = "content-box";
          div.cloneNode(true).style.backgroundClip = "";
          support.clearCloneStyle = div.style.backgroundClip === "content-box";
          jQuery2.extend(support, {
            boxSizingReliable: function() {
              computeStyleTests();
              return boxSizingReliableVal;
            },
            pixelBoxStyles: function() {
              computeStyleTests();
              return pixelBoxStylesVal;
            },
            pixelPosition: function() {
              computeStyleTests();
              return pixelPositionVal;
            },
            reliableMarginLeft: function() {
              computeStyleTests();
              return reliableMarginLeftVal;
            },
            scrollboxSize: function() {
              computeStyleTests();
              return scrollboxSizeVal;
            },
            reliableTrDimensions: function() {
              var table, tr, trChild, trStyle;
              if (reliableTrDimensionsVal == null) {
                table = document2.createElement("table");
                tr = document2.createElement("tr");
                trChild = document2.createElement("div");
                table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
                tr.style.cssText = "border:1px solid";
                tr.style.height = "1px";
                trChild.style.height = "9px";
                trChild.style.display = "block";
                documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
                trStyle = window2.getComputedStyle(tr);
                reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
                documentElement.removeChild(table);
              }
              return reliableTrDimensionsVal;
            }
          });
        })();
        function curCSS(elem, name, computed) {
          var width, minWidth, maxWidth, ret, style = elem.style;
          computed = computed || getStyles(elem);
          if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];
            if (ret === "" && !isAttached(elem)) {
              ret = jQuery2.style(elem, name);
            }
            if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
              width = style.width;
              minWidth = style.minWidth;
              maxWidth = style.maxWidth;
              style.minWidth = style.maxWidth = style.width = ret;
              ret = computed.width;
              style.width = width;
              style.minWidth = minWidth;
              style.maxWidth = maxWidth;
            }
          }
          return ret !== void 0 ? ret + "" : ret;
        }
        function addGetHookIf(conditionFn, hookFn) {
          return {
            get: function() {
              if (conditionFn()) {
                delete this.get;
                return;
              }
              return (this.get = hookFn).apply(this, arguments);
            }
          };
        }
        var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
        function vendorPropName(name) {
          var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;
          while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in emptyStyle) {
              return name;
            }
          }
        }
        function finalPropName(name) {
          var final = jQuery2.cssProps[name] || vendorProps[name];
          if (final) {
            return final;
          }
          if (name in emptyStyle) {
            return name;
          }
          return vendorProps[name] = vendorPropName(name) || name;
        }
        var rdisplayswap = /^(none|table(?!-c[ea]).+)/, rcustomProp = /^--/, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
          letterSpacing: "0",
          fontWeight: "400"
        };
        function setPositiveNumber(_elem, value, subtract) {
          var matches = rcssNum.exec(value);
          return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
        }
        function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
          var i = dimension === "width" ? 1 : 0, extra = 0, delta = 0;
          if (box === (isBorderBox ? "border" : "content")) {
            return 0;
          }
          for (; i < 4; i += 2) {
            if (box === "margin") {
              delta += jQuery2.css(elem, box + cssExpand[i], true, styles);
            }
            if (!isBorderBox) {
              delta += jQuery2.css(elem, "padding" + cssExpand[i], true, styles);
              if (box !== "padding") {
                delta += jQuery2.css(elem, "border" + cssExpand[i] + "Width", true, styles);
              } else {
                extra += jQuery2.css(elem, "border" + cssExpand[i] + "Width", true, styles);
              }
            } else {
              if (box === "content") {
                delta -= jQuery2.css(elem, "padding" + cssExpand[i], true, styles);
              }
              if (box !== "margin") {
                delta -= jQuery2.css(elem, "border" + cssExpand[i] + "Width", true, styles);
              }
            }
          }
          if (!isBorderBox && computedVal >= 0) {
            delta += Math.max(0, Math.ceil(
              elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5
            )) || 0;
          }
          return delta;
        }
        function getWidthOrHeight(elem, dimension, extra) {
          var styles = getStyles(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery2.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
          if (rnumnonpx.test(val)) {
            if (!extra) {
              return val;
            }
            val = "auto";
          }
          if ((!support.boxSizingReliable() && isBorderBox || !support.reliableTrDimensions() && nodeName(elem, "tr") || val === "auto" || !parseFloat(val) && jQuery2.css(elem, "display", false, styles) === "inline") && elem.getClientRects().length) {
            isBorderBox = jQuery2.css(elem, "boxSizing", false, styles) === "border-box";
            valueIsBorderBox = offsetProp in elem;
            if (valueIsBorderBox) {
              val = elem[offsetProp];
            }
          }
          val = parseFloat(val) || 0;
          return val + boxModelAdjustment(
            elem,
            dimension,
            extra || (isBorderBox ? "border" : "content"),
            valueIsBorderBox,
            styles,
            val
          ) + "px";
        }
        jQuery2.extend({
          cssHooks: {
            opacity: {
              get: function(elem, computed) {
                if (computed) {
                  var ret = curCSS(elem, "opacity");
                  return ret === "" ? "1" : ret;
                }
              }
            }
          },
          cssNumber: {
            "animationIterationCount": true,
            "columnCount": true,
            "fillOpacity": true,
            "flexGrow": true,
            "flexShrink": true,
            "fontWeight": true,
            "gridArea": true,
            "gridColumn": true,
            "gridColumnEnd": true,
            "gridColumnStart": true,
            "gridRow": true,
            "gridRowEnd": true,
            "gridRowStart": true,
            "lineHeight": true,
            "opacity": true,
            "order": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
          },
          cssProps: {},
          style: function(elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
              return;
            }
            var ret, type, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
            if (!isCustomProp) {
              name = finalPropName(origName);
            }
            hooks = jQuery2.cssHooks[name] || jQuery2.cssHooks[origName];
            if (value !== void 0) {
              type = typeof value;
              if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                value = adjustCSS(elem, name, ret);
                type = "number";
              }
              if (value == null || value !== value) {
                return;
              }
              if (type === "number" && !isCustomProp) {
                value += ret && ret[3] || (jQuery2.cssNumber[origName] ? "" : "px");
              }
              if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                style[name] = "inherit";
              }
              if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== void 0) {
                if (isCustomProp) {
                  style.setProperty(name, value);
                } else {
                  style[name] = value;
                }
              }
            } else {
              if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
                return ret;
              }
              return style[name];
            }
          },
          css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name);
            if (!isCustomProp) {
              name = finalPropName(origName);
            }
            hooks = jQuery2.cssHooks[name] || jQuery2.cssHooks[origName];
            if (hooks && "get" in hooks) {
              val = hooks.get(elem, true, extra);
            }
            if (val === void 0) {
              val = curCSS(elem, name, styles);
            }
            if (val === "normal" && name in cssNormalTransform) {
              val = cssNormalTransform[name];
            }
            if (extra === "" || extra) {
              num = parseFloat(val);
              return extra === true || isFinite(num) ? num || 0 : val;
            }
            return val;
          }
        });
        jQuery2.each(["height", "width"], function(_i, dimension) {
          jQuery2.cssHooks[dimension] = {
            get: function(elem, computed, extra) {
              if (computed) {
                return rdisplayswap.test(jQuery2.css(elem, "display")) && (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
                  return getWidthOrHeight(elem, dimension, extra);
                }) : getWidthOrHeight(elem, dimension, extra);
              }
            },
            set: function(elem, value, extra) {
              var matches, styles = getStyles(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery2.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra ? boxModelAdjustment(
                elem,
                dimension,
                extra,
                isBorderBox,
                styles
              ) : 0;
              if (isBorderBox && scrollboxSizeBuggy) {
                subtract -= Math.ceil(
                  elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5
                );
              }
              if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
                elem.style[dimension] = value;
                value = jQuery2.css(elem, dimension);
              }
              return setPositiveNumber(elem, value, subtract);
            }
          };
        });
        jQuery2.cssHooks.marginLeft = addGetHookIf(
          support.reliableMarginLeft,
          function(elem, computed) {
            if (computed) {
              return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function() {
                return elem.getBoundingClientRect().left;
              })) + "px";
            }
          }
        );
        jQuery2.each({
          margin: "",
          padding: "",
          border: "Width"
        }, function(prefix, suffix) {
          jQuery2.cssHooks[prefix + suffix] = {
            expand: function(value) {
              var i = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
              for (; i < 4; i++) {
                expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
              }
              return expanded;
            }
          };
          if (prefix !== "margin") {
            jQuery2.cssHooks[prefix + suffix].set = setPositiveNumber;
          }
        });
        jQuery2.fn.extend({
          css: function(name, value) {
            return access(this, function(elem, name2, value2) {
              var styles, len, map = {}, i = 0;
              if (Array.isArray(name2)) {
                styles = getStyles(elem);
                len = name2.length;
                for (; i < len; i++) {
                  map[name2[i]] = jQuery2.css(elem, name2[i], false, styles);
                }
                return map;
              }
              return value2 !== void 0 ? jQuery2.style(elem, name2, value2) : jQuery2.css(elem, name2);
            }, name, value, arguments.length > 1);
          }
        });
        function Tween(elem, options, prop, end, easing) {
          return new Tween.prototype.init(elem, options, prop, end, easing);
        }
        jQuery2.Tween = Tween;
        Tween.prototype = {
          constructor: Tween,
          init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery2.easing._default;
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery2.cssNumber[prop] ? "" : "px");
          },
          cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
          },
          run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
              this.pos = eased = jQuery2.easing[this.easing](
                percent,
                this.options.duration * percent,
                0,
                1,
                this.options.duration
              );
            } else {
              this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
              this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
              hooks.set(this);
            } else {
              Tween.propHooks._default.set(this);
            }
            return this;
          }
        };
        Tween.prototype.init.prototype = Tween.prototype;
        Tween.propHooks = {
          _default: {
            get: function(tween) {
              var result;
              if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                return tween.elem[tween.prop];
              }
              result = jQuery2.css(tween.elem, tween.prop, "");
              return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {
              if (jQuery2.fx.step[tween.prop]) {
                jQuery2.fx.step[tween.prop](tween);
              } else if (tween.elem.nodeType === 1 && (jQuery2.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
                jQuery2.style(tween.elem, tween.prop, tween.now + tween.unit);
              } else {
                tween.elem[tween.prop] = tween.now;
              }
            }
          }
        };
        Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
          set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
              tween.elem[tween.prop] = tween.now;
            }
          }
        };
        jQuery2.easing = {
          linear: function(p) {
            return p;
          },
          swing: function(p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
          },
          _default: "swing"
        };
        jQuery2.fx = Tween.prototype.init;
        jQuery2.fx.step = {};
        var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
        function schedule() {
          if (inProgress) {
            if (document2.hidden === false && window2.requestAnimationFrame) {
              window2.requestAnimationFrame(schedule);
            } else {
              window2.setTimeout(schedule, jQuery2.fx.interval);
            }
            jQuery2.fx.tick();
          }
        }
        function createFxNow() {
          window2.setTimeout(function() {
            fxNow = void 0;
          });
          return fxNow = Date.now();
        }
        function genFx(type, includeWidth) {
          var which, i = 0, attrs = { height: type };
          includeWidth = includeWidth ? 1 : 0;
          for (; i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] = type;
          }
          if (includeWidth) {
            attrs.opacity = attrs.width = type;
          }
          return attrs;
        }
        function createTween(value, prop, animation) {
          var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
          for (; index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
              return tween;
            }
          }
        }
        function defaultPrefilter(elem, props, opts) {
          var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
          if (!opts.queue) {
            hooks = jQuery2._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
              hooks.unqueued = 0;
              oldfire = hooks.empty.fire;
              hooks.empty.fire = function() {
                if (!hooks.unqueued) {
                  oldfire();
                }
              };
            }
            hooks.unqueued++;
            anim.always(function() {
              anim.always(function() {
                hooks.unqueued--;
                if (!jQuery2.queue(elem, "fx").length) {
                  hooks.empty.fire();
                }
              });
            });
          }
          for (prop in props) {
            value = props[prop];
            if (rfxtypes.test(value)) {
              delete props[prop];
              toggle = toggle || value === "toggle";
              if (value === (hidden ? "hide" : "show")) {
                if (value === "show" && dataShow && dataShow[prop] !== void 0) {
                  hidden = true;
                } else {
                  continue;
                }
              }
              orig[prop] = dataShow && dataShow[prop] || jQuery2.style(elem, prop);
            }
          }
          propTween = !jQuery2.isEmptyObject(props);
          if (!propTween && jQuery2.isEmptyObject(orig)) {
            return;
          }
          if (isBox && elem.nodeType === 1) {
            opts.overflow = [style.overflow, style.overflowX, style.overflowY];
            restoreDisplay = dataShow && dataShow.display;
            if (restoreDisplay == null) {
              restoreDisplay = dataPriv.get(elem, "display");
            }
            display = jQuery2.css(elem, "display");
            if (display === "none") {
              if (restoreDisplay) {
                display = restoreDisplay;
              } else {
                showHide([elem], true);
                restoreDisplay = elem.style.display || restoreDisplay;
                display = jQuery2.css(elem, "display");
                showHide([elem]);
              }
            }
            if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
              if (jQuery2.css(elem, "float") === "none") {
                if (!propTween) {
                  anim.done(function() {
                    style.display = restoreDisplay;
                  });
                  if (restoreDisplay == null) {
                    display = style.display;
                    restoreDisplay = display === "none" ? "" : display;
                  }
                }
                style.display = "inline-block";
              }
            }
          }
          if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function() {
              style.overflow = opts.overflow[0];
              style.overflowX = opts.overflow[1];
              style.overflowY = opts.overflow[2];
            });
          }
          propTween = false;
          for (prop in orig) {
            if (!propTween) {
              if (dataShow) {
                if ("hidden" in dataShow) {
                  hidden = dataShow.hidden;
                }
              } else {
                dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
              }
              if (toggle) {
                dataShow.hidden = !hidden;
              }
              if (hidden) {
                showHide([elem], true);
              }
              anim.done(function() {
                if (!hidden) {
                  showHide([elem]);
                }
                dataPriv.remove(elem, "fxshow");
                for (prop in orig) {
                  jQuery2.style(elem, prop, orig[prop]);
                }
              });
            }
            propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
            if (!(prop in dataShow)) {
              dataShow[prop] = propTween.start;
              if (hidden) {
                propTween.end = propTween.start;
                propTween.start = 0;
              }
            }
          }
        }
        function propFilter(props, specialEasing) {
          var index, name, easing, value, hooks;
          for (index in props) {
            name = camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (Array.isArray(value)) {
              easing = value[1];
              value = props[index] = value[0];
            }
            if (index !== name) {
              props[name] = value;
              delete props[index];
            }
            hooks = jQuery2.cssHooks[name];
            if (hooks && "expand" in hooks) {
              value = hooks.expand(value);
              delete props[name];
              for (index in value) {
                if (!(index in props)) {
                  props[index] = value[index];
                  specialEasing[index] = easing;
                }
              }
            } else {
              specialEasing[name] = easing;
            }
          }
        }
        function Animation(elem, properties, options) {
          var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery2.Deferred().always(function() {
            delete tick.elem;
          }), tick = function() {
            if (stopped) {
              return false;
            }
            var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index2 = 0, length2 = animation.tweens.length;
            for (; index2 < length2; index2++) {
              animation.tweens[index2].run(percent);
            }
            deferred.notifyWith(elem, [animation, percent, remaining]);
            if (percent < 1 && length2) {
              return remaining;
            }
            if (!length2) {
              deferred.notifyWith(elem, [animation, 1, 0]);
            }
            deferred.resolveWith(elem, [animation]);
            return false;
          }, animation = deferred.promise({
            elem,
            props: jQuery2.extend({}, properties),
            opts: jQuery2.extend(true, {
              specialEasing: {},
              easing: jQuery2.easing._default
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function(prop, end) {
              var tween = jQuery2.Tween(
                elem,
                animation.opts,
                prop,
                end,
                animation.opts.specialEasing[prop] || animation.opts.easing
              );
              animation.tweens.push(tween);
              return tween;
            },
            stop: function(gotoEnd) {
              var index2 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
              if (stopped) {
                return this;
              }
              stopped = true;
              for (; index2 < length2; index2++) {
                animation.tweens[index2].run(1);
              }
              if (gotoEnd) {
                deferred.notifyWith(elem, [animation, 1, 0]);
                deferred.resolveWith(elem, [animation, gotoEnd]);
              } else {
                deferred.rejectWith(elem, [animation, gotoEnd]);
              }
              return this;
            }
          }), props = animation.props;
          propFilter(props, animation.opts.specialEasing);
          for (; index < length; index++) {
            result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
              if (isFunction(result.stop)) {
                jQuery2._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
              }
              return result;
            }
          }
          jQuery2.map(props, createTween, animation);
          if (isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
          }
          animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
          jQuery2.fx.timer(
            jQuery2.extend(tick, {
              elem,
              anim: animation,
              queue: animation.opts.queue
            })
          );
          return animation;
        }
        jQuery2.Animation = jQuery2.extend(Animation, {
          tweeners: {
            "*": [function(prop, value) {
              var tween = this.createTween(prop, value);
              adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
              return tween;
            }]
          },
          tweener: function(props, callback) {
            if (isFunction(props)) {
              callback = props;
              props = ["*"];
            } else {
              props = props.match(rnothtmlwhite);
            }
            var prop, index = 0, length = props.length;
            for (; index < length; index++) {
              prop = props[index];
              Animation.tweeners[prop] = Animation.tweeners[prop] || [];
              Animation.tweeners[prop].unshift(callback);
            }
          },
          prefilters: [defaultPrefilter],
          prefilter: function(callback, prepend) {
            if (prepend) {
              Animation.prefilters.unshift(callback);
            } else {
              Animation.prefilters.push(callback);
            }
          }
        });
        jQuery2.speed = function(speed, easing, fn) {
          var opt = speed && typeof speed === "object" ? jQuery2.extend({}, speed) : {
            complete: fn || !fn && easing || isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !isFunction(easing) && easing
          };
          if (jQuery2.fx.off) {
            opt.duration = 0;
          } else {
            if (typeof opt.duration !== "number") {
              if (opt.duration in jQuery2.fx.speeds) {
                opt.duration = jQuery2.fx.speeds[opt.duration];
              } else {
                opt.duration = jQuery2.fx.speeds._default;
              }
            }
          }
          if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
          }
          opt.old = opt.complete;
          opt.complete = function() {
            if (isFunction(opt.old)) {
              opt.old.call(this);
            }
            if (opt.queue) {
              jQuery2.dequeue(this, opt.queue);
            }
          };
          return opt;
        };
        jQuery2.fn.extend({
          fadeTo: function(speed, to, easing, callback) {
            return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to }, speed, easing, callback);
          },
          animate: function(prop, speed, easing, callback) {
            var empty = jQuery2.isEmptyObject(prop), optall = jQuery2.speed(speed, easing, callback), doAnimation = function() {
              var anim = Animation(this, jQuery2.extend({}, prop), optall);
              if (empty || dataPriv.get(this, "finish")) {
                anim.stop(true);
              }
            };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
          },
          stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
              var stop = hooks.stop;
              delete hooks.stop;
              stop(gotoEnd);
            };
            if (typeof type !== "string") {
              gotoEnd = clearQueue;
              clearQueue = type;
              type = void 0;
            }
            if (clearQueue) {
              this.queue(type || "fx", []);
            }
            return this.each(function() {
              var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery2.timers, data = dataPriv.get(this);
              if (index) {
                if (data[index] && data[index].stop) {
                  stopQueue(data[index]);
                }
              } else {
                for (index in data) {
                  if (data[index] && data[index].stop && rrun.test(index)) {
                    stopQueue(data[index]);
                  }
                }
              }
              for (index = timers.length; index--; ) {
                if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                  timers[index].anim.stop(gotoEnd);
                  dequeue = false;
                  timers.splice(index, 1);
                }
              }
              if (dequeue || !gotoEnd) {
                jQuery2.dequeue(this, type);
              }
            });
          },
          finish: function(type) {
            if (type !== false) {
              type = type || "fx";
            }
            return this.each(function() {
              var index, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery2.timers, length = queue ? queue.length : 0;
              data.finish = true;
              jQuery2.queue(this, type, []);
              if (hooks && hooks.stop) {
                hooks.stop.call(this, true);
              }
              for (index = timers.length; index--; ) {
                if (timers[index].elem === this && timers[index].queue === type) {
                  timers[index].anim.stop(true);
                  timers.splice(index, 1);
                }
              }
              for (index = 0; index < length; index++) {
                if (queue[index] && queue[index].finish) {
                  queue[index].finish.call(this);
                }
              }
              delete data.finish;
            });
          }
        });
        jQuery2.each(["toggle", "show", "hide"], function(_i, name) {
          var cssFn = jQuery2.fn[name];
          jQuery2.fn[name] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
          };
        });
        jQuery2.each({
          slideDown: genFx("show"),
          slideUp: genFx("hide"),
          slideToggle: genFx("toggle"),
          fadeIn: { opacity: "show" },
          fadeOut: { opacity: "hide" },
          fadeToggle: { opacity: "toggle" }
        }, function(name, props) {
          jQuery2.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
          };
        });
        jQuery2.timers = [];
        jQuery2.fx.tick = function() {
          var timer, i = 0, timers = jQuery2.timers;
          fxNow = Date.now();
          for (; i < timers.length; i++) {
            timer = timers[i];
            if (!timer() && timers[i] === timer) {
              timers.splice(i--, 1);
            }
          }
          if (!timers.length) {
            jQuery2.fx.stop();
          }
          fxNow = void 0;
        };
        jQuery2.fx.timer = function(timer) {
          jQuery2.timers.push(timer);
          jQuery2.fx.start();
        };
        jQuery2.fx.interval = 13;
        jQuery2.fx.start = function() {
          if (inProgress) {
            return;
          }
          inProgress = true;
          schedule();
        };
        jQuery2.fx.stop = function() {
          inProgress = null;
        };
        jQuery2.fx.speeds = {
          slow: 600,
          fast: 200,
          _default: 400
        };
        jQuery2.fn.delay = function(time, type) {
          time = jQuery2.fx ? jQuery2.fx.speeds[time] || time : time;
          type = type || "fx";
          return this.queue(type, function(next, hooks) {
            var timeout = window2.setTimeout(next, time);
            hooks.stop = function() {
              window2.clearTimeout(timeout);
            };
          });
        };
        (function() {
          var input = document2.createElement("input"), select = document2.createElement("select"), opt = select.appendChild(document2.createElement("option"));
          input.type = "checkbox";
          support.checkOn = input.value !== "";
          support.optSelected = opt.selected;
          input = document2.createElement("input");
          input.value = "t";
          input.type = "radio";
          support.radioValue = input.value === "t";
        })();
        var boolHook, attrHandle = jQuery2.expr.attrHandle;
        jQuery2.fn.extend({
          attr: function(name, value) {
            return access(this, jQuery2.attr, name, value, arguments.length > 1);
          },
          removeAttr: function(name) {
            return this.each(function() {
              jQuery2.removeAttr(this, name);
            });
          }
        });
        jQuery2.extend({
          attr: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
              return;
            }
            if (typeof elem.getAttribute === "undefined") {
              return jQuery2.prop(elem, name, value);
            }
            if (nType !== 1 || !jQuery2.isXMLDoc(elem)) {
              hooks = jQuery2.attrHooks[name.toLowerCase()] || (jQuery2.expr.match.bool.test(name) ? boolHook : void 0);
            }
            if (value !== void 0) {
              if (value === null) {
                jQuery2.removeAttr(elem, name);
                return;
              }
              if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
                return ret;
              }
              elem.setAttribute(name, value + "");
              return value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
              return ret;
            }
            ret = jQuery2.find.attr(elem, name);
            return ret == null ? void 0 : ret;
          },
          attrHooks: {
            type: {
              set: function(elem, value) {
                if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
                  var val = elem.value;
                  elem.setAttribute("type", value);
                  if (val) {
                    elem.value = val;
                  }
                  return value;
                }
              }
            }
          },
          removeAttr: function(elem, value) {
            var name, i = 0, attrNames = value && value.match(rnothtmlwhite);
            if (attrNames && elem.nodeType === 1) {
              while (name = attrNames[i++]) {
                elem.removeAttribute(name);
              }
            }
          }
        });
        boolHook = {
          set: function(elem, value, name) {
            if (value === false) {
              jQuery2.removeAttr(elem, name);
            } else {
              elem.setAttribute(name, name);
            }
            return name;
          }
        };
        jQuery2.each(jQuery2.expr.match.bool.source.match(/\w+/g), function(_i, name) {
          var getter = attrHandle[name] || jQuery2.find.attr;
          attrHandle[name] = function(elem, name2, isXML) {
            var ret, handle, lowercaseName = name2.toLowerCase();
            if (!isXML) {
              handle = attrHandle[lowercaseName];
              attrHandle[lowercaseName] = ret;
              ret = getter(elem, name2, isXML) != null ? lowercaseName : null;
              attrHandle[lowercaseName] = handle;
            }
            return ret;
          };
        });
        var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
        jQuery2.fn.extend({
          prop: function(name, value) {
            return access(this, jQuery2.prop, name, value, arguments.length > 1);
          },
          removeProp: function(name) {
            return this.each(function() {
              delete this[jQuery2.propFix[name] || name];
            });
          }
        });
        jQuery2.extend({
          prop: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
              return;
            }
            if (nType !== 1 || !jQuery2.isXMLDoc(elem)) {
              name = jQuery2.propFix[name] || name;
              hooks = jQuery2.propHooks[name];
            }
            if (value !== void 0) {
              if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
                return ret;
              }
              return elem[name] = value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
              return ret;
            }
            return elem[name];
          },
          propHooks: {
            tabIndex: {
              get: function(elem) {
                var tabindex = jQuery2.find.attr(elem, "tabindex");
                if (tabindex) {
                  return parseInt(tabindex, 10);
                }
                if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                  return 0;
                }
                return -1;
              }
            }
          },
          propFix: {
            "for": "htmlFor",
            "class": "className"
          }
        });
        if (!support.optSelected) {
          jQuery2.propHooks.selected = {
            get: function(elem) {
              var parent = elem.parentNode;
              if (parent && parent.parentNode) {
                parent.parentNode.selectedIndex;
              }
              return null;
            },
            set: function(elem) {
              var parent = elem.parentNode;
              if (parent) {
                parent.selectedIndex;
                if (parent.parentNode) {
                  parent.parentNode.selectedIndex;
                }
              }
            }
          };
        }
        jQuery2.each([
          "tabIndex",
          "readOnly",
          "maxLength",
          "cellSpacing",
          "cellPadding",
          "rowSpan",
          "colSpan",
          "useMap",
          "frameBorder",
          "contentEditable"
        ], function() {
          jQuery2.propFix[this.toLowerCase()] = this;
        });
        function stripAndCollapse(value) {
          var tokens = value.match(rnothtmlwhite) || [];
          return tokens.join(" ");
        }
        function getClass(elem) {
          return elem.getAttribute && elem.getAttribute("class") || "";
        }
        function classesToArray(value) {
          if (Array.isArray(value)) {
            return value;
          }
          if (typeof value === "string") {
            return value.match(rnothtmlwhite) || [];
          }
          return [];
        }
        jQuery2.fn.extend({
          addClass: function(value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
            if (isFunction(value)) {
              return this.each(function(j2) {
                jQuery2(this).addClass(value.call(this, j2, getClass(this)));
              });
            }
            classes = classesToArray(value);
            if (classes.length) {
              while (elem = this[i++]) {
                curValue = getClass(elem);
                cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                if (cur) {
                  j = 0;
                  while (clazz = classes[j++]) {
                    if (cur.indexOf(" " + clazz + " ") < 0) {
                      cur += clazz + " ";
                    }
                  }
                  finalValue = stripAndCollapse(cur);
                  if (curValue !== finalValue) {
                    elem.setAttribute("class", finalValue);
                  }
                }
              }
            }
            return this;
          },
          removeClass: function(value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
            if (isFunction(value)) {
              return this.each(function(j2) {
                jQuery2(this).removeClass(value.call(this, j2, getClass(this)));
              });
            }
            if (!arguments.length) {
              return this.attr("class", "");
            }
            classes = classesToArray(value);
            if (classes.length) {
              while (elem = this[i++]) {
                curValue = getClass(elem);
                cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                if (cur) {
                  j = 0;
                  while (clazz = classes[j++]) {
                    while (cur.indexOf(" " + clazz + " ") > -1) {
                      cur = cur.replace(" " + clazz + " ", " ");
                    }
                  }
                  finalValue = stripAndCollapse(cur);
                  if (curValue !== finalValue) {
                    elem.setAttribute("class", finalValue);
                  }
                }
              }
            }
            return this;
          },
          toggleClass: function(value, stateVal) {
            var type = typeof value, isValidValue = type === "string" || Array.isArray(value);
            if (typeof stateVal === "boolean" && isValidValue) {
              return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            if (isFunction(value)) {
              return this.each(function(i) {
                jQuery2(this).toggleClass(
                  value.call(this, i, getClass(this), stateVal),
                  stateVal
                );
              });
            }
            return this.each(function() {
              var className, i, self2, classNames;
              if (isValidValue) {
                i = 0;
                self2 = jQuery2(this);
                classNames = classesToArray(value);
                while (className = classNames[i++]) {
                  if (self2.hasClass(className)) {
                    self2.removeClass(className);
                  } else {
                    self2.addClass(className);
                  }
                }
              } else if (value === void 0 || type === "boolean") {
                className = getClass(this);
                if (className) {
                  dataPriv.set(this, "__className__", className);
                }
                if (this.setAttribute) {
                  this.setAttribute(
                    "class",
                    className || value === false ? "" : dataPriv.get(this, "__className__") || ""
                  );
                }
              }
            });
          },
          hasClass: function(selector) {
            var className, elem, i = 0;
            className = " " + selector + " ";
            while (elem = this[i++]) {
              if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
                return true;
              }
            }
            return false;
          }
        });
        var rreturn = /\r/g;
        jQuery2.fn.extend({
          val: function(value) {
            var hooks, ret, valueIsFunction, elem = this[0];
            if (!arguments.length) {
              if (elem) {
                hooks = jQuery2.valHooks[elem.type] || jQuery2.valHooks[elem.nodeName.toLowerCase()];
                if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
                  return ret;
                }
                ret = elem.value;
                if (typeof ret === "string") {
                  return ret.replace(rreturn, "");
                }
                return ret == null ? "" : ret;
              }
              return;
            }
            valueIsFunction = isFunction(value);
            return this.each(function(i) {
              var val;
              if (this.nodeType !== 1) {
                return;
              }
              if (valueIsFunction) {
                val = value.call(this, i, jQuery2(this).val());
              } else {
                val = value;
              }
              if (val == null) {
                val = "";
              } else if (typeof val === "number") {
                val += "";
              } else if (Array.isArray(val)) {
                val = jQuery2.map(val, function(value2) {
                  return value2 == null ? "" : value2 + "";
                });
              }
              hooks = jQuery2.valHooks[this.type] || jQuery2.valHooks[this.nodeName.toLowerCase()];
              if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
                this.value = val;
              }
            });
          }
        });
        jQuery2.extend({
          valHooks: {
            option: {
              get: function(elem) {
                var val = jQuery2.find.attr(elem, "value");
                return val != null ? val : stripAndCollapse(jQuery2.text(elem));
              }
            },
            select: {
              get: function(elem) {
                var value, option, i, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one", values = one ? null : [], max = one ? index + 1 : options.length;
                if (index < 0) {
                  i = max;
                } else {
                  i = one ? index : 0;
                }
                for (; i < max; i++) {
                  option = options[i];
                  if ((option.selected || i === index) && !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                    value = jQuery2(option).val();
                    if (one) {
                      return value;
                    }
                    values.push(value);
                  }
                }
                return values;
              },
              set: function(elem, value) {
                var optionSet, option, options = elem.options, values = jQuery2.makeArray(value), i = options.length;
                while (i--) {
                  option = options[i];
                  if (option.selected = jQuery2.inArray(jQuery2.valHooks.option.get(option), values) > -1) {
                    optionSet = true;
                  }
                }
                if (!optionSet) {
                  elem.selectedIndex = -1;
                }
                return values;
              }
            }
          }
        });
        jQuery2.each(["radio", "checkbox"], function() {
          jQuery2.valHooks[this] = {
            set: function(elem, value) {
              if (Array.isArray(value)) {
                return elem.checked = jQuery2.inArray(jQuery2(elem).val(), value) > -1;
              }
            }
          };
          if (!support.checkOn) {
            jQuery2.valHooks[this].get = function(elem) {
              return elem.getAttribute("value") === null ? "on" : elem.value;
            };
          }
        });
        support.focusin = "onfocusin" in window2;
        var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e) {
          e.stopPropagation();
        };
        jQuery2.extend(jQuery2.event, {
          trigger: function(event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document2], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            cur = lastElement = tmp = elem = elem || document2;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
              return;
            }
            if (rfocusMorph.test(type + jQuery2.event.triggered)) {
              return;
            }
            if (type.indexOf(".") > -1) {
              namespaces = type.split(".");
              type = namespaces.shift();
              namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;
            event = event[jQuery2.expando] ? event : new jQuery2.Event(type, typeof event === "object" && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            event.result = void 0;
            if (!event.target) {
              event.target = elem;
            }
            data = data == null ? [event] : jQuery2.makeArray(data, [event]);
            special = jQuery2.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
              return;
            }
            if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
              bubbleType = special.delegateType || type;
              if (!rfocusMorph.test(bubbleType + type)) {
                cur = cur.parentNode;
              }
              for (; cur; cur = cur.parentNode) {
                eventPath.push(cur);
                tmp = cur;
              }
              if (tmp === (elem.ownerDocument || document2)) {
                eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
              }
            }
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
              lastElement = cur;
              event.type = i > 1 ? bubbleType : special.bindType || type;
              handle = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event.type] && dataPriv.get(cur, "handle");
              if (handle) {
                handle.apply(cur, data);
              }
              handle = ontype && cur[ontype];
              if (handle && handle.apply && acceptData(cur)) {
                event.result = handle.apply(cur, data);
                if (event.result === false) {
                  event.preventDefault();
                }
              }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
              if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
                if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
                  tmp = elem[ontype];
                  if (tmp) {
                    elem[ontype] = null;
                  }
                  jQuery2.event.triggered = type;
                  if (event.isPropagationStopped()) {
                    lastElement.addEventListener(type, stopPropagationCallback);
                  }
                  elem[type]();
                  if (event.isPropagationStopped()) {
                    lastElement.removeEventListener(type, stopPropagationCallback);
                  }
                  jQuery2.event.triggered = void 0;
                  if (tmp) {
                    elem[ontype] = tmp;
                  }
                }
              }
            }
            return event.result;
          },
          simulate: function(type, elem, event) {
            var e = jQuery2.extend(
              new jQuery2.Event(),
              event,
              {
                type,
                isSimulated: true
              }
            );
            jQuery2.event.trigger(e, null, elem);
          }
        });
        jQuery2.fn.extend({
          trigger: function(type, data) {
            return this.each(function() {
              jQuery2.event.trigger(type, data, this);
            });
          },
          triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) {
              return jQuery2.event.trigger(type, data, elem, true);
            }
          }
        });
        if (!support.focusin) {
          jQuery2.each({ focus: "focusin", blur: "focusout" }, function(orig, fix) {
            var handler = function(event) {
              jQuery2.event.simulate(fix, event.target, jQuery2.event.fix(event));
            };
            jQuery2.event.special[fix] = {
              setup: function() {
                var doc = this.ownerDocument || this.document || this, attaches = dataPriv.access(doc, fix);
                if (!attaches) {
                  doc.addEventListener(orig, handler, true);
                }
                dataPriv.access(doc, fix, (attaches || 0) + 1);
              },
              teardown: function() {
                var doc = this.ownerDocument || this.document || this, attaches = dataPriv.access(doc, fix) - 1;
                if (!attaches) {
                  doc.removeEventListener(orig, handler, true);
                  dataPriv.remove(doc, fix);
                } else {
                  dataPriv.access(doc, fix, attaches);
                }
              }
            };
          });
        }
        var location2 = window2.location;
        var nonce = { guid: Date.now() };
        var rquery = /\?/;
        jQuery2.parseXML = function(data) {
          var xml, parserErrorElem;
          if (!data || typeof data !== "string") {
            return null;
          }
          try {
            xml = new window2.DOMParser().parseFromString(data, "text/xml");
          } catch (e) {
          }
          parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
          if (!xml || parserErrorElem) {
            jQuery2.error("Invalid XML: " + (parserErrorElem ? jQuery2.map(parserErrorElem.childNodes, function(el) {
              return el.textContent;
            }).join("\n") : data));
          }
          return xml;
        };
        var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
        function buildParams(prefix, obj, traditional, add) {
          var name;
          if (Array.isArray(obj)) {
            jQuery2.each(obj, function(i, v) {
              if (traditional || rbracket.test(prefix)) {
                add(prefix, v);
              } else {
                buildParams(
                  prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]",
                  v,
                  traditional,
                  add
                );
              }
            });
          } else if (!traditional && toType(obj) === "object") {
            for (name in obj) {
              buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
            }
          } else {
            add(prefix, obj);
          }
        }
        jQuery2.param = function(a, traditional) {
          var prefix, s = [], add = function(key, valueOrFunction) {
            var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
          };
          if (a == null) {
            return "";
          }
          if (Array.isArray(a) || a.jquery && !jQuery2.isPlainObject(a)) {
            jQuery2.each(a, function() {
              add(this.name, this.value);
            });
          } else {
            for (prefix in a) {
              buildParams(prefix, a[prefix], traditional, add);
            }
          }
          return s.join("&");
        };
        jQuery2.fn.extend({
          serialize: function() {
            return jQuery2.param(this.serializeArray());
          },
          serializeArray: function() {
            return this.map(function() {
              var elements = jQuery2.prop(this, "elements");
              return elements ? jQuery2.makeArray(elements) : this;
            }).filter(function() {
              var type = this.type;
              return this.name && !jQuery2(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(_i, elem) {
              var val = jQuery2(this).val();
              if (val == null) {
                return null;
              }
              if (Array.isArray(val)) {
                return jQuery2.map(val, function(val2) {
                  return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
                });
              }
              return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
            }).get();
          }
        });
        var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
        originAnchor.href = location2.href;
        function addToPrefiltersOrTransports(structure) {
          return function(dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") {
              func = dataTypeExpression;
              dataTypeExpression = "*";
            }
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
            if (isFunction(func)) {
              while (dataType = dataTypes[i++]) {
                if (dataType[0] === "+") {
                  dataType = dataType.slice(1) || "*";
                  (structure[dataType] = structure[dataType] || []).unshift(func);
                } else {
                  (structure[dataType] = structure[dataType] || []).push(func);
                }
              }
            }
          };
        }
        function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
          var inspected = {}, seekingTransport = structure === transports;
          function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery2.each(structure[dataType] || [], function(_, prefilterOrFactory) {
              var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
              if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                options.dataTypes.unshift(dataTypeOrTransport);
                inspect(dataTypeOrTransport);
                return false;
              } else if (seekingTransport) {
                return !(selected = dataTypeOrTransport);
              }
            });
            return selected;
          }
          return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
        }
        function ajaxExtend(target, src) {
          var key, deep, flatOptions = jQuery2.ajaxSettings.flatOptions || {};
          for (key in src) {
            if (src[key] !== void 0) {
              (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
          }
          if (deep) {
            jQuery2.extend(true, target, deep);
          }
          return target;
        }
        function ajaxHandleResponses(s, jqXHR, responses) {
          var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
          while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === void 0) {
              ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
          }
          if (ct) {
            for (type in contents) {
              if (contents[type] && contents[type].test(ct)) {
                dataTypes.unshift(type);
                break;
              }
            }
          }
          if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
          } else {
            for (type in responses) {
              if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                finalDataType = type;
                break;
              }
              if (!firstDataType) {
                firstDataType = type;
              }
            }
            finalDataType = finalDataType || firstDataType;
          }
          if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
              dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
          }
        }
        function ajaxConvert(s, response, jqXHR, isSuccess) {
          var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
          if (dataTypes[1]) {
            for (conv in s.converters) {
              converters[conv.toLowerCase()] = s.converters[conv];
            }
          }
          current = dataTypes.shift();
          while (current) {
            if (s.responseFields[current]) {
              jqXHR[s.responseFields[current]] = response;
            }
            if (!prev && isSuccess && s.dataFilter) {
              response = s.dataFilter(response, s.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
              if (current === "*") {
                current = prev;
              } else if (prev !== "*" && prev !== current) {
                conv = converters[prev + " " + current] || converters["* " + current];
                if (!conv) {
                  for (conv2 in converters) {
                    tmp = conv2.split(" ");
                    if (tmp[1] === current) {
                      conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                      if (conv) {
                        if (conv === true) {
                          conv = converters[conv2];
                        } else if (converters[conv2] !== true) {
                          current = tmp[0];
                          dataTypes.unshift(tmp[1]);
                        }
                        break;
                      }
                    }
                  }
                }
                if (conv !== true) {
                  if (conv && s.throws) {
                    response = conv(response);
                  } else {
                    try {
                      response = conv(response);
                    } catch (e) {
                      return {
                        state: "parsererror",
                        error: conv ? e : "No conversion from " + prev + " to " + current
                      };
                    }
                  }
                }
              }
            }
          }
          return { state: "success", data: response };
        }
        jQuery2.extend({
          active: 0,
          lastModified: {},
          etag: {},
          ajaxSettings: {
            url: location2.href,
            type: "GET",
            isLocal: rlocalProtocol.test(location2.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
              "*": allTypes,
              text: "text/plain",
              html: "text/html",
              xml: "application/xml, text/xml",
              json: "application/json, text/javascript"
            },
            contents: {
              xml: /\bxml\b/,
              html: /\bhtml/,
              json: /\bjson\b/
            },
            responseFields: {
              xml: "responseXML",
              text: "responseText",
              json: "responseJSON"
            },
            converters: {
              "* text": String,
              "text html": true,
              "text json": JSON.parse,
              "text xml": jQuery2.parseXML
            },
            flatOptions: {
              url: true,
              context: true
            }
          },
          ajaxSetup: function(target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery2.ajaxSettings), settings) : ajaxExtend(jQuery2.ajaxSettings, target);
          },
          ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
          ajaxTransport: addToPrefiltersOrTransports(transports),
          ajax: function(url, options) {
            if (typeof url === "object") {
              options = url;
              url = void 0;
            }
            options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i, uncached, s = jQuery2.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery2(callbackContext) : jQuery2.event, deferred = jQuery2.Deferred(), completeDeferred = jQuery2.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
              readyState: 0,
              getResponseHeader: function(key) {
                var match;
                if (completed2) {
                  if (!responseHeaders) {
                    responseHeaders = {};
                    while (match = rheaders.exec(responseHeadersString)) {
                      responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                    }
                  }
                  match = responseHeaders[key.toLowerCase() + " "];
                }
                return match == null ? null : match.join(", ");
              },
              getAllResponseHeaders: function() {
                return completed2 ? responseHeadersString : null;
              },
              setRequestHeader: function(name, value) {
                if (completed2 == null) {
                  name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                  requestHeaders[name] = value;
                }
                return this;
              },
              overrideMimeType: function(type) {
                if (completed2 == null) {
                  s.mimeType = type;
                }
                return this;
              },
              statusCode: function(map) {
                var code;
                if (map) {
                  if (completed2) {
                    jqXHR.always(map[jqXHR.status]);
                  } else {
                    for (code in map) {
                      statusCode[code] = [statusCode[code], map[code]];
                    }
                  }
                }
                return this;
              },
              abort: function(statusText) {
                var finalText = statusText || strAbort;
                if (transport) {
                  transport.abort(finalText);
                }
                done(0, finalText);
                return this;
              }
            };
            deferred.promise(jqXHR);
            s.url = ((url || s.url || location2.href) + "").replace(rprotocol, location2.protocol + "//");
            s.type = options.method || options.type || s.method || s.type;
            s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
            if (s.crossDomain == null) {
              urlAnchor = document2.createElement("a");
              try {
                urlAnchor.href = s.url;
                urlAnchor.href = urlAnchor.href;
                s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
              } catch (e) {
                s.crossDomain = true;
              }
            }
            if (s.data && s.processData && typeof s.data !== "string") {
              s.data = jQuery2.param(s.data, s.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            if (completed2) {
              return jqXHR;
            }
            fireGlobals = jQuery2.event && s.global;
            if (fireGlobals && jQuery2.active++ === 0) {
              jQuery2.event.trigger("ajaxStart");
            }
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test(s.type);
            cacheURL = s.url.replace(rhash, "");
            if (!s.hasContent) {
              uncached = s.url.slice(cacheURL.length);
              if (s.data && (s.processData || typeof s.data === "string")) {
                cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
                delete s.data;
              }
              if (s.cache === false) {
                cacheURL = cacheURL.replace(rantiCache, "$1");
                uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
              }
              s.url = cacheURL + uncached;
            } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
              s.data = s.data.replace(r20, "+");
            }
            if (s.ifModified) {
              if (jQuery2.lastModified[cacheURL]) {
                jqXHR.setRequestHeader("If-Modified-Since", jQuery2.lastModified[cacheURL]);
              }
              if (jQuery2.etag[cacheURL]) {
                jqXHR.setRequestHeader("If-None-Match", jQuery2.etag[cacheURL]);
              }
            }
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
              jqXHR.setRequestHeader("Content-Type", s.contentType);
            }
            jqXHR.setRequestHeader(
              "Accept",
              s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]
            );
            for (i in s.headers) {
              jqXHR.setRequestHeader(i, s.headers[i]);
            }
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed2)) {
              return jqXHR.abort();
            }
            strAbort = "abort";
            completeDeferred.add(s.complete);
            jqXHR.done(s.success);
            jqXHR.fail(s.error);
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            if (!transport) {
              done(-1, "No Transport");
            } else {
              jqXHR.readyState = 1;
              if (fireGlobals) {
                globalEventContext.trigger("ajaxSend", [jqXHR, s]);
              }
              if (completed2) {
                return jqXHR;
              }
              if (s.async && s.timeout > 0) {
                timeoutTimer = window2.setTimeout(function() {
                  jqXHR.abort("timeout");
                }, s.timeout);
              }
              try {
                completed2 = false;
                transport.send(requestHeaders, done);
              } catch (e) {
                if (completed2) {
                  throw e;
                }
                done(-1, e);
              }
            }
            function done(status, nativeStatusText, responses, headers) {
              var isSuccess, success, error, response, modified, statusText = nativeStatusText;
              if (completed2) {
                return;
              }
              completed2 = true;
              if (timeoutTimer) {
                window2.clearTimeout(timeoutTimer);
              }
              transport = void 0;
              responseHeadersString = headers || "";
              jqXHR.readyState = status > 0 ? 4 : 0;
              isSuccess = status >= 200 && status < 300 || status === 304;
              if (responses) {
                response = ajaxHandleResponses(s, jqXHR, responses);
              }
              if (!isSuccess && jQuery2.inArray("script", s.dataTypes) > -1 && jQuery2.inArray("json", s.dataTypes) < 0) {
                s.converters["text script"] = function() {
                };
              }
              response = ajaxConvert(s, response, jqXHR, isSuccess);
              if (isSuccess) {
                if (s.ifModified) {
                  modified = jqXHR.getResponseHeader("Last-Modified");
                  if (modified) {
                    jQuery2.lastModified[cacheURL] = modified;
                  }
                  modified = jqXHR.getResponseHeader("etag");
                  if (modified) {
                    jQuery2.etag[cacheURL] = modified;
                  }
                }
                if (status === 204 || s.type === "HEAD") {
                  statusText = "nocontent";
                } else if (status === 304) {
                  statusText = "notmodified";
                } else {
                  statusText = response.state;
                  success = response.data;
                  error = response.error;
                  isSuccess = !error;
                }
              } else {
                error = statusText;
                if (status || !statusText) {
                  statusText = "error";
                  if (status < 0) {
                    status = 0;
                  }
                }
              }
              jqXHR.status = status;
              jqXHR.statusText = (nativeStatusText || statusText) + "";
              if (isSuccess) {
                deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
              } else {
                deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
              }
              jqXHR.statusCode(statusCode);
              statusCode = void 0;
              if (fireGlobals) {
                globalEventContext.trigger(
                  isSuccess ? "ajaxSuccess" : "ajaxError",
                  [jqXHR, s, isSuccess ? success : error]
                );
              }
              completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
              if (fireGlobals) {
                globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
                if (!--jQuery2.active) {
                  jQuery2.event.trigger("ajaxStop");
                }
              }
            }
            return jqXHR;
          },
          getJSON: function(url, data, callback) {
            return jQuery2.get(url, data, callback, "json");
          },
          getScript: function(url, callback) {
            return jQuery2.get(url, void 0, callback, "script");
          }
        });
        jQuery2.each(["get", "post"], function(_i, method) {
          jQuery2[method] = function(url, data, callback, type) {
            if (isFunction(data)) {
              type = type || callback;
              callback = data;
              data = void 0;
            }
            return jQuery2.ajax(jQuery2.extend({
              url,
              type: method,
              dataType: type,
              data,
              success: callback
            }, jQuery2.isPlainObject(url) && url));
          };
        });
        jQuery2.ajaxPrefilter(function(s) {
          var i;
          for (i in s.headers) {
            if (i.toLowerCase() === "content-type") {
              s.contentType = s.headers[i] || "";
            }
          }
        });
        jQuery2._evalUrl = function(url, options, doc) {
          return jQuery2.ajax({
            url,
            type: "GET",
            dataType: "script",
            cache: true,
            async: false,
            global: false,
            converters: {
              "text script": function() {
              }
            },
            dataFilter: function(response) {
              jQuery2.globalEval(response, options, doc);
            }
          });
        };
        jQuery2.fn.extend({
          wrapAll: function(html) {
            var wrap;
            if (this[0]) {
              if (isFunction(html)) {
                html = html.call(this[0]);
              }
              wrap = jQuery2(html, this[0].ownerDocument).eq(0).clone(true);
              if (this[0].parentNode) {
                wrap.insertBefore(this[0]);
              }
              wrap.map(function() {
                var elem = this;
                while (elem.firstElementChild) {
                  elem = elem.firstElementChild;
                }
                return elem;
              }).append(this);
            }
            return this;
          },
          wrapInner: function(html) {
            if (isFunction(html)) {
              return this.each(function(i) {
                jQuery2(this).wrapInner(html.call(this, i));
              });
            }
            return this.each(function() {
              var self2 = jQuery2(this), contents = self2.contents();
              if (contents.length) {
                contents.wrapAll(html);
              } else {
                self2.append(html);
              }
            });
          },
          wrap: function(html) {
            var htmlIsFunction = isFunction(html);
            return this.each(function(i) {
              jQuery2(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
            });
          },
          unwrap: function(selector) {
            this.parent(selector).not("body").each(function() {
              jQuery2(this).replaceWith(this.childNodes);
            });
            return this;
          }
        });
        jQuery2.expr.pseudos.hidden = function(elem) {
          return !jQuery2.expr.pseudos.visible(elem);
        };
        jQuery2.expr.pseudos.visible = function(elem) {
          return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
        };
        jQuery2.ajaxSettings.xhr = function() {
          try {
            return new window2.XMLHttpRequest();
          } catch (e) {
          }
        };
        var xhrSuccessStatus = {
          0: 200,
          1223: 204
        }, xhrSupported = jQuery2.ajaxSettings.xhr();
        support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
        support.ajax = xhrSupported = !!xhrSupported;
        jQuery2.ajaxTransport(function(options) {
          var callback, errorCallback;
          if (support.cors || xhrSupported && !options.crossDomain) {
            return {
              send: function(headers, complete) {
                var i, xhr = options.xhr();
                xhr.open(
                  options.type,
                  options.url,
                  options.async,
                  options.username,
                  options.password
                );
                if (options.xhrFields) {
                  for (i in options.xhrFields) {
                    xhr[i] = options.xhrFields[i];
                  }
                }
                if (options.mimeType && xhr.overrideMimeType) {
                  xhr.overrideMimeType(options.mimeType);
                }
                if (!options.crossDomain && !headers["X-Requested-With"]) {
                  headers["X-Requested-With"] = "XMLHttpRequest";
                }
                for (i in headers) {
                  xhr.setRequestHeader(i, headers[i]);
                }
                callback = function(type) {
                  return function() {
                    if (callback) {
                      callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                      if (type === "abort") {
                        xhr.abort();
                      } else if (type === "error") {
                        if (typeof xhr.status !== "number") {
                          complete(0, "error");
                        } else {
                          complete(
                            xhr.status,
                            xhr.statusText
                          );
                        }
                      } else {
                        complete(
                          xhrSuccessStatus[xhr.status] || xhr.status,
                          xhr.statusText,
                          (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText },
                          xhr.getAllResponseHeaders()
                        );
                      }
                    }
                  };
                };
                xhr.onload = callback();
                errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
                if (xhr.onabort !== void 0) {
                  xhr.onabort = errorCallback;
                } else {
                  xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4) {
                      window2.setTimeout(function() {
                        if (callback) {
                          errorCallback();
                        }
                      });
                    }
                  };
                }
                callback = callback("abort");
                try {
                  xhr.send(options.hasContent && options.data || null);
                } catch (e) {
                  if (callback) {
                    throw e;
                  }
                }
              },
              abort: function() {
                if (callback) {
                  callback();
                }
              }
            };
          }
        });
        jQuery2.ajaxPrefilter(function(s) {
          if (s.crossDomain) {
            s.contents.script = false;
          }
        });
        jQuery2.ajaxSetup({
          accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
          },
          contents: {
            script: /\b(?:java|ecma)script\b/
          },
          converters: {
            "text script": function(text) {
              jQuery2.globalEval(text);
              return text;
            }
          }
        });
        jQuery2.ajaxPrefilter("script", function(s) {
          if (s.cache === void 0) {
            s.cache = false;
          }
          if (s.crossDomain) {
            s.type = "GET";
          }
        });
        jQuery2.ajaxTransport("script", function(s) {
          if (s.crossDomain || s.scriptAttrs) {
            var script, callback;
            return {
              send: function(_, complete) {
                script = jQuery2("<script>").attr(s.scriptAttrs || {}).prop({ charset: s.scriptCharset, src: s.url }).on("load error", callback = function(evt) {
                  script.remove();
                  callback = null;
                  if (evt) {
                    complete(evt.type === "error" ? 404 : 200, evt.type);
                  }
                });
                document2.head.appendChild(script[0]);
              },
              abort: function() {
                if (callback) {
                  callback();
                }
              }
            };
          }
        });
        var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
        jQuery2.ajaxSetup({
          jsonp: "callback",
          jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery2.expando + "_" + nonce.guid++;
            this[callback] = true;
            return callback;
          }
        });
        jQuery2.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
          var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
          if (jsonProp || s.dataTypes[0] === "jsonp") {
            callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            if (jsonProp) {
              s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
            } else if (s.jsonp !== false) {
              s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            }
            s.converters["script json"] = function() {
              if (!responseContainer) {
                jQuery2.error(callbackName + " was not called");
              }
              return responseContainer[0];
            };
            s.dataTypes[0] = "json";
            overwritten = window2[callbackName];
            window2[callbackName] = function() {
              responseContainer = arguments;
            };
            jqXHR.always(function() {
              if (overwritten === void 0) {
                jQuery2(window2).removeProp(callbackName);
              } else {
                window2[callbackName] = overwritten;
              }
              if (s[callbackName]) {
                s.jsonpCallback = originalSettings.jsonpCallback;
                oldCallbacks.push(callbackName);
              }
              if (responseContainer && isFunction(overwritten)) {
                overwritten(responseContainer[0]);
              }
              responseContainer = overwritten = void 0;
            });
            return "script";
          }
        });
        support.createHTMLDocument = function() {
          var body = document2.implementation.createHTMLDocument("").body;
          body.innerHTML = "<form></form><form></form>";
          return body.childNodes.length === 2;
        }();
        jQuery2.parseHTML = function(data, context, keepScripts) {
          if (typeof data !== "string") {
            return [];
          }
          if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
          }
          var base, parsed, scripts;
          if (!context) {
            if (support.createHTMLDocument) {
              context = document2.implementation.createHTMLDocument("");
              base = context.createElement("base");
              base.href = document2.location.href;
              context.head.appendChild(base);
            } else {
              context = document2;
            }
          }
          parsed = rsingleTag.exec(data);
          scripts = !keepScripts && [];
          if (parsed) {
            return [context.createElement(parsed[1])];
          }
          parsed = buildFragment([data], context, scripts);
          if (scripts && scripts.length) {
            jQuery2(scripts).remove();
          }
          return jQuery2.merge([], parsed.childNodes);
        };
        jQuery2.fn.load = function(url, params, callback) {
          var selector, type, response, self2 = this, off = url.indexOf(" ");
          if (off > -1) {
            selector = stripAndCollapse(url.slice(off));
            url = url.slice(0, off);
          }
          if (isFunction(params)) {
            callback = params;
            params = void 0;
          } else if (params && typeof params === "object") {
            type = "POST";
          }
          if (self2.length > 0) {
            jQuery2.ajax({
              url,
              type: type || "GET",
              dataType: "html",
              data: params
            }).done(function(responseText) {
              response = arguments;
              self2.html(selector ? jQuery2("<div>").append(jQuery2.parseHTML(responseText)).find(selector) : responseText);
            }).always(callback && function(jqXHR, status) {
              self2.each(function() {
                callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
              });
            });
          }
          return this;
        };
        jQuery2.expr.pseudos.animated = function(elem) {
          return jQuery2.grep(jQuery2.timers, function(fn) {
            return elem === fn.elem;
          }).length;
        };
        jQuery2.offset = {
          setOffset: function(elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery2.css(elem, "position"), curElem = jQuery2(elem), props = {};
            if (position === "static") {
              elem.style.position = "relative";
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery2.css(elem, "top");
            curCSSLeft = jQuery2.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
            if (calculatePosition) {
              curPosition = curElem.position();
              curTop = curPosition.top;
              curLeft = curPosition.left;
            } else {
              curTop = parseFloat(curCSSTop) || 0;
              curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (isFunction(options)) {
              options = options.call(elem, i, jQuery2.extend({}, curOffset));
            }
            if (options.top != null) {
              props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
              props.left = options.left - curOffset.left + curLeft;
            }
            if ("using" in options) {
              options.using.call(elem, props);
            } else {
              curElem.css(props);
            }
          }
        };
        jQuery2.fn.extend({
          offset: function(options) {
            if (arguments.length) {
              return options === void 0 ? this : this.each(function(i) {
                jQuery2.offset.setOffset(this, options, i);
              });
            }
            var rect, win, elem = this[0];
            if (!elem) {
              return;
            }
            if (!elem.getClientRects().length) {
              return { top: 0, left: 0 };
            }
            rect = elem.getBoundingClientRect();
            win = elem.ownerDocument.defaultView;
            return {
              top: rect.top + win.pageYOffset,
              left: rect.left + win.pageXOffset
            };
          },
          position: function() {
            if (!this[0]) {
              return;
            }
            var offsetParent, offset, doc, elem = this[0], parentOffset = { top: 0, left: 0 };
            if (jQuery2.css(elem, "position") === "fixed") {
              offset = elem.getBoundingClientRect();
            } else {
              offset = this.offset();
              doc = elem.ownerDocument;
              offsetParent = elem.offsetParent || doc.documentElement;
              while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery2.css(offsetParent, "position") === "static") {
                offsetParent = offsetParent.parentNode;
              }
              if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
                parentOffset = jQuery2(offsetParent).offset();
                parentOffset.top += jQuery2.css(offsetParent, "borderTopWidth", true);
                parentOffset.left += jQuery2.css(offsetParent, "borderLeftWidth", true);
              }
            }
            return {
              top: offset.top - parentOffset.top - jQuery2.css(elem, "marginTop", true),
              left: offset.left - parentOffset.left - jQuery2.css(elem, "marginLeft", true)
            };
          },
          offsetParent: function() {
            return this.map(function() {
              var offsetParent = this.offsetParent;
              while (offsetParent && jQuery2.css(offsetParent, "position") === "static") {
                offsetParent = offsetParent.offsetParent;
              }
              return offsetParent || documentElement;
            });
          }
        });
        jQuery2.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
          var top = "pageYOffset" === prop;
          jQuery2.fn[method] = function(val) {
            return access(this, function(elem, method2, val2) {
              var win;
              if (isWindow(elem)) {
                win = elem;
              } else if (elem.nodeType === 9) {
                win = elem.defaultView;
              }
              if (val2 === void 0) {
                return win ? win[prop] : elem[method2];
              }
              if (win) {
                win.scrollTo(
                  !top ? val2 : win.pageXOffset,
                  top ? val2 : win.pageYOffset
                );
              } else {
                elem[method2] = val2;
              }
            }, method, val, arguments.length);
          };
        });
        jQuery2.each(["top", "left"], function(_i, prop) {
          jQuery2.cssHooks[prop] = addGetHookIf(
            support.pixelPosition,
            function(elem, computed) {
              if (computed) {
                computed = curCSS(elem, prop);
                return rnumnonpx.test(computed) ? jQuery2(elem).position()[prop] + "px" : computed;
              }
            }
          );
        });
        jQuery2.each({ Height: "height", Width: "width" }, function(name, type) {
          jQuery2.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
          }, function(defaultExtra, funcName) {
            jQuery2.fn[funcName] = function(margin, value) {
              var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
              return access(this, function(elem, type2, value2) {
                var doc;
                if (isWindow(elem)) {
                  return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
                }
                if (elem.nodeType === 9) {
                  doc = elem.documentElement;
                  return Math.max(
                    elem.body["scroll" + name],
                    doc["scroll" + name],
                    elem.body["offset" + name],
                    doc["offset" + name],
                    doc["client" + name]
                  );
                }
                return value2 === void 0 ? jQuery2.css(elem, type2, extra) : jQuery2.style(elem, type2, value2, extra);
              }, type, chainable ? margin : void 0, chainable);
            };
          });
        });
        jQuery2.each([
          "ajaxStart",
          "ajaxStop",
          "ajaxComplete",
          "ajaxError",
          "ajaxSuccess",
          "ajaxSend"
        ], function(_i, type) {
          jQuery2.fn[type] = function(fn) {
            return this.on(type, fn);
          };
        });
        jQuery2.fn.extend({
          bind: function(types, data, fn) {
            return this.on(types, null, data, fn);
          },
          unbind: function(types, fn) {
            return this.off(types, null, fn);
          },
          delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn);
          },
          undelegate: function(selector, types, fn) {
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
          },
          hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
          }
        });
        jQuery2.each(
          "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
          function(_i, name) {
            jQuery2.fn[name] = function(data, fn) {
              return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
            };
          }
        );
        var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
        jQuery2.proxy = function(fn, context) {
          var tmp, args, proxy;
          if (typeof context === "string") {
            tmp = fn[context];
            context = fn;
            fn = tmp;
          }
          if (!isFunction(fn)) {
            return void 0;
          }
          args = slice.call(arguments, 2);
          proxy = function() {
            return fn.apply(context || this, args.concat(slice.call(arguments)));
          };
          proxy.guid = fn.guid = fn.guid || jQuery2.guid++;
          return proxy;
        };
        jQuery2.holdReady = function(hold) {
          if (hold) {
            jQuery2.readyWait++;
          } else {
            jQuery2.ready(true);
          }
        };
        jQuery2.isArray = Array.isArray;
        jQuery2.parseJSON = JSON.parse;
        jQuery2.nodeName = nodeName;
        jQuery2.isFunction = isFunction;
        jQuery2.isWindow = isWindow;
        jQuery2.camelCase = camelCase;
        jQuery2.type = toType;
        jQuery2.now = Date.now;
        jQuery2.isNumeric = function(obj) {
          var type = jQuery2.type(obj);
          return (type === "number" || type === "string") && !isNaN(obj - parseFloat(obj));
        };
        jQuery2.trim = function(text) {
          return text == null ? "" : (text + "").replace(rtrim, "");
        };
        if (typeof define === "function" && define.amd) {
          define("jquery", [], function() {
            return jQuery2;
          });
        }
        var _jQuery = window2.jQuery, _$ = window2.$;
        jQuery2.noConflict = function(deep) {
          if (window2.$ === jQuery2) {
            window2.$ = _$;
          }
          if (deep && window2.jQuery === jQuery2) {
            window2.jQuery = _jQuery;
          }
          return jQuery2;
        };
        if (typeof noGlobal === "undefined") {
          window2.jQuery = window2.$ = jQuery2;
        }
        return jQuery2;
      });
    }
  });

  // node_modules/papaparse/papaparse.min.js
  var require_papaparse_min = __commonJS({
    "node_modules/papaparse/papaparse.min.js"(exports, module) {
      !function(e, t) {
        "function" == typeof define && define.amd ? define([], t) : "object" == typeof module && "undefined" != typeof exports ? module.exports = t() : e.Papa = t();
      }(exports, function s() {
        "use strict";
        var f = "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== f ? f : {};
        var n = !f.document && !!f.postMessage, o = n && /blob:/i.test((f.location || {}).protocol), a = {}, h = 0, b = { parse: function(e, t) {
          var i2 = (t = t || {}).dynamicTyping || false;
          M(i2) && (t.dynamicTypingFunction = i2, i2 = {});
          if (t.dynamicTyping = i2, t.transform = !!M(t.transform) && t.transform, t.worker && b.WORKERS_SUPPORTED) {
            var r = function() {
              if (!b.WORKERS_SUPPORTED)
                return false;
              var e2 = (i3 = f.URL || f.webkitURL || null, r2 = s.toString(), b.BLOB_URL || (b.BLOB_URL = i3.createObjectURL(new Blob(["(", r2, ")();"], { type: "text/javascript" })))), t2 = new f.Worker(e2);
              var i3, r2;
              return t2.onmessage = _, t2.id = h++, a[t2.id] = t2;
            }();
            return r.userStep = t.step, r.userChunk = t.chunk, r.userComplete = t.complete, r.userError = t.error, t.step = M(t.step), t.chunk = M(t.chunk), t.complete = M(t.complete), t.error = M(t.error), delete t.worker, void r.postMessage({ input: e, config: t, workerId: r.id });
          }
          var n2 = null;
          b.NODE_STREAM_INPUT, "string" == typeof e ? n2 = t.download ? new l(t) : new p(t) : true === e.readable && M(e.read) && M(e.on) ? n2 = new g(t) : (f.File && e instanceof File || e instanceof Object) && (n2 = new c(t));
          return n2.stream(e);
        }, unparse: function(e, t) {
          var n2 = false, _2 = true, m2 = ",", y2 = "\r\n", s2 = '"', a2 = s2 + s2, i2 = false, r = null, o2 = false;
          !function() {
            if ("object" != typeof t)
              return;
            "string" != typeof t.delimiter || b.BAD_DELIMITERS.filter(function(e2) {
              return -1 !== t.delimiter.indexOf(e2);
            }).length || (m2 = t.delimiter);
            ("boolean" == typeof t.quotes || "function" == typeof t.quotes || Array.isArray(t.quotes)) && (n2 = t.quotes);
            "boolean" != typeof t.skipEmptyLines && "string" != typeof t.skipEmptyLines || (i2 = t.skipEmptyLines);
            "string" == typeof t.newline && (y2 = t.newline);
            "string" == typeof t.quoteChar && (s2 = t.quoteChar);
            "boolean" == typeof t.header && (_2 = t.header);
            if (Array.isArray(t.columns)) {
              if (0 === t.columns.length)
                throw new Error("Option columns is empty");
              r = t.columns;
            }
            void 0 !== t.escapeChar && (a2 = t.escapeChar + s2);
            ("boolean" == typeof t.escapeFormulae || t.escapeFormulae instanceof RegExp) && (o2 = t.escapeFormulae instanceof RegExp ? t.escapeFormulae : /^[=+\-@\t\r].*$/);
          }();
          var h2 = new RegExp(j(s2), "g");
          "string" == typeof e && (e = JSON.parse(e));
          if (Array.isArray(e)) {
            if (!e.length || Array.isArray(e[0]))
              return u2(null, e, i2);
            if ("object" == typeof e[0])
              return u2(r || Object.keys(e[0]), e, i2);
          } else if ("object" == typeof e)
            return "string" == typeof e.data && (e.data = JSON.parse(e.data)), Array.isArray(e.data) && (e.fields || (e.fields = e.meta && e.meta.fields || r), e.fields || (e.fields = Array.isArray(e.data[0]) ? e.fields : "object" == typeof e.data[0] ? Object.keys(e.data[0]) : []), Array.isArray(e.data[0]) || "object" == typeof e.data[0] || (e.data = [e.data])), u2(e.fields || [], e.data || [], i2);
          throw new Error("Unable to serialize unrecognized input");
          function u2(e2, t2, i3) {
            var r2 = "";
            "string" == typeof e2 && (e2 = JSON.parse(e2)), "string" == typeof t2 && (t2 = JSON.parse(t2));
            var n3 = Array.isArray(e2) && 0 < e2.length, s3 = !Array.isArray(t2[0]);
            if (n3 && _2) {
              for (var a3 = 0; a3 < e2.length; a3++)
                0 < a3 && (r2 += m2), r2 += v2(e2[a3], a3);
              0 < t2.length && (r2 += y2);
            }
            for (var o3 = 0; o3 < t2.length; o3++) {
              var h3 = n3 ? e2.length : t2[o3].length, u3 = false, f2 = n3 ? 0 === Object.keys(t2[o3]).length : 0 === t2[o3].length;
              if (i3 && !n3 && (u3 = "greedy" === i3 ? "" === t2[o3].join("").trim() : 1 === t2[o3].length && 0 === t2[o3][0].length), "greedy" === i3 && n3) {
                for (var d2 = [], l2 = 0; l2 < h3; l2++) {
                  var c2 = s3 ? e2[l2] : l2;
                  d2.push(t2[o3][c2]);
                }
                u3 = "" === d2.join("").trim();
              }
              if (!u3) {
                for (var p2 = 0; p2 < h3; p2++) {
                  0 < p2 && !f2 && (r2 += m2);
                  var g2 = n3 && s3 ? e2[p2] : p2;
                  r2 += v2(t2[o3][g2], p2);
                }
                o3 < t2.length - 1 && (!i3 || 0 < h3 && !f2) && (r2 += y2);
              }
            }
            return r2;
          }
          function v2(e2, t2) {
            if (null == e2)
              return "";
            if (e2.constructor === Date)
              return JSON.stringify(e2).slice(1, 25);
            var i3 = false;
            o2 && "string" == typeof e2 && o2.test(e2) && (e2 = "'" + e2, i3 = true);
            var r2 = e2.toString().replace(h2, a2);
            return (i3 = i3 || true === n2 || "function" == typeof n2 && n2(e2, t2) || Array.isArray(n2) && n2[t2] || function(e3, t3) {
              for (var i4 = 0; i4 < t3.length; i4++)
                if (-1 < e3.indexOf(t3[i4]))
                  return true;
              return false;
            }(r2, b.BAD_DELIMITERS) || -1 < r2.indexOf(m2) || " " === r2.charAt(0) || " " === r2.charAt(r2.length - 1)) ? s2 + r2 + s2 : r2;
          }
        } };
        if (b.RECORD_SEP = String.fromCharCode(30), b.UNIT_SEP = String.fromCharCode(31), b.BYTE_ORDER_MARK = "\uFEFF", b.BAD_DELIMITERS = ["\r", "\n", '"', b.BYTE_ORDER_MARK], b.WORKERS_SUPPORTED = !n && !!f.Worker, b.NODE_STREAM_INPUT = 1, b.LocalChunkSize = 10485760, b.RemoteChunkSize = 5242880, b.DefaultDelimiter = ",", b.Parser = E, b.ParserHandle = i, b.NetworkStreamer = l, b.FileStreamer = c, b.StringStreamer = p, b.ReadableStreamStreamer = g, f.jQuery) {
          var d = f.jQuery;
          d.fn.parse = function(o2) {
            var i2 = o2.config || {}, h2 = [];
            return this.each(function(e2) {
              if (!("INPUT" === d(this).prop("tagName").toUpperCase() && "file" === d(this).attr("type").toLowerCase() && f.FileReader) || !this.files || 0 === this.files.length)
                return true;
              for (var t = 0; t < this.files.length; t++)
                h2.push({ file: this.files[t], inputElem: this, instanceConfig: d.extend({}, i2) });
            }), e(), this;
            function e() {
              if (0 !== h2.length) {
                var e2, t, i3, r, n2 = h2[0];
                if (M(o2.before)) {
                  var s2 = o2.before(n2.file, n2.inputElem);
                  if ("object" == typeof s2) {
                    if ("abort" === s2.action)
                      return e2 = "AbortError", t = n2.file, i3 = n2.inputElem, r = s2.reason, void (M(o2.error) && o2.error({ name: e2 }, t, i3, r));
                    if ("skip" === s2.action)
                      return void u2();
                    "object" == typeof s2.config && (n2.instanceConfig = d.extend(n2.instanceConfig, s2.config));
                  } else if ("skip" === s2)
                    return void u2();
                }
                var a2 = n2.instanceConfig.complete;
                n2.instanceConfig.complete = function(e3) {
                  M(a2) && a2(e3, n2.file, n2.inputElem), u2();
                }, b.parse(n2.file, n2.instanceConfig);
              } else
                M(o2.complete) && o2.complete();
            }
            function u2() {
              h2.splice(0, 1), e();
            }
          };
        }
        function u(e) {
          this._handle = null, this._finished = false, this._completed = false, this._halted = false, this._input = null, this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, this._start = 0, this._nextChunk = null, this.isFirstChunk = true, this._completeResults = { data: [], errors: [], meta: {} }, function(e2) {
            var t = w(e2);
            t.chunkSize = parseInt(t.chunkSize), e2.step || e2.chunk || (t.chunkSize = null);
            this._handle = new i(t), (this._handle.streamer = this)._config = t;
          }.call(this, e), this.parseChunk = function(e2, t) {
            if (this.isFirstChunk && M(this._config.beforeFirstChunk)) {
              var i2 = this._config.beforeFirstChunk(e2);
              void 0 !== i2 && (e2 = i2);
            }
            this.isFirstChunk = false, this._halted = false;
            var r = this._partialLine + e2;
            this._partialLine = "";
            var n2 = this._handle.parse(r, this._baseIndex, !this._finished);
            if (!this._handle.paused() && !this._handle.aborted()) {
              var s2 = n2.meta.cursor;
              this._finished || (this._partialLine = r.substring(s2 - this._baseIndex), this._baseIndex = s2), n2 && n2.data && (this._rowCount += n2.data.length);
              var a2 = this._finished || this._config.preview && this._rowCount >= this._config.preview;
              if (o)
                f.postMessage({ results: n2, workerId: b.WORKER_ID, finished: a2 });
              else if (M(this._config.chunk) && !t) {
                if (this._config.chunk(n2, this._handle), this._handle.paused() || this._handle.aborted())
                  return void (this._halted = true);
                n2 = void 0, this._completeResults = void 0;
              }
              return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(n2.data), this._completeResults.errors = this._completeResults.errors.concat(n2.errors), this._completeResults.meta = n2.meta), this._completed || !a2 || !M(this._config.complete) || n2 && n2.meta.aborted || (this._config.complete(this._completeResults, this._input), this._completed = true), a2 || n2 && n2.meta.paused || this._nextChunk(), n2;
            }
            this._halted = true;
          }, this._sendError = function(e2) {
            M(this._config.error) ? this._config.error(e2) : o && this._config.error && f.postMessage({ workerId: b.WORKER_ID, error: e2, finished: false });
          };
        }
        function l(e) {
          var r;
          (e = e || {}).chunkSize || (e.chunkSize = b.RemoteChunkSize), u.call(this, e), this._nextChunk = n ? function() {
            this._readChunk(), this._chunkLoaded();
          } : function() {
            this._readChunk();
          }, this.stream = function(e2) {
            this._input = e2, this._nextChunk();
          }, this._readChunk = function() {
            if (this._finished)
              this._chunkLoaded();
            else {
              if (r = new XMLHttpRequest(), this._config.withCredentials && (r.withCredentials = this._config.withCredentials), n || (r.onload = v(this._chunkLoaded, this), r.onerror = v(this._chunkError, this)), r.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !n), this._config.downloadRequestHeaders) {
                var e2 = this._config.downloadRequestHeaders;
                for (var t in e2)
                  r.setRequestHeader(t, e2[t]);
              }
              if (this._config.chunkSize) {
                var i2 = this._start + this._config.chunkSize - 1;
                r.setRequestHeader("Range", "bytes=" + this._start + "-" + i2);
              }
              try {
                r.send(this._config.downloadRequestBody);
              } catch (e3) {
                this._chunkError(e3.message);
              }
              n && 0 === r.status && this._chunkError();
            }
          }, this._chunkLoaded = function() {
            4 === r.readyState && (r.status < 200 || 400 <= r.status ? this._chunkError() : (this._start += this._config.chunkSize ? this._config.chunkSize : r.responseText.length, this._finished = !this._config.chunkSize || this._start >= function(e2) {
              var t = e2.getResponseHeader("Content-Range");
              if (null === t)
                return -1;
              return parseInt(t.substring(t.lastIndexOf("/") + 1));
            }(r), this.parseChunk(r.responseText)));
          }, this._chunkError = function(e2) {
            var t = r.statusText || e2;
            this._sendError(new Error(t));
          };
        }
        function c(e) {
          var r, n2;
          (e = e || {}).chunkSize || (e.chunkSize = b.LocalChunkSize), u.call(this, e);
          var s2 = "undefined" != typeof FileReader;
          this.stream = function(e2) {
            this._input = e2, n2 = e2.slice || e2.webkitSlice || e2.mozSlice, s2 ? ((r = new FileReader()).onload = v(this._chunkLoaded, this), r.onerror = v(this._chunkError, this)) : r = new FileReaderSync(), this._nextChunk();
          }, this._nextChunk = function() {
            this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
          }, this._readChunk = function() {
            var e2 = this._input;
            if (this._config.chunkSize) {
              var t = Math.min(this._start + this._config.chunkSize, this._input.size);
              e2 = n2.call(e2, this._start, t);
            }
            var i2 = r.readAsText(e2, this._config.encoding);
            s2 || this._chunkLoaded({ target: { result: i2 } });
          }, this._chunkLoaded = function(e2) {
            this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, this.parseChunk(e2.target.result);
          }, this._chunkError = function() {
            this._sendError(r.error);
          };
        }
        function p(e) {
          var i2;
          u.call(this, e = e || {}), this.stream = function(e2) {
            return i2 = e2, this._nextChunk();
          }, this._nextChunk = function() {
            if (!this._finished) {
              var e2, t = this._config.chunkSize;
              return t ? (e2 = i2.substring(0, t), i2 = i2.substring(t)) : (e2 = i2, i2 = ""), this._finished = !i2, this.parseChunk(e2);
            }
          };
        }
        function g(e) {
          u.call(this, e = e || {});
          var t = [], i2 = true, r = false;
          this.pause = function() {
            u.prototype.pause.apply(this, arguments), this._input.pause();
          }, this.resume = function() {
            u.prototype.resume.apply(this, arguments), this._input.resume();
          }, this.stream = function(e2) {
            this._input = e2, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), this._input.on("error", this._streamError);
          }, this._checkIsFinished = function() {
            r && 1 === t.length && (this._finished = true);
          }, this._nextChunk = function() {
            this._checkIsFinished(), t.length ? this.parseChunk(t.shift()) : i2 = true;
          }, this._streamData = v(function(e2) {
            try {
              t.push("string" == typeof e2 ? e2 : e2.toString(this._config.encoding)), i2 && (i2 = false, this._checkIsFinished(), this.parseChunk(t.shift()));
            } catch (e3) {
              this._streamError(e3);
            }
          }, this), this._streamError = v(function(e2) {
            this._streamCleanUp(), this._sendError(e2);
          }, this), this._streamEnd = v(function() {
            this._streamCleanUp(), r = true, this._streamData("");
          }, this), this._streamCleanUp = v(function() {
            this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), this._input.removeListener("error", this._streamError);
          }, this);
        }
        function i(m2) {
          var a2, o2, h2, r = Math.pow(2, 53), n2 = -r, s2 = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/, u2 = /^(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))$/, t = this, i2 = 0, f2 = 0, d2 = false, e = false, l2 = [], c2 = { data: [], errors: [], meta: {} };
          if (M(m2.step)) {
            var p2 = m2.step;
            m2.step = function(e2) {
              if (c2 = e2, _2())
                g2();
              else {
                if (g2(), 0 === c2.data.length)
                  return;
                i2 += e2.data.length, m2.preview && i2 > m2.preview ? o2.abort() : (c2.data = c2.data[0], p2(c2, t));
              }
            };
          }
          function y2(e2) {
            return "greedy" === m2.skipEmptyLines ? "" === e2.join("").trim() : 1 === e2.length && 0 === e2[0].length;
          }
          function g2() {
            return c2 && h2 && (k("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + b.DefaultDelimiter + "'"), h2 = false), m2.skipEmptyLines && (c2.data = c2.data.filter(function(e2) {
              return !y2(e2);
            })), _2() && function() {
              if (!c2)
                return;
              function e2(e3, t3) {
                M(m2.transformHeader) && (e3 = m2.transformHeader(e3, t3)), l2.push(e3);
              }
              if (Array.isArray(c2.data[0])) {
                for (var t2 = 0; _2() && t2 < c2.data.length; t2++)
                  c2.data[t2].forEach(e2);
                c2.data.splice(0, 1);
              } else
                c2.data.forEach(e2);
            }(), function() {
              if (!c2 || !m2.header && !m2.dynamicTyping && !m2.transform)
                return c2;
              function e2(e3, t3) {
                var i3, r2 = m2.header ? {} : [];
                for (i3 = 0; i3 < e3.length; i3++) {
                  var n3 = i3, s3 = e3[i3];
                  m2.header && (n3 = i3 >= l2.length ? "__parsed_extra" : l2[i3]), m2.transform && (s3 = m2.transform(s3, n3)), s3 = v2(n3, s3), "__parsed_extra" === n3 ? (r2[n3] = r2[n3] || [], r2[n3].push(s3)) : r2[n3] = s3;
                }
                return m2.header && (i3 > l2.length ? k("FieldMismatch", "TooManyFields", "Too many fields: expected " + l2.length + " fields but parsed " + i3, f2 + t3) : i3 < l2.length && k("FieldMismatch", "TooFewFields", "Too few fields: expected " + l2.length + " fields but parsed " + i3, f2 + t3)), r2;
              }
              var t2 = 1;
              !c2.data.length || Array.isArray(c2.data[0]) ? (c2.data = c2.data.map(e2), t2 = c2.data.length) : c2.data = e2(c2.data, 0);
              m2.header && c2.meta && (c2.meta.fields = l2);
              return f2 += t2, c2;
            }();
          }
          function _2() {
            return m2.header && 0 === l2.length;
          }
          function v2(e2, t2) {
            return i3 = e2, m2.dynamicTypingFunction && void 0 === m2.dynamicTyping[i3] && (m2.dynamicTyping[i3] = m2.dynamicTypingFunction(i3)), true === (m2.dynamicTyping[i3] || m2.dynamicTyping) ? "true" === t2 || "TRUE" === t2 || "false" !== t2 && "FALSE" !== t2 && (function(e3) {
              if (s2.test(e3)) {
                var t3 = parseFloat(e3);
                if (n2 < t3 && t3 < r)
                  return true;
              }
              return false;
            }(t2) ? parseFloat(t2) : u2.test(t2) ? new Date(t2) : "" === t2 ? null : t2) : t2;
            var i3;
          }
          function k(e2, t2, i3, r2) {
            var n3 = { type: e2, code: t2, message: i3 };
            void 0 !== r2 && (n3.row = r2), c2.errors.push(n3);
          }
          this.parse = function(e2, t2, i3) {
            var r2 = m2.quoteChar || '"';
            if (m2.newline || (m2.newline = function(e3, t3) {
              e3 = e3.substring(0, 1048576);
              var i4 = new RegExp(j(t3) + "([^]*?)" + j(t3), "gm"), r3 = (e3 = e3.replace(i4, "")).split("\r"), n4 = e3.split("\n"), s4 = 1 < n4.length && n4[0].length < r3[0].length;
              if (1 === r3.length || s4)
                return "\n";
              for (var a3 = 0, o3 = 0; o3 < r3.length; o3++)
                "\n" === r3[o3][0] && a3++;
              return a3 >= r3.length / 2 ? "\r\n" : "\r";
            }(e2, r2)), h2 = false, m2.delimiter)
              M(m2.delimiter) && (m2.delimiter = m2.delimiter(e2), c2.meta.delimiter = m2.delimiter);
            else {
              var n3 = function(e3, t3, i4, r3, n4) {
                var s4, a3, o3, h3;
                n4 = n4 || [",", "	", "|", ";", b.RECORD_SEP, b.UNIT_SEP];
                for (var u3 = 0; u3 < n4.length; u3++) {
                  var f3 = n4[u3], d3 = 0, l3 = 0, c3 = 0;
                  o3 = void 0;
                  for (var p3 = new E({ comments: r3, delimiter: f3, newline: t3, preview: 10 }).parse(e3), g3 = 0; g3 < p3.data.length; g3++)
                    if (i4 && y2(p3.data[g3]))
                      c3++;
                    else {
                      var _3 = p3.data[g3].length;
                      l3 += _3, void 0 !== o3 ? 0 < _3 && (d3 += Math.abs(_3 - o3), o3 = _3) : o3 = _3;
                    }
                  0 < p3.data.length && (l3 /= p3.data.length - c3), (void 0 === a3 || d3 <= a3) && (void 0 === h3 || h3 < l3) && 1.99 < l3 && (a3 = d3, s4 = f3, h3 = l3);
                }
                return { successful: !!(m2.delimiter = s4), bestDelimiter: s4 };
              }(e2, m2.newline, m2.skipEmptyLines, m2.comments, m2.delimitersToGuess);
              n3.successful ? m2.delimiter = n3.bestDelimiter : (h2 = true, m2.delimiter = b.DefaultDelimiter), c2.meta.delimiter = m2.delimiter;
            }
            var s3 = w(m2);
            return m2.preview && m2.header && s3.preview++, a2 = e2, o2 = new E(s3), c2 = o2.parse(a2, t2, i3), g2(), d2 ? { meta: { paused: true } } : c2 || { meta: { paused: false } };
          }, this.paused = function() {
            return d2;
          }, this.pause = function() {
            d2 = true, o2.abort(), a2 = M(m2.chunk) ? "" : a2.substring(o2.getCharIndex());
          }, this.resume = function() {
            t.streamer._halted ? (d2 = false, t.streamer.parseChunk(a2, true)) : setTimeout(t.resume, 3);
          }, this.aborted = function() {
            return e;
          }, this.abort = function() {
            e = true, o2.abort(), c2.meta.aborted = true, M(m2.complete) && m2.complete(c2), a2 = "";
          };
        }
        function j(e) {
          return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        }
        function E(e) {
          var S, O = (e = e || {}).delimiter, x = e.newline, I = e.comments, T = e.step, D = e.preview, A = e.fastMode, L3 = S = void 0 === e.quoteChar || null === e.quoteChar ? '"' : e.quoteChar;
          if (void 0 !== e.escapeChar && (L3 = e.escapeChar), ("string" != typeof O || -1 < b.BAD_DELIMITERS.indexOf(O)) && (O = ","), I === O)
            throw new Error("Comment character same as delimiter");
          true === I ? I = "#" : ("string" != typeof I || -1 < b.BAD_DELIMITERS.indexOf(I)) && (I = false), "\n" !== x && "\r" !== x && "\r\n" !== x && (x = "\n");
          var F = 0, z = false;
          this.parse = function(r, t, i2) {
            if ("string" != typeof r)
              throw new Error("Input must be a string");
            var n2 = r.length, e2 = O.length, s2 = x.length, a2 = I.length, o2 = M(T), h2 = [], u2 = [], f2 = [], d2 = F = 0;
            if (!r)
              return C();
            if (A || false !== A && -1 === r.indexOf(S)) {
              for (var l2 = r.split(x), c2 = 0; c2 < l2.length; c2++) {
                if (f2 = l2[c2], F += f2.length, c2 !== l2.length - 1)
                  F += x.length;
                else if (i2)
                  return C();
                if (!I || f2.substring(0, a2) !== I) {
                  if (o2) {
                    if (h2 = [], k(f2.split(O)), R(), z)
                      return C();
                  } else
                    k(f2.split(O));
                  if (D && D <= c2)
                    return h2 = h2.slice(0, D), C(true);
                }
              }
              return C();
            }
            for (var p2 = r.indexOf(O, F), g2 = r.indexOf(x, F), _2 = new RegExp(j(L3) + j(S), "g"), m2 = r.indexOf(S, F); ; )
              if (r[F] !== S)
                if (I && 0 === f2.length && r.substring(F, F + a2) === I) {
                  if (-1 === g2)
                    return C();
                  F = g2 + s2, g2 = r.indexOf(x, F), p2 = r.indexOf(O, F);
                } else if (-1 !== p2 && (p2 < g2 || -1 === g2))
                  f2.push(r.substring(F, p2)), F = p2 + e2, p2 = r.indexOf(O, F);
                else {
                  if (-1 === g2)
                    break;
                  if (f2.push(r.substring(F, g2)), w2(g2 + s2), o2 && (R(), z))
                    return C();
                  if (D && h2.length >= D)
                    return C(true);
                }
              else
                for (m2 = F, F++; ; ) {
                  if (-1 === (m2 = r.indexOf(S, m2 + 1)))
                    return i2 || u2.push({ type: "Quotes", code: "MissingQuotes", message: "Quoted field unterminated", row: h2.length, index: F }), E2();
                  if (m2 === n2 - 1)
                    return E2(r.substring(F, m2).replace(_2, S));
                  if (S !== L3 || r[m2 + 1] !== L3) {
                    if (S === L3 || 0 === m2 || r[m2 - 1] !== L3) {
                      -1 !== p2 && p2 < m2 + 1 && (p2 = r.indexOf(O, m2 + 1)), -1 !== g2 && g2 < m2 + 1 && (g2 = r.indexOf(x, m2 + 1));
                      var y2 = b2(-1 === g2 ? p2 : Math.min(p2, g2));
                      if (r.substr(m2 + 1 + y2, e2) === O) {
                        f2.push(r.substring(F, m2).replace(_2, S)), r[F = m2 + 1 + y2 + e2] !== S && (m2 = r.indexOf(S, F)), p2 = r.indexOf(O, F), g2 = r.indexOf(x, F);
                        break;
                      }
                      var v2 = b2(g2);
                      if (r.substring(m2 + 1 + v2, m2 + 1 + v2 + s2) === x) {
                        if (f2.push(r.substring(F, m2).replace(_2, S)), w2(m2 + 1 + v2 + s2), p2 = r.indexOf(O, F), m2 = r.indexOf(S, F), o2 && (R(), z))
                          return C();
                        if (D && h2.length >= D)
                          return C(true);
                        break;
                      }
                      u2.push({ type: "Quotes", code: "InvalidQuotes", message: "Trailing quote on quoted field is malformed", row: h2.length, index: F }), m2++;
                    }
                  } else
                    m2++;
                }
            return E2();
            function k(e3) {
              h2.push(e3), d2 = F;
            }
            function b2(e3) {
              var t2 = 0;
              if (-1 !== e3) {
                var i3 = r.substring(m2 + 1, e3);
                i3 && "" === i3.trim() && (t2 = i3.length);
              }
              return t2;
            }
            function E2(e3) {
              return i2 || (void 0 === e3 && (e3 = r.substring(F)), f2.push(e3), F = n2, k(f2), o2 && R()), C();
            }
            function w2(e3) {
              F = e3, k(f2), f2 = [], g2 = r.indexOf(x, F);
            }
            function C(e3) {
              return { data: h2, errors: u2, meta: { delimiter: O, linebreak: x, aborted: z, truncated: !!e3, cursor: d2 + (t || 0) } };
            }
            function R() {
              T(C()), h2 = [], u2 = [];
            }
          }, this.abort = function() {
            z = true;
          }, this.getCharIndex = function() {
            return F;
          };
        }
        function _(e) {
          var t = e.data, i2 = a[t.workerId], r = false;
          if (t.error)
            i2.userError(t.error, t.file);
          else if (t.results && t.results.data) {
            var n2 = { abort: function() {
              r = true, m(t.workerId, { data: [], errors: [], meta: { aborted: true } });
            }, pause: y, resume: y };
            if (M(i2.userStep)) {
              for (var s2 = 0; s2 < t.results.data.length && (i2.userStep({ data: t.results.data[s2], errors: t.results.errors, meta: t.results.meta }, n2), !r); s2++)
                ;
              delete t.results;
            } else
              M(i2.userChunk) && (i2.userChunk(t.results, n2, t.file), delete t.results);
          }
          t.finished && !r && m(t.workerId, t.results);
        }
        function m(e, t) {
          var i2 = a[e];
          M(i2.userComplete) && i2.userComplete(t), i2.terminate(), delete a[e];
        }
        function y() {
          throw new Error("Not implemented.");
        }
        function w(e) {
          if ("object" != typeof e || null === e)
            return e;
          var t = Array.isArray(e) ? [] : {};
          for (var i2 in e)
            t[i2] = w(e[i2]);
          return t;
        }
        function v(e, t) {
          return function() {
            e.apply(t, arguments);
          };
        }
        function M(e) {
          return "function" == typeof e;
        }
        return o && (f.onmessage = function(e) {
          var t = e.data;
          void 0 === b.WORKER_ID && t && (b.WORKER_ID = t.workerId);
          if ("string" == typeof t.input)
            f.postMessage({ workerId: b.WORKER_ID, results: b.parse(t.input, t.config), finished: true });
          else if (f.File && t.input instanceof File || t.input instanceof Object) {
            var i2 = b.parse(t.input, t.config);
            i2 && f.postMessage({ workerId: b.WORKER_ID, results: i2, finished: true });
          }
        }), (l.prototype = Object.create(u.prototype)).constructor = l, (c.prototype = Object.create(u.prototype)).constructor = c, (p.prototype = Object.create(p.prototype)).constructor = p, (g.prototype = Object.create(u.prototype)).constructor = g, b;
      });
    }
  });

  // node_modules/leaflet/dist/leaflet-src.js
  var require_leaflet_src = __commonJS({
    "node_modules/leaflet/dist/leaflet-src.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.leaflet = {}));
      })(exports, function(exports2) {
        "use strict";
        var version = "1.8.0";
        function extend(dest) {
          var i, j, len, src;
          for (j = 1, len = arguments.length; j < len; j++) {
            src = arguments[j];
            for (i in src) {
              dest[i] = src[i];
            }
          }
          return dest;
        }
        var create$2 = Object.create || function() {
          function F() {
          }
          return function(proto) {
            F.prototype = proto;
            return new F();
          };
        }();
        function bind(fn, obj) {
          var slice = Array.prototype.slice;
          if (fn.bind) {
            return fn.bind.apply(fn, slice.call(arguments, 1));
          }
          var args = slice.call(arguments, 2);
          return function() {
            return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
          };
        }
        var lastId = 0;
        function stamp(obj) {
          if (!("_leaflet_id" in obj)) {
            obj["_leaflet_id"] = ++lastId;
          }
          return obj._leaflet_id;
        }
        function throttle(fn, time, context) {
          var lock, args, wrapperFn, later;
          later = function() {
            lock = false;
            if (args) {
              wrapperFn.apply(context, args);
              args = false;
            }
          };
          wrapperFn = function() {
            if (lock) {
              args = arguments;
            } else {
              fn.apply(context, arguments);
              setTimeout(later, time);
              lock = true;
            }
          };
          return wrapperFn;
        }
        function wrapNum(x, range, includeMax) {
          var max = range[1], min = range[0], d = max - min;
          return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
        }
        function falseFn() {
          return false;
        }
        function formatNum(num, precision) {
          if (precision === false) {
            return num;
          }
          var pow = Math.pow(10, precision === void 0 ? 6 : precision);
          return Math.round(num * pow) / pow;
        }
        function trim(str) {
          return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
        }
        function splitWords(str) {
          return trim(str).split(/\s+/);
        }
        function setOptions(obj, options) {
          if (!Object.prototype.hasOwnProperty.call(obj, "options")) {
            obj.options = obj.options ? create$2(obj.options) : {};
          }
          for (var i in options) {
            obj.options[i] = options[i];
          }
          return obj.options;
        }
        function getParamString(obj, existingUrl, uppercase) {
          var params = [];
          for (var i in obj) {
            params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + "=" + encodeURIComponent(obj[i]));
          }
          return (!existingUrl || existingUrl.indexOf("?") === -1 ? "?" : "&") + params.join("&");
        }
        var templateRe = /\{ *([\w_ -]+) *\}/g;
        function template(str, data) {
          return str.replace(templateRe, function(str2, key) {
            var value = data[key];
            if (value === void 0) {
              throw new Error("No value provided for variable " + str2);
            } else if (typeof value === "function") {
              value = value(data);
            }
            return value;
          });
        }
        var isArray = Array.isArray || function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
        function indexOf(array, el) {
          for (var i = 0; i < array.length; i++) {
            if (array[i] === el) {
              return i;
            }
          }
          return -1;
        }
        var emptyImageUrl = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
        function getPrefixed(name) {
          return window["webkit" + name] || window["moz" + name] || window["ms" + name];
        }
        var lastTime = 0;
        function timeoutDefer(fn) {
          var time = +new Date(), timeToCall = Math.max(0, 16 - (time - lastTime));
          lastTime = time + timeToCall;
          return window.setTimeout(fn, timeToCall);
        }
        var requestFn = window.requestAnimationFrame || getPrefixed("RequestAnimationFrame") || timeoutDefer;
        var cancelFn = window.cancelAnimationFrame || getPrefixed("CancelAnimationFrame") || getPrefixed("CancelRequestAnimationFrame") || function(id) {
          window.clearTimeout(id);
        };
        function requestAnimFrame(fn, context, immediate) {
          if (immediate && requestFn === timeoutDefer) {
            fn.call(context);
          } else {
            return requestFn.call(window, bind(fn, context));
          }
        }
        function cancelAnimFrame(id) {
          if (id) {
            cancelFn.call(window, id);
          }
        }
        var Util = {
          __proto__: null,
          extend,
          create: create$2,
          bind,
          get lastId() {
            return lastId;
          },
          stamp,
          throttle,
          wrapNum,
          falseFn,
          formatNum,
          trim,
          splitWords,
          setOptions,
          getParamString,
          template,
          isArray,
          indexOf,
          emptyImageUrl,
          requestFn,
          cancelFn,
          requestAnimFrame,
          cancelAnimFrame
        };
        function Class() {
        }
        Class.extend = function(props) {
          var NewClass = function() {
            setOptions(this);
            if (this.initialize) {
              this.initialize.apply(this, arguments);
            }
            this.callInitHooks();
          };
          var parentProto = NewClass.__super__ = this.prototype;
          var proto = create$2(parentProto);
          proto.constructor = NewClass;
          NewClass.prototype = proto;
          for (var i in this) {
            if (Object.prototype.hasOwnProperty.call(this, i) && i !== "prototype" && i !== "__super__") {
              NewClass[i] = this[i];
            }
          }
          if (props.statics) {
            extend(NewClass, props.statics);
          }
          if (props.includes) {
            checkDeprecatedMixinEvents(props.includes);
            extend.apply(null, [proto].concat(props.includes));
          }
          extend(proto, props);
          delete proto.statics;
          delete proto.includes;
          if (proto.options) {
            proto.options = parentProto.options ? create$2(parentProto.options) : {};
            extend(proto.options, props.options);
          }
          proto._initHooks = [];
          proto.callInitHooks = function() {
            if (this._initHooksCalled) {
              return;
            }
            if (parentProto.callInitHooks) {
              parentProto.callInitHooks.call(this);
            }
            this._initHooksCalled = true;
            for (var i2 = 0, len = proto._initHooks.length; i2 < len; i2++) {
              proto._initHooks[i2].call(this);
            }
          };
          return NewClass;
        };
        Class.include = function(props) {
          var parentOptions = this.prototype.options;
          extend(this.prototype, props);
          if (props.options) {
            this.prototype.options = parentOptions;
            this.mergeOptions(props.options);
          }
          return this;
        };
        Class.mergeOptions = function(options) {
          extend(this.prototype.options, options);
          return this;
        };
        Class.addInitHook = function(fn) {
          var args = Array.prototype.slice.call(arguments, 1);
          var init = typeof fn === "function" ? fn : function() {
            this[fn].apply(this, args);
          };
          this.prototype._initHooks = this.prototype._initHooks || [];
          this.prototype._initHooks.push(init);
          return this;
        };
        function checkDeprecatedMixinEvents(includes) {
          if (typeof L === "undefined" || !L || !L.Mixin) {
            return;
          }
          includes = isArray(includes) ? includes : [includes];
          for (var i = 0; i < includes.length; i++) {
            if (includes[i] === L.Mixin.Events) {
              console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
            }
          }
        }
        var Events = {
          on: function(types, fn, context) {
            if (typeof types === "object") {
              for (var type in types) {
                this._on(type, types[type], fn);
              }
            } else {
              types = splitWords(types);
              for (var i = 0, len = types.length; i < len; i++) {
                this._on(types[i], fn, context);
              }
            }
            return this;
          },
          off: function(types, fn, context) {
            if (!arguments.length) {
              delete this._events;
            } else if (typeof types === "object") {
              for (var type in types) {
                this._off(type, types[type], fn);
              }
            } else {
              types = splitWords(types);
              var removeAll = arguments.length === 1;
              for (var i = 0, len = types.length; i < len; i++) {
                if (removeAll) {
                  this._off(types[i]);
                } else {
                  this._off(types[i], fn, context);
                }
              }
            }
            return this;
          },
          _on: function(type, fn, context) {
            if (typeof fn !== "function") {
              console.warn("wrong listener type: " + typeof fn);
              return;
            }
            this._events = this._events || {};
            var typeListeners = this._events[type];
            if (!typeListeners) {
              typeListeners = [];
              this._events[type] = typeListeners;
            }
            if (context === this) {
              context = void 0;
            }
            var newListener = { fn, ctx: context }, listeners = typeListeners;
            for (var i = 0, len = listeners.length; i < len; i++) {
              if (listeners[i].fn === fn && listeners[i].ctx === context) {
                return;
              }
            }
            listeners.push(newListener);
          },
          _off: function(type, fn, context) {
            var listeners, i, len;
            if (!this._events) {
              return;
            }
            listeners = this._events[type];
            if (!listeners) {
              return;
            }
            if (arguments.length === 1) {
              if (this._firingCount) {
                for (i = 0, len = listeners.length; i < len; i++) {
                  listeners[i].fn = falseFn;
                }
              }
              delete this._events[type];
              return;
            }
            if (context === this) {
              context = void 0;
            }
            if (typeof fn !== "function") {
              console.warn("wrong listener type: " + typeof fn);
              return;
            }
            for (i = 0, len = listeners.length; i < len; i++) {
              var l = listeners[i];
              if (l.ctx !== context) {
                continue;
              }
              if (l.fn === fn) {
                if (this._firingCount) {
                  l.fn = falseFn;
                  this._events[type] = listeners = listeners.slice();
                }
                listeners.splice(i, 1);
                return;
              }
            }
            console.warn("listener not found");
          },
          fire: function(type, data, propagate) {
            if (!this.listens(type, propagate)) {
              return this;
            }
            var event = extend({}, data, {
              type,
              target: this,
              sourceTarget: data && data.sourceTarget || this
            });
            if (this._events) {
              var listeners = this._events[type];
              if (listeners) {
                this._firingCount = this._firingCount + 1 || 1;
                for (var i = 0, len = listeners.length; i < len; i++) {
                  var l = listeners[i];
                  l.fn.call(l.ctx || this, event);
                }
                this._firingCount--;
              }
            }
            if (propagate) {
              this._propagateEvent(event);
            }
            return this;
          },
          listens: function(type, propagate) {
            if (typeof type !== "string") {
              console.warn('"string" type argument expected');
            }
            var listeners = this._events && this._events[type];
            if (listeners && listeners.length) {
              return true;
            }
            if (propagate) {
              for (var id in this._eventParents) {
                if (this._eventParents[id].listens(type, propagate)) {
                  return true;
                }
              }
            }
            return false;
          },
          once: function(types, fn, context) {
            if (typeof types === "object") {
              for (var type in types) {
                this.once(type, types[type], fn);
              }
              return this;
            }
            var handler = bind(function() {
              this.off(types, fn, context).off(types, handler, context);
            }, this);
            return this.on(types, fn, context).on(types, handler, context);
          },
          addEventParent: function(obj) {
            this._eventParents = this._eventParents || {};
            this._eventParents[stamp(obj)] = obj;
            return this;
          },
          removeEventParent: function(obj) {
            if (this._eventParents) {
              delete this._eventParents[stamp(obj)];
            }
            return this;
          },
          _propagateEvent: function(e) {
            for (var id in this._eventParents) {
              this._eventParents[id].fire(e.type, extend({
                layer: e.target,
                propagatedFrom: e.target
              }, e), true);
            }
          }
        };
        Events.addEventListener = Events.on;
        Events.removeEventListener = Events.clearAllEventListeners = Events.off;
        Events.addOneTimeEventListener = Events.once;
        Events.fireEvent = Events.fire;
        Events.hasEventListeners = Events.listens;
        var Evented = Class.extend(Events);
        function Point(x, y, round) {
          this.x = round ? Math.round(x) : x;
          this.y = round ? Math.round(y) : y;
        }
        var trunc = Math.trunc || function(v) {
          return v > 0 ? Math.floor(v) : Math.ceil(v);
        };
        Point.prototype = {
          clone: function() {
            return new Point(this.x, this.y);
          },
          add: function(point) {
            return this.clone()._add(toPoint(point));
          },
          _add: function(point) {
            this.x += point.x;
            this.y += point.y;
            return this;
          },
          subtract: function(point) {
            return this.clone()._subtract(toPoint(point));
          },
          _subtract: function(point) {
            this.x -= point.x;
            this.y -= point.y;
            return this;
          },
          divideBy: function(num) {
            return this.clone()._divideBy(num);
          },
          _divideBy: function(num) {
            this.x /= num;
            this.y /= num;
            return this;
          },
          multiplyBy: function(num) {
            return this.clone()._multiplyBy(num);
          },
          _multiplyBy: function(num) {
            this.x *= num;
            this.y *= num;
            return this;
          },
          scaleBy: function(point) {
            return new Point(this.x * point.x, this.y * point.y);
          },
          unscaleBy: function(point) {
            return new Point(this.x / point.x, this.y / point.y);
          },
          round: function() {
            return this.clone()._round();
          },
          _round: function() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this;
          },
          floor: function() {
            return this.clone()._floor();
          },
          _floor: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            return this;
          },
          ceil: function() {
            return this.clone()._ceil();
          },
          _ceil: function() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            return this;
          },
          trunc: function() {
            return this.clone()._trunc();
          },
          _trunc: function() {
            this.x = trunc(this.x);
            this.y = trunc(this.y);
            return this;
          },
          distanceTo: function(point) {
            point = toPoint(point);
            var x = point.x - this.x, y = point.y - this.y;
            return Math.sqrt(x * x + y * y);
          },
          equals: function(point) {
            point = toPoint(point);
            return point.x === this.x && point.y === this.y;
          },
          contains: function(point) {
            point = toPoint(point);
            return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
          },
          toString: function() {
            return "Point(" + formatNum(this.x) + ", " + formatNum(this.y) + ")";
          }
        };
        function toPoint(x, y, round) {
          if (x instanceof Point) {
            return x;
          }
          if (isArray(x)) {
            return new Point(x[0], x[1]);
          }
          if (x === void 0 || x === null) {
            return x;
          }
          if (typeof x === "object" && "x" in x && "y" in x) {
            return new Point(x.x, x.y);
          }
          return new Point(x, y, round);
        }
        function Bounds(a, b) {
          if (!a) {
            return;
          }
          var points = b ? [a, b] : a;
          for (var i = 0, len = points.length; i < len; i++) {
            this.extend(points[i]);
          }
        }
        Bounds.prototype = {
          extend: function(point) {
            point = toPoint(point);
            if (!this.min && !this.max) {
              this.min = point.clone();
              this.max = point.clone();
            } else {
              this.min.x = Math.min(point.x, this.min.x);
              this.max.x = Math.max(point.x, this.max.x);
              this.min.y = Math.min(point.y, this.min.y);
              this.max.y = Math.max(point.y, this.max.y);
            }
            return this;
          },
          getCenter: function(round) {
            return new Point(
              (this.min.x + this.max.x) / 2,
              (this.min.y + this.max.y) / 2,
              round
            );
          },
          getBottomLeft: function() {
            return new Point(this.min.x, this.max.y);
          },
          getTopRight: function() {
            return new Point(this.max.x, this.min.y);
          },
          getTopLeft: function() {
            return this.min;
          },
          getBottomRight: function() {
            return this.max;
          },
          getSize: function() {
            return this.max.subtract(this.min);
          },
          contains: function(obj) {
            var min, max;
            if (typeof obj[0] === "number" || obj instanceof Point) {
              obj = toPoint(obj);
            } else {
              obj = toBounds(obj);
            }
            if (obj instanceof Bounds) {
              min = obj.min;
              max = obj.max;
            } else {
              min = max = obj;
            }
            return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
          },
          intersects: function(bounds) {
            bounds = toBounds(bounds);
            var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xIntersects = max2.x >= min.x && min2.x <= max.x, yIntersects = max2.y >= min.y && min2.y <= max.y;
            return xIntersects && yIntersects;
          },
          overlaps: function(bounds) {
            bounds = toBounds(bounds);
            var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xOverlaps = max2.x > min.x && min2.x < max.x, yOverlaps = max2.y > min.y && min2.y < max.y;
            return xOverlaps && yOverlaps;
          },
          isValid: function() {
            return !!(this.min && this.max);
          }
        };
        function toBounds(a, b) {
          if (!a || a instanceof Bounds) {
            return a;
          }
          return new Bounds(a, b);
        }
        function LatLngBounds(corner1, corner2) {
          if (!corner1) {
            return;
          }
          var latlngs = corner2 ? [corner1, corner2] : corner1;
          for (var i = 0, len = latlngs.length; i < len; i++) {
            this.extend(latlngs[i]);
          }
        }
        LatLngBounds.prototype = {
          extend: function(obj) {
            var sw = this._southWest, ne = this._northEast, sw2, ne2;
            if (obj instanceof LatLng) {
              sw2 = obj;
              ne2 = obj;
            } else if (obj instanceof LatLngBounds) {
              sw2 = obj._southWest;
              ne2 = obj._northEast;
              if (!sw2 || !ne2) {
                return this;
              }
            } else {
              return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
            }
            if (!sw && !ne) {
              this._southWest = new LatLng(sw2.lat, sw2.lng);
              this._northEast = new LatLng(ne2.lat, ne2.lng);
            } else {
              sw.lat = Math.min(sw2.lat, sw.lat);
              sw.lng = Math.min(sw2.lng, sw.lng);
              ne.lat = Math.max(ne2.lat, ne.lat);
              ne.lng = Math.max(ne2.lng, ne.lng);
            }
            return this;
          },
          pad: function(bufferRatio) {
            var sw = this._southWest, ne = this._northEast, heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
            return new LatLngBounds(
              new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
              new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer)
            );
          },
          getCenter: function() {
            return new LatLng(
              (this._southWest.lat + this._northEast.lat) / 2,
              (this._southWest.lng + this._northEast.lng) / 2
            );
          },
          getSouthWest: function() {
            return this._southWest;
          },
          getNorthEast: function() {
            return this._northEast;
          },
          getNorthWest: function() {
            return new LatLng(this.getNorth(), this.getWest());
          },
          getSouthEast: function() {
            return new LatLng(this.getSouth(), this.getEast());
          },
          getWest: function() {
            return this._southWest.lng;
          },
          getSouth: function() {
            return this._southWest.lat;
          },
          getEast: function() {
            return this._northEast.lng;
          },
          getNorth: function() {
            return this._northEast.lat;
          },
          contains: function(obj) {
            if (typeof obj[0] === "number" || obj instanceof LatLng || "lat" in obj) {
              obj = toLatLng(obj);
            } else {
              obj = toLatLngBounds(obj);
            }
            var sw = this._southWest, ne = this._northEast, sw2, ne2;
            if (obj instanceof LatLngBounds) {
              sw2 = obj.getSouthWest();
              ne2 = obj.getNorthEast();
            } else {
              sw2 = ne2 = obj;
            }
            return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
          },
          intersects: function(bounds) {
            bounds = toLatLngBounds(bounds);
            var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat, lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
            return latIntersects && lngIntersects;
          },
          overlaps: function(bounds) {
            bounds = toLatLngBounds(bounds);
            var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat, lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;
            return latOverlaps && lngOverlaps;
          },
          toBBoxString: function() {
            return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
          },
          equals: function(bounds, maxMargin) {
            if (!bounds) {
              return false;
            }
            bounds = toLatLngBounds(bounds);
            return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
          },
          isValid: function() {
            return !!(this._southWest && this._northEast);
          }
        };
        function toLatLngBounds(a, b) {
          if (a instanceof LatLngBounds) {
            return a;
          }
          return new LatLngBounds(a, b);
        }
        function LatLng(lat, lng, alt) {
          if (isNaN(lat) || isNaN(lng)) {
            throw new Error("Invalid LatLng object: (" + lat + ", " + lng + ")");
          }
          this.lat = +lat;
          this.lng = +lng;
          if (alt !== void 0) {
            this.alt = +alt;
          }
        }
        LatLng.prototype = {
          equals: function(obj, maxMargin) {
            if (!obj) {
              return false;
            }
            obj = toLatLng(obj);
            var margin = Math.max(
              Math.abs(this.lat - obj.lat),
              Math.abs(this.lng - obj.lng)
            );
            return margin <= (maxMargin === void 0 ? 1e-9 : maxMargin);
          },
          toString: function(precision) {
            return "LatLng(" + formatNum(this.lat, precision) + ", " + formatNum(this.lng, precision) + ")";
          },
          distanceTo: function(other) {
            return Earth.distance(this, toLatLng(other));
          },
          wrap: function() {
            return Earth.wrapLatLng(this);
          },
          toBounds: function(sizeInMeters) {
            var latAccuracy = 180 * sizeInMeters / 40075017, lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
            return toLatLngBounds(
              [this.lat - latAccuracy, this.lng - lngAccuracy],
              [this.lat + latAccuracy, this.lng + lngAccuracy]
            );
          },
          clone: function() {
            return new LatLng(this.lat, this.lng, this.alt);
          }
        };
        function toLatLng(a, b, c) {
          if (a instanceof LatLng) {
            return a;
          }
          if (isArray(a) && typeof a[0] !== "object") {
            if (a.length === 3) {
              return new LatLng(a[0], a[1], a[2]);
            }
            if (a.length === 2) {
              return new LatLng(a[0], a[1]);
            }
            return null;
          }
          if (a === void 0 || a === null) {
            return a;
          }
          if (typeof a === "object" && "lat" in a) {
            return new LatLng(a.lat, "lng" in a ? a.lng : a.lon, a.alt);
          }
          if (b === void 0) {
            return null;
          }
          return new LatLng(a, b, c);
        }
        var CRS = {
          latLngToPoint: function(latlng, zoom2) {
            var projectedPoint = this.projection.project(latlng), scale2 = this.scale(zoom2);
            return this.transformation._transform(projectedPoint, scale2);
          },
          pointToLatLng: function(point, zoom2) {
            var scale2 = this.scale(zoom2), untransformedPoint = this.transformation.untransform(point, scale2);
            return this.projection.unproject(untransformedPoint);
          },
          project: function(latlng) {
            return this.projection.project(latlng);
          },
          unproject: function(point) {
            return this.projection.unproject(point);
          },
          scale: function(zoom2) {
            return 256 * Math.pow(2, zoom2);
          },
          zoom: function(scale2) {
            return Math.log(scale2 / 256) / Math.LN2;
          },
          getProjectedBounds: function(zoom2) {
            if (this.infinite) {
              return null;
            }
            var b = this.projection.bounds, s = this.scale(zoom2), min = this.transformation.transform(b.min, s), max = this.transformation.transform(b.max, s);
            return new Bounds(min, max);
          },
          infinite: false,
          wrapLatLng: function(latlng) {
            var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng, lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat, alt = latlng.alt;
            return new LatLng(lat, lng, alt);
          },
          wrapLatLngBounds: function(bounds) {
            var center = bounds.getCenter(), newCenter = this.wrapLatLng(center), latShift = center.lat - newCenter.lat, lngShift = center.lng - newCenter.lng;
            if (latShift === 0 && lngShift === 0) {
              return bounds;
            }
            var sw = bounds.getSouthWest(), ne = bounds.getNorthEast(), newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift), newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);
            return new LatLngBounds(newSw, newNe);
          }
        };
        var Earth = extend({}, CRS, {
          wrapLng: [-180, 180],
          R: 6371e3,
          distance: function(latlng1, latlng2) {
            var rad = Math.PI / 180, lat1 = latlng1.lat * rad, lat2 = latlng2.lat * rad, sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2), sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2), a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon, c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return this.R * c;
          }
        });
        var earthRadius = 6378137;
        var SphericalMercator = {
          R: earthRadius,
          MAX_LATITUDE: 85.0511287798,
          project: function(latlng) {
            var d = Math.PI / 180, max = this.MAX_LATITUDE, lat = Math.max(Math.min(max, latlng.lat), -max), sin = Math.sin(lat * d);
            return new Point(
              this.R * latlng.lng * d,
              this.R * Math.log((1 + sin) / (1 - sin)) / 2
            );
          },
          unproject: function(point) {
            var d = 180 / Math.PI;
            return new LatLng(
              (2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d,
              point.x * d / this.R
            );
          },
          bounds: function() {
            var d = earthRadius * Math.PI;
            return new Bounds([-d, -d], [d, d]);
          }()
        };
        function Transformation(a, b, c, d) {
          if (isArray(a)) {
            this._a = a[0];
            this._b = a[1];
            this._c = a[2];
            this._d = a[3];
            return;
          }
          this._a = a;
          this._b = b;
          this._c = c;
          this._d = d;
        }
        Transformation.prototype = {
          transform: function(point, scale2) {
            return this._transform(point.clone(), scale2);
          },
          _transform: function(point, scale2) {
            scale2 = scale2 || 1;
            point.x = scale2 * (this._a * point.x + this._b);
            point.y = scale2 * (this._c * point.y + this._d);
            return point;
          },
          untransform: function(point, scale2) {
            scale2 = scale2 || 1;
            return new Point(
              (point.x / scale2 - this._b) / this._a,
              (point.y / scale2 - this._d) / this._c
            );
          }
        };
        function toTransformation(a, b, c, d) {
          return new Transformation(a, b, c, d);
        }
        var EPSG3857 = extend({}, Earth, {
          code: "EPSG:3857",
          projection: SphericalMercator,
          transformation: function() {
            var scale2 = 0.5 / (Math.PI * SphericalMercator.R);
            return toTransformation(scale2, 0.5, -scale2, 0.5);
          }()
        });
        var EPSG900913 = extend({}, EPSG3857, {
          code: "EPSG:900913"
        });
        function svgCreate(name) {
          return document.createElementNS("http://www.w3.org/2000/svg", name);
        }
        function pointsToPath(rings, closed) {
          var str = "", i, j, len, len2, points, p;
          for (i = 0, len = rings.length; i < len; i++) {
            points = rings[i];
            for (j = 0, len2 = points.length; j < len2; j++) {
              p = points[j];
              str += (j ? "L" : "M") + p.x + " " + p.y;
            }
            str += closed ? Browser.svg ? "z" : "x" : "";
          }
          return str || "M0 0";
        }
        var style = document.documentElement.style;
        var ie = "ActiveXObject" in window;
        var ielt9 = ie && !document.addEventListener;
        var edge = "msLaunchUri" in navigator && !("documentMode" in document);
        var webkit = userAgentContains("webkit");
        var android = userAgentContains("android");
        var android23 = userAgentContains("android 2") || userAgentContains("android 3");
        var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10);
        var androidStock = android && userAgentContains("Google") && webkitVer < 537 && !("AudioNode" in window);
        var opera = !!window.opera;
        var chrome = !edge && userAgentContains("chrome");
        var gecko = userAgentContains("gecko") && !webkit && !opera && !ie;
        var safari = !chrome && userAgentContains("safari");
        var phantom = userAgentContains("phantom");
        var opera12 = "OTransition" in style;
        var win = navigator.platform.indexOf("Win") === 0;
        var ie3d = ie && "transition" in style;
        var webkit3d = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !android23;
        var gecko3d = "MozPerspective" in style;
        var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;
        var mobile = typeof orientation !== "undefined" || userAgentContains("mobile");
        var mobileWebkit = mobile && webkit;
        var mobileWebkit3d = mobile && webkit3d;
        var msPointer = !window.PointerEvent && window.MSPointerEvent;
        var pointer = !!(window.PointerEvent || msPointer);
        var touchNative = "ontouchstart" in window || !!window.TouchEvent;
        var touch = !window.L_NO_TOUCH && (touchNative || pointer);
        var mobileOpera = mobile && opera;
        var mobileGecko = mobile && gecko;
        var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;
        var passiveEvents = function() {
          var supportsPassiveOption = false;
          try {
            var opts = Object.defineProperty({}, "passive", {
              get: function() {
                supportsPassiveOption = true;
              }
            });
            window.addEventListener("testPassiveEventSupport", falseFn, opts);
            window.removeEventListener("testPassiveEventSupport", falseFn, opts);
          } catch (e) {
          }
          return supportsPassiveOption;
        }();
        var canvas$1 = function() {
          return !!document.createElement("canvas").getContext;
        }();
        var svg$1 = !!(document.createElementNS && svgCreate("svg").createSVGRect);
        var inlineSvg = !!svg$1 && function() {
          var div = document.createElement("div");
          div.innerHTML = "<svg/>";
          return (div.firstChild && div.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
        }();
        var vml = !svg$1 && function() {
          try {
            var div = document.createElement("div");
            div.innerHTML = '<v:shape adj="1"/>';
            var shape = div.firstChild;
            shape.style.behavior = "url(#default#VML)";
            return shape && typeof shape.adj === "object";
          } catch (e) {
            return false;
          }
        }();
        function userAgentContains(str) {
          return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
        }
        var Browser = {
          ie,
          ielt9,
          edge,
          webkit,
          android,
          android23,
          androidStock,
          opera,
          chrome,
          gecko,
          safari,
          phantom,
          opera12,
          win,
          ie3d,
          webkit3d,
          gecko3d,
          any3d,
          mobile,
          mobileWebkit,
          mobileWebkit3d,
          msPointer,
          pointer,
          touch,
          touchNative,
          mobileOpera,
          mobileGecko,
          retina,
          passiveEvents,
          canvas: canvas$1,
          svg: svg$1,
          vml,
          inlineSvg
        };
        var POINTER_DOWN = Browser.msPointer ? "MSPointerDown" : "pointerdown";
        var POINTER_MOVE = Browser.msPointer ? "MSPointerMove" : "pointermove";
        var POINTER_UP = Browser.msPointer ? "MSPointerUp" : "pointerup";
        var POINTER_CANCEL = Browser.msPointer ? "MSPointerCancel" : "pointercancel";
        var pEvent = {
          touchstart: POINTER_DOWN,
          touchmove: POINTER_MOVE,
          touchend: POINTER_UP,
          touchcancel: POINTER_CANCEL
        };
        var handle = {
          touchstart: _onPointerStart,
          touchmove: _handlePointer,
          touchend: _handlePointer,
          touchcancel: _handlePointer
        };
        var _pointers = {};
        var _pointerDocListener = false;
        function addPointerListener(obj, type, handler) {
          if (type === "touchstart") {
            _addPointerDocListener();
          }
          if (!handle[type]) {
            console.warn("wrong event specified:", type);
            return L.Util.falseFn;
          }
          handler = handle[type].bind(this, handler);
          obj.addEventListener(pEvent[type], handler, false);
          return handler;
        }
        function removePointerListener(obj, type, handler) {
          if (!pEvent[type]) {
            console.warn("wrong event specified:", type);
            return;
          }
          obj.removeEventListener(pEvent[type], handler, false);
        }
        function _globalPointerDown(e) {
          _pointers[e.pointerId] = e;
        }
        function _globalPointerMove(e) {
          if (_pointers[e.pointerId]) {
            _pointers[e.pointerId] = e;
          }
        }
        function _globalPointerUp(e) {
          delete _pointers[e.pointerId];
        }
        function _addPointerDocListener() {
          if (!_pointerDocListener) {
            document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
            document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
            document.addEventListener(POINTER_UP, _globalPointerUp, true);
            document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);
            _pointerDocListener = true;
          }
        }
        function _handlePointer(handler, e) {
          if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || "mouse")) {
            return;
          }
          e.touches = [];
          for (var i in _pointers) {
            e.touches.push(_pointers[i]);
          }
          e.changedTouches = [e];
          handler(e);
        }
        function _onPointerStart(handler, e) {
          if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {
            preventDefault(e);
          }
          _handlePointer(handler, e);
        }
        function makeDblclick(event) {
          var newEvent = {}, prop, i;
          for (i in event) {
            prop = event[i];
            newEvent[i] = prop && prop.bind ? prop.bind(event) : prop;
          }
          event = newEvent;
          newEvent.type = "dblclick";
          newEvent.detail = 2;
          newEvent.isTrusted = false;
          newEvent._simulated = true;
          return newEvent;
        }
        var delay = 200;
        function addDoubleTapListener(obj, handler) {
          obj.addEventListener("dblclick", handler);
          var last = 0, detail;
          function simDblclick(e) {
            if (e.detail !== 1) {
              detail = e.detail;
              return;
            }
            if (e.pointerType === "mouse" || e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents) {
              return;
            }
            var now = Date.now();
            if (now - last <= delay) {
              detail++;
              if (detail === 2) {
                handler(makeDblclick(e));
              }
            } else {
              detail = 1;
            }
            last = now;
          }
          obj.addEventListener("click", simDblclick);
          return {
            dblclick: handler,
            simDblclick
          };
        }
        function removeDoubleTapListener(obj, handlers) {
          obj.removeEventListener("dblclick", handlers.dblclick);
          obj.removeEventListener("click", handlers.simDblclick);
        }
        var TRANSFORM = testProp(
          ["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]
        );
        var TRANSITION = testProp(
          ["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]
        );
        var TRANSITION_END = TRANSITION === "webkitTransition" || TRANSITION === "OTransition" ? TRANSITION + "End" : "transitionend";
        function get(id) {
          return typeof id === "string" ? document.getElementById(id) : id;
        }
        function getStyle(el, style2) {
          var value = el.style[style2] || el.currentStyle && el.currentStyle[style2];
          if ((!value || value === "auto") && document.defaultView) {
            var css = document.defaultView.getComputedStyle(el, null);
            value = css ? css[style2] : null;
          }
          return value === "auto" ? null : value;
        }
        function create$1(tagName, className, container) {
          var el = document.createElement(tagName);
          el.className = className || "";
          if (container) {
            container.appendChild(el);
          }
          return el;
        }
        function remove(el) {
          var parent = el.parentNode;
          if (parent) {
            parent.removeChild(el);
          }
        }
        function empty(el) {
          while (el.firstChild) {
            el.removeChild(el.firstChild);
          }
        }
        function toFront(el) {
          var parent = el.parentNode;
          if (parent && parent.lastChild !== el) {
            parent.appendChild(el);
          }
        }
        function toBack(el) {
          var parent = el.parentNode;
          if (parent && parent.firstChild !== el) {
            parent.insertBefore(el, parent.firstChild);
          }
        }
        function hasClass(el, name) {
          if (el.classList !== void 0) {
            return el.classList.contains(name);
          }
          var className = getClass(el);
          return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className);
        }
        function addClass(el, name) {
          if (el.classList !== void 0) {
            var classes = splitWords(name);
            for (var i = 0, len = classes.length; i < len; i++) {
              el.classList.add(classes[i]);
            }
          } else if (!hasClass(el, name)) {
            var className = getClass(el);
            setClass(el, (className ? className + " " : "") + name);
          }
        }
        function removeClass(el, name) {
          if (el.classList !== void 0) {
            el.classList.remove(name);
          } else {
            setClass(el, trim((" " + getClass(el) + " ").replace(" " + name + " ", " ")));
          }
        }
        function setClass(el, name) {
          if (el.className.baseVal === void 0) {
            el.className = name;
          } else {
            el.className.baseVal = name;
          }
        }
        function getClass(el) {
          if (el.correspondingElement) {
            el = el.correspondingElement;
          }
          return el.className.baseVal === void 0 ? el.className : el.className.baseVal;
        }
        function setOpacity(el, value) {
          if ("opacity" in el.style) {
            el.style.opacity = value;
          } else if ("filter" in el.style) {
            _setOpacityIE(el, value);
          }
        }
        function _setOpacityIE(el, value) {
          var filter = false, filterName = "DXImageTransform.Microsoft.Alpha";
          try {
            filter = el.filters.item(filterName);
          } catch (e) {
            if (value === 1) {
              return;
            }
          }
          value = Math.round(value * 100);
          if (filter) {
            filter.Enabled = value !== 100;
            filter.Opacity = value;
          } else {
            el.style.filter += " progid:" + filterName + "(opacity=" + value + ")";
          }
        }
        function testProp(props) {
          var style2 = document.documentElement.style;
          for (var i = 0; i < props.length; i++) {
            if (props[i] in style2) {
              return props[i];
            }
          }
          return false;
        }
        function setTransform(el, offset, scale2) {
          var pos = offset || new Point(0, 0);
          el.style[TRANSFORM] = (Browser.ie3d ? "translate(" + pos.x + "px," + pos.y + "px)" : "translate3d(" + pos.x + "px," + pos.y + "px,0)") + (scale2 ? " scale(" + scale2 + ")" : "");
        }
        function setPosition(el, point) {
          el._leaflet_pos = point;
          if (Browser.any3d) {
            setTransform(el, point);
          } else {
            el.style.left = point.x + "px";
            el.style.top = point.y + "px";
          }
        }
        function getPosition(el) {
          return el._leaflet_pos || new Point(0, 0);
        }
        var disableTextSelection;
        var enableTextSelection;
        var _userSelect;
        if ("onselectstart" in document) {
          disableTextSelection = function() {
            on(window, "selectstart", preventDefault);
          };
          enableTextSelection = function() {
            off(window, "selectstart", preventDefault);
          };
        } else {
          var userSelectProperty = testProp(
            ["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]
          );
          disableTextSelection = function() {
            if (userSelectProperty) {
              var style2 = document.documentElement.style;
              _userSelect = style2[userSelectProperty];
              style2[userSelectProperty] = "none";
            }
          };
          enableTextSelection = function() {
            if (userSelectProperty) {
              document.documentElement.style[userSelectProperty] = _userSelect;
              _userSelect = void 0;
            }
          };
        }
        function disableImageDrag() {
          on(window, "dragstart", preventDefault);
        }
        function enableImageDrag() {
          off(window, "dragstart", preventDefault);
        }
        var _outlineElement, _outlineStyle;
        function preventOutline(element) {
          while (element.tabIndex === -1) {
            element = element.parentNode;
          }
          if (!element.style) {
            return;
          }
          restoreOutline();
          _outlineElement = element;
          _outlineStyle = element.style.outline;
          element.style.outline = "none";
          on(window, "keydown", restoreOutline);
        }
        function restoreOutline() {
          if (!_outlineElement) {
            return;
          }
          _outlineElement.style.outline = _outlineStyle;
          _outlineElement = void 0;
          _outlineStyle = void 0;
          off(window, "keydown", restoreOutline);
        }
        function getSizedParentNode(element) {
          do {
            element = element.parentNode;
          } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
          return element;
        }
        function getScale(element) {
          var rect = element.getBoundingClientRect();
          return {
            x: rect.width / element.offsetWidth || 1,
            y: rect.height / element.offsetHeight || 1,
            boundingClientRect: rect
          };
        }
        var DomUtil = {
          __proto__: null,
          TRANSFORM,
          TRANSITION,
          TRANSITION_END,
          get,
          getStyle,
          create: create$1,
          remove,
          empty,
          toFront,
          toBack,
          hasClass,
          addClass,
          removeClass,
          setClass,
          getClass,
          setOpacity,
          testProp,
          setTransform,
          setPosition,
          getPosition,
          get disableTextSelection() {
            return disableTextSelection;
          },
          get enableTextSelection() {
            return enableTextSelection;
          },
          disableImageDrag,
          enableImageDrag,
          preventOutline,
          restoreOutline,
          getSizedParentNode,
          getScale
        };
        function on(obj, types, fn, context) {
          if (types && typeof types === "object") {
            for (var type in types) {
              addOne(obj, type, types[type], fn);
            }
          } else {
            types = splitWords(types);
            for (var i = 0, len = types.length; i < len; i++) {
              addOne(obj, types[i], fn, context);
            }
          }
          return this;
        }
        var eventsKey = "_leaflet_events";
        function off(obj, types, fn, context) {
          if (arguments.length === 1) {
            batchRemove(obj);
            delete obj[eventsKey];
          } else if (types && typeof types === "object") {
            for (var type in types) {
              removeOne(obj, type, types[type], fn);
            }
          } else {
            types = splitWords(types);
            if (arguments.length === 2) {
              batchRemove(obj, function(type2) {
                return indexOf(types, type2) !== -1;
              });
            } else {
              for (var i = 0, len = types.length; i < len; i++) {
                removeOne(obj, types[i], fn, context);
              }
            }
          }
          return this;
        }
        function batchRemove(obj, filterFn) {
          for (var id in obj[eventsKey]) {
            var type = id.split(/\d/)[0];
            if (!filterFn || filterFn(type)) {
              removeOne(obj, type, null, null, id);
            }
          }
        }
        var mouseSubst = {
          mouseenter: "mouseover",
          mouseleave: "mouseout",
          wheel: !("onwheel" in window) && "mousewheel"
        };
        function addOne(obj, type, fn, context) {
          var id = type + stamp(fn) + (context ? "_" + stamp(context) : "");
          if (obj[eventsKey] && obj[eventsKey][id]) {
            return this;
          }
          var handler = function(e) {
            return fn.call(context || obj, e || window.event);
          };
          var originalHandler = handler;
          if (!Browser.touchNative && Browser.pointer && type.indexOf("touch") === 0) {
            handler = addPointerListener(obj, type, handler);
          } else if (Browser.touch && type === "dblclick") {
            handler = addDoubleTapListener(obj, handler);
          } else if ("addEventListener" in obj) {
            if (type === "touchstart" || type === "touchmove" || type === "wheel" || type === "mousewheel") {
              obj.addEventListener(mouseSubst[type] || type, handler, Browser.passiveEvents ? { passive: false } : false);
            } else if (type === "mouseenter" || type === "mouseleave") {
              handler = function(e) {
                e = e || window.event;
                if (isExternalTarget(obj, e)) {
                  originalHandler(e);
                }
              };
              obj.addEventListener(mouseSubst[type], handler, false);
            } else {
              obj.addEventListener(type, originalHandler, false);
            }
          } else {
            obj.attachEvent("on" + type, handler);
          }
          obj[eventsKey] = obj[eventsKey] || {};
          obj[eventsKey][id] = handler;
        }
        function removeOne(obj, type, fn, context, id) {
          id = id || type + stamp(fn) + (context ? "_" + stamp(context) : "");
          var handler = obj[eventsKey] && obj[eventsKey][id];
          if (!handler) {
            return this;
          }
          if (!Browser.touchNative && Browser.pointer && type.indexOf("touch") === 0) {
            removePointerListener(obj, type, handler);
          } else if (Browser.touch && type === "dblclick") {
            removeDoubleTapListener(obj, handler);
          } else if ("removeEventListener" in obj) {
            obj.removeEventListener(mouseSubst[type] || type, handler, false);
          } else {
            obj.detachEvent("on" + type, handler);
          }
          obj[eventsKey][id] = null;
        }
        function stopPropagation(e) {
          if (e.stopPropagation) {
            e.stopPropagation();
          } else if (e.originalEvent) {
            e.originalEvent._stopped = true;
          } else {
            e.cancelBubble = true;
          }
          return this;
        }
        function disableScrollPropagation(el) {
          addOne(el, "wheel", stopPropagation);
          return this;
        }
        function disableClickPropagation(el) {
          on(el, "mousedown touchstart dblclick contextmenu", stopPropagation);
          el["_leaflet_disable_click"] = true;
          return this;
        }
        function preventDefault(e) {
          if (e.preventDefault) {
            e.preventDefault();
          } else {
            e.returnValue = false;
          }
          return this;
        }
        function stop(e) {
          preventDefault(e);
          stopPropagation(e);
          return this;
        }
        function getMousePosition(e, container) {
          if (!container) {
            return new Point(e.clientX, e.clientY);
          }
          var scale2 = getScale(container), offset = scale2.boundingClientRect;
          return new Point(
            (e.clientX - offset.left) / scale2.x - container.clientLeft,
            (e.clientY - offset.top) / scale2.y - container.clientTop
          );
        }
        var wheelPxFactor = Browser.win && Browser.chrome ? 2 * window.devicePixelRatio : Browser.gecko ? window.devicePixelRatio : 1;
        function getWheelDelta(e) {
          return Browser.edge ? e.wheelDeltaY / 2 : e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : e.deltaX || e.deltaZ ? 0 : e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : e.detail ? e.detail / -32765 * 60 : 0;
        }
        function isExternalTarget(el, e) {
          var related = e.relatedTarget;
          if (!related) {
            return true;
          }
          try {
            while (related && related !== el) {
              related = related.parentNode;
            }
          } catch (err) {
            return false;
          }
          return related !== el;
        }
        var DomEvent = {
          __proto__: null,
          on,
          off,
          stopPropagation,
          disableScrollPropagation,
          disableClickPropagation,
          preventDefault,
          stop,
          getMousePosition,
          getWheelDelta,
          isExternalTarget,
          addListener: on,
          removeListener: off
        };
        var PosAnimation = Evented.extend({
          run: function(el, newPos, duration, easeLinearity) {
            this.stop();
            this._el = el;
            this._inProgress = true;
            this._duration = duration || 0.25;
            this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);
            this._startPos = getPosition(el);
            this._offset = newPos.subtract(this._startPos);
            this._startTime = +new Date();
            this.fire("start");
            this._animate();
          },
          stop: function() {
            if (!this._inProgress) {
              return;
            }
            this._step(true);
            this._complete();
          },
          _animate: function() {
            this._animId = requestAnimFrame(this._animate, this);
            this._step();
          },
          _step: function(round) {
            var elapsed = +new Date() - this._startTime, duration = this._duration * 1e3;
            if (elapsed < duration) {
              this._runFrame(this._easeOut(elapsed / duration), round);
            } else {
              this._runFrame(1);
              this._complete();
            }
          },
          _runFrame: function(progress, round) {
            var pos = this._startPos.add(this._offset.multiplyBy(progress));
            if (round) {
              pos._round();
            }
            setPosition(this._el, pos);
            this.fire("step");
          },
          _complete: function() {
            cancelAnimFrame(this._animId);
            this._inProgress = false;
            this.fire("end");
          },
          _easeOut: function(t) {
            return 1 - Math.pow(1 - t, this._easeOutPower);
          }
        });
        var Map2 = Evented.extend({
          options: {
            crs: EPSG3857,
            center: void 0,
            zoom: void 0,
            minZoom: void 0,
            maxZoom: void 0,
            layers: [],
            maxBounds: void 0,
            renderer: void 0,
            zoomAnimation: true,
            zoomAnimationThreshold: 4,
            fadeAnimation: true,
            markerZoomAnimation: true,
            transform3DLimit: 8388608,
            zoomSnap: 1,
            zoomDelta: 1,
            trackResize: true
          },
          initialize: function(id, options) {
            options = setOptions(this, options);
            this._handlers = [];
            this._layers = {};
            this._zoomBoundLayers = {};
            this._sizeChanged = true;
            this._initContainer(id);
            this._initLayout();
            this._onResize = bind(this._onResize, this);
            this._initEvents();
            if (options.maxBounds) {
              this.setMaxBounds(options.maxBounds);
            }
            if (options.zoom !== void 0) {
              this._zoom = this._limitZoom(options.zoom);
            }
            if (options.center && options.zoom !== void 0) {
              this.setView(toLatLng(options.center), options.zoom, { reset: true });
            }
            this.callInitHooks();
            this._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation;
            if (this._zoomAnimated) {
              this._createAnimProxy();
              on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
            }
            this._addLayers(this.options.layers);
          },
          setView: function(center, zoom2, options) {
            zoom2 = zoom2 === void 0 ? this._zoom : this._limitZoom(zoom2);
            center = this._limitCenter(toLatLng(center), zoom2, this.options.maxBounds);
            options = options || {};
            this._stop();
            if (this._loaded && !options.reset && options !== true) {
              if (options.animate !== void 0) {
                options.zoom = extend({ animate: options.animate }, options.zoom);
                options.pan = extend({ animate: options.animate, duration: options.duration }, options.pan);
              }
              var moved = this._zoom !== zoom2 ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom2, options.zoom) : this._tryAnimatedPan(center, options.pan);
              if (moved) {
                clearTimeout(this._sizeTimer);
                return this;
              }
            }
            this._resetView(center, zoom2);
            return this;
          },
          setZoom: function(zoom2, options) {
            if (!this._loaded) {
              this._zoom = zoom2;
              return this;
            }
            return this.setView(this.getCenter(), zoom2, { zoom: options });
          },
          zoomIn: function(delta, options) {
            delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
            return this.setZoom(this._zoom + delta, options);
          },
          zoomOut: function(delta, options) {
            delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
            return this.setZoom(this._zoom - delta, options);
          },
          setZoomAround: function(latlng, zoom2, options) {
            var scale2 = this.getZoomScale(zoom2), viewHalf = this.getSize().divideBy(2), containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng), centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale2), newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
            return this.setView(newCenter, zoom2, { zoom: options });
          },
          _getBoundsCenterZoom: function(bounds, options) {
            options = options || {};
            bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
            var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), zoom2 = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
            zoom2 = typeof options.maxZoom === "number" ? Math.min(options.maxZoom, zoom2) : zoom2;
            if (zoom2 === Infinity) {
              return {
                center: bounds.getCenter(),
                zoom: zoom2
              };
            }
            var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.project(bounds.getSouthWest(), zoom2), nePoint = this.project(bounds.getNorthEast(), zoom2), center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom2);
            return {
              center,
              zoom: zoom2
            };
          },
          fitBounds: function(bounds, options) {
            bounds = toLatLngBounds(bounds);
            if (!bounds.isValid()) {
              throw new Error("Bounds are not valid.");
            }
            var target = this._getBoundsCenterZoom(bounds, options);
            return this.setView(target.center, target.zoom, options);
          },
          fitWorld: function(options) {
            return this.fitBounds([[-90, -180], [90, 180]], options);
          },
          panTo: function(center, options) {
            return this.setView(center, this._zoom, { pan: options });
          },
          panBy: function(offset, options) {
            offset = toPoint(offset).round();
            options = options || {};
            if (!offset.x && !offset.y) {
              return this.fire("moveend");
            }
            if (options.animate !== true && !this.getSize().contains(offset)) {
              this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
              return this;
            }
            if (!this._panAnim) {
              this._panAnim = new PosAnimation();
              this._panAnim.on({
                "step": this._onPanTransitionStep,
                "end": this._onPanTransitionEnd
              }, this);
            }
            if (!options.noMoveStart) {
              this.fire("movestart");
            }
            if (options.animate !== false) {
              addClass(this._mapPane, "leaflet-pan-anim");
              var newPos = this._getMapPanePos().subtract(offset).round();
              this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
            } else {
              this._rawPanBy(offset);
              this.fire("move").fire("moveend");
            }
            return this;
          },
          flyTo: function(targetCenter, targetZoom, options) {
            options = options || {};
            if (options.animate === false || !Browser.any3d) {
              return this.setView(targetCenter, targetZoom, options);
            }
            this._stop();
            var from = this.project(this.getCenter()), to = this.project(targetCenter), size = this.getSize(), startZoom = this._zoom;
            targetCenter = toLatLng(targetCenter);
            targetZoom = targetZoom === void 0 ? startZoom : targetZoom;
            var w0 = Math.max(size.x, size.y), w1 = w0 * this.getZoomScale(startZoom, targetZoom), u1 = to.distanceTo(from) || 1, rho = 1.42, rho2 = rho * rho;
            function r(i) {
              var s1 = i ? -1 : 1, s2 = i ? w1 : w0, t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1, b1 = 2 * s2 * rho2 * u1, b = t1 / b1, sq = Math.sqrt(b * b + 1) - b;
              var log = sq < 1e-9 ? -18 : Math.log(sq);
              return log;
            }
            function sinh(n) {
              return (Math.exp(n) - Math.exp(-n)) / 2;
            }
            function cosh(n) {
              return (Math.exp(n) + Math.exp(-n)) / 2;
            }
            function tanh(n) {
              return sinh(n) / cosh(n);
            }
            var r0 = r(0);
            function w(s) {
              return w0 * (cosh(r0) / cosh(r0 + rho * s));
            }
            function u(s) {
              return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;
            }
            function easeOut(t) {
              return 1 - Math.pow(1 - t, 1.5);
            }
            var start = Date.now(), S = (r(1) - r0) / rho, duration = options.duration ? 1e3 * options.duration : 1e3 * S * 0.8;
            function frame() {
              var t = (Date.now() - start) / duration, s = easeOut(t) * S;
              if (t <= 1) {
                this._flyToFrame = requestAnimFrame(frame, this);
                this._move(
                  this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
                  this.getScaleZoom(w0 / w(s), startZoom),
                  { flyTo: true }
                );
              } else {
                this._move(targetCenter, targetZoom)._moveEnd(true);
              }
            }
            this._moveStart(true, options.noMoveStart);
            frame.call(this);
            return this;
          },
          flyToBounds: function(bounds, options) {
            var target = this._getBoundsCenterZoom(bounds, options);
            return this.flyTo(target.center, target.zoom, options);
          },
          setMaxBounds: function(bounds) {
            bounds = toLatLngBounds(bounds);
            if (!bounds.isValid()) {
              this.options.maxBounds = null;
              return this.off("moveend", this._panInsideMaxBounds);
            } else if (this.options.maxBounds) {
              this.off("moveend", this._panInsideMaxBounds);
            }
            this.options.maxBounds = bounds;
            if (this._loaded) {
              this._panInsideMaxBounds();
            }
            return this.on("moveend", this._panInsideMaxBounds);
          },
          setMinZoom: function(zoom2) {
            var oldZoom = this.options.minZoom;
            this.options.minZoom = zoom2;
            if (this._loaded && oldZoom !== zoom2) {
              this.fire("zoomlevelschange");
              if (this.getZoom() < this.options.minZoom) {
                return this.setZoom(zoom2);
              }
            }
            return this;
          },
          setMaxZoom: function(zoom2) {
            var oldZoom = this.options.maxZoom;
            this.options.maxZoom = zoom2;
            if (this._loaded && oldZoom !== zoom2) {
              this.fire("zoomlevelschange");
              if (this.getZoom() > this.options.maxZoom) {
                return this.setZoom(zoom2);
              }
            }
            return this;
          },
          panInsideBounds: function(bounds, options) {
            this._enforcingBounds = true;
            var center = this.getCenter(), newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));
            if (!center.equals(newCenter)) {
              this.panTo(newCenter, options);
            }
            this._enforcingBounds = false;
            return this;
          },
          panInside: function(latlng, options) {
            options = options || {};
            var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), pixelCenter = this.project(this.getCenter()), pixelPoint = this.project(latlng), pixelBounds = this.getPixelBounds(), paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]), paddedSize = paddedBounds.getSize();
            if (!paddedBounds.contains(pixelPoint)) {
              this._enforcingBounds = true;
              var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());
              var offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);
              pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;
              pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;
              this.panTo(this.unproject(pixelCenter), options);
              this._enforcingBounds = false;
            }
            return this;
          },
          invalidateSize: function(options) {
            if (!this._loaded) {
              return this;
            }
            options = extend({
              animate: false,
              pan: true
            }, options === true ? { animate: true } : options);
            var oldSize = this.getSize();
            this._sizeChanged = true;
            this._lastCenter = null;
            var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset = oldCenter.subtract(newCenter);
            if (!offset.x && !offset.y) {
              return this;
            }
            if (options.animate && options.pan) {
              this.panBy(offset);
            } else {
              if (options.pan) {
                this._rawPanBy(offset);
              }
              this.fire("move");
              if (options.debounceMoveend) {
                clearTimeout(this._sizeTimer);
                this._sizeTimer = setTimeout(bind(this.fire, this, "moveend"), 200);
              } else {
                this.fire("moveend");
              }
            }
            return this.fire("resize", {
              oldSize,
              newSize
            });
          },
          stop: function() {
            this.setZoom(this._limitZoom(this._zoom));
            if (!this.options.zoomSnap) {
              this.fire("viewreset");
            }
            return this._stop();
          },
          locate: function(options) {
            options = this._locateOptions = extend({
              timeout: 1e4,
              watch: false
            }, options);
            if (!("geolocation" in navigator)) {
              this._handleGeolocationError({
                code: 0,
                message: "Geolocation not supported."
              });
              return this;
            }
            var onResponse = bind(this._handleGeolocationResponse, this), onError = bind(this._handleGeolocationError, this);
            if (options.watch) {
              this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
            } else {
              navigator.geolocation.getCurrentPosition(onResponse, onError, options);
            }
            return this;
          },
          stopLocate: function() {
            if (navigator.geolocation && navigator.geolocation.clearWatch) {
              navigator.geolocation.clearWatch(this._locationWatchId);
            }
            if (this._locateOptions) {
              this._locateOptions.setView = false;
            }
            return this;
          },
          _handleGeolocationError: function(error) {
            if (!this._container._leaflet_id) {
              return;
            }
            var c = error.code, message = error.message || (c === 1 ? "permission denied" : c === 2 ? "position unavailable" : "timeout");
            if (this._locateOptions.setView && !this._loaded) {
              this.fitWorld();
            }
            this.fire("locationerror", {
              code: c,
              message: "Geolocation error: " + message + "."
            });
          },
          _handleGeolocationResponse: function(pos) {
            if (!this._container._leaflet_id) {
              return;
            }
            var lat = pos.coords.latitude, lng = pos.coords.longitude, latlng = new LatLng(lat, lng), bounds = latlng.toBounds(pos.coords.accuracy * 2), options = this._locateOptions;
            if (options.setView) {
              var zoom2 = this.getBoundsZoom(bounds);
              this.setView(latlng, options.maxZoom ? Math.min(zoom2, options.maxZoom) : zoom2);
            }
            var data = {
              latlng,
              bounds,
              timestamp: pos.timestamp
            };
            for (var i in pos.coords) {
              if (typeof pos.coords[i] === "number") {
                data[i] = pos.coords[i];
              }
            }
            this.fire("locationfound", data);
          },
          addHandler: function(name, HandlerClass) {
            if (!HandlerClass) {
              return this;
            }
            var handler = this[name] = new HandlerClass(this);
            this._handlers.push(handler);
            if (this.options[name]) {
              handler.enable();
            }
            return this;
          },
          remove: function() {
            this._initEvents(true);
            if (this.options.maxBounds) {
              this.off("moveend", this._panInsideMaxBounds);
            }
            if (this._containerId !== this._container._leaflet_id) {
              throw new Error("Map container is being reused by another instance");
            }
            try {
              delete this._container._leaflet_id;
              delete this._containerId;
            } catch (e) {
              this._container._leaflet_id = void 0;
              this._containerId = void 0;
            }
            if (this._locationWatchId !== void 0) {
              this.stopLocate();
            }
            this._stop();
            remove(this._mapPane);
            if (this._clearControlPos) {
              this._clearControlPos();
            }
            if (this._resizeRequest) {
              cancelAnimFrame(this._resizeRequest);
              this._resizeRequest = null;
            }
            this._clearHandlers();
            if (this._loaded) {
              this.fire("unload");
            }
            var i;
            for (i in this._layers) {
              this._layers[i].remove();
            }
            for (i in this._panes) {
              remove(this._panes[i]);
            }
            this._layers = [];
            this._panes = [];
            delete this._mapPane;
            delete this._renderer;
            return this;
          },
          createPane: function(name, container) {
            var className = "leaflet-pane" + (name ? " leaflet-" + name.replace("Pane", "") + "-pane" : ""), pane = create$1("div", className, container || this._mapPane);
            if (name) {
              this._panes[name] = pane;
            }
            return pane;
          },
          getCenter: function() {
            this._checkIfLoaded();
            if (this._lastCenter && !this._moved()) {
              return this._lastCenter;
            }
            return this.layerPointToLatLng(this._getCenterLayerPoint());
          },
          getZoom: function() {
            return this._zoom;
          },
          getBounds: function() {
            var bounds = this.getPixelBounds(), sw = this.unproject(bounds.getBottomLeft()), ne = this.unproject(bounds.getTopRight());
            return new LatLngBounds(sw, ne);
          },
          getMinZoom: function() {
            return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
          },
          getMaxZoom: function() {
            return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? Infinity : this._layersMaxZoom : this.options.maxZoom;
          },
          getBoundsZoom: function(bounds, inside, padding) {
            bounds = toLatLngBounds(bounds);
            padding = toPoint(padding || [0, 0]);
            var zoom2 = this.getZoom() || 0, min = this.getMinZoom(), max = this.getMaxZoom(), nw = bounds.getNorthWest(), se = bounds.getSouthEast(), size = this.getSize().subtract(padding), boundsSize = toBounds(this.project(se, zoom2), this.project(nw, zoom2)).getSize(), snap = Browser.any3d ? this.options.zoomSnap : 1, scalex = size.x / boundsSize.x, scaley = size.y / boundsSize.y, scale2 = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
            zoom2 = this.getScaleZoom(scale2, zoom2);
            if (snap) {
              zoom2 = Math.round(zoom2 / (snap / 100)) * (snap / 100);
              zoom2 = inside ? Math.ceil(zoom2 / snap) * snap : Math.floor(zoom2 / snap) * snap;
            }
            return Math.max(min, Math.min(max, zoom2));
          },
          getSize: function() {
            if (!this._size || this._sizeChanged) {
              this._size = new Point(
                this._container.clientWidth || 0,
                this._container.clientHeight || 0
              );
              this._sizeChanged = false;
            }
            return this._size.clone();
          },
          getPixelBounds: function(center, zoom2) {
            var topLeftPoint = this._getTopLeftPoint(center, zoom2);
            return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
          },
          getPixelOrigin: function() {
            this._checkIfLoaded();
            return this._pixelOrigin;
          },
          getPixelWorldBounds: function(zoom2) {
            return this.options.crs.getProjectedBounds(zoom2 === void 0 ? this.getZoom() : zoom2);
          },
          getPane: function(pane) {
            return typeof pane === "string" ? this._panes[pane] : pane;
          },
          getPanes: function() {
            return this._panes;
          },
          getContainer: function() {
            return this._container;
          },
          getZoomScale: function(toZoom, fromZoom) {
            var crs = this.options.crs;
            fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
            return crs.scale(toZoom) / crs.scale(fromZoom);
          },
          getScaleZoom: function(scale2, fromZoom) {
            var crs = this.options.crs;
            fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
            var zoom2 = crs.zoom(scale2 * crs.scale(fromZoom));
            return isNaN(zoom2) ? Infinity : zoom2;
          },
          project: function(latlng, zoom2) {
            zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
            return this.options.crs.latLngToPoint(toLatLng(latlng), zoom2);
          },
          unproject: function(point, zoom2) {
            zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
            return this.options.crs.pointToLatLng(toPoint(point), zoom2);
          },
          layerPointToLatLng: function(point) {
            var projectedPoint = toPoint(point).add(this.getPixelOrigin());
            return this.unproject(projectedPoint);
          },
          latLngToLayerPoint: function(latlng) {
            var projectedPoint = this.project(toLatLng(latlng))._round();
            return projectedPoint._subtract(this.getPixelOrigin());
          },
          wrapLatLng: function(latlng) {
            return this.options.crs.wrapLatLng(toLatLng(latlng));
          },
          wrapLatLngBounds: function(latlng) {
            return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
          },
          distance: function(latlng1, latlng2) {
            return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
          },
          containerPointToLayerPoint: function(point) {
            return toPoint(point).subtract(this._getMapPanePos());
          },
          layerPointToContainerPoint: function(point) {
            return toPoint(point).add(this._getMapPanePos());
          },
          containerPointToLatLng: function(point) {
            var layerPoint = this.containerPointToLayerPoint(toPoint(point));
            return this.layerPointToLatLng(layerPoint);
          },
          latLngToContainerPoint: function(latlng) {
            return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
          },
          mouseEventToContainerPoint: function(e) {
            return getMousePosition(e, this._container);
          },
          mouseEventToLayerPoint: function(e) {
            return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
          },
          mouseEventToLatLng: function(e) {
            return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
          },
          _initContainer: function(id) {
            var container = this._container = get(id);
            if (!container) {
              throw new Error("Map container not found.");
            } else if (container._leaflet_id) {
              throw new Error("Map container is already initialized.");
            }
            on(container, "scroll", this._onScroll, this);
            this._containerId = stamp(container);
          },
          _initLayout: function() {
            var container = this._container;
            this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;
            addClass(container, "leaflet-container" + (Browser.touch ? " leaflet-touch" : "") + (Browser.retina ? " leaflet-retina" : "") + (Browser.ielt9 ? " leaflet-oldie" : "") + (Browser.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
            var position = getStyle(container, "position");
            if (position !== "absolute" && position !== "relative" && position !== "fixed") {
              container.style.position = "relative";
            }
            this._initPanes();
            if (this._initControlPos) {
              this._initControlPos();
            }
          },
          _initPanes: function() {
            var panes = this._panes = {};
            this._paneRenderers = {};
            this._mapPane = this.createPane("mapPane", this._container);
            setPosition(this._mapPane, new Point(0, 0));
            this.createPane("tilePane");
            this.createPane("overlayPane");
            this.createPane("shadowPane");
            this.createPane("markerPane");
            this.createPane("tooltipPane");
            this.createPane("popupPane");
            if (!this.options.markerZoomAnimation) {
              addClass(panes.markerPane, "leaflet-zoom-hide");
              addClass(panes.shadowPane, "leaflet-zoom-hide");
            }
          },
          _resetView: function(center, zoom2) {
            setPosition(this._mapPane, new Point(0, 0));
            var loading = !this._loaded;
            this._loaded = true;
            zoom2 = this._limitZoom(zoom2);
            this.fire("viewprereset");
            var zoomChanged = this._zoom !== zoom2;
            this._moveStart(zoomChanged, false)._move(center, zoom2)._moveEnd(zoomChanged);
            this.fire("viewreset");
            if (loading) {
              this.fire("load");
            }
          },
          _moveStart: function(zoomChanged, noMoveStart) {
            if (zoomChanged) {
              this.fire("zoomstart");
            }
            if (!noMoveStart) {
              this.fire("movestart");
            }
            return this;
          },
          _move: function(center, zoom2, data, supressEvent) {
            if (zoom2 === void 0) {
              zoom2 = this._zoom;
            }
            var zoomChanged = this._zoom !== zoom2;
            this._zoom = zoom2;
            this._lastCenter = center;
            this._pixelOrigin = this._getNewPixelOrigin(center);
            if (!supressEvent) {
              if (zoomChanged || data && data.pinch) {
                this.fire("zoom", data);
              }
              this.fire("move", data);
            } else if (data && data.pinch) {
              this.fire("zoom", data);
            }
            return this;
          },
          _moveEnd: function(zoomChanged) {
            if (zoomChanged) {
              this.fire("zoomend");
            }
            return this.fire("moveend");
          },
          _stop: function() {
            cancelAnimFrame(this._flyToFrame);
            if (this._panAnim) {
              this._panAnim.stop();
            }
            return this;
          },
          _rawPanBy: function(offset) {
            setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
          },
          _getZoomSpan: function() {
            return this.getMaxZoom() - this.getMinZoom();
          },
          _panInsideMaxBounds: function() {
            if (!this._enforcingBounds) {
              this.panInsideBounds(this.options.maxBounds);
            }
          },
          _checkIfLoaded: function() {
            if (!this._loaded) {
              throw new Error("Set map center and zoom first.");
            }
          },
          _initEvents: function(remove2) {
            this._targets = {};
            this._targets[stamp(this._container)] = this;
            var onOff = remove2 ? off : on;
            onOff(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this);
            if (this.options.trackResize) {
              onOff(window, "resize", this._onResize, this);
            }
            if (Browser.any3d && this.options.transform3DLimit) {
              (remove2 ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
            }
          },
          _onResize: function() {
            cancelAnimFrame(this._resizeRequest);
            this._resizeRequest = requestAnimFrame(
              function() {
                this.invalidateSize({ debounceMoveend: true });
              },
              this
            );
          },
          _onScroll: function() {
            this._container.scrollTop = 0;
            this._container.scrollLeft = 0;
          },
          _onMoveEnd: function() {
            var pos = this._getMapPanePos();
            if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
              this._resetView(this.getCenter(), this.getZoom());
            }
          },
          _findEventTargets: function(e, type) {
            var targets = [], target, isHover = type === "mouseout" || type === "mouseover", src = e.target || e.srcElement, dragging = false;
            while (src) {
              target = this._targets[stamp(src)];
              if (target && (type === "click" || type === "preclick") && this._draggableMoved(target)) {
                dragging = true;
                break;
              }
              if (target && target.listens(type, true)) {
                if (isHover && !isExternalTarget(src, e)) {
                  break;
                }
                targets.push(target);
                if (isHover) {
                  break;
                }
              }
              if (src === this._container) {
                break;
              }
              src = src.parentNode;
            }
            if (!targets.length && !dragging && !isHover && this.listens(type, true)) {
              targets = [this];
            }
            return targets;
          },
          _isClickDisabled: function(el) {
            while (el !== this._container) {
              if (el["_leaflet_disable_click"]) {
                return true;
              }
              el = el.parentNode;
            }
          },
          _handleDOMEvent: function(e) {
            var el = e.target || e.srcElement;
            if (!this._loaded || el["_leaflet_disable_events"] || e.type === "click" && this._isClickDisabled(el)) {
              return;
            }
            var type = e.type;
            if (type === "mousedown") {
              preventOutline(el);
            }
            this._fireDOMEvent(e, type);
          },
          _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
          _fireDOMEvent: function(e, type, canvasTargets) {
            if (e.type === "click") {
              var synth = extend({}, e);
              synth.type = "preclick";
              this._fireDOMEvent(synth, synth.type, canvasTargets);
            }
            var targets = this._findEventTargets(e, type);
            if (canvasTargets) {
              var filtered = [];
              for (var i = 0; i < canvasTargets.length; i++) {
                if (canvasTargets[i].listens(type, true)) {
                  filtered.push(canvasTargets[i]);
                }
              }
              targets = filtered.concat(targets);
            }
            if (!targets.length) {
              return;
            }
            if (type === "contextmenu") {
              preventDefault(e);
            }
            var target = targets[0];
            var data = {
              originalEvent: e
            };
            if (e.type !== "keypress" && e.type !== "keydown" && e.type !== "keyup") {
              var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
              data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
              data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
              data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
            }
            for (i = 0; i < targets.length; i++) {
              targets[i].fire(type, data, true);
              if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {
                return;
              }
            }
          },
          _draggableMoved: function(obj) {
            obj = obj.dragging && obj.dragging.enabled() ? obj : this;
            return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
          },
          _clearHandlers: function() {
            for (var i = 0, len = this._handlers.length; i < len; i++) {
              this._handlers[i].disable();
            }
          },
          whenReady: function(callback, context) {
            if (this._loaded) {
              callback.call(context || this, { target: this });
            } else {
              this.on("load", callback, context);
            }
            return this;
          },
          _getMapPanePos: function() {
            return getPosition(this._mapPane) || new Point(0, 0);
          },
          _moved: function() {
            var pos = this._getMapPanePos();
            return pos && !pos.equals([0, 0]);
          },
          _getTopLeftPoint: function(center, zoom2) {
            var pixelOrigin = center && zoom2 !== void 0 ? this._getNewPixelOrigin(center, zoom2) : this.getPixelOrigin();
            return pixelOrigin.subtract(this._getMapPanePos());
          },
          _getNewPixelOrigin: function(center, zoom2) {
            var viewHalf = this.getSize()._divideBy(2);
            return this.project(center, zoom2)._subtract(viewHalf)._add(this._getMapPanePos())._round();
          },
          _latLngToNewLayerPoint: function(latlng, zoom2, center) {
            var topLeft = this._getNewPixelOrigin(center, zoom2);
            return this.project(latlng, zoom2)._subtract(topLeft);
          },
          _latLngBoundsToNewLayerBounds: function(latLngBounds, zoom2, center) {
            var topLeft = this._getNewPixelOrigin(center, zoom2);
            return toBounds([
              this.project(latLngBounds.getSouthWest(), zoom2)._subtract(topLeft),
              this.project(latLngBounds.getNorthWest(), zoom2)._subtract(topLeft),
              this.project(latLngBounds.getSouthEast(), zoom2)._subtract(topLeft),
              this.project(latLngBounds.getNorthEast(), zoom2)._subtract(topLeft)
            ]);
          },
          _getCenterLayerPoint: function() {
            return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
          },
          _getCenterOffset: function(latlng) {
            return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
          },
          _limitCenter: function(center, zoom2, bounds) {
            if (!bounds) {
              return center;
            }
            var centerPoint = this.project(center, zoom2), viewHalf = this.getSize().divideBy(2), viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset = this._getBoundsOffset(viewBounds, bounds, zoom2);
            if (offset.round().equals([0, 0])) {
              return center;
            }
            return this.unproject(centerPoint.add(offset), zoom2);
          },
          _limitOffset: function(offset, bounds) {
            if (!bounds) {
              return offset;
            }
            var viewBounds = this.getPixelBounds(), newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
            return offset.add(this._getBoundsOffset(newBounds, bounds));
          },
          _getBoundsOffset: function(pxBounds, maxBounds, zoom2) {
            var projectedMaxBounds = toBounds(
              this.project(maxBounds.getNorthEast(), zoom2),
              this.project(maxBounds.getSouthWest(), zoom2)
            ), minOffset = projectedMaxBounds.min.subtract(pxBounds.min), maxOffset = projectedMaxBounds.max.subtract(pxBounds.max), dx = this._rebound(minOffset.x, -maxOffset.x), dy = this._rebound(minOffset.y, -maxOffset.y);
            return new Point(dx, dy);
          },
          _rebound: function(left, right) {
            return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
          },
          _limitZoom: function(zoom2) {
            var min = this.getMinZoom(), max = this.getMaxZoom(), snap = Browser.any3d ? this.options.zoomSnap : 1;
            if (snap) {
              zoom2 = Math.round(zoom2 / snap) * snap;
            }
            return Math.max(min, Math.min(max, zoom2));
          },
          _onPanTransitionStep: function() {
            this.fire("move");
          },
          _onPanTransitionEnd: function() {
            removeClass(this._mapPane, "leaflet-pan-anim");
            this.fire("moveend");
          },
          _tryAnimatedPan: function(center, options) {
            var offset = this._getCenterOffset(center)._trunc();
            if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
              return false;
            }
            this.panBy(offset, options);
            return true;
          },
          _createAnimProxy: function() {
            var proxy = this._proxy = create$1("div", "leaflet-proxy leaflet-zoom-animated");
            this._panes.mapPane.appendChild(proxy);
            this.on("zoomanim", function(e) {
              var prop = TRANSFORM, transform = this._proxy.style[prop];
              setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));
              if (transform === this._proxy.style[prop] && this._animatingZoom) {
                this._onZoomTransitionEnd();
              }
            }, this);
            this.on("load moveend", this._animMoveEnd, this);
            this._on("unload", this._destroyAnimProxy, this);
          },
          _destroyAnimProxy: function() {
            remove(this._proxy);
            this.off("load moveend", this._animMoveEnd, this);
            delete this._proxy;
          },
          _animMoveEnd: function() {
            var c = this.getCenter(), z = this.getZoom();
            setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
          },
          _catchTransitionEnd: function(e) {
            if (this._animatingZoom && e.propertyName.indexOf("transform") >= 0) {
              this._onZoomTransitionEnd();
            }
          },
          _nothingToAnimate: function() {
            return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
          },
          _tryAnimatedZoom: function(center, zoom2, options) {
            if (this._animatingZoom) {
              return true;
            }
            options = options || {};
            if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom2 - this._zoom) > this.options.zoomAnimationThreshold) {
              return false;
            }
            var scale2 = this.getZoomScale(zoom2), offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale2);
            if (options.animate !== true && !this.getSize().contains(offset)) {
              return false;
            }
            requestAnimFrame(function() {
              this._moveStart(true, false)._animateZoom(center, zoom2, true);
            }, this);
            return true;
          },
          _animateZoom: function(center, zoom2, startAnim, noUpdate) {
            if (!this._mapPane) {
              return;
            }
            if (startAnim) {
              this._animatingZoom = true;
              this._animateToCenter = center;
              this._animateToZoom = zoom2;
              addClass(this._mapPane, "leaflet-zoom-anim");
            }
            this.fire("zoomanim", {
              center,
              zoom: zoom2,
              noUpdate
            });
            if (!this._tempFireZoomEvent) {
              this._tempFireZoomEvent = this._zoom !== this._animateToZoom;
            }
            this._move(this._animateToCenter, this._animateToZoom, void 0, true);
            setTimeout(bind(this._onZoomTransitionEnd, this), 250);
          },
          _onZoomTransitionEnd: function() {
            if (!this._animatingZoom) {
              return;
            }
            if (this._mapPane) {
              removeClass(this._mapPane, "leaflet-zoom-anim");
            }
            this._animatingZoom = false;
            this._move(this._animateToCenter, this._animateToZoom, void 0, true);
            if (this._tempFireZoomEvent) {
              this.fire("zoom");
            }
            delete this._tempFireZoomEvent;
            this.fire("move");
            this._moveEnd(true);
          }
        });
        function createMap(id, options) {
          return new Map2(id, options);
        }
        var Control = Class.extend({
          options: {
            position: "topright"
          },
          initialize: function(options) {
            setOptions(this, options);
          },
          getPosition: function() {
            return this.options.position;
          },
          setPosition: function(position) {
            var map = this._map;
            if (map) {
              map.removeControl(this);
            }
            this.options.position = position;
            if (map) {
              map.addControl(this);
            }
            return this;
          },
          getContainer: function() {
            return this._container;
          },
          addTo: function(map) {
            this.remove();
            this._map = map;
            var container = this._container = this.onAdd(map), pos = this.getPosition(), corner = map._controlCorners[pos];
            addClass(container, "leaflet-control");
            if (pos.indexOf("bottom") !== -1) {
              corner.insertBefore(container, corner.firstChild);
            } else {
              corner.appendChild(container);
            }
            this._map.on("unload", this.remove, this);
            return this;
          },
          remove: function() {
            if (!this._map) {
              return this;
            }
            remove(this._container);
            if (this.onRemove) {
              this.onRemove(this._map);
            }
            this._map.off("unload", this.remove, this);
            this._map = null;
            return this;
          },
          _refocusOnMap: function(e) {
            if (this._map && e && e.screenX > 0 && e.screenY > 0) {
              this._map.getContainer().focus();
            }
          }
        });
        var control = function(options) {
          return new Control(options);
        };
        Map2.include({
          addControl: function(control2) {
            control2.addTo(this);
            return this;
          },
          removeControl: function(control2) {
            control2.remove();
            return this;
          },
          _initControlPos: function() {
            var corners = this._controlCorners = {}, l = "leaflet-", container = this._controlContainer = create$1("div", l + "control-container", this._container);
            function createCorner(vSide, hSide) {
              var className = l + vSide + " " + l + hSide;
              corners[vSide + hSide] = create$1("div", className, container);
            }
            createCorner("top", "left");
            createCorner("top", "right");
            createCorner("bottom", "left");
            createCorner("bottom", "right");
          },
          _clearControlPos: function() {
            for (var i in this._controlCorners) {
              remove(this._controlCorners[i]);
            }
            remove(this._controlContainer);
            delete this._controlCorners;
            delete this._controlContainer;
          }
        });
        var Layers = Control.extend({
          options: {
            collapsed: true,
            position: "topright",
            autoZIndex: true,
            hideSingleBase: false,
            sortLayers: false,
            sortFunction: function(layerA, layerB, nameA, nameB) {
              return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
            }
          },
          initialize: function(baseLayers, overlays, options) {
            setOptions(this, options);
            this._layerControlInputs = [];
            this._layers = [];
            this._lastZIndex = 0;
            this._handlingClick = false;
            for (var i in baseLayers) {
              this._addLayer(baseLayers[i], i);
            }
            for (i in overlays) {
              this._addLayer(overlays[i], i, true);
            }
          },
          onAdd: function(map) {
            this._initLayout();
            this._update();
            this._map = map;
            map.on("zoomend", this._checkDisabledLayers, this);
            for (var i = 0; i < this._layers.length; i++) {
              this._layers[i].layer.on("add remove", this._onLayerChange, this);
            }
            return this._container;
          },
          addTo: function(map) {
            Control.prototype.addTo.call(this, map);
            return this._expandIfNotCollapsed();
          },
          onRemove: function() {
            this._map.off("zoomend", this._checkDisabledLayers, this);
            for (var i = 0; i < this._layers.length; i++) {
              this._layers[i].layer.off("add remove", this._onLayerChange, this);
            }
          },
          addBaseLayer: function(layer, name) {
            this._addLayer(layer, name);
            return this._map ? this._update() : this;
          },
          addOverlay: function(layer, name) {
            this._addLayer(layer, name, true);
            return this._map ? this._update() : this;
          },
          removeLayer: function(layer) {
            layer.off("add remove", this._onLayerChange, this);
            var obj = this._getLayer(stamp(layer));
            if (obj) {
              this._layers.splice(this._layers.indexOf(obj), 1);
            }
            return this._map ? this._update() : this;
          },
          expand: function() {
            addClass(this._container, "leaflet-control-layers-expanded");
            this._section.style.height = null;
            var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
            if (acceptableHeight < this._section.clientHeight) {
              addClass(this._section, "leaflet-control-layers-scrollbar");
              this._section.style.height = acceptableHeight + "px";
            } else {
              removeClass(this._section, "leaflet-control-layers-scrollbar");
            }
            this._checkDisabledLayers();
            return this;
          },
          collapse: function() {
            removeClass(this._container, "leaflet-control-layers-expanded");
            return this;
          },
          _initLayout: function() {
            var className = "leaflet-control-layers", container = this._container = create$1("div", className), collapsed = this.options.collapsed;
            container.setAttribute("aria-haspopup", true);
            disableClickPropagation(container);
            disableScrollPropagation(container);
            var section = this._section = create$1("section", className + "-list");
            if (collapsed) {
              this._map.on("click", this.collapse, this);
              on(container, {
                mouseenter: function() {
                  on(section, "click", preventDefault);
                  this.expand();
                  setTimeout(function() {
                    off(section, "click", preventDefault);
                  });
                },
                mouseleave: this.collapse
              }, this);
            }
            var link = this._layersLink = create$1("a", className + "-toggle", container);
            link.href = "#";
            link.title = "Layers";
            link.setAttribute("role", "button");
            on(link, "click", preventDefault);
            on(link, "focus", this.expand, this);
            if (!collapsed) {
              this.expand();
            }
            this._baseLayersList = create$1("div", className + "-base", section);
            this._separator = create$1("div", className + "-separator", section);
            this._overlaysList = create$1("div", className + "-overlays", section);
            container.appendChild(section);
          },
          _getLayer: function(id) {
            for (var i = 0; i < this._layers.length; i++) {
              if (this._layers[i] && stamp(this._layers[i].layer) === id) {
                return this._layers[i];
              }
            }
          },
          _addLayer: function(layer, name, overlay) {
            if (this._map) {
              layer.on("add remove", this._onLayerChange, this);
            }
            this._layers.push({
              layer,
              name,
              overlay
            });
            if (this.options.sortLayers) {
              this._layers.sort(bind(function(a, b) {
                return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
              }, this));
            }
            if (this.options.autoZIndex && layer.setZIndex) {
              this._lastZIndex++;
              layer.setZIndex(this._lastZIndex);
            }
            this._expandIfNotCollapsed();
          },
          _update: function() {
            if (!this._container) {
              return this;
            }
            empty(this._baseLayersList);
            empty(this._overlaysList);
            this._layerControlInputs = [];
            var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;
            for (i = 0; i < this._layers.length; i++) {
              obj = this._layers[i];
              this._addItem(obj);
              overlaysPresent = overlaysPresent || obj.overlay;
              baseLayersPresent = baseLayersPresent || !obj.overlay;
              baseLayersCount += !obj.overlay ? 1 : 0;
            }
            if (this.options.hideSingleBase) {
              baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
              this._baseLayersList.style.display = baseLayersPresent ? "" : "none";
            }
            this._separator.style.display = overlaysPresent && baseLayersPresent ? "" : "none";
            return this;
          },
          _onLayerChange: function(e) {
            if (!this._handlingClick) {
              this._update();
            }
            var obj = this._getLayer(stamp(e.target));
            var type = obj.overlay ? e.type === "add" ? "overlayadd" : "overlayremove" : e.type === "add" ? "baselayerchange" : null;
            if (type) {
              this._map.fire(type, obj);
            }
          },
          _createRadioElement: function(name, checked) {
            var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : "") + "/>";
            var radioFragment = document.createElement("div");
            radioFragment.innerHTML = radioHtml;
            return radioFragment.firstChild;
          },
          _addItem: function(obj) {
            var label = document.createElement("label"), checked = this._map.hasLayer(obj.layer), input;
            if (obj.overlay) {
              input = document.createElement("input");
              input.type = "checkbox";
              input.className = "leaflet-control-layers-selector";
              input.defaultChecked = checked;
            } else {
              input = this._createRadioElement("leaflet-base-layers_" + stamp(this), checked);
            }
            this._layerControlInputs.push(input);
            input.layerId = stamp(obj.layer);
            on(input, "click", this._onInputClick, this);
            var name = document.createElement("span");
            name.innerHTML = " " + obj.name;
            var holder = document.createElement("span");
            label.appendChild(holder);
            holder.appendChild(input);
            holder.appendChild(name);
            var container = obj.overlay ? this._overlaysList : this._baseLayersList;
            container.appendChild(label);
            this._checkDisabledLayers();
            return label;
          },
          _onInputClick: function() {
            var inputs = this._layerControlInputs, input, layer;
            var addedLayers = [], removedLayers = [];
            this._handlingClick = true;
            for (var i = inputs.length - 1; i >= 0; i--) {
              input = inputs[i];
              layer = this._getLayer(input.layerId).layer;
              if (input.checked) {
                addedLayers.push(layer);
              } else if (!input.checked) {
                removedLayers.push(layer);
              }
            }
            for (i = 0; i < removedLayers.length; i++) {
              if (this._map.hasLayer(removedLayers[i])) {
                this._map.removeLayer(removedLayers[i]);
              }
            }
            for (i = 0; i < addedLayers.length; i++) {
              if (!this._map.hasLayer(addedLayers[i])) {
                this._map.addLayer(addedLayers[i]);
              }
            }
            this._handlingClick = false;
            this._refocusOnMap();
          },
          _checkDisabledLayers: function() {
            var inputs = this._layerControlInputs, input, layer, zoom2 = this._map.getZoom();
            for (var i = inputs.length - 1; i >= 0; i--) {
              input = inputs[i];
              layer = this._getLayer(input.layerId).layer;
              input.disabled = layer.options.minZoom !== void 0 && zoom2 < layer.options.minZoom || layer.options.maxZoom !== void 0 && zoom2 > layer.options.maxZoom;
            }
          },
          _expandIfNotCollapsed: function() {
            if (this._map && !this.options.collapsed) {
              this.expand();
            }
            return this;
          }
        });
        var layers = function(baseLayers, overlays, options) {
          return new Layers(baseLayers, overlays, options);
        };
        var Zoom = Control.extend({
          options: {
            position: "topleft",
            zoomInText: '<span aria-hidden="true">+</span>',
            zoomInTitle: "Zoom in",
            zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
            zoomOutTitle: "Zoom out"
          },
          onAdd: function(map) {
            var zoomName = "leaflet-control-zoom", container = create$1("div", zoomName + " leaflet-bar"), options = this.options;
            this._zoomInButton = this._createButton(
              options.zoomInText,
              options.zoomInTitle,
              zoomName + "-in",
              container,
              this._zoomIn
            );
            this._zoomOutButton = this._createButton(
              options.zoomOutText,
              options.zoomOutTitle,
              zoomName + "-out",
              container,
              this._zoomOut
            );
            this._updateDisabled();
            map.on("zoomend zoomlevelschange", this._updateDisabled, this);
            return container;
          },
          onRemove: function(map) {
            map.off("zoomend zoomlevelschange", this._updateDisabled, this);
          },
          disable: function() {
            this._disabled = true;
            this._updateDisabled();
            return this;
          },
          enable: function() {
            this._disabled = false;
            this._updateDisabled();
            return this;
          },
          _zoomIn: function(e) {
            if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
              this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
            }
          },
          _zoomOut: function(e) {
            if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
              this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
            }
          },
          _createButton: function(html, title, className, container, fn) {
            var link = create$1("a", className, container);
            link.innerHTML = html;
            link.href = "#";
            link.title = title;
            link.setAttribute("role", "button");
            link.setAttribute("aria-label", title);
            disableClickPropagation(link);
            on(link, "click", stop);
            on(link, "click", fn, this);
            on(link, "click", this._refocusOnMap, this);
            return link;
          },
          _updateDisabled: function() {
            var map = this._map, className = "leaflet-disabled";
            removeClass(this._zoomInButton, className);
            removeClass(this._zoomOutButton, className);
            this._zoomInButton.setAttribute("aria-disabled", "false");
            this._zoomOutButton.setAttribute("aria-disabled", "false");
            if (this._disabled || map._zoom === map.getMinZoom()) {
              addClass(this._zoomOutButton, className);
              this._zoomOutButton.setAttribute("aria-disabled", "true");
            }
            if (this._disabled || map._zoom === map.getMaxZoom()) {
              addClass(this._zoomInButton, className);
              this._zoomInButton.setAttribute("aria-disabled", "true");
            }
          }
        });
        Map2.mergeOptions({
          zoomControl: true
        });
        Map2.addInitHook(function() {
          if (this.options.zoomControl) {
            this.zoomControl = new Zoom();
            this.addControl(this.zoomControl);
          }
        });
        var zoom = function(options) {
          return new Zoom(options);
        };
        var Scale = Control.extend({
          options: {
            position: "bottomleft",
            maxWidth: 100,
            metric: true,
            imperial: true
          },
          onAdd: function(map) {
            var className = "leaflet-control-scale", container = create$1("div", className), options = this.options;
            this._addScales(options, className + "-line", container);
            map.on(options.updateWhenIdle ? "moveend" : "move", this._update, this);
            map.whenReady(this._update, this);
            return container;
          },
          onRemove: function(map) {
            map.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
          },
          _addScales: function(options, className, container) {
            if (options.metric) {
              this._mScale = create$1("div", className, container);
            }
            if (options.imperial) {
              this._iScale = create$1("div", className, container);
            }
          },
          _update: function() {
            var map = this._map, y = map.getSize().y / 2;
            var maxMeters = map.distance(
              map.containerPointToLatLng([0, y]),
              map.containerPointToLatLng([this.options.maxWidth, y])
            );
            this._updateScales(maxMeters);
          },
          _updateScales: function(maxMeters) {
            if (this.options.metric && maxMeters) {
              this._updateMetric(maxMeters);
            }
            if (this.options.imperial && maxMeters) {
              this._updateImperial(maxMeters);
            }
          },
          _updateMetric: function(maxMeters) {
            var meters = this._getRoundNum(maxMeters), label = meters < 1e3 ? meters + " m" : meters / 1e3 + " km";
            this._updateScale(this._mScale, label, meters / maxMeters);
          },
          _updateImperial: function(maxMeters) {
            var maxFeet = maxMeters * 3.2808399, maxMiles, miles, feet;
            if (maxFeet > 5280) {
              maxMiles = maxFeet / 5280;
              miles = this._getRoundNum(maxMiles);
              this._updateScale(this._iScale, miles + " mi", miles / maxMiles);
            } else {
              feet = this._getRoundNum(maxFeet);
              this._updateScale(this._iScale, feet + " ft", feet / maxFeet);
            }
          },
          _updateScale: function(scale2, text, ratio) {
            scale2.style.width = Math.round(this.options.maxWidth * ratio) + "px";
            scale2.innerHTML = text;
          },
          _getRoundNum: function(num) {
            var pow10 = Math.pow(10, (Math.floor(num) + "").length - 1), d = num / pow10;
            d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;
            return pow10 * d;
          }
        });
        var scale = function(options) {
          return new Scale(options);
        };
        var ukrainianFlag = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>';
        var Attribution = Control.extend({
          options: {
            position: "bottomright",
            prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Browser.inlineSvg ? ukrainianFlag + " " : "") + "Leaflet</a>"
          },
          initialize: function(options) {
            setOptions(this, options);
            this._attributions = {};
          },
          onAdd: function(map) {
            map.attributionControl = this;
            this._container = create$1("div", "leaflet-control-attribution");
            disableClickPropagation(this._container);
            for (var i in map._layers) {
              if (map._layers[i].getAttribution) {
                this.addAttribution(map._layers[i].getAttribution());
              }
            }
            this._update();
            map.on("layeradd", this._addAttribution, this);
            return this._container;
          },
          onRemove: function(map) {
            map.off("layeradd", this._addAttribution, this);
          },
          _addAttribution: function(ev) {
            if (ev.layer.getAttribution) {
              this.addAttribution(ev.layer.getAttribution());
              ev.layer.once("remove", function() {
                this.removeAttribution(ev.layer.getAttribution());
              }, this);
            }
          },
          setPrefix: function(prefix) {
            this.options.prefix = prefix;
            this._update();
            return this;
          },
          addAttribution: function(text) {
            if (!text) {
              return this;
            }
            if (!this._attributions[text]) {
              this._attributions[text] = 0;
            }
            this._attributions[text]++;
            this._update();
            return this;
          },
          removeAttribution: function(text) {
            if (!text) {
              return this;
            }
            if (this._attributions[text]) {
              this._attributions[text]--;
              this._update();
            }
            return this;
          },
          _update: function() {
            if (!this._map) {
              return;
            }
            var attribs = [];
            for (var i in this._attributions) {
              if (this._attributions[i]) {
                attribs.push(i);
              }
            }
            var prefixAndAttribs = [];
            if (this.options.prefix) {
              prefixAndAttribs.push(this.options.prefix);
            }
            if (attribs.length) {
              prefixAndAttribs.push(attribs.join(", "));
            }
            this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden="true">|</span> ');
          }
        });
        Map2.mergeOptions({
          attributionControl: true
        });
        Map2.addInitHook(function() {
          if (this.options.attributionControl) {
            new Attribution().addTo(this);
          }
        });
        var attribution = function(options) {
          return new Attribution(options);
        };
        Control.Layers = Layers;
        Control.Zoom = Zoom;
        Control.Scale = Scale;
        Control.Attribution = Attribution;
        control.layers = layers;
        control.zoom = zoom;
        control.scale = scale;
        control.attribution = attribution;
        var Handler = Class.extend({
          initialize: function(map) {
            this._map = map;
          },
          enable: function() {
            if (this._enabled) {
              return this;
            }
            this._enabled = true;
            this.addHooks();
            return this;
          },
          disable: function() {
            if (!this._enabled) {
              return this;
            }
            this._enabled = false;
            this.removeHooks();
            return this;
          },
          enabled: function() {
            return !!this._enabled;
          }
        });
        Handler.addTo = function(map, name) {
          map.addHandler(name, this);
          return this;
        };
        var Mixin = { Events };
        var START = Browser.touch ? "touchstart mousedown" : "mousedown";
        var Draggable = Evented.extend({
          options: {
            clickTolerance: 3
          },
          initialize: function(element, dragStartTarget, preventOutline2, options) {
            setOptions(this, options);
            this._element = element;
            this._dragStartTarget = dragStartTarget || element;
            this._preventOutline = preventOutline2;
          },
          enable: function() {
            if (this._enabled) {
              return;
            }
            on(this._dragStartTarget, START, this._onDown, this);
            this._enabled = true;
          },
          disable: function() {
            if (!this._enabled) {
              return;
            }
            if (Draggable._dragging === this) {
              this.finishDrag(true);
            }
            off(this._dragStartTarget, START, this._onDown, this);
            this._enabled = false;
            this._moved = false;
          },
          _onDown: function(e) {
            if (!this._enabled) {
              return;
            }
            this._moved = false;
            if (hasClass(this._element, "leaflet-zoom-anim")) {
              return;
            }
            if (e.touches && e.touches.length !== 1) {
              if (Draggable._dragging === this) {
                this.finishDrag();
              }
              return;
            }
            if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {
              return;
            }
            Draggable._dragging = this;
            if (this._preventOutline) {
              preventOutline(this._element);
            }
            disableImageDrag();
            disableTextSelection();
            if (this._moving) {
              return;
            }
            this.fire("down");
            var first = e.touches ? e.touches[0] : e, sizedParent = getSizedParentNode(this._element);
            this._startPoint = new Point(first.clientX, first.clientY);
            this._startPos = getPosition(this._element);
            this._parentScale = getScale(sizedParent);
            var mouseevent = e.type === "mousedown";
            on(document, mouseevent ? "mousemove" : "touchmove", this._onMove, this);
            on(document, mouseevent ? "mouseup" : "touchend touchcancel", this._onUp, this);
          },
          _onMove: function(e) {
            if (!this._enabled) {
              return;
            }
            if (e.touches && e.touches.length > 1) {
              this._moved = true;
              return;
            }
            var first = e.touches && e.touches.length === 1 ? e.touches[0] : e, offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);
            if (!offset.x && !offset.y) {
              return;
            }
            if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {
              return;
            }
            offset.x /= this._parentScale.x;
            offset.y /= this._parentScale.y;
            preventDefault(e);
            if (!this._moved) {
              this.fire("dragstart");
              this._moved = true;
              addClass(document.body, "leaflet-dragging");
              this._lastTarget = e.target || e.srcElement;
              if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {
                this._lastTarget = this._lastTarget.correspondingUseElement;
              }
              addClass(this._lastTarget, "leaflet-drag-target");
            }
            this._newPos = this._startPos.add(offset);
            this._moving = true;
            this._lastEvent = e;
            this._updatePosition();
          },
          _updatePosition: function() {
            var e = { originalEvent: this._lastEvent };
            this.fire("predrag", e);
            setPosition(this._element, this._newPos);
            this.fire("drag", e);
          },
          _onUp: function() {
            if (!this._enabled) {
              return;
            }
            this.finishDrag();
          },
          finishDrag: function(noInertia) {
            removeClass(document.body, "leaflet-dragging");
            if (this._lastTarget) {
              removeClass(this._lastTarget, "leaflet-drag-target");
              this._lastTarget = null;
            }
            off(document, "mousemove touchmove", this._onMove, this);
            off(document, "mouseup touchend touchcancel", this._onUp, this);
            enableImageDrag();
            enableTextSelection();
            if (this._moved && this._moving) {
              this.fire("dragend", {
                noInertia,
                distance: this._newPos.distanceTo(this._startPos)
              });
            }
            this._moving = false;
            Draggable._dragging = false;
          }
        });
        function simplify(points, tolerance) {
          if (!tolerance || !points.length) {
            return points.slice();
          }
          var sqTolerance = tolerance * tolerance;
          points = _reducePoints(points, sqTolerance);
          points = _simplifyDP(points, sqTolerance);
          return points;
        }
        function pointToSegmentDistance(p, p1, p2) {
          return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
        }
        function closestPointOnSegment(p, p1, p2) {
          return _sqClosestPointOnSegment(p, p1, p2);
        }
        function _simplifyDP(points, sqTolerance) {
          var len = points.length, ArrayConstructor = typeof Uint8Array !== void 0 + "" ? Uint8Array : Array, markers = new ArrayConstructor(len);
          markers[0] = markers[len - 1] = 1;
          _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);
          var i, newPoints = [];
          for (i = 0; i < len; i++) {
            if (markers[i]) {
              newPoints.push(points[i]);
            }
          }
          return newPoints;
        }
        function _simplifyDPStep(points, markers, sqTolerance, first, last) {
          var maxSqDist = 0, index2, i, sqDist;
          for (i = first + 1; i <= last - 1; i++) {
            sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);
            if (sqDist > maxSqDist) {
              index2 = i;
              maxSqDist = sqDist;
            }
          }
          if (maxSqDist > sqTolerance) {
            markers[index2] = 1;
            _simplifyDPStep(points, markers, sqTolerance, first, index2);
            _simplifyDPStep(points, markers, sqTolerance, index2, last);
          }
        }
        function _reducePoints(points, sqTolerance) {
          var reducedPoints = [points[0]];
          for (var i = 1, prev = 0, len = points.length; i < len; i++) {
            if (_sqDist(points[i], points[prev]) > sqTolerance) {
              reducedPoints.push(points[i]);
              prev = i;
            }
          }
          if (prev < len - 1) {
            reducedPoints.push(points[len - 1]);
          }
          return reducedPoints;
        }
        var _lastCode;
        function clipSegment(a, b, bounds, useLastCode, round) {
          var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds), codeB = _getBitCode(b, bounds), codeOut, p, newCode;
          _lastCode = codeB;
          while (true) {
            if (!(codeA | codeB)) {
              return [a, b];
            }
            if (codeA & codeB) {
              return false;
            }
            codeOut = codeA || codeB;
            p = _getEdgeIntersection(a, b, codeOut, bounds, round);
            newCode = _getBitCode(p, bounds);
            if (codeOut === codeA) {
              a = p;
              codeA = newCode;
            } else {
              b = p;
              codeB = newCode;
            }
          }
        }
        function _getEdgeIntersection(a, b, code, bounds, round) {
          var dx = b.x - a.x, dy = b.y - a.y, min = bounds.min, max = bounds.max, x, y;
          if (code & 8) {
            x = a.x + dx * (max.y - a.y) / dy;
            y = max.y;
          } else if (code & 4) {
            x = a.x + dx * (min.y - a.y) / dy;
            y = min.y;
          } else if (code & 2) {
            x = max.x;
            y = a.y + dy * (max.x - a.x) / dx;
          } else if (code & 1) {
            x = min.x;
            y = a.y + dy * (min.x - a.x) / dx;
          }
          return new Point(x, y, round);
        }
        function _getBitCode(p, bounds) {
          var code = 0;
          if (p.x < bounds.min.x) {
            code |= 1;
          } else if (p.x > bounds.max.x) {
            code |= 2;
          }
          if (p.y < bounds.min.y) {
            code |= 4;
          } else if (p.y > bounds.max.y) {
            code |= 8;
          }
          return code;
        }
        function _sqDist(p1, p2) {
          var dx = p2.x - p1.x, dy = p2.y - p1.y;
          return dx * dx + dy * dy;
        }
        function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
          var x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y, dot = dx * dx + dy * dy, t;
          if (dot > 0) {
            t = ((p.x - x) * dx + (p.y - y) * dy) / dot;
            if (t > 1) {
              x = p2.x;
              y = p2.y;
            } else if (t > 0) {
              x += dx * t;
              y += dy * t;
            }
          }
          dx = p.x - x;
          dy = p.y - y;
          return sqDist ? dx * dx + dy * dy : new Point(x, y);
        }
        function isFlat(latlngs) {
          return !isArray(latlngs[0]) || typeof latlngs[0][0] !== "object" && typeof latlngs[0][0] !== "undefined";
        }
        function _flat(latlngs) {
          console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead.");
          return isFlat(latlngs);
        }
        var LineUtil = {
          __proto__: null,
          simplify,
          pointToSegmentDistance,
          closestPointOnSegment,
          clipSegment,
          _getEdgeIntersection,
          _getBitCode,
          _sqClosestPointOnSegment,
          isFlat,
          _flat
        };
        function clipPolygon(points, bounds, round) {
          var clippedPoints, edges = [1, 4, 2, 8], i, j, k, a, b, len, edge2, p;
          for (i = 0, len = points.length; i < len; i++) {
            points[i]._code = _getBitCode(points[i], bounds);
          }
          for (k = 0; k < 4; k++) {
            edge2 = edges[k];
            clippedPoints = [];
            for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
              a = points[i];
              b = points[j];
              if (!(a._code & edge2)) {
                if (b._code & edge2) {
                  p = _getEdgeIntersection(b, a, edge2, bounds, round);
                  p._code = _getBitCode(p, bounds);
                  clippedPoints.push(p);
                }
                clippedPoints.push(a);
              } else if (!(b._code & edge2)) {
                p = _getEdgeIntersection(b, a, edge2, bounds, round);
                p._code = _getBitCode(p, bounds);
                clippedPoints.push(p);
              }
            }
            points = clippedPoints;
          }
          return points;
        }
        var PolyUtil = {
          __proto__: null,
          clipPolygon
        };
        var LonLat = {
          project: function(latlng) {
            return new Point(latlng.lng, latlng.lat);
          },
          unproject: function(point) {
            return new LatLng(point.y, point.x);
          },
          bounds: new Bounds([-180, -90], [180, 90])
        };
        var Mercator = {
          R: 6378137,
          R_MINOR: 6356752314245179e-9,
          bounds: new Bounds([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]),
          project: function(latlng) {
            var d = Math.PI / 180, r = this.R, y = latlng.lat * d, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), con = e * Math.sin(y);
            var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
            y = -r * Math.log(Math.max(ts, 1e-10));
            return new Point(latlng.lng * d * r, y);
          },
          unproject: function(point) {
            var d = 180 / Math.PI, r = this.R, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-point.y / r), phi = Math.PI / 2 - 2 * Math.atan(ts);
            for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
              con = e * Math.sin(phi);
              con = Math.pow((1 - con) / (1 + con), e / 2);
              dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
              phi += dphi;
            }
            return new LatLng(phi * d, point.x * d / r);
          }
        };
        var index = {
          __proto__: null,
          LonLat,
          Mercator,
          SphericalMercator
        };
        var EPSG3395 = extend({}, Earth, {
          code: "EPSG:3395",
          projection: Mercator,
          transformation: function() {
            var scale2 = 0.5 / (Math.PI * Mercator.R);
            return toTransformation(scale2, 0.5, -scale2, 0.5);
          }()
        });
        var EPSG4326 = extend({}, Earth, {
          code: "EPSG:4326",
          projection: LonLat,
          transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
        });
        var Simple = extend({}, CRS, {
          projection: LonLat,
          transformation: toTransformation(1, 0, -1, 0),
          scale: function(zoom2) {
            return Math.pow(2, zoom2);
          },
          zoom: function(scale2) {
            return Math.log(scale2) / Math.LN2;
          },
          distance: function(latlng1, latlng2) {
            var dx = latlng2.lng - latlng1.lng, dy = latlng2.lat - latlng1.lat;
            return Math.sqrt(dx * dx + dy * dy);
          },
          infinite: true
        });
        CRS.Earth = Earth;
        CRS.EPSG3395 = EPSG3395;
        CRS.EPSG3857 = EPSG3857;
        CRS.EPSG900913 = EPSG900913;
        CRS.EPSG4326 = EPSG4326;
        CRS.Simple = Simple;
        var Layer = Evented.extend({
          options: {
            pane: "overlayPane",
            attribution: null,
            bubblingMouseEvents: true
          },
          addTo: function(map) {
            map.addLayer(this);
            return this;
          },
          remove: function() {
            return this.removeFrom(this._map || this._mapToAdd);
          },
          removeFrom: function(obj) {
            if (obj) {
              obj.removeLayer(this);
            }
            return this;
          },
          getPane: function(name) {
            return this._map.getPane(name ? this.options[name] || name : this.options.pane);
          },
          addInteractiveTarget: function(targetEl) {
            this._map._targets[stamp(targetEl)] = this;
            return this;
          },
          removeInteractiveTarget: function(targetEl) {
            delete this._map._targets[stamp(targetEl)];
            return this;
          },
          getAttribution: function() {
            return this.options.attribution;
          },
          _layerAdd: function(e) {
            var map = e.target;
            if (!map.hasLayer(this)) {
              return;
            }
            this._map = map;
            this._zoomAnimated = map._zoomAnimated;
            if (this.getEvents) {
              var events = this.getEvents();
              map.on(events, this);
              this.once("remove", function() {
                map.off(events, this);
              }, this);
            }
            this.onAdd(map);
            this.fire("add");
            map.fire("layeradd", { layer: this });
          }
        });
        Map2.include({
          addLayer: function(layer) {
            if (!layer._layerAdd) {
              throw new Error("The provided object is not a Layer.");
            }
            var id = stamp(layer);
            if (this._layers[id]) {
              return this;
            }
            this._layers[id] = layer;
            layer._mapToAdd = this;
            if (layer.beforeAdd) {
              layer.beforeAdd(this);
            }
            this.whenReady(layer._layerAdd, layer);
            return this;
          },
          removeLayer: function(layer) {
            var id = stamp(layer);
            if (!this._layers[id]) {
              return this;
            }
            if (this._loaded) {
              layer.onRemove(this);
            }
            delete this._layers[id];
            if (this._loaded) {
              this.fire("layerremove", { layer });
              layer.fire("remove");
            }
            layer._map = layer._mapToAdd = null;
            return this;
          },
          hasLayer: function(layer) {
            return stamp(layer) in this._layers;
          },
          eachLayer: function(method, context) {
            for (var i in this._layers) {
              method.call(context, this._layers[i]);
            }
            return this;
          },
          _addLayers: function(layers2) {
            layers2 = layers2 ? isArray(layers2) ? layers2 : [layers2] : [];
            for (var i = 0, len = layers2.length; i < len; i++) {
              this.addLayer(layers2[i]);
            }
          },
          _addZoomLimit: function(layer) {
            if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
              this._zoomBoundLayers[stamp(layer)] = layer;
              this._updateZoomLevels();
            }
          },
          _removeZoomLimit: function(layer) {
            var id = stamp(layer);
            if (this._zoomBoundLayers[id]) {
              delete this._zoomBoundLayers[id];
              this._updateZoomLevels();
            }
          },
          _updateZoomLevels: function() {
            var minZoom = Infinity, maxZoom = -Infinity, oldZoomSpan = this._getZoomSpan();
            for (var i in this._zoomBoundLayers) {
              var options = this._zoomBoundLayers[i].options;
              minZoom = options.minZoom === void 0 ? minZoom : Math.min(minZoom, options.minZoom);
              maxZoom = options.maxZoom === void 0 ? maxZoom : Math.max(maxZoom, options.maxZoom);
            }
            this._layersMaxZoom = maxZoom === -Infinity ? void 0 : maxZoom;
            this._layersMinZoom = minZoom === Infinity ? void 0 : minZoom;
            if (oldZoomSpan !== this._getZoomSpan()) {
              this.fire("zoomlevelschange");
            }
            if (this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
              this.setZoom(this._layersMaxZoom);
            }
            if (this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
              this.setZoom(this._layersMinZoom);
            }
          }
        });
        var LayerGroup = Layer.extend({
          initialize: function(layers2, options) {
            setOptions(this, options);
            this._layers = {};
            var i, len;
            if (layers2) {
              for (i = 0, len = layers2.length; i < len; i++) {
                this.addLayer(layers2[i]);
              }
            }
          },
          addLayer: function(layer) {
            var id = this.getLayerId(layer);
            this._layers[id] = layer;
            if (this._map) {
              this._map.addLayer(layer);
            }
            return this;
          },
          removeLayer: function(layer) {
            var id = layer in this._layers ? layer : this.getLayerId(layer);
            if (this._map && this._layers[id]) {
              this._map.removeLayer(this._layers[id]);
            }
            delete this._layers[id];
            return this;
          },
          hasLayer: function(layer) {
            var layerId = typeof layer === "number" ? layer : this.getLayerId(layer);
            return layerId in this._layers;
          },
          clearLayers: function() {
            return this.eachLayer(this.removeLayer, this);
          },
          invoke: function(methodName) {
            var args = Array.prototype.slice.call(arguments, 1), i, layer;
            for (i in this._layers) {
              layer = this._layers[i];
              if (layer[methodName]) {
                layer[methodName].apply(layer, args);
              }
            }
            return this;
          },
          onAdd: function(map) {
            this.eachLayer(map.addLayer, map);
          },
          onRemove: function(map) {
            this.eachLayer(map.removeLayer, map);
          },
          eachLayer: function(method, context) {
            for (var i in this._layers) {
              method.call(context, this._layers[i]);
            }
            return this;
          },
          getLayer: function(id) {
            return this._layers[id];
          },
          getLayers: function() {
            var layers2 = [];
            this.eachLayer(layers2.push, layers2);
            return layers2;
          },
          setZIndex: function(zIndex) {
            return this.invoke("setZIndex", zIndex);
          },
          getLayerId: function(layer) {
            return stamp(layer);
          }
        });
        var layerGroup = function(layers2, options) {
          return new LayerGroup(layers2, options);
        };
        var FeatureGroup = LayerGroup.extend({
          addLayer: function(layer) {
            if (this.hasLayer(layer)) {
              return this;
            }
            layer.addEventParent(this);
            LayerGroup.prototype.addLayer.call(this, layer);
            return this.fire("layeradd", { layer });
          },
          removeLayer: function(layer) {
            if (!this.hasLayer(layer)) {
              return this;
            }
            if (layer in this._layers) {
              layer = this._layers[layer];
            }
            layer.removeEventParent(this);
            LayerGroup.prototype.removeLayer.call(this, layer);
            return this.fire("layerremove", { layer });
          },
          setStyle: function(style2) {
            return this.invoke("setStyle", style2);
          },
          bringToFront: function() {
            return this.invoke("bringToFront");
          },
          bringToBack: function() {
            return this.invoke("bringToBack");
          },
          getBounds: function() {
            var bounds = new LatLngBounds();
            for (var id in this._layers) {
              var layer = this._layers[id];
              bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
            }
            return bounds;
          }
        });
        var featureGroup = function(layers2, options) {
          return new FeatureGroup(layers2, options);
        };
        var Icon = Class.extend({
          options: {
            popupAnchor: [0, 0],
            tooltipAnchor: [0, 0],
            crossOrigin: false
          },
          initialize: function(options) {
            setOptions(this, options);
          },
          createIcon: function(oldIcon) {
            return this._createIcon("icon", oldIcon);
          },
          createShadow: function(oldIcon) {
            return this._createIcon("shadow", oldIcon);
          },
          _createIcon: function(name, oldIcon) {
            var src = this._getIconUrl(name);
            if (!src) {
              if (name === "icon") {
                throw new Error("iconUrl not set in Icon options (see the docs).");
              }
              return null;
            }
            var img = this._createImg(src, oldIcon && oldIcon.tagName === "IMG" ? oldIcon : null);
            this._setIconStyles(img, name);
            if (this.options.crossOrigin || this.options.crossOrigin === "") {
              img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
            }
            return img;
          },
          _setIconStyles: function(img, name) {
            var options = this.options;
            var sizeOption = options[name + "Size"];
            if (typeof sizeOption === "number") {
              sizeOption = [sizeOption, sizeOption];
            }
            var size = toPoint(sizeOption), anchor = toPoint(name === "shadow" && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));
            img.className = "leaflet-marker-" + name + " " + (options.className || "");
            if (anchor) {
              img.style.marginLeft = -anchor.x + "px";
              img.style.marginTop = -anchor.y + "px";
            }
            if (size) {
              img.style.width = size.x + "px";
              img.style.height = size.y + "px";
            }
          },
          _createImg: function(src, el) {
            el = el || document.createElement("img");
            el.src = src;
            return el;
          },
          _getIconUrl: function(name) {
            return Browser.retina && this.options[name + "RetinaUrl"] || this.options[name + "Url"];
          }
        });
        function icon(options) {
          return new Icon(options);
        }
        var IconDefault = Icon.extend({
          options: {
            iconUrl: "marker-icon.png",
            iconRetinaUrl: "marker-icon-2x.png",
            shadowUrl: "marker-shadow.png",
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            tooltipAnchor: [16, -28],
            shadowSize: [41, 41]
          },
          _getIconUrl: function(name) {
            if (typeof IconDefault.imagePath !== "string") {
              IconDefault.imagePath = this._detectIconPath();
            }
            return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
          },
          _stripUrl: function(path) {
            var strip = function(str, re, idx) {
              var match = re.exec(str);
              return match && match[idx];
            };
            path = strip(path, /^url\((['"])?(.+)\1\)$/, 2);
            return path && strip(path, /^(.*)marker-icon\.png$/, 1);
          },
          _detectIconPath: function() {
            var el = create$1("div", "leaflet-default-icon-path", document.body);
            var path = getStyle(el, "background-image") || getStyle(el, "backgroundImage");
            document.body.removeChild(el);
            path = this._stripUrl(path);
            if (path) {
              return path;
            }
            var link = document.querySelector('link[href$="leaflet.css"]');
            if (!link) {
              return "";
            }
            return link.href.substring(0, link.href.length - "leaflet.css".length - 1);
          }
        });
        var MarkerDrag = Handler.extend({
          initialize: function(marker2) {
            this._marker = marker2;
          },
          addHooks: function() {
            var icon2 = this._marker._icon;
            if (!this._draggable) {
              this._draggable = new Draggable(icon2, icon2, true);
            }
            this._draggable.on({
              dragstart: this._onDragStart,
              predrag: this._onPreDrag,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this).enable();
            addClass(icon2, "leaflet-marker-draggable");
          },
          removeHooks: function() {
            this._draggable.off({
              dragstart: this._onDragStart,
              predrag: this._onPreDrag,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this).disable();
            if (this._marker._icon) {
              removeClass(this._marker._icon, "leaflet-marker-draggable");
            }
          },
          moved: function() {
            return this._draggable && this._draggable._moved;
          },
          _adjustPan: function(e) {
            var marker2 = this._marker, map = marker2._map, speed = this._marker.options.autoPanSpeed, padding = this._marker.options.autoPanPadding, iconPos = getPosition(marker2._icon), bounds = map.getPixelBounds(), origin = map.getPixelOrigin();
            var panBounds = toBounds(
              bounds.min._subtract(origin).add(padding),
              bounds.max._subtract(origin).subtract(padding)
            );
            if (!panBounds.contains(iconPos)) {
              var movement = toPoint(
                (Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),
                (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)
              ).multiplyBy(speed);
              map.panBy(movement, { animate: false });
              this._draggable._newPos._add(movement);
              this._draggable._startPos._add(movement);
              setPosition(marker2._icon, this._draggable._newPos);
              this._onDrag(e);
              this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
            }
          },
          _onDragStart: function() {
            this._oldLatLng = this._marker.getLatLng();
            this._marker.closePopup && this._marker.closePopup();
            this._marker.fire("movestart").fire("dragstart");
          },
          _onPreDrag: function(e) {
            if (this._marker.options.autoPan) {
              cancelAnimFrame(this._panRequest);
              this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
            }
          },
          _onDrag: function(e) {
            var marker2 = this._marker, shadow = marker2._shadow, iconPos = getPosition(marker2._icon), latlng = marker2._map.layerPointToLatLng(iconPos);
            if (shadow) {
              setPosition(shadow, iconPos);
            }
            marker2._latlng = latlng;
            e.latlng = latlng;
            e.oldLatLng = this._oldLatLng;
            marker2.fire("move", e).fire("drag", e);
          },
          _onDragEnd: function(e) {
            cancelAnimFrame(this._panRequest);
            delete this._oldLatLng;
            this._marker.fire("moveend").fire("dragend", e);
          }
        });
        var Marker = Layer.extend({
          options: {
            icon: new IconDefault(),
            interactive: true,
            keyboard: true,
            title: "",
            alt: "Marker",
            zIndexOffset: 0,
            opacity: 1,
            riseOnHover: false,
            riseOffset: 250,
            pane: "markerPane",
            shadowPane: "shadowPane",
            bubblingMouseEvents: false,
            autoPanOnFocus: true,
            draggable: false,
            autoPan: false,
            autoPanPadding: [50, 50],
            autoPanSpeed: 10
          },
          initialize: function(latlng, options) {
            setOptions(this, options);
            this._latlng = toLatLng(latlng);
          },
          onAdd: function(map) {
            this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;
            if (this._zoomAnimated) {
              map.on("zoomanim", this._animateZoom, this);
            }
            this._initIcon();
            this.update();
          },
          onRemove: function(map) {
            if (this.dragging && this.dragging.enabled()) {
              this.options.draggable = true;
              this.dragging.removeHooks();
            }
            delete this.dragging;
            if (this._zoomAnimated) {
              map.off("zoomanim", this._animateZoom, this);
            }
            this._removeIcon();
            this._removeShadow();
          },
          getEvents: function() {
            return {
              zoom: this.update,
              viewreset: this.update
            };
          },
          getLatLng: function() {
            return this._latlng;
          },
          setLatLng: function(latlng) {
            var oldLatLng = this._latlng;
            this._latlng = toLatLng(latlng);
            this.update();
            return this.fire("move", { oldLatLng, latlng: this._latlng });
          },
          setZIndexOffset: function(offset) {
            this.options.zIndexOffset = offset;
            return this.update();
          },
          getIcon: function() {
            return this.options.icon;
          },
          setIcon: function(icon2) {
            this.options.icon = icon2;
            if (this._map) {
              this._initIcon();
              this.update();
            }
            if (this._popup) {
              this.bindPopup(this._popup, this._popup.options);
            }
            return this;
          },
          getElement: function() {
            return this._icon;
          },
          update: function() {
            if (this._icon && this._map) {
              var pos = this._map.latLngToLayerPoint(this._latlng).round();
              this._setPos(pos);
            }
            return this;
          },
          _initIcon: function() {
            var options = this.options, classToAdd = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
            var icon2 = options.icon.createIcon(this._icon), addIcon = false;
            if (icon2 !== this._icon) {
              if (this._icon) {
                this._removeIcon();
              }
              addIcon = true;
              if (options.title) {
                icon2.title = options.title;
              }
              if (icon2.tagName === "IMG") {
                icon2.alt = options.alt || "";
              }
            }
            addClass(icon2, classToAdd);
            if (options.keyboard) {
              icon2.tabIndex = "0";
              icon2.setAttribute("role", "button");
            }
            this._icon = icon2;
            if (options.riseOnHover) {
              this.on({
                mouseover: this._bringToFront,
                mouseout: this._resetZIndex
              });
            }
            if (this.options.autoPanOnFocus) {
              on(icon2, "focus", this._panOnFocus, this);
            }
            var newShadow = options.icon.createShadow(this._shadow), addShadow = false;
            if (newShadow !== this._shadow) {
              this._removeShadow();
              addShadow = true;
            }
            if (newShadow) {
              addClass(newShadow, classToAdd);
              newShadow.alt = "";
            }
            this._shadow = newShadow;
            if (options.opacity < 1) {
              this._updateOpacity();
            }
            if (addIcon) {
              this.getPane().appendChild(this._icon);
            }
            this._initInteraction();
            if (newShadow && addShadow) {
              this.getPane(options.shadowPane).appendChild(this._shadow);
            }
          },
          _removeIcon: function() {
            if (this.options.riseOnHover) {
              this.off({
                mouseover: this._bringToFront,
                mouseout: this._resetZIndex
              });
            }
            if (this.options.autoPanOnFocus) {
              off(this._icon, "focus", this._panOnFocus, this);
            }
            remove(this._icon);
            this.removeInteractiveTarget(this._icon);
            this._icon = null;
          },
          _removeShadow: function() {
            if (this._shadow) {
              remove(this._shadow);
            }
            this._shadow = null;
          },
          _setPos: function(pos) {
            if (this._icon) {
              setPosition(this._icon, pos);
            }
            if (this._shadow) {
              setPosition(this._shadow, pos);
            }
            this._zIndex = pos.y + this.options.zIndexOffset;
            this._resetZIndex();
          },
          _updateZIndex: function(offset) {
            if (this._icon) {
              this._icon.style.zIndex = this._zIndex + offset;
            }
          },
          _animateZoom: function(opt) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
            this._setPos(pos);
          },
          _initInteraction: function() {
            if (!this.options.interactive) {
              return;
            }
            addClass(this._icon, "leaflet-interactive");
            this.addInteractiveTarget(this._icon);
            if (MarkerDrag) {
              var draggable = this.options.draggable;
              if (this.dragging) {
                draggable = this.dragging.enabled();
                this.dragging.disable();
              }
              this.dragging = new MarkerDrag(this);
              if (draggable) {
                this.dragging.enable();
              }
            }
          },
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._map) {
              this._updateOpacity();
            }
            return this;
          },
          _updateOpacity: function() {
            var opacity = this.options.opacity;
            if (this._icon) {
              setOpacity(this._icon, opacity);
            }
            if (this._shadow) {
              setOpacity(this._shadow, opacity);
            }
          },
          _bringToFront: function() {
            this._updateZIndex(this.options.riseOffset);
          },
          _resetZIndex: function() {
            this._updateZIndex(0);
          },
          _panOnFocus: function() {
            var map = this._map;
            if (!map) {
              return;
            }
            var iconOpts = this.options.icon.options;
            var size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);
            var anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);
            map.panInside(this._latlng, {
              paddingTopLeft: anchor,
              paddingBottomRight: size.subtract(anchor)
            });
          },
          _getPopupAnchor: function() {
            return this.options.icon.options.popupAnchor;
          },
          _getTooltipAnchor: function() {
            return this.options.icon.options.tooltipAnchor;
          }
        });
        function marker(latlng, options) {
          return new Marker(latlng, options);
        }
        var Path = Layer.extend({
          options: {
            stroke: true,
            color: "#3388ff",
            weight: 3,
            opacity: 1,
            lineCap: "round",
            lineJoin: "round",
            dashArray: null,
            dashOffset: null,
            fill: false,
            fillColor: null,
            fillOpacity: 0.2,
            fillRule: "evenodd",
            interactive: true,
            bubblingMouseEvents: true
          },
          beforeAdd: function(map) {
            this._renderer = map.getRenderer(this);
          },
          onAdd: function() {
            this._renderer._initPath(this);
            this._reset();
            this._renderer._addPath(this);
          },
          onRemove: function() {
            this._renderer._removePath(this);
          },
          redraw: function() {
            if (this._map) {
              this._renderer._updatePath(this);
            }
            return this;
          },
          setStyle: function(style2) {
            setOptions(this, style2);
            if (this._renderer) {
              this._renderer._updateStyle(this);
              if (this.options.stroke && style2 && Object.prototype.hasOwnProperty.call(style2, "weight")) {
                this._updateBounds();
              }
            }
            return this;
          },
          bringToFront: function() {
            if (this._renderer) {
              this._renderer._bringToFront(this);
            }
            return this;
          },
          bringToBack: function() {
            if (this._renderer) {
              this._renderer._bringToBack(this);
            }
            return this;
          },
          getElement: function() {
            return this._path;
          },
          _reset: function() {
            this._project();
            this._update();
          },
          _clickTolerance: function() {
            return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
          }
        });
        var CircleMarker = Path.extend({
          options: {
            fill: true,
            radius: 10
          },
          initialize: function(latlng, options) {
            setOptions(this, options);
            this._latlng = toLatLng(latlng);
            this._radius = this.options.radius;
          },
          setLatLng: function(latlng) {
            var oldLatLng = this._latlng;
            this._latlng = toLatLng(latlng);
            this.redraw();
            return this.fire("move", { oldLatLng, latlng: this._latlng });
          },
          getLatLng: function() {
            return this._latlng;
          },
          setRadius: function(radius) {
            this.options.radius = this._radius = radius;
            return this.redraw();
          },
          getRadius: function() {
            return this._radius;
          },
          setStyle: function(options) {
            var radius = options && options.radius || this._radius;
            Path.prototype.setStyle.call(this, options);
            this.setRadius(radius);
            return this;
          },
          _project: function() {
            this._point = this._map.latLngToLayerPoint(this._latlng);
            this._updateBounds();
          },
          _updateBounds: function() {
            var r = this._radius, r2 = this._radiusY || r, w = this._clickTolerance(), p = [r + w, r2 + w];
            this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
          },
          _update: function() {
            if (this._map) {
              this._updatePath();
            }
          },
          _updatePath: function() {
            this._renderer._updateCircle(this);
          },
          _empty: function() {
            return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
          },
          _containsPoint: function(p) {
            return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
          }
        });
        function circleMarker(latlng, options) {
          return new CircleMarker(latlng, options);
        }
        var Circle = CircleMarker.extend({
          initialize: function(latlng, options, legacyOptions) {
            if (typeof options === "number") {
              options = extend({}, legacyOptions, { radius: options });
            }
            setOptions(this, options);
            this._latlng = toLatLng(latlng);
            if (isNaN(this.options.radius)) {
              throw new Error("Circle radius cannot be NaN");
            }
            this._mRadius = this.options.radius;
          },
          setRadius: function(radius) {
            this._mRadius = radius;
            return this.redraw();
          },
          getRadius: function() {
            return this._mRadius;
          },
          getBounds: function() {
            var half = [this._radius, this._radiusY || this._radius];
            return new LatLngBounds(
              this._map.layerPointToLatLng(this._point.subtract(half)),
              this._map.layerPointToLatLng(this._point.add(half))
            );
          },
          setStyle: Path.prototype.setStyle,
          _project: function() {
            var lng = this._latlng.lng, lat = this._latlng.lat, map = this._map, crs = map.options.crs;
            if (crs.distance === Earth.distance) {
              var d = Math.PI / 180, latR = this._mRadius / Earth.R / d, top = map.project([lat + latR, lng]), bottom = map.project([lat - latR, lng]), p = top.add(bottom).divideBy(2), lat2 = map.unproject(p).lat, lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;
              if (isNaN(lngR) || lngR === 0) {
                lngR = latR / Math.cos(Math.PI / 180 * lat);
              }
              this._point = p.subtract(map.getPixelOrigin());
              this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;
              this._radiusY = p.y - top.y;
            } else {
              var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));
              this._point = map.latLngToLayerPoint(this._latlng);
              this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
            }
            this._updateBounds();
          }
        });
        function circle(latlng, options, legacyOptions) {
          return new Circle(latlng, options, legacyOptions);
        }
        var Polyline = Path.extend({
          options: {
            smoothFactor: 1,
            noClip: false
          },
          initialize: function(latlngs, options) {
            setOptions(this, options);
            this._setLatLngs(latlngs);
          },
          getLatLngs: function() {
            return this._latlngs;
          },
          setLatLngs: function(latlngs) {
            this._setLatLngs(latlngs);
            return this.redraw();
          },
          isEmpty: function() {
            return !this._latlngs.length;
          },
          closestLayerPoint: function(p) {
            var minDistance = Infinity, minPoint = null, closest = _sqClosestPointOnSegment, p1, p2;
            for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
              var points = this._parts[j];
              for (var i = 1, len = points.length; i < len; i++) {
                p1 = points[i - 1];
                p2 = points[i];
                var sqDist = closest(p, p1, p2, true);
                if (sqDist < minDistance) {
                  minDistance = sqDist;
                  minPoint = closest(p, p1, p2);
                }
              }
            }
            if (minPoint) {
              minPoint.distance = Math.sqrt(minDistance);
            }
            return minPoint;
          },
          getCenter: function() {
            if (!this._map) {
              throw new Error("Must add layer to map before using getCenter()");
            }
            var i, halfDist, segDist, dist, p1, p2, ratio, points = this._rings[0], len = points.length;
            if (!len) {
              return null;
            }
            for (i = 0, halfDist = 0; i < len - 1; i++) {
              halfDist += points[i].distanceTo(points[i + 1]) / 2;
            }
            if (halfDist === 0) {
              return this._map.layerPointToLatLng(points[0]);
            }
            for (i = 0, dist = 0; i < len - 1; i++) {
              p1 = points[i];
              p2 = points[i + 1];
              segDist = p1.distanceTo(p2);
              dist += segDist;
              if (dist > halfDist) {
                ratio = (dist - halfDist) / segDist;
                return this._map.layerPointToLatLng([
                  p2.x - ratio * (p2.x - p1.x),
                  p2.y - ratio * (p2.y - p1.y)
                ]);
              }
            }
          },
          getBounds: function() {
            return this._bounds;
          },
          addLatLng: function(latlng, latlngs) {
            latlngs = latlngs || this._defaultShape();
            latlng = toLatLng(latlng);
            latlngs.push(latlng);
            this._bounds.extend(latlng);
            return this.redraw();
          },
          _setLatLngs: function(latlngs) {
            this._bounds = new LatLngBounds();
            this._latlngs = this._convertLatLngs(latlngs);
          },
          _defaultShape: function() {
            return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
          },
          _convertLatLngs: function(latlngs) {
            var result = [], flat = isFlat(latlngs);
            for (var i = 0, len = latlngs.length; i < len; i++) {
              if (flat) {
                result[i] = toLatLng(latlngs[i]);
                this._bounds.extend(result[i]);
              } else {
                result[i] = this._convertLatLngs(latlngs[i]);
              }
            }
            return result;
          },
          _project: function() {
            var pxBounds = new Bounds();
            this._rings = [];
            this._projectLatlngs(this._latlngs, this._rings, pxBounds);
            if (this._bounds.isValid() && pxBounds.isValid()) {
              this._rawPxBounds = pxBounds;
              this._updateBounds();
            }
          },
          _updateBounds: function() {
            var w = this._clickTolerance(), p = new Point(w, w);
            if (!this._rawPxBounds) {
              return;
            }
            this._pxBounds = new Bounds([
              this._rawPxBounds.min.subtract(p),
              this._rawPxBounds.max.add(p)
            ]);
          },
          _projectLatlngs: function(latlngs, result, projectedBounds) {
            var flat = latlngs[0] instanceof LatLng, len = latlngs.length, i, ring;
            if (flat) {
              ring = [];
              for (i = 0; i < len; i++) {
                ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
                projectedBounds.extend(ring[i]);
              }
              result.push(ring);
            } else {
              for (i = 0; i < len; i++) {
                this._projectLatlngs(latlngs[i], result, projectedBounds);
              }
            }
          },
          _clipPoints: function() {
            var bounds = this._renderer._bounds;
            this._parts = [];
            if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
              return;
            }
            if (this.options.noClip) {
              this._parts = this._rings;
              return;
            }
            var parts = this._parts, i, j, k, len, len2, segment, points;
            for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
              points = this._rings[i];
              for (j = 0, len2 = points.length; j < len2 - 1; j++) {
                segment = clipSegment(points[j], points[j + 1], bounds, j, true);
                if (!segment) {
                  continue;
                }
                parts[k] = parts[k] || [];
                parts[k].push(segment[0]);
                if (segment[1] !== points[j + 1] || j === len2 - 2) {
                  parts[k].push(segment[1]);
                  k++;
                }
              }
            }
          },
          _simplifyPoints: function() {
            var parts = this._parts, tolerance = this.options.smoothFactor;
            for (var i = 0, len = parts.length; i < len; i++) {
              parts[i] = simplify(parts[i], tolerance);
            }
          },
          _update: function() {
            if (!this._map) {
              return;
            }
            this._clipPoints();
            this._simplifyPoints();
            this._updatePath();
          },
          _updatePath: function() {
            this._renderer._updatePoly(this);
          },
          _containsPoint: function(p, closed) {
            var i, j, k, len, len2, part, w = this._clickTolerance();
            if (!this._pxBounds || !this._pxBounds.contains(p)) {
              return false;
            }
            for (i = 0, len = this._parts.length; i < len; i++) {
              part = this._parts[i];
              for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                if (!closed && j === 0) {
                  continue;
                }
                if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
                  return true;
                }
              }
            }
            return false;
          }
        });
        function polyline(latlngs, options) {
          return new Polyline(latlngs, options);
        }
        Polyline._flat = _flat;
        var Polygon = Polyline.extend({
          options: {
            fill: true
          },
          isEmpty: function() {
            return !this._latlngs.length || !this._latlngs[0].length;
          },
          getCenter: function() {
            if (!this._map) {
              throw new Error("Must add layer to map before using getCenter()");
            }
            var i, j, p1, p2, f, area, x, y, center, points = this._rings[0], len = points.length;
            if (!len) {
              return null;
            }
            area = x = y = 0;
            for (i = 0, j = len - 1; i < len; j = i++) {
              p1 = points[i];
              p2 = points[j];
              f = p1.y * p2.x - p2.y * p1.x;
              x += (p1.x + p2.x) * f;
              y += (p1.y + p2.y) * f;
              area += f * 3;
            }
            if (area === 0) {
              center = points[0];
            } else {
              center = [x / area, y / area];
            }
            return this._map.layerPointToLatLng(center);
          },
          _convertLatLngs: function(latlngs) {
            var result = Polyline.prototype._convertLatLngs.call(this, latlngs), len = result.length;
            if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
              result.pop();
            }
            return result;
          },
          _setLatLngs: function(latlngs) {
            Polyline.prototype._setLatLngs.call(this, latlngs);
            if (isFlat(this._latlngs)) {
              this._latlngs = [this._latlngs];
            }
          },
          _defaultShape: function() {
            return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
          },
          _clipPoints: function() {
            var bounds = this._renderer._bounds, w = this.options.weight, p = new Point(w, w);
            bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));
            this._parts = [];
            if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
              return;
            }
            if (this.options.noClip) {
              this._parts = this._rings;
              return;
            }
            for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
              clipped = clipPolygon(this._rings[i], bounds, true);
              if (clipped.length) {
                this._parts.push(clipped);
              }
            }
          },
          _updatePath: function() {
            this._renderer._updatePoly(this, true);
          },
          _containsPoint: function(p) {
            var inside = false, part, p1, p2, i, j, k, len, len2;
            if (!this._pxBounds || !this._pxBounds.contains(p)) {
              return false;
            }
            for (i = 0, len = this._parts.length; i < len; i++) {
              part = this._parts[i];
              for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                p1 = part[j];
                p2 = part[k];
                if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
                  inside = !inside;
                }
              }
            }
            return inside || Polyline.prototype._containsPoint.call(this, p, true);
          }
        });
        function polygon(latlngs, options) {
          return new Polygon(latlngs, options);
        }
        var GeoJSON = FeatureGroup.extend({
          initialize: function(geojson, options) {
            setOptions(this, options);
            this._layers = {};
            if (geojson) {
              this.addData(geojson);
            }
          },
          addData: function(geojson) {
            var features = isArray(geojson) ? geojson : geojson.features, i, len, feature;
            if (features) {
              for (i = 0, len = features.length; i < len; i++) {
                feature = features[i];
                if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
                  this.addData(feature);
                }
              }
              return this;
            }
            var options = this.options;
            if (options.filter && !options.filter(geojson)) {
              return this;
            }
            var layer = geometryToLayer(geojson, options);
            if (!layer) {
              return this;
            }
            layer.feature = asFeature(geojson);
            layer.defaultOptions = layer.options;
            this.resetStyle(layer);
            if (options.onEachFeature) {
              options.onEachFeature(geojson, layer);
            }
            return this.addLayer(layer);
          },
          resetStyle: function(layer) {
            if (layer === void 0) {
              return this.eachLayer(this.resetStyle, this);
            }
            layer.options = extend({}, layer.defaultOptions);
            this._setLayerStyle(layer, this.options.style);
            return this;
          },
          setStyle: function(style2) {
            return this.eachLayer(function(layer) {
              this._setLayerStyle(layer, style2);
            }, this);
          },
          _setLayerStyle: function(layer, style2) {
            if (layer.setStyle) {
              if (typeof style2 === "function") {
                style2 = style2(layer.feature);
              }
              layer.setStyle(style2);
            }
          }
        });
        function geometryToLayer(geojson, options) {
          var geometry = geojson.type === "Feature" ? geojson.geometry : geojson, coords = geometry ? geometry.coordinates : null, layers2 = [], pointToLayer = options && options.pointToLayer, _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng, latlng, latlngs, i, len;
          if (!coords && !geometry) {
            return null;
          }
          switch (geometry.type) {
            case "Point":
              latlng = _coordsToLatLng(coords);
              return _pointToLayer(pointToLayer, geojson, latlng, options);
            case "MultiPoint":
              for (i = 0, len = coords.length; i < len; i++) {
                latlng = _coordsToLatLng(coords[i]);
                layers2.push(_pointToLayer(pointToLayer, geojson, latlng, options));
              }
              return new FeatureGroup(layers2);
            case "LineString":
            case "MultiLineString":
              latlngs = coordsToLatLngs(coords, geometry.type === "LineString" ? 0 : 1, _coordsToLatLng);
              return new Polyline(latlngs, options);
            case "Polygon":
            case "MultiPolygon":
              latlngs = coordsToLatLngs(coords, geometry.type === "Polygon" ? 1 : 2, _coordsToLatLng);
              return new Polygon(latlngs, options);
            case "GeometryCollection":
              for (i = 0, len = geometry.geometries.length; i < len; i++) {
                var layer = geometryToLayer({
                  geometry: geometry.geometries[i],
                  type: "Feature",
                  properties: geojson.properties
                }, options);
                if (layer) {
                  layers2.push(layer);
                }
              }
              return new FeatureGroup(layers2);
            default:
              throw new Error("Invalid GeoJSON object.");
          }
        }
        function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
          return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);
        }
        function coordsToLatLng(coords) {
          return new LatLng(coords[1], coords[0], coords[2]);
        }
        function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
          var latlngs = [];
          for (var i = 0, len = coords.length, latlng; i < len; i++) {
            latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);
            latlngs.push(latlng);
          }
          return latlngs;
        }
        function latLngToCoords(latlng, precision) {
          latlng = toLatLng(latlng);
          return latlng.alt !== void 0 ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
        }
        function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
          var coords = [];
          for (var i = 0, len = latlngs.length; i < len; i++) {
            coords.push(levelsDeep ? latLngsToCoords(latlngs[i], levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));
          }
          if (!levelsDeep && closed) {
            coords.push(coords[0]);
          }
          return coords;
        }
        function getFeature(layer, newGeometry) {
          return layer.feature ? extend({}, layer.feature, { geometry: newGeometry }) : asFeature(newGeometry);
        }
        function asFeature(geojson) {
          if (geojson.type === "Feature" || geojson.type === "FeatureCollection") {
            return geojson;
          }
          return {
            type: "Feature",
            properties: {},
            geometry: geojson
          };
        }
        var PointToGeoJSON = {
          toGeoJSON: function(precision) {
            return getFeature(this, {
              type: "Point",
              coordinates: latLngToCoords(this.getLatLng(), precision)
            });
          }
        };
        Marker.include(PointToGeoJSON);
        Circle.include(PointToGeoJSON);
        CircleMarker.include(PointToGeoJSON);
        Polyline.include({
          toGeoJSON: function(precision) {
            var multi = !isFlat(this._latlngs);
            var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);
            return getFeature(this, {
              type: (multi ? "Multi" : "") + "LineString",
              coordinates: coords
            });
          }
        });
        Polygon.include({
          toGeoJSON: function(precision) {
            var holes = !isFlat(this._latlngs), multi = holes && !isFlat(this._latlngs[0]);
            var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);
            if (!holes) {
              coords = [coords];
            }
            return getFeature(this, {
              type: (multi ? "Multi" : "") + "Polygon",
              coordinates: coords
            });
          }
        });
        LayerGroup.include({
          toMultiPoint: function(precision) {
            var coords = [];
            this.eachLayer(function(layer) {
              coords.push(layer.toGeoJSON(precision).geometry.coordinates);
            });
            return getFeature(this, {
              type: "MultiPoint",
              coordinates: coords
            });
          },
          toGeoJSON: function(precision) {
            var type = this.feature && this.feature.geometry && this.feature.geometry.type;
            if (type === "MultiPoint") {
              return this.toMultiPoint(precision);
            }
            var isGeometryCollection = type === "GeometryCollection", jsons = [];
            this.eachLayer(function(layer) {
              if (layer.toGeoJSON) {
                var json = layer.toGeoJSON(precision);
                if (isGeometryCollection) {
                  jsons.push(json.geometry);
                } else {
                  var feature = asFeature(json);
                  if (feature.type === "FeatureCollection") {
                    jsons.push.apply(jsons, feature.features);
                  } else {
                    jsons.push(feature);
                  }
                }
              }
            });
            if (isGeometryCollection) {
              return getFeature(this, {
                geometries: jsons,
                type: "GeometryCollection"
              });
            }
            return {
              type: "FeatureCollection",
              features: jsons
            };
          }
        });
        function geoJSON(geojson, options) {
          return new GeoJSON(geojson, options);
        }
        var geoJson = geoJSON;
        var ImageOverlay = Layer.extend({
          options: {
            opacity: 1,
            alt: "",
            interactive: false,
            crossOrigin: false,
            errorOverlayUrl: "",
            zIndex: 1,
            className: ""
          },
          initialize: function(url, bounds, options) {
            this._url = url;
            this._bounds = toLatLngBounds(bounds);
            setOptions(this, options);
          },
          onAdd: function() {
            if (!this._image) {
              this._initImage();
              if (this.options.opacity < 1) {
                this._updateOpacity();
              }
            }
            if (this.options.interactive) {
              addClass(this._image, "leaflet-interactive");
              this.addInteractiveTarget(this._image);
            }
            this.getPane().appendChild(this._image);
            this._reset();
          },
          onRemove: function() {
            remove(this._image);
            if (this.options.interactive) {
              this.removeInteractiveTarget(this._image);
            }
          },
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._image) {
              this._updateOpacity();
            }
            return this;
          },
          setStyle: function(styleOpts) {
            if (styleOpts.opacity) {
              this.setOpacity(styleOpts.opacity);
            }
            return this;
          },
          bringToFront: function() {
            if (this._map) {
              toFront(this._image);
            }
            return this;
          },
          bringToBack: function() {
            if (this._map) {
              toBack(this._image);
            }
            return this;
          },
          setUrl: function(url) {
            this._url = url;
            if (this._image) {
              this._image.src = url;
            }
            return this;
          },
          setBounds: function(bounds) {
            this._bounds = toLatLngBounds(bounds);
            if (this._map) {
              this._reset();
            }
            return this;
          },
          getEvents: function() {
            var events = {
              zoom: this._reset,
              viewreset: this._reset
            };
            if (this._zoomAnimated) {
              events.zoomanim = this._animateZoom;
            }
            return events;
          },
          setZIndex: function(value) {
            this.options.zIndex = value;
            this._updateZIndex();
            return this;
          },
          getBounds: function() {
            return this._bounds;
          },
          getElement: function() {
            return this._image;
          },
          _initImage: function() {
            var wasElementSupplied = this._url.tagName === "IMG";
            var img = this._image = wasElementSupplied ? this._url : create$1("img");
            addClass(img, "leaflet-image-layer");
            if (this._zoomAnimated) {
              addClass(img, "leaflet-zoom-animated");
            }
            if (this.options.className) {
              addClass(img, this.options.className);
            }
            img.onselectstart = falseFn;
            img.onmousemove = falseFn;
            img.onload = bind(this.fire, this, "load");
            img.onerror = bind(this._overlayOnError, this, "error");
            if (this.options.crossOrigin || this.options.crossOrigin === "") {
              img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
            }
            if (this.options.zIndex) {
              this._updateZIndex();
            }
            if (wasElementSupplied) {
              this._url = img.src;
              return;
            }
            img.src = this._url;
            img.alt = this.options.alt;
          },
          _animateZoom: function(e) {
            var scale2 = this._map.getZoomScale(e.zoom), offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;
            setTransform(this._image, offset, scale2);
          },
          _reset: function() {
            var image = this._image, bounds = new Bounds(
              this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
              this._map.latLngToLayerPoint(this._bounds.getSouthEast())
            ), size = bounds.getSize();
            setPosition(image, bounds.min);
            image.style.width = size.x + "px";
            image.style.height = size.y + "px";
          },
          _updateOpacity: function() {
            setOpacity(this._image, this.options.opacity);
          },
          _updateZIndex: function() {
            if (this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
              this._image.style.zIndex = this.options.zIndex;
            }
          },
          _overlayOnError: function() {
            this.fire("error");
            var errorUrl = this.options.errorOverlayUrl;
            if (errorUrl && this._url !== errorUrl) {
              this._url = errorUrl;
              this._image.src = errorUrl;
            }
          },
          getCenter: function() {
            return this._bounds.getCenter();
          }
        });
        var imageOverlay = function(url, bounds, options) {
          return new ImageOverlay(url, bounds, options);
        };
        var VideoOverlay = ImageOverlay.extend({
          options: {
            autoplay: true,
            loop: true,
            keepAspectRatio: true,
            muted: false,
            playsInline: true
          },
          _initImage: function() {
            var wasElementSupplied = this._url.tagName === "VIDEO";
            var vid = this._image = wasElementSupplied ? this._url : create$1("video");
            addClass(vid, "leaflet-image-layer");
            if (this._zoomAnimated) {
              addClass(vid, "leaflet-zoom-animated");
            }
            if (this.options.className) {
              addClass(vid, this.options.className);
            }
            vid.onselectstart = falseFn;
            vid.onmousemove = falseFn;
            vid.onloadeddata = bind(this.fire, this, "load");
            if (wasElementSupplied) {
              var sourceElements = vid.getElementsByTagName("source");
              var sources = [];
              for (var j = 0; j < sourceElements.length; j++) {
                sources.push(sourceElements[j].src);
              }
              this._url = sourceElements.length > 0 ? sources : [vid.src];
              return;
            }
            if (!isArray(this._url)) {
              this._url = [this._url];
            }
            if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, "objectFit")) {
              vid.style["objectFit"] = "fill";
            }
            vid.autoplay = !!this.options.autoplay;
            vid.loop = !!this.options.loop;
            vid.muted = !!this.options.muted;
            vid.playsInline = !!this.options.playsInline;
            for (var i = 0; i < this._url.length; i++) {
              var source = create$1("source");
              source.src = this._url[i];
              vid.appendChild(source);
            }
          }
        });
        function videoOverlay(video, bounds, options) {
          return new VideoOverlay(video, bounds, options);
        }
        var SVGOverlay = ImageOverlay.extend({
          _initImage: function() {
            var el = this._image = this._url;
            addClass(el, "leaflet-image-layer");
            if (this._zoomAnimated) {
              addClass(el, "leaflet-zoom-animated");
            }
            if (this.options.className) {
              addClass(el, this.options.className);
            }
            el.onselectstart = falseFn;
            el.onmousemove = falseFn;
          }
        });
        function svgOverlay(el, bounds, options) {
          return new SVGOverlay(el, bounds, options);
        }
        var DivOverlay = Layer.extend({
          options: {
            interactive: false,
            offset: [0, 0],
            className: "",
            pane: void 0
          },
          initialize: function(options, source) {
            setOptions(this, options);
            this._source = source;
          },
          openOn: function(map) {
            map = arguments.length ? map : this._source._map;
            if (!map.hasLayer(this)) {
              map.addLayer(this);
            }
            return this;
          },
          close: function() {
            if (this._map) {
              this._map.removeLayer(this);
            }
            return this;
          },
          toggle: function(layer) {
            if (this._map) {
              this.close();
            } else {
              if (arguments.length) {
                this._source = layer;
              } else {
                layer = this._source;
              }
              this._prepareOpen();
              this.openOn(layer._map);
            }
            return this;
          },
          onAdd: function(map) {
            this._zoomAnimated = map._zoomAnimated;
            if (!this._container) {
              this._initLayout();
            }
            if (map._fadeAnimated) {
              setOpacity(this._container, 0);
            }
            clearTimeout(this._removeTimeout);
            this.getPane().appendChild(this._container);
            this.update();
            if (map._fadeAnimated) {
              setOpacity(this._container, 1);
            }
            this.bringToFront();
            if (this.options.interactive) {
              addClass(this._container, "leaflet-interactive");
              this.addInteractiveTarget(this._container);
            }
          },
          onRemove: function(map) {
            if (map._fadeAnimated) {
              setOpacity(this._container, 0);
              this._removeTimeout = setTimeout(bind(remove, void 0, this._container), 200);
            } else {
              remove(this._container);
            }
            if (this.options.interactive) {
              removeClass(this._container, "leaflet-interactive");
              this.removeInteractiveTarget(this._container);
            }
          },
          getLatLng: function() {
            return this._latlng;
          },
          setLatLng: function(latlng) {
            this._latlng = toLatLng(latlng);
            if (this._map) {
              this._updatePosition();
              this._adjustPan();
            }
            return this;
          },
          getContent: function() {
            return this._content;
          },
          setContent: function(content) {
            this._content = content;
            this.update();
            return this;
          },
          getElement: function() {
            return this._container;
          },
          update: function() {
            if (!this._map) {
              return;
            }
            this._container.style.visibility = "hidden";
            this._updateContent();
            this._updateLayout();
            this._updatePosition();
            this._container.style.visibility = "";
            this._adjustPan();
          },
          getEvents: function() {
            var events = {
              zoom: this._updatePosition,
              viewreset: this._updatePosition
            };
            if (this._zoomAnimated) {
              events.zoomanim = this._animateZoom;
            }
            return events;
          },
          isOpen: function() {
            return !!this._map && this._map.hasLayer(this);
          },
          bringToFront: function() {
            if (this._map) {
              toFront(this._container);
            }
            return this;
          },
          bringToBack: function() {
            if (this._map) {
              toBack(this._container);
            }
            return this;
          },
          _prepareOpen: function(latlng) {
            var source = this._source;
            if (!source._map) {
              return false;
            }
            if (source instanceof FeatureGroup) {
              source = null;
              var layers2 = this._source._layers;
              for (var id in layers2) {
                if (layers2[id]._map) {
                  source = layers2[id];
                  break;
                }
              }
              if (!source) {
                return false;
              }
              this._source = source;
            }
            if (!latlng) {
              if (source.getCenter) {
                latlng = source.getCenter();
              } else if (source.getLatLng) {
                latlng = source.getLatLng();
              } else if (source.getBounds) {
                latlng = source.getBounds().getCenter();
              } else {
                throw new Error("Unable to get source layer LatLng.");
              }
            }
            this.setLatLng(latlng);
            if (this._map) {
              this.update();
            }
            return true;
          },
          _updateContent: function() {
            if (!this._content) {
              return;
            }
            var node = this._contentNode;
            var content = typeof this._content === "function" ? this._content(this._source || this) : this._content;
            if (typeof content === "string") {
              node.innerHTML = content;
            } else {
              while (node.hasChildNodes()) {
                node.removeChild(node.firstChild);
              }
              node.appendChild(content);
            }
            this.fire("contentupdate");
          },
          _updatePosition: function() {
            if (!this._map) {
              return;
            }
            var pos = this._map.latLngToLayerPoint(this._latlng), offset = toPoint(this.options.offset), anchor = this._getAnchor();
            if (this._zoomAnimated) {
              setPosition(this._container, pos.add(anchor));
            } else {
              offset = offset.add(pos).add(anchor);
            }
            var bottom = this._containerBottom = -offset.y, left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;
            this._container.style.bottom = bottom + "px";
            this._container.style.left = left + "px";
          },
          _getAnchor: function() {
            return [0, 0];
          }
        });
        Map2.include({
          _initOverlay: function(OverlayClass, content, latlng, options) {
            var overlay = content;
            if (!(overlay instanceof OverlayClass)) {
              overlay = new OverlayClass(options).setContent(content);
            }
            if (latlng) {
              overlay.setLatLng(latlng);
            }
            return overlay;
          }
        });
        Layer.include({
          _initOverlay: function(OverlayClass, old, content, options) {
            var overlay = content;
            if (overlay instanceof OverlayClass) {
              setOptions(overlay, options);
              overlay._source = this;
            } else {
              overlay = old && !options ? old : new OverlayClass(options, this);
              overlay.setContent(content);
            }
            return overlay;
          }
        });
        var Popup = DivOverlay.extend({
          options: {
            pane: "popupPane",
            offset: [0, 7],
            maxWidth: 300,
            minWidth: 50,
            maxHeight: null,
            autoPan: true,
            autoPanPaddingTopLeft: null,
            autoPanPaddingBottomRight: null,
            autoPanPadding: [5, 5],
            keepInView: false,
            closeButton: true,
            autoClose: true,
            closeOnEscapeKey: true,
            className: ""
          },
          openOn: function(map) {
            map = arguments.length ? map : this._source._map;
            if (!map.hasLayer(this) && map._popup && map._popup.options.autoClose) {
              map.removeLayer(map._popup);
            }
            map._popup = this;
            return DivOverlay.prototype.openOn.call(this, map);
          },
          onAdd: function(map) {
            DivOverlay.prototype.onAdd.call(this, map);
            map.fire("popupopen", { popup: this });
            if (this._source) {
              this._source.fire("popupopen", { popup: this }, true);
              if (!(this._source instanceof Path)) {
                this._source.on("preclick", stopPropagation);
              }
            }
          },
          onRemove: function(map) {
            DivOverlay.prototype.onRemove.call(this, map);
            map.fire("popupclose", { popup: this });
            if (this._source) {
              this._source.fire("popupclose", { popup: this }, true);
              if (!(this._source instanceof Path)) {
                this._source.off("preclick", stopPropagation);
              }
            }
          },
          getEvents: function() {
            var events = DivOverlay.prototype.getEvents.call(this);
            if (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
              events.preclick = this.close;
            }
            if (this.options.keepInView) {
              events.moveend = this._adjustPan;
            }
            return events;
          },
          _initLayout: function() {
            var prefix = "leaflet-popup", container = this._container = create$1(
              "div",
              prefix + " " + (this.options.className || "") + " leaflet-zoom-animated"
            );
            var wrapper = this._wrapper = create$1("div", prefix + "-content-wrapper", container);
            this._contentNode = create$1("div", prefix + "-content", wrapper);
            disableClickPropagation(container);
            disableScrollPropagation(this._contentNode);
            on(container, "contextmenu", stopPropagation);
            this._tipContainer = create$1("div", prefix + "-tip-container", container);
            this._tip = create$1("div", prefix + "-tip", this._tipContainer);
            if (this.options.closeButton) {
              var closeButton = this._closeButton = create$1("a", prefix + "-close-button", container);
              closeButton.setAttribute("role", "button");
              closeButton.setAttribute("aria-label", "Close popup");
              closeButton.href = "#close";
              closeButton.innerHTML = '<span aria-hidden="true">&#215;</span>';
              on(closeButton, "click", this.close, this);
            }
          },
          _updateLayout: function() {
            var container = this._contentNode, style2 = container.style;
            style2.width = "";
            style2.whiteSpace = "nowrap";
            var width = container.offsetWidth;
            width = Math.min(width, this.options.maxWidth);
            width = Math.max(width, this.options.minWidth);
            style2.width = width + 1 + "px";
            style2.whiteSpace = "";
            style2.height = "";
            var height = container.offsetHeight, maxHeight = this.options.maxHeight, scrolledClass = "leaflet-popup-scrolled";
            if (maxHeight && height > maxHeight) {
              style2.height = maxHeight + "px";
              addClass(container, scrolledClass);
            } else {
              removeClass(container, scrolledClass);
            }
            this._containerWidth = this._container.offsetWidth;
          },
          _animateZoom: function(e) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center), anchor = this._getAnchor();
            setPosition(this._container, pos.add(anchor));
          },
          _adjustPan: function(e) {
            if (!this.options.autoPan) {
              return;
            }
            if (this._map._panAnim) {
              this._map._panAnim.stop();
            }
            var map = this._map, marginBottom = parseInt(getStyle(this._container, "marginBottom"), 10) || 0, containerHeight = this._container.offsetHeight + marginBottom, containerWidth = this._containerWidth, layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);
            layerPos._add(getPosition(this._container));
            var containerPos = map.layerPointToContainerPoint(layerPos), padding = toPoint(this.options.autoPanPadding), paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding), paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding), size = map.getSize(), dx = 0, dy = 0;
            if (containerPos.x + containerWidth + paddingBR.x > size.x) {
              dx = containerPos.x + containerWidth - size.x + paddingBR.x;
            }
            if (containerPos.x - dx - paddingTL.x < 0) {
              dx = containerPos.x - paddingTL.x;
            }
            if (containerPos.y + containerHeight + paddingBR.y > size.y) {
              dy = containerPos.y + containerHeight - size.y + paddingBR.y;
            }
            if (containerPos.y - dy - paddingTL.y < 0) {
              dy = containerPos.y - paddingTL.y;
            }
            if (dx || dy) {
              map.fire("autopanstart").panBy([dx, dy], { animate: e && e.type === "moveend" });
            }
          },
          _getAnchor: function() {
            return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
          }
        });
        var popup = function(options, source) {
          return new Popup(options, source);
        };
        Map2.mergeOptions({
          closePopupOnClick: true
        });
        Map2.include({
          openPopup: function(popup2, latlng, options) {
            this._initOverlay(Popup, popup2, latlng, options).openOn(this);
            return this;
          },
          closePopup: function(popup2) {
            popup2 = arguments.length ? popup2 : this._popup;
            if (popup2) {
              popup2.close();
            }
            return this;
          }
        });
        Layer.include({
          bindPopup: function(content, options) {
            this._popup = this._initOverlay(Popup, this._popup, content, options);
            if (!this._popupHandlersAdded) {
              this.on({
                click: this._openPopup,
                keypress: this._onKeyPress,
                remove: this.closePopup,
                move: this._movePopup
              });
              this._popupHandlersAdded = true;
            }
            return this;
          },
          unbindPopup: function() {
            if (this._popup) {
              this.off({
                click: this._openPopup,
                keypress: this._onKeyPress,
                remove: this.closePopup,
                move: this._movePopup
              });
              this._popupHandlersAdded = false;
              this._popup = null;
            }
            return this;
          },
          openPopup: function(latlng) {
            if (this._popup && this._popup._prepareOpen(latlng)) {
              this._popup.openOn(this._map);
            }
            return this;
          },
          closePopup: function() {
            if (this._popup) {
              this._popup.close();
            }
            return this;
          },
          togglePopup: function() {
            if (this._popup) {
              this._popup.toggle(this);
            }
            return this;
          },
          isPopupOpen: function() {
            return this._popup ? this._popup.isOpen() : false;
          },
          setPopupContent: function(content) {
            if (this._popup) {
              this._popup.setContent(content);
            }
            return this;
          },
          getPopup: function() {
            return this._popup;
          },
          _openPopup: function(e) {
            if (!this._popup || !this._map) {
              return;
            }
            stop(e);
            var target = e.layer || e.target;
            if (this._popup._source === target && !(target instanceof Path)) {
              if (this._map.hasLayer(this._popup)) {
                this.closePopup();
              } else {
                this.openPopup(e.latlng);
              }
              return;
            }
            this._popup._source = target;
            this.openPopup(e.latlng);
          },
          _movePopup: function(e) {
            this._popup.setLatLng(e.latlng);
          },
          _onKeyPress: function(e) {
            if (e.originalEvent.keyCode === 13) {
              this._openPopup(e);
            }
          }
        });
        var Tooltip = DivOverlay.extend({
          options: {
            pane: "tooltipPane",
            offset: [0, 0],
            direction: "auto",
            permanent: false,
            sticky: false,
            opacity: 0.9
          },
          onAdd: function(map) {
            DivOverlay.prototype.onAdd.call(this, map);
            this.setOpacity(this.options.opacity);
            map.fire("tooltipopen", { tooltip: this });
            if (this._source) {
              this.addEventParent(this._source);
              this._source.fire("tooltipopen", { tooltip: this }, true);
            }
          },
          onRemove: function(map) {
            DivOverlay.prototype.onRemove.call(this, map);
            map.fire("tooltipclose", { tooltip: this });
            if (this._source) {
              this.removeEventParent(this._source);
              this._source.fire("tooltipclose", { tooltip: this }, true);
            }
          },
          getEvents: function() {
            var events = DivOverlay.prototype.getEvents.call(this);
            if (!this.options.permanent) {
              events.preclick = this.close;
            }
            return events;
          },
          _initLayout: function() {
            var prefix = "leaflet-tooltip", className = prefix + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
            this._contentNode = this._container = create$1("div", className);
          },
          _updateLayout: function() {
          },
          _adjustPan: function() {
          },
          _setPosition: function(pos) {
            var subX, subY, map = this._map, container = this._container, centerPoint = map.latLngToContainerPoint(map.getCenter()), tooltipPoint = map.layerPointToContainerPoint(pos), direction = this.options.direction, tooltipWidth = container.offsetWidth, tooltipHeight = container.offsetHeight, offset = toPoint(this.options.offset), anchor = this._getAnchor();
            if (direction === "top") {
              subX = tooltipWidth / 2;
              subY = tooltipHeight;
            } else if (direction === "bottom") {
              subX = tooltipWidth / 2;
              subY = 0;
            } else if (direction === "center") {
              subX = tooltipWidth / 2;
              subY = tooltipHeight / 2;
            } else if (direction === "right") {
              subX = 0;
              subY = tooltipHeight / 2;
            } else if (direction === "left") {
              subX = tooltipWidth;
              subY = tooltipHeight / 2;
            } else if (tooltipPoint.x < centerPoint.x) {
              direction = "right";
              subX = 0;
              subY = tooltipHeight / 2;
            } else {
              direction = "left";
              subX = tooltipWidth + (offset.x + anchor.x) * 2;
              subY = tooltipHeight / 2;
            }
            pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);
            removeClass(container, "leaflet-tooltip-right");
            removeClass(container, "leaflet-tooltip-left");
            removeClass(container, "leaflet-tooltip-top");
            removeClass(container, "leaflet-tooltip-bottom");
            addClass(container, "leaflet-tooltip-" + direction);
            setPosition(container, pos);
          },
          _updatePosition: function() {
            var pos = this._map.latLngToLayerPoint(this._latlng);
            this._setPosition(pos);
          },
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._container) {
              setOpacity(this._container, opacity);
            }
          },
          _animateZoom: function(e) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
            this._setPosition(pos);
          },
          _getAnchor: function() {
            return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
          }
        });
        var tooltip = function(options, source) {
          return new Tooltip(options, source);
        };
        Map2.include({
          openTooltip: function(tooltip2, latlng, options) {
            this._initOverlay(Tooltip, tooltip2, latlng, options).openOn(this);
            return this;
          },
          closeTooltip: function(tooltip2) {
            tooltip2.close();
            return this;
          }
        });
        Layer.include({
          bindTooltip: function(content, options) {
            if (this._tooltip && this.isTooltipOpen()) {
              this.unbindTooltip();
            }
            this._tooltip = this._initOverlay(Tooltip, this._tooltip, content, options);
            this._initTooltipInteractions();
            if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
              this.openTooltip();
            }
            return this;
          },
          unbindTooltip: function() {
            if (this._tooltip) {
              this._initTooltipInteractions(true);
              this.closeTooltip();
              this._tooltip = null;
            }
            return this;
          },
          _initTooltipInteractions: function(remove2) {
            if (!remove2 && this._tooltipHandlersAdded) {
              return;
            }
            var onOff = remove2 ? "off" : "on", events = {
              remove: this.closeTooltip,
              move: this._moveTooltip
            };
            if (!this._tooltip.options.permanent) {
              events.mouseover = this._openTooltip;
              events.mouseout = this.closeTooltip;
              events.click = this._openTooltip;
            } else {
              events.add = this._openTooltip;
            }
            if (this._tooltip.options.sticky) {
              events.mousemove = this._moveTooltip;
            }
            this[onOff](events);
            this._tooltipHandlersAdded = !remove2;
          },
          openTooltip: function(latlng) {
            if (this._tooltip && this._tooltip._prepareOpen(latlng)) {
              this._tooltip.openOn(this._map);
            }
            return this;
          },
          closeTooltip: function() {
            if (this._tooltip) {
              return this._tooltip.close();
            }
          },
          toggleTooltip: function() {
            if (this._tooltip) {
              this._tooltip.toggle(this);
            }
            return this;
          },
          isTooltipOpen: function() {
            return this._tooltip.isOpen();
          },
          setTooltipContent: function(content) {
            if (this._tooltip) {
              this._tooltip.setContent(content);
            }
            return this;
          },
          getTooltip: function() {
            return this._tooltip;
          },
          _openTooltip: function(e) {
            if (!this._tooltip || !this._map || this._map.dragging && this._map.dragging.moving()) {
              return;
            }
            this._tooltip._source = e.layer || e.target;
            this.openTooltip(this._tooltip.options.sticky ? e.latlng : void 0);
          },
          _moveTooltip: function(e) {
            var latlng = e.latlng, containerPoint, layerPoint;
            if (this._tooltip.options.sticky && e.originalEvent) {
              containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
              layerPoint = this._map.containerPointToLayerPoint(containerPoint);
              latlng = this._map.layerPointToLatLng(layerPoint);
            }
            this._tooltip.setLatLng(latlng);
          }
        });
        var DivIcon = Icon.extend({
          options: {
            iconSize: [12, 12],
            html: false,
            bgPos: null,
            className: "leaflet-div-icon"
          },
          createIcon: function(oldIcon) {
            var div = oldIcon && oldIcon.tagName === "DIV" ? oldIcon : document.createElement("div"), options = this.options;
            if (options.html instanceof Element) {
              empty(div);
              div.appendChild(options.html);
            } else {
              div.innerHTML = options.html !== false ? options.html : "";
            }
            if (options.bgPos) {
              var bgPos = toPoint(options.bgPos);
              div.style.backgroundPosition = -bgPos.x + "px " + -bgPos.y + "px";
            }
            this._setIconStyles(div, "icon");
            return div;
          },
          createShadow: function() {
            return null;
          }
        });
        function divIcon(options) {
          return new DivIcon(options);
        }
        Icon.Default = IconDefault;
        var GridLayer = Layer.extend({
          options: {
            tileSize: 256,
            opacity: 1,
            updateWhenIdle: Browser.mobile,
            updateWhenZooming: true,
            updateInterval: 200,
            zIndex: 1,
            bounds: null,
            minZoom: 0,
            maxZoom: void 0,
            maxNativeZoom: void 0,
            minNativeZoom: void 0,
            noWrap: false,
            pane: "tilePane",
            className: "",
            keepBuffer: 2
          },
          initialize: function(options) {
            setOptions(this, options);
          },
          onAdd: function() {
            this._initContainer();
            this._levels = {};
            this._tiles = {};
            this._resetView();
          },
          beforeAdd: function(map) {
            map._addZoomLimit(this);
          },
          onRemove: function(map) {
            this._removeAllTiles();
            remove(this._container);
            map._removeZoomLimit(this);
            this._container = null;
            this._tileZoom = void 0;
          },
          bringToFront: function() {
            if (this._map) {
              toFront(this._container);
              this._setAutoZIndex(Math.max);
            }
            return this;
          },
          bringToBack: function() {
            if (this._map) {
              toBack(this._container);
              this._setAutoZIndex(Math.min);
            }
            return this;
          },
          getContainer: function() {
            return this._container;
          },
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            this._updateOpacity();
            return this;
          },
          setZIndex: function(zIndex) {
            this.options.zIndex = zIndex;
            this._updateZIndex();
            return this;
          },
          isLoading: function() {
            return this._loading;
          },
          redraw: function() {
            if (this._map) {
              this._removeAllTiles();
              var tileZoom = this._clampZoom(this._map.getZoom());
              if (tileZoom !== this._tileZoom) {
                this._tileZoom = tileZoom;
                this._updateLevels();
              }
              this._update();
            }
            return this;
          },
          getEvents: function() {
            var events = {
              viewprereset: this._invalidateAll,
              viewreset: this._resetView,
              zoom: this._resetView,
              moveend: this._onMoveEnd
            };
            if (!this.options.updateWhenIdle) {
              if (!this._onMove) {
                this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
              }
              events.move = this._onMove;
            }
            if (this._zoomAnimated) {
              events.zoomanim = this._animateZoom;
            }
            return events;
          },
          createTile: function() {
            return document.createElement("div");
          },
          getTileSize: function() {
            var s = this.options.tileSize;
            return s instanceof Point ? s : new Point(s, s);
          },
          _updateZIndex: function() {
            if (this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
              this._container.style.zIndex = this.options.zIndex;
            }
          },
          _setAutoZIndex: function(compare) {
            var layers2 = this.getPane().children, edgeZIndex = -compare(-Infinity, Infinity);
            for (var i = 0, len = layers2.length, zIndex; i < len; i++) {
              zIndex = layers2[i].style.zIndex;
              if (layers2[i] !== this._container && zIndex) {
                edgeZIndex = compare(edgeZIndex, +zIndex);
              }
            }
            if (isFinite(edgeZIndex)) {
              this.options.zIndex = edgeZIndex + compare(-1, 1);
              this._updateZIndex();
            }
          },
          _updateOpacity: function() {
            if (!this._map) {
              return;
            }
            if (Browser.ielt9) {
              return;
            }
            setOpacity(this._container, this.options.opacity);
            var now = +new Date(), nextFrame = false, willPrune = false;
            for (var key in this._tiles) {
              var tile = this._tiles[key];
              if (!tile.current || !tile.loaded) {
                continue;
              }
              var fade = Math.min(1, (now - tile.loaded) / 200);
              setOpacity(tile.el, fade);
              if (fade < 1) {
                nextFrame = true;
              } else {
                if (tile.active) {
                  willPrune = true;
                } else {
                  this._onOpaqueTile(tile);
                }
                tile.active = true;
              }
            }
            if (willPrune && !this._noPrune) {
              this._pruneTiles();
            }
            if (nextFrame) {
              cancelAnimFrame(this._fadeFrame);
              this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
            }
          },
          _onOpaqueTile: falseFn,
          _initContainer: function() {
            if (this._container) {
              return;
            }
            this._container = create$1("div", "leaflet-layer " + (this.options.className || ""));
            this._updateZIndex();
            if (this.options.opacity < 1) {
              this._updateOpacity();
            }
            this.getPane().appendChild(this._container);
          },
          _updateLevels: function() {
            var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom;
            if (zoom2 === void 0) {
              return void 0;
            }
            for (var z in this._levels) {
              z = Number(z);
              if (this._levels[z].el.children.length || z === zoom2) {
                this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom2 - z);
                this._onUpdateLevel(z);
              } else {
                remove(this._levels[z].el);
                this._removeTilesAtZoom(z);
                this._onRemoveLevel(z);
                delete this._levels[z];
              }
            }
            var level = this._levels[zoom2], map = this._map;
            if (!level) {
              level = this._levels[zoom2] = {};
              level.el = create$1("div", "leaflet-tile-container leaflet-zoom-animated", this._container);
              level.el.style.zIndex = maxZoom;
              level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom2).round();
              level.zoom = zoom2;
              this._setZoomTransform(level, map.getCenter(), map.getZoom());
              falseFn(level.el.offsetWidth);
              this._onCreateLevel(level);
            }
            this._level = level;
            return level;
          },
          _onUpdateLevel: falseFn,
          _onRemoveLevel: falseFn,
          _onCreateLevel: falseFn,
          _pruneTiles: function() {
            if (!this._map) {
              return;
            }
            var key, tile;
            var zoom2 = this._map.getZoom();
            if (zoom2 > this.options.maxZoom || zoom2 < this.options.minZoom) {
              this._removeAllTiles();
              return;
            }
            for (key in this._tiles) {
              tile = this._tiles[key];
              tile.retain = tile.current;
            }
            for (key in this._tiles) {
              tile = this._tiles[key];
              if (tile.current && !tile.active) {
                var coords = tile.coords;
                if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
                  this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
                }
              }
            }
            for (key in this._tiles) {
              if (!this._tiles[key].retain) {
                this._removeTile(key);
              }
            }
          },
          _removeTilesAtZoom: function(zoom2) {
            for (var key in this._tiles) {
              if (this._tiles[key].coords.z !== zoom2) {
                continue;
              }
              this._removeTile(key);
            }
          },
          _removeAllTiles: function() {
            for (var key in this._tiles) {
              this._removeTile(key);
            }
          },
          _invalidateAll: function() {
            for (var z in this._levels) {
              remove(this._levels[z].el);
              this._onRemoveLevel(Number(z));
              delete this._levels[z];
            }
            this._removeAllTiles();
            this._tileZoom = void 0;
          },
          _retainParent: function(x, y, z, minZoom) {
            var x2 = Math.floor(x / 2), y2 = Math.floor(y / 2), z2 = z - 1, coords2 = new Point(+x2, +y2);
            coords2.z = +z2;
            var key = this._tileCoordsToKey(coords2), tile = this._tiles[key];
            if (tile && tile.active) {
              tile.retain = true;
              return true;
            } else if (tile && tile.loaded) {
              tile.retain = true;
            }
            if (z2 > minZoom) {
              return this._retainParent(x2, y2, z2, minZoom);
            }
            return false;
          },
          _retainChildren: function(x, y, z, maxZoom) {
            for (var i = 2 * x; i < 2 * x + 2; i++) {
              for (var j = 2 * y; j < 2 * y + 2; j++) {
                var coords = new Point(i, j);
                coords.z = z + 1;
                var key = this._tileCoordsToKey(coords), tile = this._tiles[key];
                if (tile && tile.active) {
                  tile.retain = true;
                  continue;
                } else if (tile && tile.loaded) {
                  tile.retain = true;
                }
                if (z + 1 < maxZoom) {
                  this._retainChildren(i, j, z + 1, maxZoom);
                }
              }
            }
          },
          _resetView: function(e) {
            var animating = e && (e.pinch || e.flyTo);
            this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
          },
          _animateZoom: function(e) {
            this._setView(e.center, e.zoom, true, e.noUpdate);
          },
          _clampZoom: function(zoom2) {
            var options = this.options;
            if (void 0 !== options.minNativeZoom && zoom2 < options.minNativeZoom) {
              return options.minNativeZoom;
            }
            if (void 0 !== options.maxNativeZoom && options.maxNativeZoom < zoom2) {
              return options.maxNativeZoom;
            }
            return zoom2;
          },
          _setView: function(center, zoom2, noPrune, noUpdate) {
            var tileZoom = Math.round(zoom2);
            if (this.options.maxZoom !== void 0 && tileZoom > this.options.maxZoom || this.options.minZoom !== void 0 && tileZoom < this.options.minZoom) {
              tileZoom = void 0;
            } else {
              tileZoom = this._clampZoom(tileZoom);
            }
            var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;
            if (!noUpdate || tileZoomChanged) {
              this._tileZoom = tileZoom;
              if (this._abortLoading) {
                this._abortLoading();
              }
              this._updateLevels();
              this._resetGrid();
              if (tileZoom !== void 0) {
                this._update(center);
              }
              if (!noPrune) {
                this._pruneTiles();
              }
              this._noPrune = !!noPrune;
            }
            this._setZoomTransforms(center, zoom2);
          },
          _setZoomTransforms: function(center, zoom2) {
            for (var i in this._levels) {
              this._setZoomTransform(this._levels[i], center, zoom2);
            }
          },
          _setZoomTransform: function(level, center, zoom2) {
            var scale2 = this._map.getZoomScale(zoom2, level.zoom), translate = level.origin.multiplyBy(scale2).subtract(this._map._getNewPixelOrigin(center, zoom2)).round();
            if (Browser.any3d) {
              setTransform(level.el, translate, scale2);
            } else {
              setPosition(level.el, translate);
            }
          },
          _resetGrid: function() {
            var map = this._map, crs = map.options.crs, tileSize = this._tileSize = this.getTileSize(), tileZoom = this._tileZoom;
            var bounds = this._map.getPixelWorldBounds(this._tileZoom);
            if (bounds) {
              this._globalTileRange = this._pxBoundsToTileRange(bounds);
            }
            this._wrapX = crs.wrapLng && !this.options.noWrap && [
              Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
              Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
            ];
            this._wrapY = crs.wrapLat && !this.options.noWrap && [
              Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
              Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
            ];
          },
          _onMoveEnd: function() {
            if (!this._map || this._map._animatingZoom) {
              return;
            }
            this._update();
          },
          _getTiledPixelBounds: function(center) {
            var map = this._map, mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(), scale2 = map.getZoomScale(mapZoom, this._tileZoom), pixelCenter = map.project(center, this._tileZoom).floor(), halfSize = map.getSize().divideBy(scale2 * 2);
            return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
          },
          _update: function(center) {
            var map = this._map;
            if (!map) {
              return;
            }
            var zoom2 = this._clampZoom(map.getZoom());
            if (center === void 0) {
              center = map.getCenter();
            }
            if (this._tileZoom === void 0) {
              return;
            }
            var pixelBounds = this._getTiledPixelBounds(center), tileRange = this._pxBoundsToTileRange(pixelBounds), tileCenter = tileRange.getCenter(), queue = [], margin = this.options.keepBuffer, noPruneRange = new Bounds(
              tileRange.getBottomLeft().subtract([margin, -margin]),
              tileRange.getTopRight().add([margin, -margin])
            );
            if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
              throw new Error("Attempted to load an infinite number of tiles");
            }
            for (var key in this._tiles) {
              var c = this._tiles[key].coords;
              if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
                this._tiles[key].current = false;
              }
            }
            if (Math.abs(zoom2 - this._tileZoom) > 1) {
              this._setView(center, zoom2);
              return;
            }
            for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
              for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
                var coords = new Point(i, j);
                coords.z = this._tileZoom;
                if (!this._isValidTile(coords)) {
                  continue;
                }
                var tile = this._tiles[this._tileCoordsToKey(coords)];
                if (tile) {
                  tile.current = true;
                } else {
                  queue.push(coords);
                }
              }
            }
            queue.sort(function(a, b) {
              return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
            });
            if (queue.length !== 0) {
              if (!this._loading) {
                this._loading = true;
                this.fire("loading");
              }
              var fragment = document.createDocumentFragment();
              for (i = 0; i < queue.length; i++) {
                this._addTile(queue[i], fragment);
              }
              this._level.el.appendChild(fragment);
            }
          },
          _isValidTile: function(coords) {
            var crs = this._map.options.crs;
            if (!crs.infinite) {
              var bounds = this._globalTileRange;
              if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
                return false;
              }
            }
            if (!this.options.bounds) {
              return true;
            }
            var tileBounds = this._tileCoordsToBounds(coords);
            return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
          },
          _keyToBounds: function(key) {
            return this._tileCoordsToBounds(this._keyToTileCoords(key));
          },
          _tileCoordsToNwSe: function(coords) {
            var map = this._map, tileSize = this.getTileSize(), nwPoint = coords.scaleBy(tileSize), sePoint = nwPoint.add(tileSize), nw = map.unproject(nwPoint, coords.z), se = map.unproject(sePoint, coords.z);
            return [nw, se];
          },
          _tileCoordsToBounds: function(coords) {
            var bp = this._tileCoordsToNwSe(coords), bounds = new LatLngBounds(bp[0], bp[1]);
            if (!this.options.noWrap) {
              bounds = this._map.wrapLatLngBounds(bounds);
            }
            return bounds;
          },
          _tileCoordsToKey: function(coords) {
            return coords.x + ":" + coords.y + ":" + coords.z;
          },
          _keyToTileCoords: function(key) {
            var k = key.split(":"), coords = new Point(+k[0], +k[1]);
            coords.z = +k[2];
            return coords;
          },
          _removeTile: function(key) {
            var tile = this._tiles[key];
            if (!tile) {
              return;
            }
            remove(tile.el);
            delete this._tiles[key];
            this.fire("tileunload", {
              tile: tile.el,
              coords: this._keyToTileCoords(key)
            });
          },
          _initTile: function(tile) {
            addClass(tile, "leaflet-tile");
            var tileSize = this.getTileSize();
            tile.style.width = tileSize.x + "px";
            tile.style.height = tileSize.y + "px";
            tile.onselectstart = falseFn;
            tile.onmousemove = falseFn;
            if (Browser.ielt9 && this.options.opacity < 1) {
              setOpacity(tile, this.options.opacity);
            }
          },
          _addTile: function(coords, container) {
            var tilePos = this._getTilePos(coords), key = this._tileCoordsToKey(coords);
            var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));
            this._initTile(tile);
            if (this.createTile.length < 2) {
              requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
            }
            setPosition(tile, tilePos);
            this._tiles[key] = {
              el: tile,
              coords,
              current: true
            };
            container.appendChild(tile);
            this.fire("tileloadstart", {
              tile,
              coords
            });
          },
          _tileReady: function(coords, err, tile) {
            if (err) {
              this.fire("tileerror", {
                error: err,
                tile,
                coords
              });
            }
            var key = this._tileCoordsToKey(coords);
            tile = this._tiles[key];
            if (!tile) {
              return;
            }
            tile.loaded = +new Date();
            if (this._map._fadeAnimated) {
              setOpacity(tile.el, 0);
              cancelAnimFrame(this._fadeFrame);
              this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
            } else {
              tile.active = true;
              this._pruneTiles();
            }
            if (!err) {
              addClass(tile.el, "leaflet-tile-loaded");
              this.fire("tileload", {
                tile: tile.el,
                coords
              });
            }
            if (this._noTilesToLoad()) {
              this._loading = false;
              this.fire("load");
              if (Browser.ielt9 || !this._map._fadeAnimated) {
                requestAnimFrame(this._pruneTiles, this);
              } else {
                setTimeout(bind(this._pruneTiles, this), 250);
              }
            }
          },
          _getTilePos: function(coords) {
            return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
          },
          _wrapCoords: function(coords) {
            var newCoords = new Point(
              this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,
              this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y
            );
            newCoords.z = coords.z;
            return newCoords;
          },
          _pxBoundsToTileRange: function(bounds) {
            var tileSize = this.getTileSize();
            return new Bounds(
              bounds.min.unscaleBy(tileSize).floor(),
              bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1])
            );
          },
          _noTilesToLoad: function() {
            for (var key in this._tiles) {
              if (!this._tiles[key].loaded) {
                return false;
              }
            }
            return true;
          }
        });
        function gridLayer(options) {
          return new GridLayer(options);
        }
        var TileLayer = GridLayer.extend({
          options: {
            minZoom: 0,
            maxZoom: 18,
            subdomains: "abc",
            errorTileUrl: "",
            zoomOffset: 0,
            tms: false,
            zoomReverse: false,
            detectRetina: false,
            crossOrigin: false,
            referrerPolicy: false
          },
          initialize: function(url, options) {
            this._url = url;
            options = setOptions(this, options);
            if (options.detectRetina && Browser.retina && options.maxZoom > 0) {
              options.tileSize = Math.floor(options.tileSize / 2);
              if (!options.zoomReverse) {
                options.zoomOffset++;
                options.maxZoom--;
              } else {
                options.zoomOffset--;
                options.minZoom++;
              }
              options.minZoom = Math.max(0, options.minZoom);
            }
            if (typeof options.subdomains === "string") {
              options.subdomains = options.subdomains.split("");
            }
            this.on("tileunload", this._onTileRemove);
          },
          setUrl: function(url, noRedraw) {
            if (this._url === url && noRedraw === void 0) {
              noRedraw = true;
            }
            this._url = url;
            if (!noRedraw) {
              this.redraw();
            }
            return this;
          },
          createTile: function(coords, done) {
            var tile = document.createElement("img");
            on(tile, "load", bind(this._tileOnLoad, this, done, tile));
            on(tile, "error", bind(this._tileOnError, this, done, tile));
            if (this.options.crossOrigin || this.options.crossOrigin === "") {
              tile.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
            }
            if (typeof this.options.referrerPolicy === "string") {
              tile.referrerPolicy = this.options.referrerPolicy;
            }
            tile.alt = "";
            tile.setAttribute("role", "presentation");
            tile.src = this.getTileUrl(coords);
            return tile;
          },
          getTileUrl: function(coords) {
            var data = {
              r: Browser.retina ? "@2x" : "",
              s: this._getSubdomain(coords),
              x: coords.x,
              y: coords.y,
              z: this._getZoomForUrl()
            };
            if (this._map && !this._map.options.crs.infinite) {
              var invertedY = this._globalTileRange.max.y - coords.y;
              if (this.options.tms) {
                data["y"] = invertedY;
              }
              data["-y"] = invertedY;
            }
            return template(this._url, extend(data, this.options));
          },
          _tileOnLoad: function(done, tile) {
            if (Browser.ielt9) {
              setTimeout(bind(done, this, null, tile), 0);
            } else {
              done(null, tile);
            }
          },
          _tileOnError: function(done, tile, e) {
            var errorUrl = this.options.errorTileUrl;
            if (errorUrl && tile.getAttribute("src") !== errorUrl) {
              tile.src = errorUrl;
            }
            done(e, tile);
          },
          _onTileRemove: function(e) {
            e.tile.onload = null;
          },
          _getZoomForUrl: function() {
            var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom, zoomReverse = this.options.zoomReverse, zoomOffset = this.options.zoomOffset;
            if (zoomReverse) {
              zoom2 = maxZoom - zoom2;
            }
            return zoom2 + zoomOffset;
          },
          _getSubdomain: function(tilePoint) {
            var index2 = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
            return this.options.subdomains[index2];
          },
          _abortLoading: function() {
            var i, tile;
            for (i in this._tiles) {
              if (this._tiles[i].coords.z !== this._tileZoom) {
                tile = this._tiles[i].el;
                tile.onload = falseFn;
                tile.onerror = falseFn;
                if (!tile.complete) {
                  tile.src = emptyImageUrl;
                  var coords = this._tiles[i].coords;
                  remove(tile);
                  delete this._tiles[i];
                  this.fire("tileabort", {
                    tile,
                    coords
                  });
                }
              }
            }
          },
          _removeTile: function(key) {
            var tile = this._tiles[key];
            if (!tile) {
              return;
            }
            tile.el.setAttribute("src", emptyImageUrl);
            return GridLayer.prototype._removeTile.call(this, key);
          },
          _tileReady: function(coords, err, tile) {
            if (!this._map || tile && tile.getAttribute("src") === emptyImageUrl) {
              return;
            }
            return GridLayer.prototype._tileReady.call(this, coords, err, tile);
          }
        });
        function tileLayer(url, options) {
          return new TileLayer(url, options);
        }
        var TileLayerWMS = TileLayer.extend({
          defaultWmsParams: {
            service: "WMS",
            request: "GetMap",
            layers: "",
            styles: "",
            format: "image/jpeg",
            transparent: false,
            version: "1.1.1"
          },
          options: {
            crs: null,
            uppercase: false
          },
          initialize: function(url, options) {
            this._url = url;
            var wmsParams = extend({}, this.defaultWmsParams);
            for (var i in options) {
              if (!(i in this.options)) {
                wmsParams[i] = options[i];
              }
            }
            options = setOptions(this, options);
            var realRetina = options.detectRetina && Browser.retina ? 2 : 1;
            var tileSize = this.getTileSize();
            wmsParams.width = tileSize.x * realRetina;
            wmsParams.height = tileSize.y * realRetina;
            this.wmsParams = wmsParams;
          },
          onAdd: function(map) {
            this._crs = this.options.crs || map.options.crs;
            this._wmsVersion = parseFloat(this.wmsParams.version);
            var projectionKey = this._wmsVersion >= 1.3 ? "crs" : "srs";
            this.wmsParams[projectionKey] = this._crs.code;
            TileLayer.prototype.onAdd.call(this, map);
          },
          getTileUrl: function(coords) {
            var tileBounds = this._tileCoordsToNwSe(coords), crs = this._crs, bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])), min = bounds.min, max = bounds.max, bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(","), url = TileLayer.prototype.getTileUrl.call(this, coords);
            return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + bbox;
          },
          setParams: function(params, noRedraw) {
            extend(this.wmsParams, params);
            if (!noRedraw) {
              this.redraw();
            }
            return this;
          }
        });
        function tileLayerWMS(url, options) {
          return new TileLayerWMS(url, options);
        }
        TileLayer.WMS = TileLayerWMS;
        tileLayer.wms = tileLayerWMS;
        var Renderer = Layer.extend({
          options: {
            padding: 0.1
          },
          initialize: function(options) {
            setOptions(this, options);
            stamp(this);
            this._layers = this._layers || {};
          },
          onAdd: function() {
            if (!this._container) {
              this._initContainer();
              if (this._zoomAnimated) {
                addClass(this._container, "leaflet-zoom-animated");
              }
            }
            this.getPane().appendChild(this._container);
            this._update();
            this.on("update", this._updatePaths, this);
          },
          onRemove: function() {
            this.off("update", this._updatePaths, this);
            this._destroyContainer();
          },
          getEvents: function() {
            var events = {
              viewreset: this._reset,
              zoom: this._onZoom,
              moveend: this._update,
              zoomend: this._onZoomEnd
            };
            if (this._zoomAnimated) {
              events.zoomanim = this._onAnimZoom;
            }
            return events;
          },
          _onAnimZoom: function(ev) {
            this._updateTransform(ev.center, ev.zoom);
          },
          _onZoom: function() {
            this._updateTransform(this._map.getCenter(), this._map.getZoom());
          },
          _updateTransform: function(center, zoom2) {
            var scale2 = this._map.getZoomScale(zoom2, this._zoom), viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding), currentCenterPoint = this._map.project(this._center, zoom2), topLeftOffset = viewHalf.multiplyBy(-scale2).add(currentCenterPoint).subtract(this._map._getNewPixelOrigin(center, zoom2));
            if (Browser.any3d) {
              setTransform(this._container, topLeftOffset, scale2);
            } else {
              setPosition(this._container, topLeftOffset);
            }
          },
          _reset: function() {
            this._update();
            this._updateTransform(this._center, this._zoom);
            for (var id in this._layers) {
              this._layers[id]._reset();
            }
          },
          _onZoomEnd: function() {
            for (var id in this._layers) {
              this._layers[id]._project();
            }
          },
          _updatePaths: function() {
            for (var id in this._layers) {
              this._layers[id]._update();
            }
          },
          _update: function() {
            var p = this.options.padding, size = this._map.getSize(), min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();
            this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());
            this._center = this._map.getCenter();
            this._zoom = this._map.getZoom();
          }
        });
        var Canvas = Renderer.extend({
          options: {
            tolerance: 0
          },
          getEvents: function() {
            var events = Renderer.prototype.getEvents.call(this);
            events.viewprereset = this._onViewPreReset;
            return events;
          },
          _onViewPreReset: function() {
            this._postponeUpdatePaths = true;
          },
          onAdd: function() {
            Renderer.prototype.onAdd.call(this);
            this._draw();
          },
          _initContainer: function() {
            var container = this._container = document.createElement("canvas");
            on(container, "mousemove", this._onMouseMove, this);
            on(container, "click dblclick mousedown mouseup contextmenu", this._onClick, this);
            on(container, "mouseout", this._handleMouseOut, this);
            container["_leaflet_disable_events"] = true;
            this._ctx = container.getContext("2d");
          },
          _destroyContainer: function() {
            cancelAnimFrame(this._redrawRequest);
            delete this._ctx;
            remove(this._container);
            off(this._container);
            delete this._container;
          },
          _updatePaths: function() {
            if (this._postponeUpdatePaths) {
              return;
            }
            var layer;
            this._redrawBounds = null;
            for (var id in this._layers) {
              layer = this._layers[id];
              layer._update();
            }
            this._redraw();
          },
          _update: function() {
            if (this._map._animatingZoom && this._bounds) {
              return;
            }
            Renderer.prototype._update.call(this);
            var b = this._bounds, container = this._container, size = b.getSize(), m = Browser.retina ? 2 : 1;
            setPosition(container, b.min);
            container.width = m * size.x;
            container.height = m * size.y;
            container.style.width = size.x + "px";
            container.style.height = size.y + "px";
            if (Browser.retina) {
              this._ctx.scale(2, 2);
            }
            this._ctx.translate(-b.min.x, -b.min.y);
            this.fire("update");
          },
          _reset: function() {
            Renderer.prototype._reset.call(this);
            if (this._postponeUpdatePaths) {
              this._postponeUpdatePaths = false;
              this._updatePaths();
            }
          },
          _initPath: function(layer) {
            this._updateDashArray(layer);
            this._layers[stamp(layer)] = layer;
            var order = layer._order = {
              layer,
              prev: this._drawLast,
              next: null
            };
            if (this._drawLast) {
              this._drawLast.next = order;
            }
            this._drawLast = order;
            this._drawFirst = this._drawFirst || this._drawLast;
          },
          _addPath: function(layer) {
            this._requestRedraw(layer);
          },
          _removePath: function(layer) {
            var order = layer._order;
            var next = order.next;
            var prev = order.prev;
            if (next) {
              next.prev = prev;
            } else {
              this._drawLast = prev;
            }
            if (prev) {
              prev.next = next;
            } else {
              this._drawFirst = next;
            }
            delete layer._order;
            delete this._layers[stamp(layer)];
            this._requestRedraw(layer);
          },
          _updatePath: function(layer) {
            this._extendRedrawBounds(layer);
            layer._project();
            layer._update();
            this._requestRedraw(layer);
          },
          _updateStyle: function(layer) {
            this._updateDashArray(layer);
            this._requestRedraw(layer);
          },
          _updateDashArray: function(layer) {
            if (typeof layer.options.dashArray === "string") {
              var parts = layer.options.dashArray.split(/[, ]+/), dashArray = [], dashValue, i;
              for (i = 0; i < parts.length; i++) {
                dashValue = Number(parts[i]);
                if (isNaN(dashValue)) {
                  return;
                }
                dashArray.push(dashValue);
              }
              layer.options._dashArray = dashArray;
            } else {
              layer.options._dashArray = layer.options.dashArray;
            }
          },
          _requestRedraw: function(layer) {
            if (!this._map) {
              return;
            }
            this._extendRedrawBounds(layer);
            this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
          },
          _extendRedrawBounds: function(layer) {
            if (layer._pxBounds) {
              var padding = (layer.options.weight || 0) + 1;
              this._redrawBounds = this._redrawBounds || new Bounds();
              this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
              this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
            }
          },
          _redraw: function() {
            this._redrawRequest = null;
            if (this._redrawBounds) {
              this._redrawBounds.min._floor();
              this._redrawBounds.max._ceil();
            }
            this._clear();
            this._draw();
            this._redrawBounds = null;
          },
          _clear: function() {
            var bounds = this._redrawBounds;
            if (bounds) {
              var size = bounds.getSize();
              this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
            } else {
              this._ctx.save();
              this._ctx.setTransform(1, 0, 0, 1, 0, 0);
              this._ctx.clearRect(0, 0, this._container.width, this._container.height);
              this._ctx.restore();
            }
          },
          _draw: function() {
            var layer, bounds = this._redrawBounds;
            this._ctx.save();
            if (bounds) {
              var size = bounds.getSize();
              this._ctx.beginPath();
              this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
              this._ctx.clip();
            }
            this._drawing = true;
            for (var order = this._drawFirst; order; order = order.next) {
              layer = order.layer;
              if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {
                layer._updatePath();
              }
            }
            this._drawing = false;
            this._ctx.restore();
          },
          _updatePoly: function(layer, closed) {
            if (!this._drawing) {
              return;
            }
            var i, j, len2, p, parts = layer._parts, len = parts.length, ctx = this._ctx;
            if (!len) {
              return;
            }
            ctx.beginPath();
            for (i = 0; i < len; i++) {
              for (j = 0, len2 = parts[i].length; j < len2; j++) {
                p = parts[i][j];
                ctx[j ? "lineTo" : "moveTo"](p.x, p.y);
              }
              if (closed) {
                ctx.closePath();
              }
            }
            this._fillStroke(ctx, layer);
          },
          _updateCircle: function(layer) {
            if (!this._drawing || layer._empty()) {
              return;
            }
            var p = layer._point, ctx = this._ctx, r = Math.max(Math.round(layer._radius), 1), s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;
            if (s !== 1) {
              ctx.save();
              ctx.scale(1, s);
            }
            ctx.beginPath();
            ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);
            if (s !== 1) {
              ctx.restore();
            }
            this._fillStroke(ctx, layer);
          },
          _fillStroke: function(ctx, layer) {
            var options = layer.options;
            if (options.fill) {
              ctx.globalAlpha = options.fillOpacity;
              ctx.fillStyle = options.fillColor || options.color;
              ctx.fill(options.fillRule || "evenodd");
            }
            if (options.stroke && options.weight !== 0) {
              if (ctx.setLineDash) {
                ctx.setLineDash(layer.options && layer.options._dashArray || []);
              }
              ctx.globalAlpha = options.opacity;
              ctx.lineWidth = options.weight;
              ctx.strokeStyle = options.color;
              ctx.lineCap = options.lineCap;
              ctx.lineJoin = options.lineJoin;
              ctx.stroke();
            }
          },
          _onClick: function(e) {
            var point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;
            for (var order = this._drawFirst; order; order = order.next) {
              layer = order.layer;
              if (layer.options.interactive && layer._containsPoint(point)) {
                if (!(e.type === "click" || e.type === "preclick") || !this._map._draggableMoved(layer)) {
                  clickedLayer = layer;
                }
              }
            }
            this._fireEvent(clickedLayer ? [clickedLayer] : false, e);
          },
          _onMouseMove: function(e) {
            if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
              return;
            }
            var point = this._map.mouseEventToLayerPoint(e);
            this._handleMouseHover(e, point);
          },
          _handleMouseOut: function(e) {
            var layer = this._hoveredLayer;
            if (layer) {
              removeClass(this._container, "leaflet-interactive");
              this._fireEvent([layer], e, "mouseout");
              this._hoveredLayer = null;
              this._mouseHoverThrottled = false;
            }
          },
          _handleMouseHover: function(e, point) {
            if (this._mouseHoverThrottled) {
              return;
            }
            var layer, candidateHoveredLayer;
            for (var order = this._drawFirst; order; order = order.next) {
              layer = order.layer;
              if (layer.options.interactive && layer._containsPoint(point)) {
                candidateHoveredLayer = layer;
              }
            }
            if (candidateHoveredLayer !== this._hoveredLayer) {
              this._handleMouseOut(e);
              if (candidateHoveredLayer) {
                addClass(this._container, "leaflet-interactive");
                this._fireEvent([candidateHoveredLayer], e, "mouseover");
                this._hoveredLayer = candidateHoveredLayer;
              }
            }
            this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : false, e);
            this._mouseHoverThrottled = true;
            setTimeout(bind(function() {
              this._mouseHoverThrottled = false;
            }, this), 32);
          },
          _fireEvent: function(layers2, e, type) {
            this._map._fireDOMEvent(e, type || e.type, layers2);
          },
          _bringToFront: function(layer) {
            var order = layer._order;
            if (!order) {
              return;
            }
            var next = order.next;
            var prev = order.prev;
            if (next) {
              next.prev = prev;
            } else {
              return;
            }
            if (prev) {
              prev.next = next;
            } else if (next) {
              this._drawFirst = next;
            }
            order.prev = this._drawLast;
            this._drawLast.next = order;
            order.next = null;
            this._drawLast = order;
            this._requestRedraw(layer);
          },
          _bringToBack: function(layer) {
            var order = layer._order;
            if (!order) {
              return;
            }
            var next = order.next;
            var prev = order.prev;
            if (prev) {
              prev.next = next;
            } else {
              return;
            }
            if (next) {
              next.prev = prev;
            } else if (prev) {
              this._drawLast = prev;
            }
            order.prev = null;
            order.next = this._drawFirst;
            this._drawFirst.prev = order;
            this._drawFirst = order;
            this._requestRedraw(layer);
          }
        });
        function canvas(options) {
          return Browser.canvas ? new Canvas(options) : null;
        }
        var vmlCreate = function() {
          try {
            document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml");
            return function(name) {
              return document.createElement("<lvml:" + name + ' class="lvml">');
            };
          } catch (e) {
          }
          return function(name) {
            return document.createElement("<" + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
          };
        }();
        var vmlMixin = {
          _initContainer: function() {
            this._container = create$1("div", "leaflet-vml-container");
          },
          _update: function() {
            if (this._map._animatingZoom) {
              return;
            }
            Renderer.prototype._update.call(this);
            this.fire("update");
          },
          _initPath: function(layer) {
            var container = layer._container = vmlCreate("shape");
            addClass(container, "leaflet-vml-shape " + (this.options.className || ""));
            container.coordsize = "1 1";
            layer._path = vmlCreate("path");
            container.appendChild(layer._path);
            this._updateStyle(layer);
            this._layers[stamp(layer)] = layer;
          },
          _addPath: function(layer) {
            var container = layer._container;
            this._container.appendChild(container);
            if (layer.options.interactive) {
              layer.addInteractiveTarget(container);
            }
          },
          _removePath: function(layer) {
            var container = layer._container;
            remove(container);
            layer.removeInteractiveTarget(container);
            delete this._layers[stamp(layer)];
          },
          _updateStyle: function(layer) {
            var stroke = layer._stroke, fill = layer._fill, options = layer.options, container = layer._container;
            container.stroked = !!options.stroke;
            container.filled = !!options.fill;
            if (options.stroke) {
              if (!stroke) {
                stroke = layer._stroke = vmlCreate("stroke");
              }
              container.appendChild(stroke);
              stroke.weight = options.weight + "px";
              stroke.color = options.color;
              stroke.opacity = options.opacity;
              if (options.dashArray) {
                stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(" ") : options.dashArray.replace(/( *, *)/g, " ");
              } else {
                stroke.dashStyle = "";
              }
              stroke.endcap = options.lineCap.replace("butt", "flat");
              stroke.joinstyle = options.lineJoin;
            } else if (stroke) {
              container.removeChild(stroke);
              layer._stroke = null;
            }
            if (options.fill) {
              if (!fill) {
                fill = layer._fill = vmlCreate("fill");
              }
              container.appendChild(fill);
              fill.color = options.fillColor || options.color;
              fill.opacity = options.fillOpacity;
            } else if (fill) {
              container.removeChild(fill);
              layer._fill = null;
            }
          },
          _updateCircle: function(layer) {
            var p = layer._point.round(), r = Math.round(layer._radius), r2 = Math.round(layer._radiusY || r);
            this._setPath(layer, layer._empty() ? "M0 0" : "AL " + p.x + "," + p.y + " " + r + "," + r2 + " 0," + 65535 * 360);
          },
          _setPath: function(layer, path) {
            layer._path.v = path;
          },
          _bringToFront: function(layer) {
            toFront(layer._container);
          },
          _bringToBack: function(layer) {
            toBack(layer._container);
          }
        };
        var create = Browser.vml ? vmlCreate : svgCreate;
        var SVG = Renderer.extend({
          _initContainer: function() {
            this._container = create("svg");
            this._container.setAttribute("pointer-events", "none");
            this._rootGroup = create("g");
            this._container.appendChild(this._rootGroup);
          },
          _destroyContainer: function() {
            remove(this._container);
            off(this._container);
            delete this._container;
            delete this._rootGroup;
            delete this._svgSize;
          },
          _update: function() {
            if (this._map._animatingZoom && this._bounds) {
              return;
            }
            Renderer.prototype._update.call(this);
            var b = this._bounds, size = b.getSize(), container = this._container;
            if (!this._svgSize || !this._svgSize.equals(size)) {
              this._svgSize = size;
              container.setAttribute("width", size.x);
              container.setAttribute("height", size.y);
            }
            setPosition(container, b.min);
            container.setAttribute("viewBox", [b.min.x, b.min.y, size.x, size.y].join(" "));
            this.fire("update");
          },
          _initPath: function(layer) {
            var path = layer._path = create("path");
            if (layer.options.className) {
              addClass(path, layer.options.className);
            }
            if (layer.options.interactive) {
              addClass(path, "leaflet-interactive");
            }
            this._updateStyle(layer);
            this._layers[stamp(layer)] = layer;
          },
          _addPath: function(layer) {
            if (!this._rootGroup) {
              this._initContainer();
            }
            this._rootGroup.appendChild(layer._path);
            layer.addInteractiveTarget(layer._path);
          },
          _removePath: function(layer) {
            remove(layer._path);
            layer.removeInteractiveTarget(layer._path);
            delete this._layers[stamp(layer)];
          },
          _updatePath: function(layer) {
            layer._project();
            layer._update();
          },
          _updateStyle: function(layer) {
            var path = layer._path, options = layer.options;
            if (!path) {
              return;
            }
            if (options.stroke) {
              path.setAttribute("stroke", options.color);
              path.setAttribute("stroke-opacity", options.opacity);
              path.setAttribute("stroke-width", options.weight);
              path.setAttribute("stroke-linecap", options.lineCap);
              path.setAttribute("stroke-linejoin", options.lineJoin);
              if (options.dashArray) {
                path.setAttribute("stroke-dasharray", options.dashArray);
              } else {
                path.removeAttribute("stroke-dasharray");
              }
              if (options.dashOffset) {
                path.setAttribute("stroke-dashoffset", options.dashOffset);
              } else {
                path.removeAttribute("stroke-dashoffset");
              }
            } else {
              path.setAttribute("stroke", "none");
            }
            if (options.fill) {
              path.setAttribute("fill", options.fillColor || options.color);
              path.setAttribute("fill-opacity", options.fillOpacity);
              path.setAttribute("fill-rule", options.fillRule || "evenodd");
            } else {
              path.setAttribute("fill", "none");
            }
          },
          _updatePoly: function(layer, closed) {
            this._setPath(layer, pointsToPath(layer._parts, closed));
          },
          _updateCircle: function(layer) {
            var p = layer._point, r = Math.max(Math.round(layer._radius), 1), r2 = Math.max(Math.round(layer._radiusY), 1) || r, arc = "a" + r + "," + r2 + " 0 1,0 ";
            var d = layer._empty() ? "M0 0" : "M" + (p.x - r) + "," + p.y + arc + r * 2 + ",0 " + arc + -r * 2 + ",0 ";
            this._setPath(layer, d);
          },
          _setPath: function(layer, path) {
            layer._path.setAttribute("d", path);
          },
          _bringToFront: function(layer) {
            toFront(layer._path);
          },
          _bringToBack: function(layer) {
            toBack(layer._path);
          }
        });
        if (Browser.vml) {
          SVG.include(vmlMixin);
        }
        function svg(options) {
          return Browser.svg || Browser.vml ? new SVG(options) : null;
        }
        Map2.include({
          getRenderer: function(layer) {
            var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;
            if (!renderer) {
              renderer = this._renderer = this._createRenderer();
            }
            if (!this.hasLayer(renderer)) {
              this.addLayer(renderer);
            }
            return renderer;
          },
          _getPaneRenderer: function(name) {
            if (name === "overlayPane" || name === void 0) {
              return false;
            }
            var renderer = this._paneRenderers[name];
            if (renderer === void 0) {
              renderer = this._createRenderer({ pane: name });
              this._paneRenderers[name] = renderer;
            }
            return renderer;
          },
          _createRenderer: function(options) {
            return this.options.preferCanvas && canvas(options) || svg(options);
          }
        });
        var Rectangle = Polygon.extend({
          initialize: function(latLngBounds, options) {
            Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
          },
          setBounds: function(latLngBounds) {
            return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
          },
          _boundsToLatLngs: function(latLngBounds) {
            latLngBounds = toLatLngBounds(latLngBounds);
            return [
              latLngBounds.getSouthWest(),
              latLngBounds.getNorthWest(),
              latLngBounds.getNorthEast(),
              latLngBounds.getSouthEast()
            ];
          }
        });
        function rectangle(latLngBounds, options) {
          return new Rectangle(latLngBounds, options);
        }
        SVG.create = create;
        SVG.pointsToPath = pointsToPath;
        GeoJSON.geometryToLayer = geometryToLayer;
        GeoJSON.coordsToLatLng = coordsToLatLng;
        GeoJSON.coordsToLatLngs = coordsToLatLngs;
        GeoJSON.latLngToCoords = latLngToCoords;
        GeoJSON.latLngsToCoords = latLngsToCoords;
        GeoJSON.getFeature = getFeature;
        GeoJSON.asFeature = asFeature;
        Map2.mergeOptions({
          boxZoom: true
        });
        var BoxZoom = Handler.extend({
          initialize: function(map) {
            this._map = map;
            this._container = map._container;
            this._pane = map._panes.overlayPane;
            this._resetStateTimeout = 0;
            map.on("unload", this._destroy, this);
          },
          addHooks: function() {
            on(this._container, "mousedown", this._onMouseDown, this);
          },
          removeHooks: function() {
            off(this._container, "mousedown", this._onMouseDown, this);
          },
          moved: function() {
            return this._moved;
          },
          _destroy: function() {
            remove(this._pane);
            delete this._pane;
          },
          _resetState: function() {
            this._resetStateTimeout = 0;
            this._moved = false;
          },
          _clearDeferredResetState: function() {
            if (this._resetStateTimeout !== 0) {
              clearTimeout(this._resetStateTimeout);
              this._resetStateTimeout = 0;
            }
          },
          _onMouseDown: function(e) {
            if (!e.shiftKey || e.which !== 1 && e.button !== 1) {
              return false;
            }
            this._clearDeferredResetState();
            this._resetState();
            disableTextSelection();
            disableImageDrag();
            this._startPoint = this._map.mouseEventToContainerPoint(e);
            on(document, {
              contextmenu: stop,
              mousemove: this._onMouseMove,
              mouseup: this._onMouseUp,
              keydown: this._onKeyDown
            }, this);
          },
          _onMouseMove: function(e) {
            if (!this._moved) {
              this._moved = true;
              this._box = create$1("div", "leaflet-zoom-box", this._container);
              addClass(this._container, "leaflet-crosshair");
              this._map.fire("boxzoomstart");
            }
            this._point = this._map.mouseEventToContainerPoint(e);
            var bounds = new Bounds(this._point, this._startPoint), size = bounds.getSize();
            setPosition(this._box, bounds.min);
            this._box.style.width = size.x + "px";
            this._box.style.height = size.y + "px";
          },
          _finish: function() {
            if (this._moved) {
              remove(this._box);
              removeClass(this._container, "leaflet-crosshair");
            }
            enableTextSelection();
            enableImageDrag();
            off(document, {
              contextmenu: stop,
              mousemove: this._onMouseMove,
              mouseup: this._onMouseUp,
              keydown: this._onKeyDown
            }, this);
          },
          _onMouseUp: function(e) {
            if (e.which !== 1 && e.button !== 1) {
              return;
            }
            this._finish();
            if (!this._moved) {
              return;
            }
            this._clearDeferredResetState();
            this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);
            var bounds = new LatLngBounds(
              this._map.containerPointToLatLng(this._startPoint),
              this._map.containerPointToLatLng(this._point)
            );
            this._map.fitBounds(bounds).fire("boxzoomend", { boxZoomBounds: bounds });
          },
          _onKeyDown: function(e) {
            if (e.keyCode === 27) {
              this._finish();
              this._clearDeferredResetState();
              this._resetState();
            }
          }
        });
        Map2.addInitHook("addHandler", "boxZoom", BoxZoom);
        Map2.mergeOptions({
          doubleClickZoom: true
        });
        var DoubleClickZoom = Handler.extend({
          addHooks: function() {
            this._map.on("dblclick", this._onDoubleClick, this);
          },
          removeHooks: function() {
            this._map.off("dblclick", this._onDoubleClick, this);
          },
          _onDoubleClick: function(e) {
            var map = this._map, oldZoom = map.getZoom(), delta = map.options.zoomDelta, zoom2 = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;
            if (map.options.doubleClickZoom === "center") {
              map.setZoom(zoom2);
            } else {
              map.setZoomAround(e.containerPoint, zoom2);
            }
          }
        });
        Map2.addInitHook("addHandler", "doubleClickZoom", DoubleClickZoom);
        Map2.mergeOptions({
          dragging: true,
          inertia: true,
          inertiaDeceleration: 3400,
          inertiaMaxSpeed: Infinity,
          easeLinearity: 0.2,
          worldCopyJump: false,
          maxBoundsViscosity: 0
        });
        var Drag = Handler.extend({
          addHooks: function() {
            if (!this._draggable) {
              var map = this._map;
              this._draggable = new Draggable(map._mapPane, map._container);
              this._draggable.on({
                dragstart: this._onDragStart,
                drag: this._onDrag,
                dragend: this._onDragEnd
              }, this);
              this._draggable.on("predrag", this._onPreDragLimit, this);
              if (map.options.worldCopyJump) {
                this._draggable.on("predrag", this._onPreDragWrap, this);
                map.on("zoomend", this._onZoomEnd, this);
                map.whenReady(this._onZoomEnd, this);
              }
            }
            addClass(this._map._container, "leaflet-grab leaflet-touch-drag");
            this._draggable.enable();
            this._positions = [];
            this._times = [];
          },
          removeHooks: function() {
            removeClass(this._map._container, "leaflet-grab");
            removeClass(this._map._container, "leaflet-touch-drag");
            this._draggable.disable();
          },
          moved: function() {
            return this._draggable && this._draggable._moved;
          },
          moving: function() {
            return this._draggable && this._draggable._moving;
          },
          _onDragStart: function() {
            var map = this._map;
            map._stop();
            if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
              var bounds = toLatLngBounds(this._map.options.maxBounds);
              this._offsetLimit = toBounds(
                this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
                this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize())
              );
              this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
            } else {
              this._offsetLimit = null;
            }
            map.fire("movestart").fire("dragstart");
            if (map.options.inertia) {
              this._positions = [];
              this._times = [];
            }
          },
          _onDrag: function(e) {
            if (this._map.options.inertia) {
              var time = this._lastTime = +new Date(), pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;
              this._positions.push(pos);
              this._times.push(time);
              this._prunePositions(time);
            }
            this._map.fire("move", e).fire("drag", e);
          },
          _prunePositions: function(time) {
            while (this._positions.length > 1 && time - this._times[0] > 50) {
              this._positions.shift();
              this._times.shift();
            }
          },
          _onZoomEnd: function() {
            var pxCenter = this._map.getSize().divideBy(2), pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);
            this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
            this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
          },
          _viscousLimit: function(value, threshold) {
            return value - (value - threshold) * this._viscosity;
          },
          _onPreDragLimit: function() {
            if (!this._viscosity || !this._offsetLimit) {
              return;
            }
            var offset = this._draggable._newPos.subtract(this._draggable._startPos);
            var limit = this._offsetLimit;
            if (offset.x < limit.min.x) {
              offset.x = this._viscousLimit(offset.x, limit.min.x);
            }
            if (offset.y < limit.min.y) {
              offset.y = this._viscousLimit(offset.y, limit.min.y);
            }
            if (offset.x > limit.max.x) {
              offset.x = this._viscousLimit(offset.x, limit.max.x);
            }
            if (offset.y > limit.max.y) {
              offset.y = this._viscousLimit(offset.y, limit.max.y);
            }
            this._draggable._newPos = this._draggable._startPos.add(offset);
          },
          _onPreDragWrap: function() {
            var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x = this._draggable._newPos.x, newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx, newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx, newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
            this._draggable._absPos = this._draggable._newPos.clone();
            this._draggable._newPos.x = newX;
          },
          _onDragEnd: function(e) {
            var map = this._map, options = map.options, noInertia = !options.inertia || e.noInertia || this._times.length < 2;
            map.fire("dragend", e);
            if (noInertia) {
              map.fire("moveend");
            } else {
              this._prunePositions(+new Date());
              var direction = this._lastPos.subtract(this._positions[0]), duration = (this._lastTime - this._times[0]) / 1e3, ease = options.easeLinearity, speedVector = direction.multiplyBy(ease / duration), speed = speedVector.distanceTo([0, 0]), limitedSpeed = Math.min(options.inertiaMaxSpeed, speed), limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed), decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease), offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
              if (!offset.x && !offset.y) {
                map.fire("moveend");
              } else {
                offset = map._limitOffset(offset, map.options.maxBounds);
                requestAnimFrame(function() {
                  map.panBy(offset, {
                    duration: decelerationDuration,
                    easeLinearity: ease,
                    noMoveStart: true,
                    animate: true
                  });
                });
              }
            }
          }
        });
        Map2.addInitHook("addHandler", "dragging", Drag);
        Map2.mergeOptions({
          keyboard: true,
          keyboardPanDelta: 80
        });
        var Keyboard = Handler.extend({
          keyCodes: {
            left: [37],
            right: [39],
            down: [40],
            up: [38],
            zoomIn: [187, 107, 61, 171],
            zoomOut: [189, 109, 54, 173]
          },
          initialize: function(map) {
            this._map = map;
            this._setPanDelta(map.options.keyboardPanDelta);
            this._setZoomDelta(map.options.zoomDelta);
          },
          addHooks: function() {
            var container = this._map._container;
            if (container.tabIndex <= 0) {
              container.tabIndex = "0";
            }
            on(container, {
              focus: this._onFocus,
              blur: this._onBlur,
              mousedown: this._onMouseDown
            }, this);
            this._map.on({
              focus: this._addHooks,
              blur: this._removeHooks
            }, this);
          },
          removeHooks: function() {
            this._removeHooks();
            off(this._map._container, {
              focus: this._onFocus,
              blur: this._onBlur,
              mousedown: this._onMouseDown
            }, this);
            this._map.off({
              focus: this._addHooks,
              blur: this._removeHooks
            }, this);
          },
          _onMouseDown: function() {
            if (this._focused) {
              return;
            }
            var body = document.body, docEl = document.documentElement, top = body.scrollTop || docEl.scrollTop, left = body.scrollLeft || docEl.scrollLeft;
            this._map._container.focus();
            window.scrollTo(left, top);
          },
          _onFocus: function() {
            this._focused = true;
            this._map.fire("focus");
          },
          _onBlur: function() {
            this._focused = false;
            this._map.fire("blur");
          },
          _setPanDelta: function(panDelta) {
            var keys = this._panKeys = {}, codes = this.keyCodes, i, len;
            for (i = 0, len = codes.left.length; i < len; i++) {
              keys[codes.left[i]] = [-1 * panDelta, 0];
            }
            for (i = 0, len = codes.right.length; i < len; i++) {
              keys[codes.right[i]] = [panDelta, 0];
            }
            for (i = 0, len = codes.down.length; i < len; i++) {
              keys[codes.down[i]] = [0, panDelta];
            }
            for (i = 0, len = codes.up.length; i < len; i++) {
              keys[codes.up[i]] = [0, -1 * panDelta];
            }
          },
          _setZoomDelta: function(zoomDelta) {
            var keys = this._zoomKeys = {}, codes = this.keyCodes, i, len;
            for (i = 0, len = codes.zoomIn.length; i < len; i++) {
              keys[codes.zoomIn[i]] = zoomDelta;
            }
            for (i = 0, len = codes.zoomOut.length; i < len; i++) {
              keys[codes.zoomOut[i]] = -zoomDelta;
            }
          },
          _addHooks: function() {
            on(document, "keydown", this._onKeyDown, this);
          },
          _removeHooks: function() {
            off(document, "keydown", this._onKeyDown, this);
          },
          _onKeyDown: function(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) {
              return;
            }
            var key = e.keyCode, map = this._map, offset;
            if (key in this._panKeys) {
              if (!map._panAnim || !map._panAnim._inProgress) {
                offset = this._panKeys[key];
                if (e.shiftKey) {
                  offset = toPoint(offset).multiplyBy(3);
                }
                map.panBy(offset);
                if (map.options.maxBounds) {
                  map.panInsideBounds(map.options.maxBounds);
                }
              }
            } else if (key in this._zoomKeys) {
              map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);
            } else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {
              map.closePopup();
            } else {
              return;
            }
            stop(e);
          }
        });
        Map2.addInitHook("addHandler", "keyboard", Keyboard);
        Map2.mergeOptions({
          scrollWheelZoom: true,
          wheelDebounceTime: 40,
          wheelPxPerZoomLevel: 60
        });
        var ScrollWheelZoom = Handler.extend({
          addHooks: function() {
            on(this._map._container, "wheel", this._onWheelScroll, this);
            this._delta = 0;
          },
          removeHooks: function() {
            off(this._map._container, "wheel", this._onWheelScroll, this);
          },
          _onWheelScroll: function(e) {
            var delta = getWheelDelta(e);
            var debounce = this._map.options.wheelDebounceTime;
            this._delta += delta;
            this._lastMousePos = this._map.mouseEventToContainerPoint(e);
            if (!this._startTime) {
              this._startTime = +new Date();
            }
            var left = Math.max(debounce - (+new Date() - this._startTime), 0);
            clearTimeout(this._timer);
            this._timer = setTimeout(bind(this._performZoom, this), left);
            stop(e);
          },
          _performZoom: function() {
            var map = this._map, zoom2 = map.getZoom(), snap = this._map.options.zoomSnap || 0;
            map._stop();
            var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2, d4 = snap ? Math.ceil(d3 / snap) * snap : d3, delta = map._limitZoom(zoom2 + (this._delta > 0 ? d4 : -d4)) - zoom2;
            this._delta = 0;
            this._startTime = null;
            if (!delta) {
              return;
            }
            if (map.options.scrollWheelZoom === "center") {
              map.setZoom(zoom2 + delta);
            } else {
              map.setZoomAround(this._lastMousePos, zoom2 + delta);
            }
          }
        });
        Map2.addInitHook("addHandler", "scrollWheelZoom", ScrollWheelZoom);
        var tapHoldDelay = 600;
        Map2.mergeOptions({
          tapHold: Browser.touchNative && Browser.safari && Browser.mobile,
          tapTolerance: 15
        });
        var TapHold = Handler.extend({
          addHooks: function() {
            on(this._map._container, "touchstart", this._onDown, this);
          },
          removeHooks: function() {
            off(this._map._container, "touchstart", this._onDown, this);
          },
          _onDown: function(e) {
            clearTimeout(this._holdTimeout);
            if (e.touches.length !== 1) {
              return;
            }
            var first = e.touches[0];
            this._startPos = this._newPos = new Point(first.clientX, first.clientY);
            this._holdTimeout = setTimeout(bind(function() {
              this._cancel();
              if (!this._isTapValid()) {
                return;
              }
              on(document, "touchend", preventDefault);
              on(document, "touchend touchcancel", this._cancelClickPrevent);
              this._simulateEvent("contextmenu", first);
            }, this), tapHoldDelay);
            on(document, "touchend touchcancel contextmenu", this._cancel, this);
            on(document, "touchmove", this._onMove, this);
          },
          _cancelClickPrevent: function cancelClickPrevent() {
            off(document, "touchend", preventDefault);
            off(document, "touchend touchcancel", cancelClickPrevent);
          },
          _cancel: function() {
            clearTimeout(this._holdTimeout);
            off(document, "touchend touchcancel contextmenu", this._cancel, this);
            off(document, "touchmove", this._onMove, this);
          },
          _onMove: function(e) {
            var first = e.touches[0];
            this._newPos = new Point(first.clientX, first.clientY);
          },
          _isTapValid: function() {
            return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
          },
          _simulateEvent: function(type, e) {
            var simulatedEvent = new MouseEvent(type, {
              bubbles: true,
              cancelable: true,
              view: window,
              screenX: e.screenX,
              screenY: e.screenY,
              clientX: e.clientX,
              clientY: e.clientY
            });
            simulatedEvent._simulated = true;
            e.target.dispatchEvent(simulatedEvent);
          }
        });
        Map2.addInitHook("addHandler", "tapHold", TapHold);
        Map2.mergeOptions({
          touchZoom: Browser.touch,
          bounceAtZoomLimits: true
        });
        var TouchZoom = Handler.extend({
          addHooks: function() {
            addClass(this._map._container, "leaflet-touch-zoom");
            on(this._map._container, "touchstart", this._onTouchStart, this);
          },
          removeHooks: function() {
            removeClass(this._map._container, "leaflet-touch-zoom");
            off(this._map._container, "touchstart", this._onTouchStart, this);
          },
          _onTouchStart: function(e) {
            var map = this._map;
            if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {
              return;
            }
            var p1 = map.mouseEventToContainerPoint(e.touches[0]), p2 = map.mouseEventToContainerPoint(e.touches[1]);
            this._centerPoint = map.getSize()._divideBy(2);
            this._startLatLng = map.containerPointToLatLng(this._centerPoint);
            if (map.options.touchZoom !== "center") {
              this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
            }
            this._startDist = p1.distanceTo(p2);
            this._startZoom = map.getZoom();
            this._moved = false;
            this._zooming = true;
            map._stop();
            on(document, "touchmove", this._onTouchMove, this);
            on(document, "touchend touchcancel", this._onTouchEnd, this);
            preventDefault(e);
          },
          _onTouchMove: function(e) {
            if (!e.touches || e.touches.length !== 2 || !this._zooming) {
              return;
            }
            var map = this._map, p1 = map.mouseEventToContainerPoint(e.touches[0]), p2 = map.mouseEventToContainerPoint(e.touches[1]), scale2 = p1.distanceTo(p2) / this._startDist;
            this._zoom = map.getScaleZoom(scale2, this._startZoom);
            if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale2 < 1 || this._zoom > map.getMaxZoom() && scale2 > 1)) {
              this._zoom = map._limitZoom(this._zoom);
            }
            if (map.options.touchZoom === "center") {
              this._center = this._startLatLng;
              if (scale2 === 1) {
                return;
              }
            } else {
              var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
              if (scale2 === 1 && delta.x === 0 && delta.y === 0) {
                return;
              }
              this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
            }
            if (!this._moved) {
              map._moveStart(true, false);
              this._moved = true;
            }
            cancelAnimFrame(this._animRequest);
            var moveFn = bind(map._move, map, this._center, this._zoom, { pinch: true, round: false });
            this._animRequest = requestAnimFrame(moveFn, this, true);
            preventDefault(e);
          },
          _onTouchEnd: function() {
            if (!this._moved || !this._zooming) {
              this._zooming = false;
              return;
            }
            this._zooming = false;
            cancelAnimFrame(this._animRequest);
            off(document, "touchmove", this._onTouchMove, this);
            off(document, "touchend touchcancel", this._onTouchEnd, this);
            if (this._map.options.zoomAnimation) {
              this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
            } else {
              this._map._resetView(this._center, this._map._limitZoom(this._zoom));
            }
          }
        });
        Map2.addInitHook("addHandler", "touchZoom", TouchZoom);
        Map2.BoxZoom = BoxZoom;
        Map2.DoubleClickZoom = DoubleClickZoom;
        Map2.Drag = Drag;
        Map2.Keyboard = Keyboard;
        Map2.ScrollWheelZoom = ScrollWheelZoom;
        Map2.TapHold = TapHold;
        Map2.TouchZoom = TouchZoom;
        exports2.Bounds = Bounds;
        exports2.Browser = Browser;
        exports2.CRS = CRS;
        exports2.Canvas = Canvas;
        exports2.Circle = Circle;
        exports2.CircleMarker = CircleMarker;
        exports2.Class = Class;
        exports2.Control = Control;
        exports2.DivIcon = DivIcon;
        exports2.DivOverlay = DivOverlay;
        exports2.DomEvent = DomEvent;
        exports2.DomUtil = DomUtil;
        exports2.Draggable = Draggable;
        exports2.Evented = Evented;
        exports2.FeatureGroup = FeatureGroup;
        exports2.GeoJSON = GeoJSON;
        exports2.GridLayer = GridLayer;
        exports2.Handler = Handler;
        exports2.Icon = Icon;
        exports2.ImageOverlay = ImageOverlay;
        exports2.LatLng = LatLng;
        exports2.LatLngBounds = LatLngBounds;
        exports2.Layer = Layer;
        exports2.LayerGroup = LayerGroup;
        exports2.LineUtil = LineUtil;
        exports2.Map = Map2;
        exports2.Marker = Marker;
        exports2.Mixin = Mixin;
        exports2.Path = Path;
        exports2.Point = Point;
        exports2.PolyUtil = PolyUtil;
        exports2.Polygon = Polygon;
        exports2.Polyline = Polyline;
        exports2.Popup = Popup;
        exports2.PosAnimation = PosAnimation;
        exports2.Projection = index;
        exports2.Rectangle = Rectangle;
        exports2.Renderer = Renderer;
        exports2.SVG = SVG;
        exports2.SVGOverlay = SVGOverlay;
        exports2.TileLayer = TileLayer;
        exports2.Tooltip = Tooltip;
        exports2.Transformation = Transformation;
        exports2.Util = Util;
        exports2.VideoOverlay = VideoOverlay;
        exports2.bind = bind;
        exports2.bounds = toBounds;
        exports2.canvas = canvas;
        exports2.circle = circle;
        exports2.circleMarker = circleMarker;
        exports2.control = control;
        exports2.divIcon = divIcon;
        exports2.extend = extend;
        exports2.featureGroup = featureGroup;
        exports2.geoJSON = geoJSON;
        exports2.geoJson = geoJson;
        exports2.gridLayer = gridLayer;
        exports2.icon = icon;
        exports2.imageOverlay = imageOverlay;
        exports2.latLng = toLatLng;
        exports2.latLngBounds = toLatLngBounds;
        exports2.layerGroup = layerGroup;
        exports2.map = createMap;
        exports2.marker = marker;
        exports2.point = toPoint;
        exports2.polygon = polygon;
        exports2.polyline = polyline;
        exports2.popup = popup;
        exports2.rectangle = rectangle;
        exports2.setOptions = setOptions;
        exports2.stamp = stamp;
        exports2.svg = svg;
        exports2.svgOverlay = svgOverlay;
        exports2.tileLayer = tileLayer;
        exports2.tooltip = tooltip;
        exports2.transformation = toTransformation;
        exports2.version = version;
        exports2.videoOverlay = videoOverlay;
        var oldL = window.L;
        exports2.noConflict = function() {
          window.L = oldL;
          return this;
        };
        window.L = exports2;
      });
    }
  });

  // node_modules/@codemirror/state/dist/index.cjs
  var require_dist = __commonJS({
    "node_modules/@codemirror/state/dist/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var Text = class {
        constructor() {
        }
        lineAt(pos) {
          if (pos < 0 || pos > this.length)
            throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
          return this.lineInner(pos, false, 1, 0);
        }
        line(n) {
          if (n < 1 || n > this.lines)
            throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
          return this.lineInner(n, true, 1, 0);
        }
        replace(from, to, text) {
          let parts = [];
          this.decompose(0, from, parts, 2);
          if (text.length)
            text.decompose(0, text.length, parts, 1 | 2);
          this.decompose(to, this.length, parts, 1);
          return TextNode.from(parts, this.length - (to - from) + text.length);
        }
        append(other) {
          return this.replace(this.length, this.length, other);
        }
        slice(from, to = this.length) {
          let parts = [];
          this.decompose(from, to, parts, 0);
          return TextNode.from(parts, to - from);
        }
        eq(other) {
          if (other == this)
            return true;
          if (other.length != this.length || other.lines != this.lines)
            return false;
          let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
          let a = new RawTextCursor(this), b = new RawTextCursor(other);
          for (let skip = start, pos = start; ; ) {
            a.next(skip);
            b.next(skip);
            skip = 0;
            if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)
              return false;
            pos += a.value.length;
            if (a.done || pos >= end)
              return true;
          }
        }
        iter(dir = 1) {
          return new RawTextCursor(this, dir);
        }
        iterRange(from, to = this.length) {
          return new PartialTextCursor(this, from, to);
        }
        iterLines(from, to) {
          let inner;
          if (from == null) {
            inner = this.iter();
          } else {
            if (to == null)
              to = this.lines + 1;
            let start = this.line(from).from;
            inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
          }
          return new LineCursor(inner);
        }
        toString() {
          return this.sliceString(0);
        }
        toJSON() {
          let lines = [];
          this.flatten(lines);
          return lines;
        }
        static of(text) {
          if (text.length == 0)
            throw new RangeError("A document must have at least one line");
          if (text.length == 1 && !text[0])
            return Text.empty;
          return text.length <= 32 ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
        }
      };
      var TextLeaf = class extends Text {
        constructor(text, length = textLength(text)) {
          super();
          this.text = text;
          this.length = length;
        }
        get lines() {
          return this.text.length;
        }
        get children() {
          return null;
        }
        lineInner(target, isLine, line, offset) {
          for (let i = 0; ; i++) {
            let string = this.text[i], end = offset + string.length;
            if ((isLine ? line : end) >= target)
              return new Line(offset, end, line, string);
            offset = end + 1;
            line++;
          }
        }
        decompose(from, to, target, open2) {
          let text = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
          if (open2 & 1) {
            let prev = target.pop();
            let joined = appendText(text.text, prev.text.slice(), 0, text.length);
            if (joined.length <= 32) {
              target.push(new TextLeaf(joined, prev.length + text.length));
            } else {
              let mid = joined.length >> 1;
              target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
            }
          } else {
            target.push(text);
          }
        }
        replace(from, to, text) {
          if (!(text instanceof TextLeaf))
            return super.replace(from, to, text);
          let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);
          let newLen = this.length + text.length - (to - from);
          if (lines.length <= 32)
            return new TextLeaf(lines, newLen);
          return TextNode.from(TextLeaf.split(lines, []), newLen);
        }
        sliceString(from, to = this.length, lineSep = "\n") {
          let result = "";
          for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
            let line = this.text[i], end = pos + line.length;
            if (pos > from && i)
              result += lineSep;
            if (from < end && to > pos)
              result += line.slice(Math.max(0, from - pos), to - pos);
            pos = end + 1;
          }
          return result;
        }
        flatten(target) {
          for (let line of this.text)
            target.push(line);
        }
        scanIdentical() {
          return 0;
        }
        static split(text, target) {
          let part = [], len = -1;
          for (let line of text) {
            part.push(line);
            len += line.length + 1;
            if (part.length == 32) {
              target.push(new TextLeaf(part, len));
              part = [];
              len = -1;
            }
          }
          if (len > -1)
            target.push(new TextLeaf(part, len));
          return target;
        }
      };
      var TextNode = class extends Text {
        constructor(children, length) {
          super();
          this.children = children;
          this.length = length;
          this.lines = 0;
          for (let child of children)
            this.lines += child.lines;
        }
        lineInner(target, isLine, line, offset) {
          for (let i = 0; ; i++) {
            let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;
            if ((isLine ? endLine : end) >= target)
              return child.lineInner(target, isLine, line, offset);
            offset = end + 1;
            line = endLine + 1;
          }
        }
        decompose(from, to, target, open2) {
          for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
            let child = this.children[i], end = pos + child.length;
            if (from <= end && to >= pos) {
              let childOpen = open2 & ((pos <= from ? 1 : 0) | (end >= to ? 2 : 0));
              if (pos >= from && end <= to && !childOpen)
                target.push(child);
              else
                child.decompose(from - pos, to - pos, target, childOpen);
            }
            pos = end + 1;
          }
        }
        replace(from, to, text) {
          if (text.lines < this.lines)
            for (let i = 0, pos = 0; i < this.children.length; i++) {
              let child = this.children[i], end = pos + child.length;
              if (from >= pos && to <= end) {
                let updated = child.replace(from - pos, to - pos, text);
                let totalLines = this.lines - child.lines + updated.lines;
                if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
                  let copy = this.children.slice();
                  copy[i] = updated;
                  return new TextNode(copy, this.length - (to - from) + text.length);
                }
                return super.replace(pos, end, updated);
              }
              pos = end + 1;
            }
          return super.replace(from, to, text);
        }
        sliceString(from, to = this.length, lineSep = "\n") {
          let result = "";
          for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
            let child = this.children[i], end = pos + child.length;
            if (pos > from && i)
              result += lineSep;
            if (from < end && to > pos)
              result += child.sliceString(from - pos, to - pos, lineSep);
            pos = end + 1;
          }
          return result;
        }
        flatten(target) {
          for (let child of this.children)
            child.flatten(target);
        }
        scanIdentical(other, dir) {
          if (!(other instanceof TextNode))
            return 0;
          let length = 0;
          let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
          for (; ; iA += dir, iB += dir) {
            if (iA == eA || iB == eB)
              return length;
            let chA = this.children[iA], chB = other.children[iB];
            if (chA != chB)
              return length + chA.scanIdentical(chB, dir);
            length += chA.length + 1;
          }
        }
        static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {
          let lines = 0;
          for (let ch of children)
            lines += ch.lines;
          if (lines < 32) {
            let flat = [];
            for (let ch of children)
              ch.flatten(flat);
            return new TextLeaf(flat, length);
          }
          let chunk = Math.max(32, lines >> 5), maxChunk = chunk << 1, minChunk = chunk >> 1;
          let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
          function add(child) {
            let last;
            if (child.lines > maxChunk && child instanceof TextNode) {
              for (let node of child.children)
                add(node);
            } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
              flush();
              chunked.push(child);
            } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32) {
              currentLines += child.lines;
              currentLen += child.length + 1;
              currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
            } else {
              if (currentLines + child.lines > chunk)
                flush();
              currentLines += child.lines;
              currentLen += child.length + 1;
              currentChunk.push(child);
            }
          }
          function flush() {
            if (currentLines == 0)
              return;
            chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
            currentLen = -1;
            currentLines = currentChunk.length = 0;
          }
          for (let child of children)
            add(child);
          flush();
          return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);
        }
      };
      Text.empty = new TextLeaf([""], 0);
      function textLength(text) {
        let length = -1;
        for (let line of text)
          length += line.length + 1;
        return length;
      }
      function appendText(text, target, from = 0, to = 1e9) {
        for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {
          let line = text[i], end = pos + line.length;
          if (end >= from) {
            if (end > to)
              line = line.slice(0, to - pos);
            if (pos < from)
              line = line.slice(from - pos);
            if (first) {
              target[target.length - 1] += line;
              first = false;
            } else
              target.push(line);
          }
          pos = end + 1;
        }
        return target;
      }
      function sliceText(text, from, to) {
        return appendText(text, [""], from, to);
      }
      var RawTextCursor = class {
        constructor(text, dir = 1) {
          this.dir = dir;
          this.done = false;
          this.lineBreak = false;
          this.value = "";
          this.nodes = [text];
          this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
        }
        nextInner(skip, dir) {
          this.done = this.lineBreak = false;
          for (; ; ) {
            let last = this.nodes.length - 1;
            let top = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;
            let size = top instanceof TextLeaf ? top.text.length : top.children.length;
            if (offset == (dir > 0 ? size : 0)) {
              if (last == 0) {
                this.done = true;
                this.value = "";
                return this;
              }
              if (dir > 0)
                this.offsets[last - 1]++;
              this.nodes.pop();
              this.offsets.pop();
            } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
              this.offsets[last] += dir;
              if (skip == 0) {
                this.lineBreak = true;
                this.value = "\n";
                return this;
              }
              skip--;
            } else if (top instanceof TextLeaf) {
              let next = top.text[offset + (dir < 0 ? -1 : 0)];
              this.offsets[last] += dir;
              if (next.length > Math.max(0, skip)) {
                this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
                return this;
              }
              skip -= next.length;
            } else {
              let next = top.children[offset + (dir < 0 ? -1 : 0)];
              if (skip > next.length) {
                skip -= next.length;
                this.offsets[last] += dir;
              } else {
                if (dir < 0)
                  this.offsets[last]--;
                this.nodes.push(next);
                this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
              }
            }
          }
        }
        next(skip = 0) {
          if (skip < 0) {
            this.nextInner(-skip, -this.dir);
            skip = this.value.length;
          }
          return this.nextInner(skip, this.dir);
        }
      };
      var PartialTextCursor = class {
        constructor(text, start, end) {
          this.value = "";
          this.done = false;
          this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
          this.pos = start > end ? text.length : 0;
          this.from = Math.min(start, end);
          this.to = Math.max(start, end);
        }
        nextInner(skip, dir) {
          if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
            this.value = "";
            this.done = true;
            return this;
          }
          skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
          let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
          if (skip > limit)
            skip = limit;
          limit -= skip;
          let { value } = this.cursor.next(skip);
          this.pos += (value.length + skip) * dir;
          this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
          this.done = !this.value;
          return this;
        }
        next(skip = 0) {
          if (skip < 0)
            skip = Math.max(skip, this.from - this.pos);
          else if (skip > 0)
            skip = Math.min(skip, this.to - this.pos);
          return this.nextInner(skip, this.cursor.dir);
        }
        get lineBreak() {
          return this.cursor.lineBreak && this.value != "";
        }
      };
      var LineCursor = class {
        constructor(inner) {
          this.inner = inner;
          this.afterBreak = true;
          this.value = "";
          this.done = false;
        }
        next(skip = 0) {
          let { done, lineBreak, value } = this.inner.next(skip);
          if (done) {
            this.done = true;
            this.value = "";
          } else if (lineBreak) {
            if (this.afterBreak) {
              this.value = "";
            } else {
              this.afterBreak = true;
              this.next();
            }
          } else {
            this.value = value;
            this.afterBreak = false;
          }
          return this;
        }
        get lineBreak() {
          return false;
        }
      };
      if (typeof Symbol != "undefined") {
        Text.prototype[Symbol.iterator] = function() {
          return this.iter();
        };
        RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
          return this;
        };
      }
      var Line = class {
        constructor(from, to, number, text) {
          this.from = from;
          this.to = to;
          this.number = number;
          this.text = text;
        }
        get length() {
          return this.to - this.from;
        }
      };
      var extend = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s) => s ? parseInt(s, 36) : 1);
      for (let i = 1; i < extend.length; i++)
        extend[i] += extend[i - 1];
      function isExtendingChar(code) {
        for (let i = 1; i < extend.length; i += 2)
          if (extend[i] > code)
            return extend[i - 1] <= code;
        return false;
      }
      function isRegionalIndicator(code) {
        return code >= 127462 && code <= 127487;
      }
      var ZWJ = 8205;
      function findClusterBreak(str, pos, forward = true, includeExtending = true) {
        return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
      }
      function nextClusterBreak(str, pos, includeExtending) {
        if (pos == str.length)
          return pos;
        if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))
          pos--;
        let prev = codePointAt(str, pos);
        pos += codePointSize(prev);
        while (pos < str.length) {
          let next = codePointAt(str, pos);
          if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
            pos += codePointSize(next);
            prev = next;
          } else if (isRegionalIndicator(next)) {
            let countBefore = 0, i = pos - 2;
            while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
              countBefore++;
              i -= 2;
            }
            if (countBefore % 2 == 0)
              break;
            else
              pos += 2;
          } else {
            break;
          }
        }
        return pos;
      }
      function prevClusterBreak(str, pos, includeExtending) {
        while (pos > 0) {
          let found = nextClusterBreak(str, pos - 2, includeExtending);
          if (found < pos)
            return found;
          pos--;
        }
        return 0;
      }
      function surrogateLow(ch) {
        return ch >= 56320 && ch < 57344;
      }
      function surrogateHigh(ch) {
        return ch >= 55296 && ch < 56320;
      }
      function codePointAt(str, pos) {
        let code0 = str.charCodeAt(pos);
        if (!surrogateHigh(code0) || pos + 1 == str.length)
          return code0;
        let code1 = str.charCodeAt(pos + 1);
        if (!surrogateLow(code1))
          return code0;
        return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
      }
      function fromCodePoint(code) {
        if (code <= 65535)
          return String.fromCharCode(code);
        code -= 65536;
        return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
      }
      function codePointSize(code) {
        return code < 65536 ? 1 : 2;
      }
      var DefaultSplit = /\r\n?|\n/;
      exports.MapMode = void 0;
      (function(MapMode) {
        MapMode[MapMode["Simple"] = 0] = "Simple";
        MapMode[MapMode["TrackDel"] = 1] = "TrackDel";
        MapMode[MapMode["TrackBefore"] = 2] = "TrackBefore";
        MapMode[MapMode["TrackAfter"] = 3] = "TrackAfter";
      })(exports.MapMode || (exports.MapMode = {}));
      var ChangeDesc = class {
        constructor(sections) {
          this.sections = sections;
        }
        get length() {
          let result = 0;
          for (let i = 0; i < this.sections.length; i += 2)
            result += this.sections[i];
          return result;
        }
        get newLength() {
          let result = 0;
          for (let i = 0; i < this.sections.length; i += 2) {
            let ins = this.sections[i + 1];
            result += ins < 0 ? this.sections[i] : ins;
          }
          return result;
        }
        get empty() {
          return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
        }
        iterGaps(f) {
          for (let i = 0, posA = 0, posB = 0; i < this.sections.length; ) {
            let len = this.sections[i++], ins = this.sections[i++];
            if (ins < 0) {
              f(posA, posB, len);
              posB += len;
            } else {
              posB += ins;
            }
            posA += len;
          }
        }
        iterChangedRanges(f, individual = false) {
          iterChanges(this, f, individual);
        }
        get invertedDesc() {
          let sections = [];
          for (let i = 0; i < this.sections.length; ) {
            let len = this.sections[i++], ins = this.sections[i++];
            if (ins < 0)
              sections.push(len, ins);
            else
              sections.push(ins, len);
          }
          return new ChangeDesc(sections);
        }
        composeDesc(other) {
          return this.empty ? other : other.empty ? this : composeSets(this, other);
        }
        mapDesc(other, before = false) {
          return other.empty ? this : mapSet(this, other, before);
        }
        mapPos(pos, assoc = -1, mode = exports.MapMode.Simple) {
          let posA = 0, posB = 0;
          for (let i = 0; i < this.sections.length; ) {
            let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;
            if (ins < 0) {
              if (endA > pos)
                return posB + (pos - posA);
              posB += len;
            } else {
              if (mode != exports.MapMode.Simple && endA >= pos && (mode == exports.MapMode.TrackDel && posA < pos && endA > pos || mode == exports.MapMode.TrackBefore && posA < pos || mode == exports.MapMode.TrackAfter && endA > pos))
                return null;
              if (endA > pos || endA == pos && assoc < 0 && !len)
                return pos == posA || assoc < 0 ? posB : posB + ins;
              posB += ins;
            }
            posA = endA;
          }
          if (pos > posA)
            throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
          return posB;
        }
        touchesRange(from, to = from) {
          for (let i = 0, pos = 0; i < this.sections.length && pos <= to; ) {
            let len = this.sections[i++], ins = this.sections[i++], end = pos + len;
            if (ins >= 0 && pos <= to && end >= from)
              return pos < from && end > to ? "cover" : true;
            pos = end;
          }
          return false;
        }
        toString() {
          let result = "";
          for (let i = 0; i < this.sections.length; ) {
            let len = this.sections[i++], ins = this.sections[i++];
            result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
          }
          return result;
        }
        toJSON() {
          return this.sections;
        }
        static fromJSON(json) {
          if (!Array.isArray(json) || json.length % 2 || json.some((a) => typeof a != "number"))
            throw new RangeError("Invalid JSON representation of ChangeDesc");
          return new ChangeDesc(json);
        }
        static create(sections) {
          return new ChangeDesc(sections);
        }
      };
      var ChangeSet = class extends ChangeDesc {
        constructor(sections, inserted) {
          super(sections);
          this.inserted = inserted;
        }
        apply(doc) {
          if (this.length != doc.length)
            throw new RangeError("Applying change set to a document with the wrong length");
          iterChanges(this, (fromA, toA, fromB, _toB, text) => doc = doc.replace(fromB, fromB + (toA - fromA), text), false);
          return doc;
        }
        mapDesc(other, before = false) {
          return mapSet(this, other, before, true);
        }
        invert(doc) {
          let sections = this.sections.slice(), inserted = [];
          for (let i = 0, pos = 0; i < sections.length; i += 2) {
            let len = sections[i], ins = sections[i + 1];
            if (ins >= 0) {
              sections[i] = ins;
              sections[i + 1] = len;
              let index = i >> 1;
              while (inserted.length < index)
                inserted.push(Text.empty);
              inserted.push(len ? doc.slice(pos, pos + len) : Text.empty);
            }
            pos += len;
          }
          return new ChangeSet(sections, inserted);
        }
        compose(other) {
          return this.empty ? other : other.empty ? this : composeSets(this, other, true);
        }
        map(other, before = false) {
          return other.empty ? this : mapSet(this, other, before, true);
        }
        iterChanges(f, individual = false) {
          iterChanges(this, f, individual);
        }
        get desc() {
          return ChangeDesc.create(this.sections);
        }
        filter(ranges) {
          let resultSections = [], resultInserted = [], filteredSections = [];
          let iter = new SectionIter(this);
          done:
            for (let i = 0, pos = 0; ; ) {
              let next = i == ranges.length ? 1e9 : ranges[i++];
              while (pos < next || pos == next && iter.len == 0) {
                if (iter.done)
                  break done;
                let len = Math.min(iter.len, next - pos);
                addSection(filteredSections, len, -1);
                let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
                addSection(resultSections, len, ins);
                if (ins > 0)
                  addInsert(resultInserted, resultSections, iter.text);
                iter.forward(len);
                pos += len;
              }
              let end = ranges[i++];
              while (pos < end) {
                if (iter.done)
                  break done;
                let len = Math.min(iter.len, end - pos);
                addSection(resultSections, len, -1);
                addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
                iter.forward(len);
                pos += len;
              }
            }
          return {
            changes: new ChangeSet(resultSections, resultInserted),
            filtered: ChangeDesc.create(filteredSections)
          };
        }
        toJSON() {
          let parts = [];
          for (let i = 0; i < this.sections.length; i += 2) {
            let len = this.sections[i], ins = this.sections[i + 1];
            if (ins < 0)
              parts.push(len);
            else if (ins == 0)
              parts.push([len]);
            else
              parts.push([len].concat(this.inserted[i >> 1].toJSON()));
          }
          return parts;
        }
        static of(changes, length, lineSep) {
          let sections = [], inserted = [], pos = 0;
          let total = null;
          function flush(force = false) {
            if (!force && !sections.length)
              return;
            if (pos < length)
              addSection(sections, length - pos, -1);
            let set = new ChangeSet(sections, inserted);
            total = total ? total.compose(set.map(total)) : set;
            sections = [];
            inserted = [];
            pos = 0;
          }
          function process2(spec) {
            if (Array.isArray(spec)) {
              for (let sub of spec)
                process2(sub);
            } else if (spec instanceof ChangeSet) {
              if (spec.length != length)
                throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
              flush();
              total = total ? total.compose(spec.map(total)) : spec;
            } else {
              let { from, to = from, insert: insert2 } = spec;
              if (from > to || from < 0 || to > length)
                throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
              let insText = !insert2 ? Text.empty : typeof insert2 == "string" ? Text.of(insert2.split(lineSep || DefaultSplit)) : insert2;
              let insLen = insText.length;
              if (from == to && insLen == 0)
                return;
              if (from < pos)
                flush();
              if (from > pos)
                addSection(sections, from - pos, -1);
              addSection(sections, to - from, insLen);
              addInsert(inserted, sections, insText);
              pos = to;
            }
          }
          process2(changes);
          flush(!total);
          return total;
        }
        static empty(length) {
          return new ChangeSet(length ? [length, -1] : [], []);
        }
        static fromJSON(json) {
          if (!Array.isArray(json))
            throw new RangeError("Invalid JSON representation of ChangeSet");
          let sections = [], inserted = [];
          for (let i = 0; i < json.length; i++) {
            let part = json[i];
            if (typeof part == "number") {
              sections.push(part, -1);
            } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i2) => i2 && typeof e != "string")) {
              throw new RangeError("Invalid JSON representation of ChangeSet");
            } else if (part.length == 1) {
              sections.push(part[0], 0);
            } else {
              while (inserted.length < i)
                inserted.push(Text.empty);
              inserted[i] = Text.of(part.slice(1));
              sections.push(part[0], inserted[i].length);
            }
          }
          return new ChangeSet(sections, inserted);
        }
        static createSet(sections, inserted) {
          return new ChangeSet(sections, inserted);
        }
      };
      function addSection(sections, len, ins, forceJoin = false) {
        if (len == 0 && ins <= 0)
          return;
        let last = sections.length - 2;
        if (last >= 0 && ins <= 0 && ins == sections[last + 1])
          sections[last] += len;
        else if (len == 0 && sections[last] == 0)
          sections[last + 1] += ins;
        else if (forceJoin) {
          sections[last] += len;
          sections[last + 1] += ins;
        } else
          sections.push(len, ins);
      }
      function addInsert(values, sections, value) {
        if (value.length == 0)
          return;
        let index = sections.length - 2 >> 1;
        if (index < values.length) {
          values[values.length - 1] = values[values.length - 1].append(value);
        } else {
          while (values.length < index)
            values.push(Text.empty);
          values.push(value);
        }
      }
      function iterChanges(desc, f, individual) {
        let inserted = desc.inserted;
        for (let posA = 0, posB = 0, i = 0; i < desc.sections.length; ) {
          let len = desc.sections[i++], ins = desc.sections[i++];
          if (ins < 0) {
            posA += len;
            posB += len;
          } else {
            let endA = posA, endB = posB, text = Text.empty;
            for (; ; ) {
              endA += len;
              endB += ins;
              if (ins && inserted)
                text = text.append(inserted[i - 2 >> 1]);
              if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)
                break;
              len = desc.sections[i++];
              ins = desc.sections[i++];
            }
            f(posA, endA, posB, endB, text);
            posA = endA;
            posB = endB;
          }
        }
      }
      function mapSet(setA, setB, before, mkSet = false) {
        let sections = [], insert2 = mkSet ? [] : null;
        let a = new SectionIter(setA), b = new SectionIter(setB);
        for (let inserted = -1; ; ) {
          if (a.ins == -1 && b.ins == -1) {
            let len = Math.min(a.len, b.len);
            addSection(sections, len, -1);
            a.forward(len);
            b.forward(len);
          } else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {
            let len = b.len;
            addSection(sections, b.ins, -1);
            while (len) {
              let piece = Math.min(a.len, len);
              if (a.ins >= 0 && inserted < a.i && a.len <= piece) {
                addSection(sections, 0, a.ins);
                if (insert2)
                  addInsert(insert2, sections, a.text);
                inserted = a.i;
              }
              a.forward(piece);
              len -= piece;
            }
            b.next();
          } else if (a.ins >= 0) {
            let len = 0, left = a.len;
            while (left) {
              if (b.ins == -1) {
                let piece = Math.min(left, b.len);
                len += piece;
                left -= piece;
                b.forward(piece);
              } else if (b.ins == 0 && b.len < left) {
                left -= b.len;
                b.next();
              } else {
                break;
              }
            }
            addSection(sections, len, inserted < a.i ? a.ins : 0);
            if (insert2 && inserted < a.i)
              addInsert(insert2, sections, a.text);
            inserted = a.i;
            a.forward(a.len - left);
          } else if (a.done && b.done) {
            return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
          } else {
            throw new Error("Mismatched change set lengths");
          }
        }
      }
      function composeSets(setA, setB, mkSet = false) {
        let sections = [];
        let insert2 = mkSet ? [] : null;
        let a = new SectionIter(setA), b = new SectionIter(setB);
        for (let open2 = false; ; ) {
          if (a.done && b.done) {
            return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
          } else if (a.ins == 0) {
            addSection(sections, a.len, 0, open2);
            a.next();
          } else if (b.len == 0 && !b.done) {
            addSection(sections, 0, b.ins, open2);
            if (insert2)
              addInsert(insert2, sections, b.text);
            b.next();
          } else if (a.done || b.done) {
            throw new Error("Mismatched change set lengths");
          } else {
            let len = Math.min(a.len2, b.len), sectionLen = sections.length;
            if (a.ins == -1) {
              let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
              addSection(sections, len, insB, open2);
              if (insert2 && insB)
                addInsert(insert2, sections, b.text);
            } else if (b.ins == -1) {
              addSection(sections, a.off ? 0 : a.len, len, open2);
              if (insert2)
                addInsert(insert2, sections, a.textBit(len));
            } else {
              addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open2);
              if (insert2 && !b.off)
                addInsert(insert2, sections, b.text);
            }
            open2 = (a.ins > len || b.ins >= 0 && b.len > len) && (open2 || sections.length > sectionLen);
            a.forward2(len);
            b.forward(len);
          }
        }
      }
      var SectionIter = class {
        constructor(set) {
          this.set = set;
          this.i = 0;
          this.next();
        }
        next() {
          let { sections } = this.set;
          if (this.i < sections.length) {
            this.len = sections[this.i++];
            this.ins = sections[this.i++];
          } else {
            this.len = 0;
            this.ins = -2;
          }
          this.off = 0;
        }
        get done() {
          return this.ins == -2;
        }
        get len2() {
          return this.ins < 0 ? this.len : this.ins;
        }
        get text() {
          let { inserted } = this.set, index = this.i - 2 >> 1;
          return index >= inserted.length ? Text.empty : inserted[index];
        }
        textBit(len) {
          let { inserted } = this.set, index = this.i - 2 >> 1;
          return index >= inserted.length && !len ? Text.empty : inserted[index].slice(this.off, len == null ? void 0 : this.off + len);
        }
        forward(len) {
          if (len == this.len)
            this.next();
          else {
            this.len -= len;
            this.off += len;
          }
        }
        forward2(len) {
          if (this.ins == -1)
            this.forward(len);
          else if (len == this.ins)
            this.next();
          else {
            this.ins -= len;
            this.off += len;
          }
        }
      };
      var SelectionRange = class {
        constructor(from, to, flags) {
          this.from = from;
          this.to = to;
          this.flags = flags;
        }
        get anchor() {
          return this.flags & 16 ? this.to : this.from;
        }
        get head() {
          return this.flags & 16 ? this.from : this.to;
        }
        get empty() {
          return this.from == this.to;
        }
        get assoc() {
          return this.flags & 4 ? -1 : this.flags & 8 ? 1 : 0;
        }
        get bidiLevel() {
          let level = this.flags & 3;
          return level == 3 ? null : level;
        }
        get goalColumn() {
          let value = this.flags >> 5;
          return value == 33554431 ? void 0 : value;
        }
        map(change, assoc = -1) {
          let from, to;
          if (this.empty) {
            from = to = change.mapPos(this.from, assoc);
          } else {
            from = change.mapPos(this.from, 1);
            to = change.mapPos(this.to, -1);
          }
          return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);
        }
        extend(from, to = from) {
          if (from <= this.anchor && to >= this.anchor)
            return EditorSelection.range(from, to);
          let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
          return EditorSelection.range(this.anchor, head);
        }
        eq(other) {
          return this.anchor == other.anchor && this.head == other.head;
        }
        toJSON() {
          return { anchor: this.anchor, head: this.head };
        }
        static fromJSON(json) {
          if (!json || typeof json.anchor != "number" || typeof json.head != "number")
            throw new RangeError("Invalid JSON representation for SelectionRange");
          return EditorSelection.range(json.anchor, json.head);
        }
        static create(from, to, flags) {
          return new SelectionRange(from, to, flags);
        }
      };
      var EditorSelection = class {
        constructor(ranges, mainIndex) {
          this.ranges = ranges;
          this.mainIndex = mainIndex;
        }
        map(change, assoc = -1) {
          if (change.empty)
            return this;
          return EditorSelection.create(this.ranges.map((r) => r.map(change, assoc)), this.mainIndex);
        }
        eq(other) {
          if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
            return false;
          for (let i = 0; i < this.ranges.length; i++)
            if (!this.ranges[i].eq(other.ranges[i]))
              return false;
          return true;
        }
        get main() {
          return this.ranges[this.mainIndex];
        }
        asSingle() {
          return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);
        }
        addRange(range, main = true) {
          return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
        }
        replaceRange(range, which = this.mainIndex) {
          let ranges = this.ranges.slice();
          ranges[which] = range;
          return EditorSelection.create(ranges, this.mainIndex);
        }
        toJSON() {
          return { ranges: this.ranges.map((r) => r.toJSON()), main: this.mainIndex };
        }
        static fromJSON(json) {
          if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
            throw new RangeError("Invalid JSON representation for EditorSelection");
          return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);
        }
        static single(anchor, head = anchor) {
          return new EditorSelection([EditorSelection.range(anchor, head)], 0);
        }
        static create(ranges, mainIndex = 0) {
          if (ranges.length == 0)
            throw new RangeError("A selection needs at least one range");
          for (let pos = 0, i = 0; i < ranges.length; i++) {
            let range = ranges[i];
            if (range.empty ? range.from <= pos : range.from < pos)
              return EditorSelection.normalized(ranges.slice(), mainIndex);
            pos = range.to;
          }
          return new EditorSelection(ranges, mainIndex);
        }
        static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
          return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4 : 8) | (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5);
        }
        static range(anchor, head, goalColumn) {
          let goal = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5;
          return head < anchor ? SelectionRange.create(head, anchor, 16 | goal | 8) : SelectionRange.create(anchor, head, goal | (head > anchor ? 4 : 0));
        }
        static normalized(ranges, mainIndex = 0) {
          let main = ranges[mainIndex];
          ranges.sort((a, b) => a.from - b.from);
          mainIndex = ranges.indexOf(main);
          for (let i = 1; i < ranges.length; i++) {
            let range = ranges[i], prev = ranges[i - 1];
            if (range.empty ? range.from <= prev.to : range.from < prev.to) {
              let from = prev.from, to = Math.max(range.to, prev.to);
              if (i <= mainIndex)
                mainIndex--;
              ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));
            }
          }
          return new EditorSelection(ranges, mainIndex);
        }
      };
      function checkSelection(selection, docLength) {
        for (let range of selection.ranges)
          if (range.to > docLength)
            throw new RangeError("Selection points outside of document");
      }
      var nextID = 0;
      var Facet = class {
        constructor(combine, compareInput, compare2, isStatic, enables) {
          this.combine = combine;
          this.compareInput = compareInput;
          this.compare = compare2;
          this.isStatic = isStatic;
          this.id = nextID++;
          this.default = combine([]);
          this.extensions = typeof enables == "function" ? enables(this) : enables;
        }
        static define(config = {}) {
          return new Facet(config.combine || ((a) => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static, config.enables);
        }
        of(value) {
          return new FacetProvider([], this, 0, value);
        }
        compute(deps, get) {
          if (this.isStatic)
            throw new Error("Can't compute a static facet");
          return new FacetProvider(deps, this, 1, get);
        }
        computeN(deps, get) {
          if (this.isStatic)
            throw new Error("Can't compute a static facet");
          return new FacetProvider(deps, this, 2, get);
        }
        from(field, get) {
          if (!get)
            get = (x) => x;
          return this.compute([field], (state) => get(state.field(field)));
        }
      };
      function sameArray(a, b) {
        return a == b || a.length == b.length && a.every((e, i) => e === b[i]);
      }
      var FacetProvider = class {
        constructor(dependencies, facet, type, value) {
          this.dependencies = dependencies;
          this.facet = facet;
          this.type = type;
          this.value = value;
          this.id = nextID++;
        }
        dynamicSlot(addresses) {
          var _a;
          let getter = this.value;
          let compare2 = this.facet.compareInput;
          let id = this.id, idx = addresses[id] >> 1, multi = this.type == 2;
          let depDoc = false, depSel = false, depAddrs = [];
          for (let dep of this.dependencies) {
            if (dep == "doc")
              depDoc = true;
            else if (dep == "selection")
              depSel = true;
            else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0)
              depAddrs.push(addresses[dep.id]);
          }
          return {
            create(state) {
              state.values[idx] = getter(state);
              return 1;
            },
            update(state, tr) {
              if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {
                let newVal = getter(state);
                if (multi ? !compareArray(newVal, state.values[idx], compare2) : !compare2(newVal, state.values[idx])) {
                  state.values[idx] = newVal;
                  return 1;
                }
              }
              return 0;
            },
            reconfigure: (state, oldState) => {
              let newVal = getter(state);
              let oldAddr = oldState.config.address[id];
              if (oldAddr != null) {
                let oldVal = getAddr(oldState, oldAddr);
                if (this.dependencies.every((dep) => {
                  return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
                }) || (multi ? compareArray(newVal, oldVal, compare2) : compare2(newVal, oldVal))) {
                  state.values[idx] = oldVal;
                  return 0;
                }
              }
              state.values[idx] = newVal;
              return 1;
            }
          };
        }
      };
      function compareArray(a, b, compare2) {
        if (a.length != b.length)
          return false;
        for (let i = 0; i < a.length; i++)
          if (!compare2(a[i], b[i]))
            return false;
        return true;
      }
      function ensureAll(state, addrs) {
        let changed = false;
        for (let addr of addrs)
          if (ensureAddr(state, addr) & 1)
            changed = true;
        return changed;
      }
      function dynamicFacetSlot(addresses, facet, providers) {
        let providerAddrs = providers.map((p) => addresses[p.id]);
        let providerTypes = providers.map((p) => p.type);
        let dynamic = providerAddrs.filter((p) => !(p & 1));
        let idx = addresses[facet.id] >> 1;
        function get(state) {
          let values = [];
          for (let i = 0; i < providerAddrs.length; i++) {
            let value = getAddr(state, providerAddrs[i]);
            if (providerTypes[i] == 2)
              for (let val of value)
                values.push(val);
            else
              values.push(value);
          }
          return facet.combine(values);
        }
        return {
          create(state) {
            for (let addr of providerAddrs)
              ensureAddr(state, addr);
            state.values[idx] = get(state);
            return 1;
          },
          update(state, tr) {
            if (!ensureAll(state, dynamic))
              return 0;
            let value = get(state);
            if (facet.compare(value, state.values[idx]))
              return 0;
            state.values[idx] = value;
            return 1;
          },
          reconfigure(state, oldState) {
            let depChanged = ensureAll(state, providerAddrs);
            let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
            if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
              state.values[idx] = oldValue;
              return 0;
            }
            let value = get(state);
            if (facet.compare(value, oldValue)) {
              state.values[idx] = oldValue;
              return 0;
            }
            state.values[idx] = value;
            return 1;
          }
        };
      }
      var initField = Facet.define({ static: true });
      var StateField = class {
        constructor(id, createF, updateF, compareF, spec) {
          this.id = id;
          this.createF = createF;
          this.updateF = updateF;
          this.compareF = compareF;
          this.spec = spec;
          this.provides = void 0;
        }
        static define(config) {
          let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), config);
          if (config.provide)
            field.provides = config.provide(field);
          return field;
        }
        create(state) {
          let init = state.facet(initField).find((i) => i.field == this);
          return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
        }
        slot(addresses) {
          let idx = addresses[this.id] >> 1;
          return {
            create: (state) => {
              state.values[idx] = this.create(state);
              return 1;
            },
            update: (state, tr) => {
              let oldVal = state.values[idx];
              let value = this.updateF(oldVal, tr);
              if (this.compareF(oldVal, value))
                return 0;
              state.values[idx] = value;
              return 1;
            },
            reconfigure: (state, oldState) => {
              if (oldState.config.address[this.id] != null) {
                state.values[idx] = oldState.field(this);
                return 0;
              }
              state.values[idx] = this.create(state);
              return 1;
            }
          };
        }
        init(create) {
          return [this, initField.of({ field: this, create })];
        }
        get extension() {
          return this;
        }
      };
      var Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
      function prec(value) {
        return (ext) => new PrecExtension(ext, value);
      }
      var Prec = {
        highest: prec(Prec_.highest),
        high: prec(Prec_.high),
        default: prec(Prec_.default),
        low: prec(Prec_.low),
        lowest: prec(Prec_.lowest)
      };
      var PrecExtension = class {
        constructor(inner, prec2) {
          this.inner = inner;
          this.prec = prec2;
        }
      };
      var Compartment = class {
        of(ext) {
          return new CompartmentInstance(this, ext);
        }
        reconfigure(content) {
          return Compartment.reconfigure.of({ compartment: this, extension: content });
        }
        get(state) {
          return state.config.compartments.get(this);
        }
      };
      var CompartmentInstance = class {
        constructor(compartment, inner) {
          this.compartment = compartment;
          this.inner = inner;
        }
      };
      var Configuration = class {
        constructor(base, compartments, dynamicSlots, address, staticValues, facets) {
          this.base = base;
          this.compartments = compartments;
          this.dynamicSlots = dynamicSlots;
          this.address = address;
          this.staticValues = staticValues;
          this.facets = facets;
          this.statusTemplate = [];
          while (this.statusTemplate.length < dynamicSlots.length)
            this.statusTemplate.push(0);
        }
        staticFacet(facet) {
          let addr = this.address[facet.id];
          return addr == null ? facet.default : this.staticValues[addr >> 1];
        }
        static resolve(base, compartments, oldState) {
          let fields = [];
          let facets = /* @__PURE__ */ Object.create(null);
          let newCompartments = /* @__PURE__ */ new Map();
          for (let ext of flatten(base, compartments, newCompartments)) {
            if (ext instanceof StateField)
              fields.push(ext);
            else
              (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
          }
          let address = /* @__PURE__ */ Object.create(null);
          let staticValues = [];
          let dynamicSlots = [];
          for (let field of fields) {
            address[field.id] = dynamicSlots.length << 1;
            dynamicSlots.push((a) => field.slot(a));
          }
          let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
          for (let id in facets) {
            let providers = facets[id], facet = providers[0].facet;
            let oldProviders = oldFacets && oldFacets[id] || [];
            if (providers.every((p) => p.type == 0)) {
              address[facet.id] = staticValues.length << 1 | 1;
              if (sameArray(oldProviders, providers)) {
                staticValues.push(oldState.facet(facet));
              } else {
                let value = facet.combine(providers.map((p) => p.value));
                staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
              }
            } else {
              for (let p of providers) {
                if (p.type == 0) {
                  address[p.id] = staticValues.length << 1 | 1;
                  staticValues.push(p.value);
                } else {
                  address[p.id] = dynamicSlots.length << 1;
                  dynamicSlots.push((a) => p.dynamicSlot(a));
                }
              }
              address[facet.id] = dynamicSlots.length << 1;
              dynamicSlots.push((a) => dynamicFacetSlot(a, facet, providers));
            }
          }
          let dynamic = dynamicSlots.map((f) => f(address));
          return new Configuration(base, newCompartments, dynamic, address, staticValues, facets);
        }
      };
      function flatten(extension, compartments, newCompartments) {
        let result = [[], [], [], [], []];
        let seen = /* @__PURE__ */ new Map();
        function inner(ext, prec2) {
          let known = seen.get(ext);
          if (known != null) {
            if (known <= prec2)
              return;
            let found = result[known].indexOf(ext);
            if (found > -1)
              result[known].splice(found, 1);
            if (ext instanceof CompartmentInstance)
              newCompartments.delete(ext.compartment);
          }
          seen.set(ext, prec2);
          if (Array.isArray(ext)) {
            for (let e of ext)
              inner(e, prec2);
          } else if (ext instanceof CompartmentInstance) {
            if (newCompartments.has(ext.compartment))
              throw new RangeError(`Duplicate use of compartment in extensions`);
            let content = compartments.get(ext.compartment) || ext.inner;
            newCompartments.set(ext.compartment, content);
            inner(content, prec2);
          } else if (ext instanceof PrecExtension) {
            inner(ext.inner, ext.prec);
          } else if (ext instanceof StateField) {
            result[prec2].push(ext);
            if (ext.provides)
              inner(ext.provides, prec2);
          } else if (ext instanceof FacetProvider) {
            result[prec2].push(ext);
            if (ext.facet.extensions)
              inner(ext.facet.extensions, Prec_.default);
          } else {
            let content = ext.extension;
            if (!content)
              throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
            inner(content, prec2);
          }
        }
        inner(extension, Prec_.default);
        return result.reduce((a, b) => a.concat(b));
      }
      function ensureAddr(state, addr) {
        if (addr & 1)
          return 2;
        let idx = addr >> 1;
        let status = state.status[idx];
        if (status == 4)
          throw new Error("Cyclic dependency between fields and/or facets");
        if (status & 2)
          return status;
        state.status[idx] = 4;
        let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
        return state.status[idx] = 2 | changed;
      }
      function getAddr(state, addr) {
        return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
      }
      var languageData = Facet.define();
      var allowMultipleSelections = Facet.define({
        combine: (values) => values.some((v) => v),
        static: true
      });
      var lineSeparator = Facet.define({
        combine: (values) => values.length ? values[0] : void 0,
        static: true
      });
      var changeFilter = Facet.define();
      var transactionFilter = Facet.define();
      var transactionExtender = Facet.define();
      var readOnly = Facet.define({
        combine: (values) => values.length ? values[0] : false
      });
      var Annotation = class {
        constructor(type, value) {
          this.type = type;
          this.value = value;
        }
        static define() {
          return new AnnotationType();
        }
      };
      var AnnotationType = class {
        of(value) {
          return new Annotation(this, value);
        }
      };
      var StateEffectType = class {
        constructor(map) {
          this.map = map;
        }
        of(value) {
          return new StateEffect(this, value);
        }
      };
      var StateEffect = class {
        constructor(type, value) {
          this.type = type;
          this.value = value;
        }
        map(mapping) {
          let mapped = this.type.map(this.value, mapping);
          return mapped === void 0 ? void 0 : mapped == this.value ? this : new StateEffect(this.type, mapped);
        }
        is(type) {
          return this.type == type;
        }
        static define(spec = {}) {
          return new StateEffectType(spec.map || ((v) => v));
        }
        static mapEffects(effects, mapping) {
          if (!effects.length)
            return effects;
          let result = [];
          for (let effect of effects) {
            let mapped = effect.map(mapping);
            if (mapped)
              result.push(mapped);
          }
          return result;
        }
      };
      StateEffect.reconfigure = StateEffect.define();
      StateEffect.appendConfig = StateEffect.define();
      var Transaction = class {
        constructor(startState, changes, selection, effects, annotations, scrollIntoView) {
          this.startState = startState;
          this.changes = changes;
          this.selection = selection;
          this.effects = effects;
          this.annotations = annotations;
          this.scrollIntoView = scrollIntoView;
          this._doc = null;
          this._state = null;
          if (selection)
            checkSelection(selection, changes.newLength);
          if (!annotations.some((a) => a.type == Transaction.time))
            this.annotations = annotations.concat(Transaction.time.of(Date.now()));
        }
        static create(startState, changes, selection, effects, annotations, scrollIntoView) {
          return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView);
        }
        get newDoc() {
          return this._doc || (this._doc = this.changes.apply(this.startState.doc));
        }
        get newSelection() {
          return this.selection || this.startState.selection.map(this.changes);
        }
        get state() {
          if (!this._state)
            this.startState.applyTransaction(this);
          return this._state;
        }
        annotation(type) {
          for (let ann of this.annotations)
            if (ann.type == type)
              return ann.value;
          return void 0;
        }
        get docChanged() {
          return !this.changes.empty;
        }
        get reconfigured() {
          return this.startState.config != this.state.config;
        }
        isUserEvent(event) {
          let e = this.annotation(Transaction.userEvent);
          return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == "."));
        }
      };
      Transaction.time = Annotation.define();
      Transaction.userEvent = Annotation.define();
      Transaction.addToHistory = Annotation.define();
      Transaction.remote = Annotation.define();
      function joinRanges(a, b) {
        let result = [];
        for (let iA = 0, iB = 0; ; ) {
          let from, to;
          if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
            from = a[iA++];
            to = a[iA++];
          } else if (iB < b.length) {
            from = b[iB++];
            to = b[iB++];
          } else
            return result;
          if (!result.length || result[result.length - 1] < from)
            result.push(from, to);
          else if (result[result.length - 1] < to)
            result[result.length - 1] = to;
        }
      }
      function mergeTransaction(a, b, sequential) {
        var _a;
        let mapForA, mapForB, changes;
        if (sequential) {
          mapForA = b.changes;
          mapForB = ChangeSet.empty(b.changes.length);
          changes = a.changes.compose(b.changes);
        } else {
          mapForA = b.changes.map(a.changes);
          mapForB = a.changes.mapDesc(b.changes, true);
          changes = a.changes.compose(mapForA);
        }
        return {
          changes,
          selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),
          effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
          annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
          scrollIntoView: a.scrollIntoView || b.scrollIntoView
        };
      }
      function resolveTransactionInner(state, spec, docSize) {
        let sel = spec.selection, annotations = asArray(spec.annotations);
        if (spec.userEvent)
          annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
        return {
          changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
          selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
          effects: asArray(spec.effects),
          annotations,
          scrollIntoView: !!spec.scrollIntoView
        };
      }
      function resolveTransaction(state, specs, filter) {
        let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
        if (specs.length && specs[0].filter === false)
          filter = false;
        for (let i = 1; i < specs.length; i++) {
          if (specs[i].filter === false)
            filter = false;
          let seq = !!specs[i].sequential;
          s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);
        }
        let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
        return extendTransaction(filter ? filterTransaction(tr) : tr);
      }
      function filterTransaction(tr) {
        let state = tr.startState;
        let result = true;
        for (let filter of state.facet(changeFilter)) {
          let value = filter(tr);
          if (value === false) {
            result = false;
            break;
          }
          if (Array.isArray(value))
            result = result === true ? value : joinRanges(result, value);
        }
        if (result !== true) {
          let changes, back;
          if (result === false) {
            back = tr.changes.invertedDesc;
            changes = ChangeSet.empty(state.doc.length);
          } else {
            let filtered = tr.changes.filter(result);
            changes = filtered.changes;
            back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
          }
          tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
        }
        let filters = state.facet(transactionFilter);
        for (let i = filters.length - 1; i >= 0; i--) {
          let filtered = filters[i](tr);
          if (filtered instanceof Transaction)
            tr = filtered;
          else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
            tr = filtered[0];
          else
            tr = resolveTransaction(state, asArray(filtered), false);
        }
        return tr;
      }
      function extendTransaction(tr) {
        let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
        for (let i = extenders.length - 1; i >= 0; i--) {
          let extension = extenders[i](tr);
          if (extension && Object.keys(extension).length)
            spec = mergeTransaction(tr, resolveTransactionInner(state, extension, tr.changes.newLength), true);
        }
        return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
      }
      var none = [];
      function asArray(value) {
        return value == null ? none : Array.isArray(value) ? value : [value];
      }
      exports.CharCategory = void 0;
      (function(CharCategory) {
        CharCategory[CharCategory["Word"] = 0] = "Word";
        CharCategory[CharCategory["Space"] = 1] = "Space";
        CharCategory[CharCategory["Other"] = 2] = "Other";
      })(exports.CharCategory || (exports.CharCategory = {}));
      var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
      var wordChar;
      try {
        wordChar = new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
      } catch (_) {
      }
      function hasWordChar(str) {
        if (wordChar)
          return wordChar.test(str);
        for (let i = 0; i < str.length; i++) {
          let ch = str[i];
          if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
            return true;
        }
        return false;
      }
      function makeCategorizer(wordChars) {
        return (char) => {
          if (!/\S/.test(char))
            return exports.CharCategory.Space;
          if (hasWordChar(char))
            return exports.CharCategory.Word;
          for (let i = 0; i < wordChars.length; i++)
            if (char.indexOf(wordChars[i]) > -1)
              return exports.CharCategory.Word;
          return exports.CharCategory.Other;
        };
      }
      var EditorState = class {
        constructor(config, doc, selection, values, computeSlot, tr) {
          this.config = config;
          this.doc = doc;
          this.selection = selection;
          this.values = values;
          this.status = config.statusTemplate.slice();
          this.computeSlot = computeSlot;
          if (tr)
            tr._state = this;
          for (let i = 0; i < this.config.dynamicSlots.length; i++)
            ensureAddr(this, i << 1);
          this.computeSlot = null;
        }
        field(field, require2 = true) {
          let addr = this.config.address[field.id];
          if (addr == null) {
            if (require2)
              throw new RangeError("Field is not present in this state");
            return void 0;
          }
          ensureAddr(this, addr);
          return getAddr(this, addr);
        }
        update(...specs) {
          return resolveTransaction(this, specs, true);
        }
        applyTransaction(tr) {
          let conf = this.config, { base, compartments } = conf;
          for (let effect of tr.effects) {
            if (effect.is(Compartment.reconfigure)) {
              if (conf) {
                compartments = /* @__PURE__ */ new Map();
                conf.compartments.forEach((val, key) => compartments.set(key, val));
                conf = null;
              }
              compartments.set(effect.value.compartment, effect.value.extension);
            } else if (effect.is(StateEffect.reconfigure)) {
              conf = null;
              base = effect.value;
            } else if (effect.is(StateEffect.appendConfig)) {
              conf = null;
              base = asArray(base).concat(effect.value);
            }
          }
          let startValues;
          if (!conf) {
            conf = Configuration.resolve(base, compartments, this);
            let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
            startValues = intermediateState.values;
          } else {
            startValues = tr.startState.values.slice();
          }
          new EditorState(conf, tr.newDoc, tr.newSelection, startValues, (state, slot) => slot.update(state, tr), tr);
        }
        replaceSelection(text) {
          if (typeof text == "string")
            text = this.toText(text);
          return this.changeByRange((range) => ({
            changes: { from: range.from, to: range.to, insert: text },
            range: EditorSelection.cursor(range.from + text.length)
          }));
        }
        changeByRange(f) {
          let sel = this.selection;
          let result1 = f(sel.ranges[0]);
          let changes = this.changes(result1.changes), ranges = [result1.range];
          let effects = asArray(result1.effects);
          for (let i = 1; i < sel.ranges.length; i++) {
            let result = f(sel.ranges[i]);
            let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
            for (let j = 0; j < i; j++)
              ranges[j] = ranges[j].map(newMapped);
            let mapBy = changes.mapDesc(newChanges, true);
            ranges.push(result.range.map(mapBy));
            changes = changes.compose(newMapped);
            effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
          }
          return {
            changes,
            selection: EditorSelection.create(ranges, sel.mainIndex),
            effects
          };
        }
        changes(spec = []) {
          if (spec instanceof ChangeSet)
            return spec;
          return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
        }
        toText(string) {
          return Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
        }
        sliceDoc(from = 0, to = this.doc.length) {
          return this.doc.sliceString(from, to, this.lineBreak);
        }
        facet(facet) {
          let addr = this.config.address[facet.id];
          if (addr == null)
            return facet.default;
          ensureAddr(this, addr);
          return getAddr(this, addr);
        }
        toJSON(fields) {
          let result = {
            doc: this.sliceDoc(),
            selection: this.selection.toJSON()
          };
          if (fields)
            for (let prop in fields) {
              let value = fields[prop];
              if (value instanceof StateField && this.config.address[value.id] != null)
                result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
            }
          return result;
        }
        static fromJSON(json, config = {}, fields) {
          if (!json || typeof json.doc != "string")
            throw new RangeError("Invalid JSON representation for EditorState");
          let fieldInit = [];
          if (fields)
            for (let prop in fields) {
              if (Object.prototype.hasOwnProperty.call(json, prop)) {
                let field = fields[prop], value = json[prop];
                fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
              }
            }
          return EditorState.create({
            doc: json.doc,
            selection: EditorSelection.fromJSON(json.selection),
            extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit
          });
        }
        static create(config = {}) {
          let configuration = Configuration.resolve(config.extensions || [], /* @__PURE__ */ new Map());
          let doc = config.doc instanceof Text ? config.doc : Text.of((config.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
          let selection = !config.selection ? EditorSelection.single(0) : config.selection instanceof EditorSelection ? config.selection : EditorSelection.single(config.selection.anchor, config.selection.head);
          checkSelection(selection, doc.length);
          if (!configuration.staticFacet(allowMultipleSelections))
            selection = selection.asSingle();
          return new EditorState(configuration, doc, selection, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
        }
        get tabSize() {
          return this.facet(EditorState.tabSize);
        }
        get lineBreak() {
          return this.facet(EditorState.lineSeparator) || "\n";
        }
        get readOnly() {
          return this.facet(readOnly);
        }
        phrase(phrase, ...insert2) {
          for (let map of this.facet(EditorState.phrases))
            if (Object.prototype.hasOwnProperty.call(map, phrase)) {
              phrase = map[phrase];
              break;
            }
          if (insert2.length)
            phrase = phrase.replace(/\$(\$|\d*)/g, (m, i) => {
              if (i == "$")
                return "$";
              let n = +(i || 1);
              return !n || n > insert2.length ? m : insert2[n - 1];
            });
          return phrase;
        }
        languageDataAt(name, pos, side = -1) {
          let values = [];
          for (let provider of this.facet(languageData)) {
            for (let result of provider(this, pos, side)) {
              if (Object.prototype.hasOwnProperty.call(result, name))
                values.push(result[name]);
            }
          }
          return values;
        }
        charCategorizer(at) {
          return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
        }
        wordAt(pos) {
          let { text, from, length } = this.doc.lineAt(pos);
          let cat = this.charCategorizer(pos);
          let start = pos - from, end = pos - from;
          while (start > 0) {
            let prev = findClusterBreak(text, start, false);
            if (cat(text.slice(prev, start)) != exports.CharCategory.Word)
              break;
            start = prev;
          }
          while (end < length) {
            let next = findClusterBreak(text, end);
            if (cat(text.slice(end, next)) != exports.CharCategory.Word)
              break;
            end = next;
          }
          return start == end ? null : EditorSelection.range(start + from, end + from);
        }
      };
      EditorState.allowMultipleSelections = allowMultipleSelections;
      EditorState.tabSize = Facet.define({
        combine: (values) => values.length ? values[0] : 4
      });
      EditorState.lineSeparator = lineSeparator;
      EditorState.readOnly = readOnly;
      EditorState.phrases = Facet.define({
        compare(a, b) {
          let kA = Object.keys(a), kB = Object.keys(b);
          return kA.length == kB.length && kA.every((k) => a[k] == b[k]);
        }
      });
      EditorState.languageData = languageData;
      EditorState.changeFilter = changeFilter;
      EditorState.transactionFilter = transactionFilter;
      EditorState.transactionExtender = transactionExtender;
      Compartment.reconfigure = StateEffect.define();
      function combineConfig(configs, defaults, combine = {}) {
        let result = {};
        for (let config of configs)
          for (let key of Object.keys(config)) {
            let value = config[key], current = result[key];
            if (current === void 0)
              result[key] = value;
            else if (current === value || value === void 0)
              ;
            else if (Object.hasOwnProperty.call(combine, key))
              result[key] = combine[key](current, value);
            else
              throw new Error("Config merge conflict for field " + key);
          }
        for (let key in defaults)
          if (result[key] === void 0)
            result[key] = defaults[key];
        return result;
      }
      var RangeValue = class {
        eq(other) {
          return this == other;
        }
        range(from, to = from) {
          return Range.create(from, to, this);
        }
      };
      RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
      RangeValue.prototype.point = false;
      RangeValue.prototype.mapMode = exports.MapMode.TrackDel;
      var Range = class {
        constructor(from, to, value) {
          this.from = from;
          this.to = to;
          this.value = value;
        }
        static create(from, to, value) {
          return new Range(from, to, value);
        }
      };
      function cmpRange(a, b) {
        return a.from - b.from || a.value.startSide - b.value.startSide;
      }
      var Chunk = class {
        constructor(from, to, value, maxPoint) {
          this.from = from;
          this.to = to;
          this.value = value;
          this.maxPoint = maxPoint;
        }
        get length() {
          return this.to[this.to.length - 1];
        }
        findIndex(pos, side, end, startAt = 0) {
          let arr = end ? this.to : this.from;
          for (let lo = startAt, hi = arr.length; ; ) {
            if (lo == hi)
              return lo;
            let mid = lo + hi >> 1;
            let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
            if (mid == lo)
              return diff >= 0 ? lo : hi;
            if (diff >= 0)
              hi = mid;
            else
              lo = mid + 1;
          }
        }
        between(offset, from, to, f) {
          for (let i = this.findIndex(from, -1e9, true), e = this.findIndex(to, 1e9, false, i); i < e; i++)
            if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)
              return false;
        }
        map(offset, changes) {
          let value = [], from = [], to = [], newPos = -1, maxPoint = -1;
          for (let i = 0; i < this.value.length; i++) {
            let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;
            if (curFrom == curTo) {
              let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
              if (mapped == null)
                continue;
              newFrom = newTo = mapped;
              if (val.startSide != val.endSide) {
                newTo = changes.mapPos(curFrom, val.endSide);
                if (newTo < newFrom)
                  continue;
              }
            } else {
              newFrom = changes.mapPos(curFrom, val.startSide);
              newTo = changes.mapPos(curTo, val.endSide);
              if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
                continue;
            }
            if ((newTo - newFrom || val.endSide - val.startSide) < 0)
              continue;
            if (newPos < 0)
              newPos = newFrom;
            if (val.point)
              maxPoint = Math.max(maxPoint, newTo - newFrom);
            value.push(val);
            from.push(newFrom - newPos);
            to.push(newTo - newPos);
          }
          return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };
        }
      };
      var RangeSet = class {
        constructor(chunkPos, chunk, nextLayer, maxPoint) {
          this.chunkPos = chunkPos;
          this.chunk = chunk;
          this.nextLayer = nextLayer;
          this.maxPoint = maxPoint;
        }
        static create(chunkPos, chunk, nextLayer, maxPoint) {
          return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);
        }
        get length() {
          let last = this.chunk.length - 1;
          return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
        }
        get size() {
          if (this.isEmpty)
            return 0;
          let size = this.nextLayer.size;
          for (let chunk of this.chunk)
            size += chunk.value.length;
          return size;
        }
        chunkEnd(index) {
          return this.chunkPos[index] + this.chunk[index].length;
        }
        update(updateSpec) {
          let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
          let filter = updateSpec.filter;
          if (add.length == 0 && !filter)
            return this;
          if (sort)
            add = add.slice().sort(cmpRange);
          if (this.isEmpty)
            return add.length ? RangeSet.of(add) : this;
          let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];
          let builder = new RangeSetBuilder();
          while (cur.value || i < add.length) {
            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {
              let range = add[i++];
              if (!builder.addInner(range.from, range.to, range.value))
                spill.push(range);
            } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) && (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {
              cur.nextChunk();
            } else {
              if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {
                if (!builder.addInner(cur.from, cur.to, cur.value))
                  spill.push(Range.create(cur.from, cur.to, cur.value));
              }
              cur.next();
            }
          }
          return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));
        }
        map(changes) {
          if (changes.empty || this.isEmpty)
            return this;
          let chunks = [], chunkPos = [], maxPoint = -1;
          for (let i = 0; i < this.chunk.length; i++) {
            let start = this.chunkPos[i], chunk = this.chunk[i];
            let touch = changes.touchesRange(start, start + chunk.length);
            if (touch === false) {
              maxPoint = Math.max(maxPoint, chunk.maxPoint);
              chunks.push(chunk);
              chunkPos.push(changes.mapPos(start));
            } else if (touch === true) {
              let { mapped, pos } = chunk.map(start, changes);
              if (mapped) {
                maxPoint = Math.max(maxPoint, mapped.maxPoint);
                chunks.push(mapped);
                chunkPos.push(pos);
              }
            }
          }
          let next = this.nextLayer.map(changes);
          return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);
        }
        between(from, to, f) {
          if (this.isEmpty)
            return;
          for (let i = 0; i < this.chunk.length; i++) {
            let start = this.chunkPos[i], chunk = this.chunk[i];
            if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false)
              return;
          }
          this.nextLayer.between(from, to, f);
        }
        iter(from = 0) {
          return HeapCursor.from([this]).goto(from);
        }
        get isEmpty() {
          return this.nextLayer == this;
        }
        static iter(sets, from = 0) {
          return HeapCursor.from(sets).goto(from);
        }
        static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
          let a = oldSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
          let b = newSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
          let sharedChunks = findSharedChunks(a, b, textDiff);
          let sideA = new SpanCursor(a, sharedChunks, minPointSize);
          let sideB = new SpanCursor(b, sharedChunks, minPointSize);
          textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
          if (textDiff.empty && textDiff.length == 0)
            compare(sideA, 0, sideB, 0, 0, comparator);
        }
        static eq(oldSets, newSets, from = 0, to) {
          if (to == null)
            to = 1e9;
          let a = oldSets.filter((set) => !set.isEmpty && newSets.indexOf(set) < 0);
          let b = newSets.filter((set) => !set.isEmpty && oldSets.indexOf(set) < 0);
          if (a.length != b.length)
            return false;
          if (!a.length)
            return true;
          let sharedChunks = findSharedChunks(a, b);
          let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);
          for (; ; ) {
            if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
              return false;
            if (sideA.to > to)
              return true;
            sideA.next();
            sideB.next();
          }
        }
        static spans(sets, from, to, iterator, minPointSize = -1) {
          let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
          let open2 = cursor.openStart;
          for (; ; ) {
            let curTo = Math.min(cursor.to, to);
            if (cursor.point) {
              iterator.point(pos, curTo, cursor.point, cursor.activeForPoint(cursor.to), open2, cursor.pointRank);
              open2 = cursor.openEnd(curTo) + (cursor.to > curTo ? 1 : 0);
            } else if (curTo > pos) {
              iterator.span(pos, curTo, cursor.active, open2);
              open2 = cursor.openEnd(curTo);
            }
            if (cursor.to > to)
              break;
            pos = cursor.to;
            cursor.next();
          }
          return open2;
        }
        static of(ranges, sort = false) {
          let build = new RangeSetBuilder();
          for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)
            build.add(range.from, range.to, range.value);
          return build.finish();
        }
      };
      RangeSet.empty = new RangeSet([], [], null, -1);
      function lazySort(ranges) {
        if (ranges.length > 1)
          for (let prev = ranges[0], i = 1; i < ranges.length; i++) {
            let cur = ranges[i];
            if (cmpRange(prev, cur) > 0)
              return ranges.slice().sort(cmpRange);
            prev = cur;
          }
        return ranges;
      }
      RangeSet.empty.nextLayer = RangeSet.empty;
      var RangeSetBuilder = class {
        constructor() {
          this.chunks = [];
          this.chunkPos = [];
          this.chunkStart = -1;
          this.last = null;
          this.lastFrom = -1e9;
          this.lastTo = -1e9;
          this.from = [];
          this.to = [];
          this.value = [];
          this.maxPoint = -1;
          this.setMaxPoint = -1;
          this.nextLayer = null;
        }
        finishChunk(newArrays) {
          this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
          this.chunkPos.push(this.chunkStart);
          this.chunkStart = -1;
          this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
          this.maxPoint = -1;
          if (newArrays) {
            this.from = [];
            this.to = [];
            this.value = [];
          }
        }
        add(from, to, value) {
          if (!this.addInner(from, to, value))
            (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to, value);
        }
        addInner(from, to, value) {
          let diff = from - this.lastTo || value.startSide - this.last.endSide;
          if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
            throw new Error("Ranges must be added sorted by `from` position and `startSide`");
          if (diff < 0)
            return false;
          if (this.from.length == 250)
            this.finishChunk(true);
          if (this.chunkStart < 0)
            this.chunkStart = from;
          this.from.push(from - this.chunkStart);
          this.to.push(to - this.chunkStart);
          this.last = value;
          this.lastFrom = from;
          this.lastTo = to;
          this.value.push(value);
          if (value.point)
            this.maxPoint = Math.max(this.maxPoint, to - from);
          return true;
        }
        addChunk(from, chunk) {
          if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
            return false;
          if (this.from.length)
            this.finishChunk(true);
          this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
          this.chunks.push(chunk);
          this.chunkPos.push(from);
          let last = chunk.value.length - 1;
          this.last = chunk.value[last];
          this.lastFrom = chunk.from[last] + from;
          this.lastTo = chunk.to[last] + from;
          return true;
        }
        finish() {
          return this.finishInner(RangeSet.empty);
        }
        finishInner(next) {
          if (this.from.length)
            this.finishChunk(false);
          if (this.chunks.length == 0)
            return next;
          let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
          this.from = null;
          return result;
        }
      };
      function findSharedChunks(a, b, textDiff) {
        let inA = /* @__PURE__ */ new Map();
        for (let set of a)
          for (let i = 0; i < set.chunk.length; i++)
            if (set.chunk[i].maxPoint <= 0)
              inA.set(set.chunk[i], set.chunkPos[i]);
        let shared = /* @__PURE__ */ new Set();
        for (let set of b)
          for (let i = 0; i < set.chunk.length; i++) {
            let known = inA.get(set.chunk[i]);
            if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length)))
              shared.add(set.chunk[i]);
          }
        return shared;
      }
      var LayerCursor = class {
        constructor(layer, skip, minPoint, rank = 0) {
          this.layer = layer;
          this.skip = skip;
          this.minPoint = minPoint;
          this.rank = rank;
        }
        get startSide() {
          return this.value ? this.value.startSide : 0;
        }
        get endSide() {
          return this.value ? this.value.endSide : 0;
        }
        goto(pos, side = -1e9) {
          this.chunkIndex = this.rangeIndex = 0;
          this.gotoInner(pos, side, false);
          return this;
        }
        gotoInner(pos, side, forward) {
          while (this.chunkIndex < this.layer.chunk.length) {
            let next = this.layer.chunk[this.chunkIndex];
            if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
              break;
            this.chunkIndex++;
            forward = false;
          }
          if (this.chunkIndex < this.layer.chunk.length) {
            let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
            if (!forward || this.rangeIndex < rangeIndex)
              this.setRangeIndex(rangeIndex);
          }
          this.next();
        }
        forward(pos, side) {
          if ((this.to - pos || this.endSide - side) < 0)
            this.gotoInner(pos, side, true);
        }
        next() {
          for (; ; ) {
            if (this.chunkIndex == this.layer.chunk.length) {
              this.from = this.to = 1e9;
              this.value = null;
              break;
            } else {
              let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
              let from = chunkPos + chunk.from[this.rangeIndex];
              this.from = from;
              this.to = chunkPos + chunk.to[this.rangeIndex];
              this.value = chunk.value[this.rangeIndex];
              this.setRangeIndex(this.rangeIndex + 1);
              if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
                break;
            }
          }
        }
        setRangeIndex(index) {
          if (index == this.layer.chunk[this.chunkIndex].value.length) {
            this.chunkIndex++;
            if (this.skip) {
              while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
                this.chunkIndex++;
            }
            this.rangeIndex = 0;
          } else {
            this.rangeIndex = index;
          }
        }
        nextChunk() {
          this.chunkIndex++;
          this.rangeIndex = 0;
          this.next();
        }
        compare(other) {
          return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
        }
      };
      var HeapCursor = class {
        constructor(heap) {
          this.heap = heap;
        }
        static from(sets, skip = null, minPoint = -1) {
          let heap = [];
          for (let i = 0; i < sets.length; i++) {
            for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {
              if (cur.maxPoint >= minPoint)
                heap.push(new LayerCursor(cur, skip, minPoint, i));
            }
          }
          return heap.length == 1 ? heap[0] : new HeapCursor(heap);
        }
        get startSide() {
          return this.value ? this.value.startSide : 0;
        }
        goto(pos, side = -1e9) {
          for (let cur of this.heap)
            cur.goto(pos, side);
          for (let i = this.heap.length >> 1; i >= 0; i--)
            heapBubble(this.heap, i);
          this.next();
          return this;
        }
        forward(pos, side) {
          for (let cur of this.heap)
            cur.forward(pos, side);
          for (let i = this.heap.length >> 1; i >= 0; i--)
            heapBubble(this.heap, i);
          if ((this.to - pos || this.value.endSide - side) < 0)
            this.next();
        }
        next() {
          if (this.heap.length == 0) {
            this.from = this.to = 1e9;
            this.value = null;
            this.rank = -1;
          } else {
            let top = this.heap[0];
            this.from = top.from;
            this.to = top.to;
            this.value = top.value;
            this.rank = top.rank;
            if (top.value)
              top.next();
            heapBubble(this.heap, 0);
          }
        }
      };
      function heapBubble(heap, index) {
        for (let cur = heap[index]; ; ) {
          let childIndex = (index << 1) + 1;
          if (childIndex >= heap.length)
            break;
          let child = heap[childIndex];
          if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
            child = heap[childIndex + 1];
            childIndex++;
          }
          if (cur.compare(child) < 0)
            break;
          heap[childIndex] = cur;
          heap[index] = child;
          index = childIndex;
        }
      }
      var SpanCursor = class {
        constructor(sets, skip, minPoint) {
          this.minPoint = minPoint;
          this.active = [];
          this.activeTo = [];
          this.activeRank = [];
          this.minActive = -1;
          this.point = null;
          this.pointFrom = 0;
          this.pointRank = 0;
          this.to = -1e9;
          this.endSide = 0;
          this.openStart = -1;
          this.cursor = HeapCursor.from(sets, skip, minPoint);
        }
        goto(pos, side = -1e9) {
          this.cursor.goto(pos, side);
          this.active.length = this.activeTo.length = this.activeRank.length = 0;
          this.minActive = -1;
          this.to = pos;
          this.endSide = side;
          this.openStart = -1;
          this.next();
          return this;
        }
        forward(pos, side) {
          while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
            this.removeActive(this.minActive);
          this.cursor.forward(pos, side);
        }
        removeActive(index) {
          remove(this.active, index);
          remove(this.activeTo, index);
          remove(this.activeRank, index);
          this.minActive = findMinIndex(this.active, this.activeTo);
        }
        addActive(trackOpen) {
          let i = 0, { value, to, rank } = this.cursor;
          while (i < this.activeRank.length && this.activeRank[i] <= rank)
            i++;
          insert(this.active, i, value);
          insert(this.activeTo, i, to);
          insert(this.activeRank, i, rank);
          if (trackOpen)
            insert(trackOpen, i, this.cursor.from);
          this.minActive = findMinIndex(this.active, this.activeTo);
        }
        next() {
          let from = this.to, wasPoint = this.point;
          this.point = null;
          let trackOpen = this.openStart < 0 ? [] : null, trackExtra = 0;
          for (; ; ) {
            let a = this.minActive;
            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
              if (this.activeTo[a] > from) {
                this.to = this.activeTo[a];
                this.endSide = this.active[a].endSide;
                break;
              }
              this.removeActive(a);
              if (trackOpen)
                remove(trackOpen, a);
            } else if (!this.cursor.value) {
              this.to = this.endSide = 1e9;
              break;
            } else if (this.cursor.from > from) {
              this.to = this.cursor.from;
              this.endSide = this.cursor.startSide;
              break;
            } else {
              let nextVal = this.cursor.value;
              if (!nextVal.point) {
                this.addActive(trackOpen);
                if (this.cursor.from < from && this.cursor.to > from)
                  trackExtra++;
                this.cursor.next();
              } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
                this.cursor.next();
              } else {
                this.point = nextVal;
                this.pointFrom = this.cursor.from;
                this.pointRank = this.cursor.rank;
                this.to = this.cursor.to;
                this.endSide = nextVal.endSide;
                if (this.cursor.from < from)
                  trackExtra = 1;
                this.cursor.next();
                this.forward(this.to, this.endSide);
                break;
              }
            }
          }
          if (trackOpen) {
            let openStart = 0;
            while (openStart < trackOpen.length && trackOpen[openStart] < from)
              openStart++;
            this.openStart = openStart + trackExtra;
          }
        }
        activeForPoint(to) {
          if (!this.active.length)
            return this.active;
          let active = [];
          for (let i = this.active.length - 1; i >= 0; i--) {
            if (this.activeRank[i] < this.pointRank)
              break;
            if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)
              active.push(this.active[i]);
          }
          return active.reverse();
        }
        openEnd(to) {
          let open2 = 0;
          for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)
            open2++;
          return open2;
        }
      };
      function compare(a, startA, b, startB, length, comparator) {
        a.goto(startA);
        b.goto(startB);
        let endB = startB + length;
        let pos = startB, dPos = startB - startA;
        for (; ; ) {
          let diff = a.to + dPos - b.to || a.endSide - b.endSide;
          let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
          if (a.point || b.point) {
            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to + dPos), b.activeForPoint(b.to))))
              comparator.comparePoint(pos, clipEnd, a.point, b.point);
          } else {
            if (clipEnd > pos && !sameValues(a.active, b.active))
              comparator.compareRange(pos, clipEnd, a.active, b.active);
          }
          if (end > endB)
            break;
          pos = end;
          if (diff <= 0)
            a.next();
          if (diff >= 0)
            b.next();
        }
      }
      function sameValues(a, b) {
        if (a.length != b.length)
          return false;
        for (let i = 0; i < a.length; i++)
          if (a[i] != b[i] && !a[i].eq(b[i]))
            return false;
        return true;
      }
      function remove(array, index) {
        for (let i = index, e = array.length - 1; i < e; i++)
          array[i] = array[i + 1];
        array.pop();
      }
      function insert(array, index, value) {
        for (let i = array.length - 1; i >= index; i--)
          array[i + 1] = array[i];
        array[index] = value;
      }
      function findMinIndex(value, array) {
        let found = -1, foundPos = 1e9;
        for (let i = 0; i < array.length; i++)
          if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
            found = i;
            foundPos = array[i];
          }
        return found;
      }
      function countColumn(string, tabSize, to = string.length) {
        let n = 0;
        for (let i = 0; i < to; ) {
          if (string.charCodeAt(i) == 9) {
            n += tabSize - n % tabSize;
            i++;
          } else {
            n++;
            i = findClusterBreak(string, i);
          }
        }
        return n;
      }
      function findColumn(string, col, tabSize, strict) {
        for (let i = 0, n = 0; ; ) {
          if (n >= col)
            return i;
          if (i == string.length)
            break;
          n += string.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;
          i = findClusterBreak(string, i);
        }
        return strict === true ? -1 : string.length;
      }
      exports.Annotation = Annotation;
      exports.AnnotationType = AnnotationType;
      exports.ChangeDesc = ChangeDesc;
      exports.ChangeSet = ChangeSet;
      exports.Compartment = Compartment;
      exports.EditorSelection = EditorSelection;
      exports.EditorState = EditorState;
      exports.Facet = Facet;
      exports.Line = Line;
      exports.Prec = Prec;
      exports.Range = Range;
      exports.RangeSet = RangeSet;
      exports.RangeSetBuilder = RangeSetBuilder;
      exports.RangeValue = RangeValue;
      exports.SelectionRange = SelectionRange;
      exports.StateEffect = StateEffect;
      exports.StateEffectType = StateEffectType;
      exports.StateField = StateField;
      exports.Text = Text;
      exports.Transaction = Transaction;
      exports.codePointAt = codePointAt;
      exports.codePointSize = codePointSize;
      exports.combineConfig = combineConfig;
      exports.countColumn = countColumn;
      exports.findClusterBreak = findClusterBreak;
      exports.findColumn = findColumn;
      exports.fromCodePoint = fromCodePoint;
    }
  });

  // node_modules/style-mod/dist/style-mod.cjs
  var require_style_mod = __commonJS({
    "node_modules/style-mod/dist/style-mod.cjs"(exports) {
      var C = "\u037C";
      var COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
      var SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
      var top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
      var StyleModule = exports.StyleModule = function StyleModule2(spec, options) {
        this.rules = [];
        var ref = options || {};
        var finish = ref.finish;
        function splitSelector(selector) {
          return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
        }
        function render(selectors, spec2, target, isKeyframes) {
          var local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
          if (isAt && spec2 == null) {
            return target.push(selectors[0] + ";");
          }
          for (var prop2 in spec2) {
            var value = spec2[prop2];
            if (/&/.test(prop2)) {
              render(
                prop2.split(/,\s*/).map(function(part) {
                  return selectors.map(function(sel) {
                    return part.replace(/&/, sel);
                  });
                }).reduce(function(a, b) {
                  return a.concat(b);
                }),
                value,
                target
              );
            } else if (value && typeof value == "object") {
              if (!isAt) {
                throw new RangeError("The value of a property (" + prop2 + ") should be a primitive value.");
              }
              render(splitSelector(prop2), value, local, keyframes);
            } else if (value != null) {
              local.push(prop2.replace(/_.*/, "").replace(/[A-Z]/g, function(l) {
                return "-" + l.toLowerCase();
              }) + ": " + value + ";");
            }
          }
          if (local.length || keyframes) {
            target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
          }
        }
        for (var prop in spec) {
          render(splitSelector(prop), spec[prop], this.rules);
        }
      };
      StyleModule.prototype.getRules = function getRules() {
        return this.rules.join("\n");
      };
      StyleModule.newName = function newName() {
        var id = top[COUNT] || 1;
        top[COUNT] = id + 1;
        return C + id.toString(36);
      };
      StyleModule.mount = function mount(root, modules) {
        (root[SET] || new StyleSet(root)).mount(Array.isArray(modules) ? modules : [modules]);
      };
      var adoptedSet = null;
      var StyleSet = function StyleSet2(root) {
        if (!root.head && root.adoptedStyleSheets && typeof CSSStyleSheet != "undefined") {
          if (adoptedSet) {
            root.adoptedStyleSheets = [adoptedSet.sheet].concat(root.adoptedStyleSheets);
            return root[SET] = adoptedSet;
          }
          this.sheet = new CSSStyleSheet();
          root.adoptedStyleSheets = [this.sheet].concat(root.adoptedStyleSheets);
          adoptedSet = this;
        } else {
          this.styleTag = (root.ownerDocument || root).createElement("style");
          var target = root.head || root;
          target.insertBefore(this.styleTag, target.firstChild);
        }
        this.modules = [];
        root[SET] = this;
      };
      StyleSet.prototype.mount = function mount(modules) {
        var sheet = this.sheet;
        var pos = 0, j = 0;
        for (var i = 0; i < modules.length; i++) {
          var mod = modules[i], index = this.modules.indexOf(mod);
          if (index < j && index > -1) {
            this.modules.splice(index, 1);
            j--;
            index = -1;
          }
          if (index == -1) {
            this.modules.splice(j++, 0, mod);
            if (sheet) {
              for (var k = 0; k < mod.rules.length; k++) {
                sheet.insertRule(mod.rules[k], pos++);
              }
            }
          } else {
            while (j < index) {
              pos += this.modules[j++].rules.length;
            }
            pos += mod.rules.length;
            j++;
          }
        }
        if (!sheet) {
          var text = "";
          for (var i$1 = 0; i$1 < this.modules.length; i$1++) {
            text += this.modules[i$1].getRules() + "\n";
          }
          this.styleTag.textContent = text;
        }
      };
    }
  });

  // node_modules/w3c-keyname/index.cjs
  var require_w3c_keyname = __commonJS({
    "node_modules/w3c-keyname/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var base = {
        8: "Backspace",
        9: "Tab",
        10: "Enter",
        12: "NumLock",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        44: "PrintScreen",
        45: "Insert",
        46: "Delete",
        59: ";",
        61: "=",
        91: "Meta",
        92: "Meta",
        106: "*",
        107: "+",
        108: ",",
        109: "-",
        110: ".",
        111: "/",
        144: "NumLock",
        145: "ScrollLock",
        160: "Shift",
        161: "Shift",
        162: "Control",
        163: "Control",
        164: "Alt",
        165: "Alt",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'"
      };
      var shift = {
        48: ")",
        49: "!",
        50: "@",
        51: "#",
        52: "$",
        53: "%",
        54: "^",
        55: "&",
        56: "*",
        57: "(",
        59: ":",
        61: "+",
        173: "_",
        186: ":",
        187: "+",
        188: "<",
        189: "_",
        190: ">",
        191: "?",
        192: "~",
        219: "{",
        220: "|",
        221: "}",
        222: '"'
      };
      var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
      var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
      var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
      var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
      var brokenModifierNames = mac || chrome && +chrome[1] < 57;
      for (i = 0; i < 10; i++)
        base[48 + i] = base[96 + i] = String(i);
      var i;
      for (i = 1; i <= 24; i++)
        base[i + 111] = "F" + i;
      var i;
      for (i = 65; i <= 90; i++) {
        base[i] = String.fromCharCode(i + 32);
        shift[i] = String.fromCharCode(i);
      }
      var i;
      for (code in base)
        if (!shift.hasOwnProperty(code))
          shift[code] = base[code];
      var code;
      function keyName(event) {
        var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
        var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
        if (name == "Esc")
          name = "Escape";
        if (name == "Del")
          name = "Delete";
        if (name == "Left")
          name = "ArrowLeft";
        if (name == "Up")
          name = "ArrowUp";
        if (name == "Right")
          name = "ArrowRight";
        if (name == "Down")
          name = "ArrowDown";
        return name;
      }
      exports.base = base;
      exports.keyName = keyName;
      exports.shift = shift;
    }
  });

  // node_modules/@codemirror/view/dist/index.cjs
  var require_dist2 = __commonJS({
    "node_modules/@codemirror/view/dist/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var state = require_dist();
      var styleMod = require_style_mod();
      var w3cKeyname = require_w3c_keyname();
      function getSelection(root) {
        let target;
        if (root.nodeType == 11) {
          target = root.getSelection ? root : root.ownerDocument;
        } else {
          target = root;
        }
        return target.getSelection();
      }
      function contains(dom, node) {
        return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
      }
      function deepActiveElement() {
        let elt = document.activeElement;
        while (elt && elt.shadowRoot)
          elt = elt.shadowRoot.activeElement;
        return elt;
      }
      function hasSelection(dom, selection) {
        if (!selection.anchorNode)
          return false;
        try {
          return contains(dom, selection.anchorNode);
        } catch (_) {
          return false;
        }
      }
      function clientRectsFor(dom) {
        if (dom.nodeType == 3)
          return textRange(dom, 0, dom.nodeValue.length).getClientRects();
        else if (dom.nodeType == 1)
          return dom.getClientRects();
        else
          return [];
      }
      function isEquivalentPosition(node, off, targetNode, targetOff) {
        return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
      }
      function domIndex(node) {
        for (var index = 0; ; index++) {
          node = node.previousSibling;
          if (!node)
            return index;
        }
      }
      function scanFor(node, off, targetNode, targetOff, dir) {
        for (; ; ) {
          if (node == targetNode && off == targetOff)
            return true;
          if (off == (dir < 0 ? 0 : maxOffset(node))) {
            if (node.nodeName == "DIV")
              return false;
            let parent = node.parentNode;
            if (!parent || parent.nodeType != 1)
              return false;
            off = domIndex(node) + (dir < 0 ? 0 : 1);
            node = parent;
          } else if (node.nodeType == 1) {
            node = node.childNodes[off + (dir < 0 ? -1 : 0)];
            if (node.nodeType == 1 && node.contentEditable == "false")
              return false;
            off = dir < 0 ? maxOffset(node) : 0;
          } else {
            return false;
          }
        }
      }
      function maxOffset(node) {
        return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
      }
      var Rect0 = { left: 0, right: 0, top: 0, bottom: 0 };
      function flattenRect(rect, left) {
        let x = left ? rect.left : rect.right;
        return { left: x, right: x, top: rect.top, bottom: rect.bottom };
      }
      function windowRect(win) {
        return {
          left: 0,
          right: win.innerWidth,
          top: 0,
          bottom: win.innerHeight
        };
      }
      function scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {
        let doc2 = dom.ownerDocument, win = doc2.defaultView;
        for (let cur = dom; cur; ) {
          if (cur.nodeType == 1) {
            let bounding, top = cur == doc2.body;
            if (top) {
              bounding = windowRect(win);
            } else {
              if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {
                cur = cur.parentNode;
                continue;
              }
              let rect2 = cur.getBoundingClientRect();
              bounding = {
                left: rect2.left,
                right: rect2.left + cur.clientWidth,
                top: rect2.top,
                bottom: rect2.top + cur.clientHeight
              };
            }
            let moveX = 0, moveY = 0;
            if (y == "nearest") {
              if (rect.top < bounding.top) {
                moveY = -(bounding.top - rect.top + yMargin);
                if (side > 0 && rect.bottom > bounding.bottom + moveY)
                  moveY = rect.bottom - bounding.bottom + moveY + yMargin;
              } else if (rect.bottom > bounding.bottom) {
                moveY = rect.bottom - bounding.bottom + yMargin;
                if (side < 0 && rect.top - moveY < bounding.top)
                  moveY = -(bounding.top + moveY - rect.top + yMargin);
              }
            } else {
              let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
              let targetTop = y == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == "start" || y == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
              moveY = targetTop - bounding.top;
            }
            if (x == "nearest") {
              if (rect.left < bounding.left) {
                moveX = -(bounding.left - rect.left + xMargin);
                if (side > 0 && rect.right > bounding.right + moveX)
                  moveX = rect.right - bounding.right + moveX + xMargin;
              } else if (rect.right > bounding.right) {
                moveX = rect.right - bounding.right + xMargin;
                if (side < 0 && rect.left < bounding.left + moveX)
                  moveX = -(bounding.left + moveX - rect.left + xMargin);
              }
            } else {
              let targetLeft = x == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
              moveX = targetLeft - bounding.left;
            }
            if (moveX || moveY) {
              if (top) {
                win.scrollBy(moveX, moveY);
              } else {
                if (moveY) {
                  let start = cur.scrollTop;
                  cur.scrollTop += moveY;
                  moveY = cur.scrollTop - start;
                }
                if (moveX) {
                  let start = cur.scrollLeft;
                  cur.scrollLeft += moveX;
                  moveX = cur.scrollLeft - start;
                }
                rect = {
                  left: rect.left - moveX,
                  top: rect.top - moveY,
                  right: rect.right - moveX,
                  bottom: rect.bottom - moveY
                };
              }
            }
            if (top)
              break;
            cur = cur.assignedSlot || cur.parentNode;
            x = y = "nearest";
          } else if (cur.nodeType == 11) {
            cur = cur.host;
          } else {
            break;
          }
        }
      }
      var DOMSelectionState = class {
        constructor() {
          this.anchorNode = null;
          this.anchorOffset = 0;
          this.focusNode = null;
          this.focusOffset = 0;
        }
        eq(domSel) {
          return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
        }
        setRange(range) {
          this.set(range.anchorNode, range.anchorOffset, range.focusNode, range.focusOffset);
        }
        set(anchorNode, anchorOffset, focusNode, focusOffset) {
          this.anchorNode = anchorNode;
          this.anchorOffset = anchorOffset;
          this.focusNode = focusNode;
          this.focusOffset = focusOffset;
        }
      };
      var preventScrollSupported = null;
      function focusPreventScroll(dom) {
        if (dom.setActive)
          return dom.setActive();
        if (preventScrollSupported)
          return dom.focus(preventScrollSupported);
        let stack = [];
        for (let cur = dom; cur; cur = cur.parentNode) {
          stack.push(cur, cur.scrollTop, cur.scrollLeft);
          if (cur == cur.ownerDocument)
            break;
        }
        dom.focus(preventScrollSupported == null ? {
          get preventScroll() {
            preventScrollSupported = { preventScroll: true };
            return true;
          }
        } : void 0);
        if (!preventScrollSupported) {
          preventScrollSupported = false;
          for (let i = 0; i < stack.length; ) {
            let elt = stack[i++], top = stack[i++], left = stack[i++];
            if (elt.scrollTop != top)
              elt.scrollTop = top;
            if (elt.scrollLeft != left)
              elt.scrollLeft = left;
          }
        }
      }
      var scratchRange;
      function textRange(node, from, to = from) {
        let range = scratchRange || (scratchRange = document.createRange());
        range.setEnd(node, to);
        range.setStart(node, from);
        return range;
      }
      function dispatchKey(elt, name, code) {
        let options = { key: name, code: name, keyCode: code, which: code, cancelable: true };
        let down = new KeyboardEvent("keydown", options);
        down.synthetic = true;
        elt.dispatchEvent(down);
        let up = new KeyboardEvent("keyup", options);
        up.synthetic = true;
        elt.dispatchEvent(up);
        return down.defaultPrevented || up.defaultPrevented;
      }
      function getRoot(node) {
        while (node) {
          if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
            return node;
          node = node.assignedSlot || node.parentNode;
        }
        return null;
      }
      function clearAttributes(node) {
        while (node.attributes.length)
          node.removeAttributeNode(node.attributes[0]);
      }
      function atElementStart(doc2, selection) {
        let node = selection.focusNode, offset = selection.focusOffset;
        if (!node || selection.anchorNode != node || selection.anchorOffset != offset)
          return false;
        for (; ; ) {
          if (offset) {
            if (node.nodeType != 1)
              return false;
            let prev = node.childNodes[offset - 1];
            if (prev.contentEditable == "false")
              offset--;
            else {
              node = prev;
              offset = maxOffset(node);
            }
          } else if (node == doc2) {
            return true;
          } else {
            offset = domIndex(node);
            node = node.parentNode;
          }
        }
      }
      var DOMPos = class {
        constructor(node, offset, precise = true) {
          this.node = node;
          this.offset = offset;
          this.precise = precise;
        }
        static before(dom, precise) {
          return new DOMPos(dom.parentNode, domIndex(dom), precise);
        }
        static after(dom, precise) {
          return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
        }
      };
      var noChildren = [];
      var ContentView = class {
        constructor() {
          this.parent = null;
          this.dom = null;
          this.dirty = 2;
        }
        get editorView() {
          if (!this.parent)
            throw new Error("Accessing view in orphan content view");
          return this.parent.editorView;
        }
        get overrideDOMText() {
          return null;
        }
        get posAtStart() {
          return this.parent ? this.parent.posBefore(this) : 0;
        }
        get posAtEnd() {
          return this.posAtStart + this.length;
        }
        posBefore(view) {
          let pos = this.posAtStart;
          for (let child of this.children) {
            if (child == view)
              return pos;
            pos += child.length + child.breakAfter;
          }
          throw new RangeError("Invalid child in posBefore");
        }
        posAfter(view) {
          return this.posBefore(view) + view.length;
        }
        coordsAt(_pos, _side) {
          return null;
        }
        sync(track) {
          if (this.dirty & 2) {
            let parent = this.dom;
            let prev = null, next;
            for (let child of this.children) {
              if (child.dirty) {
                if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
                  let contentView = ContentView.get(next);
                  if (!contentView || !contentView.parent && contentView.constructor == child.constructor)
                    child.reuseDOM(next);
                }
                child.sync(track);
                child.dirty = 0;
              }
              next = prev ? prev.nextSibling : parent.firstChild;
              if (track && !track.written && track.node == parent && next != child.dom)
                track.written = true;
              if (child.dom.parentNode == parent) {
                while (next && next != child.dom)
                  next = rm$1(next);
              } else {
                parent.insertBefore(child.dom, next);
              }
              prev = child.dom;
            }
            next = prev ? prev.nextSibling : parent.firstChild;
            if (next && track && track.node == parent)
              track.written = true;
            while (next)
              next = rm$1(next);
          } else if (this.dirty & 1) {
            for (let child of this.children)
              if (child.dirty) {
                child.sync(track);
                child.dirty = 0;
              }
          }
        }
        reuseDOM(_dom) {
        }
        localPosFromDOM(node, offset) {
          let after;
          if (node == this.dom) {
            after = this.dom.childNodes[offset];
          } else {
            let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
            for (; ; ) {
              let parent = node.parentNode;
              if (parent == this.dom)
                break;
              if (bias == 0 && parent.firstChild != parent.lastChild) {
                if (node == parent.firstChild)
                  bias = -1;
                else
                  bias = 1;
              }
              node = parent;
            }
            if (bias < 0)
              after = node;
            else
              after = node.nextSibling;
          }
          if (after == this.dom.firstChild)
            return 0;
          while (after && !ContentView.get(after))
            after = after.nextSibling;
          if (!after)
            return this.length;
          for (let i = 0, pos = 0; ; i++) {
            let child = this.children[i];
            if (child.dom == after)
              return pos;
            pos += child.length + child.breakAfter;
          }
        }
        domBoundsAround(from, to, offset = 0) {
          let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
          for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
            let child = this.children[i], end = pos + child.length;
            if (pos < from && end > to)
              return child.domBoundsAround(from, to, pos);
            if (end >= from && fromI == -1) {
              fromI = i;
              fromStart = pos;
            }
            if (pos > to && child.dom.parentNode == this.dom) {
              toI = i;
              toEnd = prevEnd;
              break;
            }
            prevEnd = end;
            pos = end + child.breakAfter;
          }
          return {
            from: fromStart,
            to: toEnd < 0 ? offset + this.length : toEnd,
            startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
            endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
          };
        }
        markDirty(andParent = false) {
          this.dirty |= 2;
          this.markParentsDirty(andParent);
        }
        markParentsDirty(childList) {
          for (let parent = this.parent; parent; parent = parent.parent) {
            if (childList)
              parent.dirty |= 2;
            if (parent.dirty & 1)
              return;
            parent.dirty |= 1;
            childList = false;
          }
        }
        setParent(parent) {
          if (this.parent != parent) {
            this.parent = parent;
            if (this.dirty)
              this.markParentsDirty(true);
          }
        }
        setDOM(dom) {
          if (this.dom)
            this.dom.cmView = null;
          this.dom = dom;
          dom.cmView = this;
        }
        get rootView() {
          for (let v = this; ; ) {
            let parent = v.parent;
            if (!parent)
              return v;
            v = parent;
          }
        }
        replaceChildren(from, to, children = noChildren) {
          this.markDirty();
          for (let i = from; i < to; i++) {
            let child = this.children[i];
            if (child.parent == this)
              child.destroy();
          }
          this.children.splice(from, to - from, ...children);
          for (let i = 0; i < children.length; i++)
            children[i].setParent(this);
        }
        ignoreMutation(_rec) {
          return false;
        }
        ignoreEvent(_event) {
          return false;
        }
        childCursor(pos = this.length) {
          return new ChildCursor(this.children, pos, this.children.length);
        }
        childPos(pos, bias = 1) {
          return this.childCursor().findPos(pos, bias);
        }
        toString() {
          let name = this.constructor.name.replace("View", "");
          return name + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
        }
        static get(node) {
          return node.cmView;
        }
        get isEditable() {
          return true;
        }
        merge(from, to, source, hasStart, openStart, openEnd) {
          return false;
        }
        become(other) {
          return false;
        }
        getSide() {
          return 0;
        }
        destroy() {
          this.parent = null;
        }
      };
      ContentView.prototype.breakAfter = 0;
      function rm$1(dom) {
        let next = dom.nextSibling;
        dom.parentNode.removeChild(dom);
        return next;
      }
      var ChildCursor = class {
        constructor(children, pos, i) {
          this.children = children;
          this.pos = pos;
          this.i = i;
          this.off = 0;
        }
        findPos(pos, bias = 1) {
          for (; ; ) {
            if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
              this.off = pos - this.pos;
              return this;
            }
            let next = this.children[--this.i];
            this.pos -= next.length + next.breakAfter;
          }
        }
      };
      function replaceRange(parent, fromI, fromOff, toI, toOff, insert, breakAtStart, openStart, openEnd) {
        let { children } = parent;
        let before = children.length ? children[fromI] : null;
        let last = insert.length ? insert[insert.length - 1] : null;
        let breakAtEnd = last ? last.breakAfter : breakAtStart;
        if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert.length < 2 && before.merge(fromOff, toOff, insert.length ? last : null, fromOff == 0, openStart, openEnd))
          return;
        if (toI < children.length) {
          let after = children[toI];
          if (after && toOff < after.length) {
            if (fromI == toI) {
              after = after.split(toOff);
              toOff = 0;
            }
            if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
              insert[insert.length - 1] = after;
            } else {
              if (toOff)
                after.merge(0, toOff, null, false, 0, openEnd);
              insert.push(after);
            }
          } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
            if (last)
              last.breakAfter = 1;
            else
              breakAtStart = 1;
          }
          toI++;
        }
        if (before) {
          before.breakAfter = breakAtStart;
          if (fromOff > 0) {
            if (!breakAtStart && insert.length && before.merge(fromOff, before.length, insert[0], false, openStart, 0)) {
              before.breakAfter = insert.shift().breakAfter;
            } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
              before.merge(fromOff, before.length, null, false, openStart, 0);
            }
            fromI++;
          }
        }
        while (fromI < toI && insert.length) {
          if (children[toI - 1].become(insert[insert.length - 1])) {
            toI--;
            insert.pop();
            openEnd = insert.length ? 0 : openStart;
          } else if (children[fromI].become(insert[0])) {
            fromI++;
            insert.shift();
            openStart = insert.length ? 0 : openEnd;
          } else {
            break;
          }
        }
        if (!insert.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))
          fromI--;
        if (fromI < toI || insert.length)
          parent.replaceChildren(fromI, toI, insert);
      }
      function mergeChildrenInto(parent, from, to, insert, openStart, openEnd) {
        let cur = parent.childCursor();
        let { i: toI, off: toOff } = cur.findPos(to, 1);
        let { i: fromI, off: fromOff } = cur.findPos(from, -1);
        let dLen = from - to;
        for (let view of insert)
          dLen += view.length;
        parent.length += dLen;
        replaceRange(parent, fromI, fromOff, toI, toOff, insert, 0, openStart, openEnd);
      }
      var nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
      var doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
      var ie_edge = /Edge\/(\d+)/.exec(nav.userAgent);
      var ie_upto10 = /MSIE \d/.test(nav.userAgent);
      var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
      var ie = !!(ie_upto10 || ie_11up || ie_edge);
      var gecko = !ie && /gecko\/(\d+)/i.test(nav.userAgent);
      var chrome = !ie && /Chrome\/(\d+)/.exec(nav.userAgent);
      var webkit = "webkitFontSmoothing" in doc.documentElement.style;
      var safari = !ie && /Apple Computer/.test(nav.vendor);
      var ios = safari && (/Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
      var browser = {
        mac: ios || /Mac/.test(nav.platform),
        windows: /Win/.test(nav.platform),
        linux: /Linux|X11/.test(nav.platform),
        ie,
        ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
        gecko,
        gecko_version: gecko ? +(/Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
        chrome: !!chrome,
        chrome_version: chrome ? +chrome[1] : 0,
        ios,
        android: /Android\b/.test(nav.userAgent),
        webkit,
        safari,
        webkit_version: webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
        tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
      };
      var MaxJoinLen = 256;
      var TextView = class extends ContentView {
        constructor(text) {
          super();
          this.text = text;
        }
        get length() {
          return this.text.length;
        }
        createDOM(textDOM) {
          this.setDOM(textDOM || document.createTextNode(this.text));
        }
        sync(track) {
          if (!this.dom)
            this.createDOM();
          if (this.dom.nodeValue != this.text) {
            if (track && track.node == this.dom)
              track.written = true;
            this.dom.nodeValue = this.text;
          }
        }
        reuseDOM(dom) {
          if (dom.nodeType == 3)
            this.createDOM(dom);
        }
        merge(from, to, source) {
          if (source && (!(source instanceof TextView) || this.length - (to - from) + source.length > MaxJoinLen))
            return false;
          this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to);
          this.markDirty();
          return true;
        }
        split(from) {
          let result = new TextView(this.text.slice(from));
          this.text = this.text.slice(0, from);
          this.markDirty();
          return result;
        }
        localPosFromDOM(node, offset) {
          return node == this.dom ? offset : offset ? this.text.length : 0;
        }
        domAtPos(pos) {
          return new DOMPos(this.dom, pos);
        }
        domBoundsAround(_from, _to, offset) {
          return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
        }
        coordsAt(pos, side) {
          return textCoords(this.dom, pos, side);
        }
      };
      var MarkView = class extends ContentView {
        constructor(mark, children = [], length = 0) {
          super();
          this.mark = mark;
          this.children = children;
          this.length = length;
          for (let ch of children)
            ch.setParent(this);
        }
        setAttrs(dom) {
          clearAttributes(dom);
          if (this.mark.class)
            dom.className = this.mark.class;
          if (this.mark.attrs)
            for (let name in this.mark.attrs)
              dom.setAttribute(name, this.mark.attrs[name]);
          return dom;
        }
        reuseDOM(node) {
          if (node.nodeName == this.mark.tagName.toUpperCase()) {
            this.setDOM(node);
            this.dirty |= 4 | 2;
          }
        }
        sync(track) {
          if (!this.dom)
            this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
          else if (this.dirty & 4)
            this.setAttrs(this.dom);
          super.sync(track);
        }
        merge(from, to, source, _hasStart, openStart, openEnd) {
          if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0))
            return false;
          mergeChildrenInto(this, from, to, source ? source.children : [], openStart - 1, openEnd - 1);
          this.markDirty();
          return true;
        }
        split(from) {
          let result = [], off = 0, detachFrom = -1, i = 0;
          for (let elt of this.children) {
            let end = off + elt.length;
            if (end > from)
              result.push(off < from ? elt.split(from - off) : elt);
            if (detachFrom < 0 && off >= from)
              detachFrom = i;
            off = end;
            i++;
          }
          let length = this.length - from;
          this.length = from;
          if (detachFrom > -1) {
            this.children.length = detachFrom;
            this.markDirty();
          }
          return new MarkView(this.mark, result, length);
        }
        domAtPos(pos) {
          return inlineDOMAtPos(this.dom, this.children, pos);
        }
        coordsAt(pos, side) {
          return coordsInChildren(this, pos, side);
        }
      };
      function textCoords(text, pos, side) {
        let length = text.nodeValue.length;
        if (pos > length)
          pos = length;
        let from = pos, to = pos, flatten = 0;
        if (pos == 0 && side < 0 || pos == length && side >= 0) {
          if (!(browser.chrome || browser.gecko)) {
            if (pos) {
              from--;
              flatten = 1;
            } else if (to < length) {
              to++;
              flatten = -1;
            }
          }
        } else {
          if (side < 0)
            from--;
          else if (to < length)
            to++;
        }
        let rects = textRange(text, from, to).getClientRects();
        if (!rects.length)
          return Rect0;
        let rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];
        if (browser.safari && !flatten && rect.width == 0)
          rect = Array.prototype.find.call(rects, (r) => r.width) || rect;
        return flatten ? flattenRect(rect, flatten < 0) : rect || null;
      }
      var WidgetView = class extends ContentView {
        constructor(widget, length, side) {
          super();
          this.widget = widget;
          this.length = length;
          this.side = side;
          this.prevWidget = null;
        }
        static create(widget, length, side) {
          return new (widget.customView || WidgetView)(widget, length, side);
        }
        split(from) {
          let result = WidgetView.create(this.widget, this.length - from, this.side);
          this.length -= from;
          return result;
        }
        sync() {
          if (!this.dom || !this.widget.updateDOM(this.dom)) {
            if (this.dom && this.prevWidget)
              this.prevWidget.destroy(this.dom);
            this.prevWidget = null;
            this.setDOM(this.widget.toDOM(this.editorView));
            this.dom.contentEditable = "false";
          }
        }
        getSide() {
          return this.side;
        }
        merge(from, to, source, hasStart, openStart, openEnd) {
          if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
            return false;
          this.length = from + (source ? source.length : 0) + (this.length - to);
          return true;
        }
        become(other) {
          if (other.length == this.length && other instanceof WidgetView && other.side == this.side) {
            if (this.widget.constructor == other.widget.constructor) {
              if (!this.widget.eq(other.widget))
                this.markDirty(true);
              if (this.dom && !this.prevWidget)
                this.prevWidget = this.widget;
              this.widget = other.widget;
              return true;
            }
          }
          return false;
        }
        ignoreMutation() {
          return true;
        }
        ignoreEvent(event) {
          return this.widget.ignoreEvent(event);
        }
        get overrideDOMText() {
          if (this.length == 0)
            return state.Text.empty;
          let top = this;
          while (top.parent)
            top = top.parent;
          let view = top.editorView, text = view && view.state.doc, start = this.posAtStart;
          return text ? text.slice(start, start + this.length) : state.Text.empty;
        }
        domAtPos(pos) {
          return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
        }
        domBoundsAround() {
          return null;
        }
        coordsAt(pos, side) {
          let rects = this.dom.getClientRects(), rect = null;
          if (!rects.length)
            return Rect0;
          for (let i = pos > 0 ? rects.length - 1 : 0; ; i += pos > 0 ? -1 : 1) {
            rect = rects[i];
            if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)
              break;
          }
          return pos == 0 && side > 0 || pos == this.length && side <= 0 ? rect : flattenRect(rect, pos == 0);
        }
        get isEditable() {
          return false;
        }
        destroy() {
          super.destroy();
          if (this.dom)
            this.widget.destroy(this.dom);
        }
      };
      var CompositionView = class extends WidgetView {
        domAtPos(pos) {
          let { topView, text } = this.widget;
          if (!topView)
            return new DOMPos(text, Math.min(pos, text.nodeValue.length));
          return scanCompositionTree(pos, 0, topView, text, (v, p) => v.domAtPos(p), (p) => new DOMPos(text, Math.min(p, text.nodeValue.length)));
        }
        sync() {
          this.setDOM(this.widget.toDOM());
        }
        localPosFromDOM(node, offset) {
          let { topView, text } = this.widget;
          if (!topView)
            return Math.min(offset, this.length);
          return posFromDOMInCompositionTree(node, offset, topView, text);
        }
        ignoreMutation() {
          return false;
        }
        get overrideDOMText() {
          return null;
        }
        coordsAt(pos, side) {
          let { topView, text } = this.widget;
          if (!topView)
            return textCoords(text, pos, side);
          return scanCompositionTree(pos, side, topView, text, (v, pos2, side2) => v.coordsAt(pos2, side2), (pos2, side2) => textCoords(text, pos2, side2));
        }
        destroy() {
          var _a;
          super.destroy();
          (_a = this.widget.topView) === null || _a === void 0 ? void 0 : _a.destroy();
        }
        get isEditable() {
          return true;
        }
      };
      function scanCompositionTree(pos, side, view, text, enterView, fromText) {
        if (view instanceof MarkView) {
          for (let child of view.children) {
            let hasComp = contains(child.dom, text);
            let len = hasComp ? text.nodeValue.length : child.length;
            if (pos < len || pos == len && child.getSide() <= 0)
              return hasComp ? scanCompositionTree(pos, side, child, text, enterView, fromText) : enterView(child, pos, side);
            pos -= len;
          }
          return enterView(view, view.length, -1);
        } else if (view.dom == text) {
          return fromText(pos, side);
        } else {
          return enterView(view, pos, side);
        }
      }
      function posFromDOMInCompositionTree(node, offset, view, text) {
        if (view instanceof MarkView) {
          for (let child of view.children) {
            let pos = 0, hasComp = contains(child.dom, text);
            if (contains(child.dom, node))
              return pos + (hasComp ? posFromDOMInCompositionTree(node, offset, child, text) : child.localPosFromDOM(node, offset));
            pos += hasComp ? text.nodeValue.length : child.length;
          }
        } else if (view.dom == text) {
          return Math.min(offset, text.nodeValue.length);
        }
        return view.localPosFromDOM(node, offset);
      }
      var WidgetBufferView = class extends ContentView {
        constructor(side) {
          super();
          this.side = side;
        }
        get length() {
          return 0;
        }
        merge() {
          return false;
        }
        become(other) {
          return other instanceof WidgetBufferView && other.side == this.side;
        }
        split() {
          return new WidgetBufferView(this.side);
        }
        sync() {
          if (!this.dom) {
            let dom = document.createElement("img");
            dom.className = "cm-widgetBuffer";
            dom.setAttribute("aria-hidden", "true");
            this.setDOM(dom);
          }
        }
        getSide() {
          return this.side;
        }
        domAtPos(pos) {
          return DOMPos.before(this.dom);
        }
        localPosFromDOM() {
          return 0;
        }
        domBoundsAround() {
          return null;
        }
        coordsAt(pos) {
          let imgRect = this.dom.getBoundingClientRect();
          let siblingRect = inlineSiblingRect(this, this.side > 0 ? -1 : 1);
          return siblingRect && siblingRect.top < imgRect.bottom && siblingRect.bottom > imgRect.top ? { left: imgRect.left, right: imgRect.right, top: siblingRect.top, bottom: siblingRect.bottom } : imgRect;
        }
        get overrideDOMText() {
          return state.Text.empty;
        }
      };
      TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
      function inlineSiblingRect(view, side) {
        let parent = view.parent, index = parent ? parent.children.indexOf(view) : -1;
        while (parent && index >= 0) {
          if (side < 0 ? index > 0 : index < parent.children.length) {
            let next = parent.children[index + side];
            if (next instanceof TextView) {
              let nextRect = next.coordsAt(side < 0 ? next.length : 0, side);
              if (nextRect)
                return nextRect;
            }
            index += side;
          } else if (parent instanceof MarkView && parent.parent) {
            index = parent.parent.children.indexOf(parent) + (side < 0 ? 0 : 1);
            parent = parent.parent;
          } else {
            let last = parent.dom.lastChild;
            if (last && last.nodeName == "BR")
              return last.getClientRects()[0];
            break;
          }
        }
        return void 0;
      }
      function inlineDOMAtPos(dom, children, pos) {
        let i = 0;
        for (let off = 0; i < children.length; i++) {
          let child = children[i], end = off + child.length;
          if (end == off && child.getSide() <= 0)
            continue;
          if (pos > off && pos < end && child.dom.parentNode == dom)
            return child.domAtPos(pos - off);
          if (pos <= off)
            break;
          off = end;
        }
        for (; i > 0; i--) {
          let before = children[i - 1].dom;
          if (before.parentNode == dom)
            return DOMPos.after(before);
        }
        return new DOMPos(dom, 0);
      }
      function joinInlineInto(parent, view, open2) {
        let last, { children } = parent;
        if (open2 > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
          joinInlineInto(last, view.children[0], open2 - 1);
        } else {
          children.push(view);
          view.setParent(parent);
        }
        parent.length += view.length;
      }
      function coordsInChildren(view, pos, side) {
        for (let off = 0, i = 0; i < view.children.length; i++) {
          let child = view.children[i], end = off + child.length, next;
          if ((side <= 0 || end == view.length || child.getSide() > 0 ? end >= pos : end > pos) && (pos < end || i + 1 == view.children.length || (next = view.children[i + 1]).length || next.getSide() > 0)) {
            let flatten = 0;
            if (end == off) {
              if (child.getSide() <= 0)
                continue;
              flatten = side = -child.getSide();
            }
            let rect = child.coordsAt(Math.max(0, pos - off), side);
            return flatten && rect ? flattenRect(rect, side < 0) : rect;
          }
          off = end;
        }
        let last = view.dom.lastChild;
        if (!last)
          return view.dom.getBoundingClientRect();
        let rects = clientRectsFor(last);
        return rects[rects.length - 1] || null;
      }
      function combineAttrs(source, target) {
        for (let name in source) {
          if (name == "class" && target.class)
            target.class += " " + source.class;
          else if (name == "style" && target.style)
            target.style += ";" + source.style;
          else
            target[name] = source[name];
        }
        return target;
      }
      function attrsEq(a, b) {
        if (a == b)
          return true;
        if (!a || !b)
          return false;
        let keysA = Object.keys(a), keysB = Object.keys(b);
        if (keysA.length != keysB.length)
          return false;
        for (let key of keysA) {
          if (keysB.indexOf(key) == -1 || a[key] !== b[key])
            return false;
        }
        return true;
      }
      function updateAttrs(dom, prev, attrs) {
        let changed = null;
        if (prev) {
          for (let name in prev)
            if (!(attrs && name in attrs))
              dom.removeAttribute(changed = name);
        }
        if (attrs) {
          for (let name in attrs)
            if (!(prev && prev[name] == attrs[name]))
              dom.setAttribute(changed = name, attrs[name]);
        }
        return !!changed;
      }
      var WidgetType = class {
        eq(widget) {
          return false;
        }
        updateDOM(dom) {
          return false;
        }
        compare(other) {
          return this == other || this.constructor == other.constructor && this.eq(other);
        }
        get estimatedHeight() {
          return -1;
        }
        ignoreEvent(event) {
          return true;
        }
        get customView() {
          return null;
        }
        destroy(dom) {
        }
      };
      exports.BlockType = void 0;
      (function(BlockType) {
        BlockType[BlockType["Text"] = 0] = "Text";
        BlockType[BlockType["WidgetBefore"] = 1] = "WidgetBefore";
        BlockType[BlockType["WidgetAfter"] = 2] = "WidgetAfter";
        BlockType[BlockType["WidgetRange"] = 3] = "WidgetRange";
      })(exports.BlockType || (exports.BlockType = {}));
      var Decoration = class extends state.RangeValue {
        constructor(startSide, endSide, widget, spec) {
          super();
          this.startSide = startSide;
          this.endSide = endSide;
          this.widget = widget;
          this.spec = spec;
        }
        get heightRelevant() {
          return false;
        }
        static mark(spec) {
          return new MarkDecoration(spec);
        }
        static widget(spec) {
          let side = spec.side || 0, block = !!spec.block;
          side += block ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
          return new PointDecoration(spec, side, side, block, spec.widget || null, false);
        }
        static replace(spec) {
          let block = !!spec.block, startSide, endSide;
          if (spec.isBlockGap) {
            startSide = -5e8;
            endSide = 4e8;
          } else {
            let { start, end } = getInclusive(spec, block);
            startSide = (start ? block ? -3e8 : -1 : 5e8) - 1;
            endSide = (end ? block ? 2e8 : 1 : -6e8) + 1;
          }
          return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
        }
        static line(spec) {
          return new LineDecoration(spec);
        }
        static set(of, sort = false) {
          return state.RangeSet.of(of, sort);
        }
        hasHeight() {
          return this.widget ? this.widget.estimatedHeight > -1 : false;
        }
      };
      Decoration.none = state.RangeSet.empty;
      var MarkDecoration = class extends Decoration {
        constructor(spec) {
          let { start, end } = getInclusive(spec);
          super(start ? -1 : 5e8, end ? 1 : -6e8, null, spec);
          this.tagName = spec.tagName || "span";
          this.class = spec.class || "";
          this.attrs = spec.attributes || null;
        }
        eq(other) {
          return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && this.class == other.class && attrsEq(this.attrs, other.attrs);
        }
        range(from, to = from) {
          if (from >= to)
            throw new RangeError("Mark decorations may not be empty");
          return super.range(from, to);
        }
      };
      MarkDecoration.prototype.point = false;
      var LineDecoration = class extends Decoration {
        constructor(spec) {
          super(-2e8, -2e8, null, spec);
        }
        eq(other) {
          return other instanceof LineDecoration && attrsEq(this.spec.attributes, other.spec.attributes);
        }
        range(from, to = from) {
          if (to != from)
            throw new RangeError("Line decoration ranges must be zero-length");
          return super.range(from, to);
        }
      };
      LineDecoration.prototype.mapMode = state.MapMode.TrackBefore;
      LineDecoration.prototype.point = true;
      var PointDecoration = class extends Decoration {
        constructor(spec, startSide, endSide, block, widget, isReplace) {
          super(startSide, endSide, widget, spec);
          this.block = block;
          this.isReplace = isReplace;
          this.mapMode = !block ? state.MapMode.TrackDel : startSide <= 0 ? state.MapMode.TrackBefore : state.MapMode.TrackAfter;
        }
        get type() {
          return this.startSide < this.endSide ? exports.BlockType.WidgetRange : this.startSide <= 0 ? exports.BlockType.WidgetBefore : exports.BlockType.WidgetAfter;
        }
        get heightRelevant() {
          return this.block || !!this.widget && this.widget.estimatedHeight >= 5;
        }
        eq(other) {
          return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
        }
        range(from, to = from) {
          if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0))
            throw new RangeError("Invalid range for replacement decoration");
          if (!this.isReplace && to != from)
            throw new RangeError("Widget decorations can only have zero-length ranges");
          return super.range(from, to);
        }
      };
      PointDecoration.prototype.point = true;
      function getInclusive(spec, block = false) {
        let { inclusiveStart: start, inclusiveEnd: end } = spec;
        if (start == null)
          start = spec.inclusive;
        if (end == null)
          end = spec.inclusive;
        return { start: start !== null && start !== void 0 ? start : block, end: end !== null && end !== void 0 ? end : block };
      }
      function widgetsEq(a, b) {
        return a == b || !!(a && b && a.compare(b));
      }
      function addRange(from, to, ranges, margin = 0) {
        let last = ranges.length - 1;
        if (last >= 0 && ranges[last] + margin >= from)
          ranges[last] = Math.max(ranges[last], to);
        else
          ranges.push(from, to);
      }
      var LineView = class extends ContentView {
        constructor() {
          super(...arguments);
          this.children = [];
          this.length = 0;
          this.prevAttrs = void 0;
          this.attrs = null;
          this.breakAfter = 0;
        }
        merge(from, to, source, hasStart, openStart, openEnd) {
          if (source) {
            if (!(source instanceof LineView))
              return false;
            if (!this.dom)
              source.transferDOM(this);
          }
          if (hasStart)
            this.setDeco(source ? source.attrs : null);
          mergeChildrenInto(this, from, to, source ? source.children : [], openStart, openEnd);
          return true;
        }
        split(at) {
          let end = new LineView();
          end.breakAfter = this.breakAfter;
          if (this.length == 0)
            return end;
          let { i, off } = this.childPos(at);
          if (off) {
            end.append(this.children[i].split(off), 0);
            this.children[i].merge(off, this.children[i].length, null, false, 0, 0);
            i++;
          }
          for (let j = i; j < this.children.length; j++)
            end.append(this.children[j], 0);
          while (i > 0 && this.children[i - 1].length == 0)
            this.children[--i].destroy();
          this.children.length = i;
          this.markDirty();
          this.length = at;
          return end;
        }
        transferDOM(other) {
          if (!this.dom)
            return;
          this.markDirty();
          other.setDOM(this.dom);
          other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
          this.prevAttrs = void 0;
          this.dom = null;
        }
        setDeco(attrs) {
          if (!attrsEq(this.attrs, attrs)) {
            if (this.dom) {
              this.prevAttrs = this.attrs;
              this.markDirty();
            }
            this.attrs = attrs;
          }
        }
        append(child, openStart) {
          joinInlineInto(this, child, openStart);
        }
        addLineDeco(deco) {
          let attrs = deco.spec.attributes, cls = deco.spec.class;
          if (attrs)
            this.attrs = combineAttrs(attrs, this.attrs || {});
          if (cls)
            this.attrs = combineAttrs({ class: cls }, this.attrs || {});
        }
        domAtPos(pos) {
          return inlineDOMAtPos(this.dom, this.children, pos);
        }
        reuseDOM(node) {
          if (node.nodeName == "DIV") {
            this.setDOM(node);
            this.dirty |= 4 | 2;
          }
        }
        sync(track) {
          var _a;
          if (!this.dom) {
            this.setDOM(document.createElement("div"));
            this.dom.className = "cm-line";
            this.prevAttrs = this.attrs ? null : void 0;
          } else if (this.dirty & 4) {
            clearAttributes(this.dom);
            this.dom.className = "cm-line";
            this.prevAttrs = this.attrs ? null : void 0;
          }
          if (this.prevAttrs !== void 0) {
            updateAttrs(this.dom, this.prevAttrs, this.attrs);
            this.dom.classList.add("cm-line");
            this.prevAttrs = void 0;
          }
          super.sync(track);
          let last = this.dom.lastChild;
          while (last && ContentView.get(last) instanceof MarkView)
            last = last.lastChild;
          if (!last || !this.length || last.nodeName != "BR" && ((_a = ContentView.get(last)) === null || _a === void 0 ? void 0 : _a.isEditable) == false && (!browser.ios || !this.children.some((ch) => ch instanceof TextView))) {
            let hack = document.createElement("BR");
            hack.cmIgnore = true;
            this.dom.appendChild(hack);
          }
        }
        measureTextSize() {
          if (this.children.length == 0 || this.length > 20)
            return null;
          let totalWidth = 0;
          for (let child of this.children) {
            if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
              return null;
            let rects = clientRectsFor(child.dom);
            if (rects.length != 1)
              return null;
            totalWidth += rects[0].width;
          }
          return !totalWidth ? null : {
            lineHeight: this.dom.getBoundingClientRect().height,
            charWidth: totalWidth / this.length
          };
        }
        coordsAt(pos, side) {
          return coordsInChildren(this, pos, side);
        }
        become(_other) {
          return false;
        }
        get type() {
          return exports.BlockType.Text;
        }
        static find(docView, pos) {
          for (let i = 0, off = 0; i < docView.children.length; i++) {
            let block = docView.children[i], end = off + block.length;
            if (end >= pos) {
              if (block instanceof LineView)
                return block;
              if (end > pos)
                break;
            }
            off = end + block.breakAfter;
          }
          return null;
        }
      };
      var BlockWidgetView = class extends ContentView {
        constructor(widget, length, type) {
          super();
          this.widget = widget;
          this.length = length;
          this.type = type;
          this.breakAfter = 0;
          this.prevWidget = null;
        }
        merge(from, to, source, _takeDeco, openStart, openEnd) {
          if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
            return false;
          this.length = from + (source ? source.length : 0) + (this.length - to);
          return true;
        }
        domAtPos(pos) {
          return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
        }
        split(at) {
          let len = this.length - at;
          this.length = at;
          let end = new BlockWidgetView(this.widget, len, this.type);
          end.breakAfter = this.breakAfter;
          return end;
        }
        get children() {
          return noChildren;
        }
        sync() {
          if (!this.dom || !this.widget.updateDOM(this.dom)) {
            if (this.dom && this.prevWidget)
              this.prevWidget.destroy(this.dom);
            this.prevWidget = null;
            this.setDOM(this.widget.toDOM(this.editorView));
            this.dom.contentEditable = "false";
          }
        }
        get overrideDOMText() {
          return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : state.Text.empty;
        }
        domBoundsAround() {
          return null;
        }
        become(other) {
          if (other instanceof BlockWidgetView && other.type == this.type && other.widget.constructor == this.widget.constructor) {
            if (!other.widget.eq(this.widget))
              this.markDirty(true);
            if (this.dom && !this.prevWidget)
              this.prevWidget = this.widget;
            this.widget = other.widget;
            this.length = other.length;
            this.breakAfter = other.breakAfter;
            return true;
          }
          return false;
        }
        ignoreMutation() {
          return true;
        }
        ignoreEvent(event) {
          return this.widget.ignoreEvent(event);
        }
        destroy() {
          super.destroy();
          if (this.dom)
            this.widget.destroy(this.dom);
        }
      };
      var ContentBuilder = class {
        constructor(doc2, pos, end, disallowBlockEffectsFor) {
          this.doc = doc2;
          this.pos = pos;
          this.end = end;
          this.disallowBlockEffectsFor = disallowBlockEffectsFor;
          this.content = [];
          this.curLine = null;
          this.breakAtStart = 0;
          this.pendingBuffer = 0;
          this.atCursorPos = true;
          this.openStart = -1;
          this.openEnd = -1;
          this.text = "";
          this.textOff = 0;
          this.cursor = doc2.iter();
          this.skip = pos;
        }
        posCovered() {
          if (this.content.length == 0)
            return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
          let last = this.content[this.content.length - 1];
          return !last.breakAfter && !(last instanceof BlockWidgetView && last.type == exports.BlockType.WidgetBefore);
        }
        getLine() {
          if (!this.curLine) {
            this.content.push(this.curLine = new LineView());
            this.atCursorPos = true;
          }
          return this.curLine;
        }
        flushBuffer(active) {
          if (this.pendingBuffer) {
            this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
            this.pendingBuffer = 0;
          }
        }
        addBlockWidget(view) {
          this.flushBuffer([]);
          this.curLine = null;
          this.content.push(view);
        }
        finish(openEnd) {
          if (!openEnd)
            this.flushBuffer([]);
          else
            this.pendingBuffer = 0;
          if (!this.posCovered())
            this.getLine();
        }
        buildText(length, active, openStart) {
          while (length > 0) {
            if (this.textOff == this.text.length) {
              let { value, lineBreak, done } = this.cursor.next(this.skip);
              this.skip = 0;
              if (done)
                throw new Error("Ran out of text content when drawing inline views");
              if (lineBreak) {
                if (!this.posCovered())
                  this.getLine();
                if (this.content.length)
                  this.content[this.content.length - 1].breakAfter = 1;
                else
                  this.breakAtStart = 1;
                this.flushBuffer([]);
                this.curLine = null;
                length--;
                continue;
              } else {
                this.text = value;
                this.textOff = 0;
              }
            }
            let take = Math.min(this.text.length - this.textOff, length, 512);
            this.flushBuffer(active.slice(0, openStart));
            this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
            this.atCursorPos = true;
            this.textOff += take;
            length -= take;
            openStart = 0;
          }
        }
        span(from, to, active, openStart) {
          this.buildText(to - from, active, openStart);
          this.pos = to;
          if (this.openStart < 0)
            this.openStart = openStart;
        }
        point(from, to, deco, active, openStart, index) {
          if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {
            if (deco.block)
              throw new RangeError("Block decorations may not be specified via plugins");
            if (to > this.doc.lineAt(this.pos).to)
              throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
          }
          let len = to - from;
          if (deco instanceof PointDecoration) {
            if (deco.block) {
              let { type } = deco;
              if (type == exports.BlockType.WidgetAfter && !this.posCovered())
                this.getLine();
              this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget("div"), len, type));
            } else {
              let view = WidgetView.create(deco.widget || new NullWidget("span"), len, deco.startSide);
              let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to || deco.startSide > 0);
              let cursorAfter = !view.isEditable && (from < to || deco.startSide <= 0);
              let line = this.getLine();
              if (this.pendingBuffer == 2 && !cursorBefore)
                this.pendingBuffer = 0;
              this.flushBuffer(active);
              if (cursorBefore) {
                line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
                openStart = active.length + Math.max(0, openStart - active.length);
              }
              line.append(wrapMarks(view, active), openStart);
              this.atCursorPos = cursorAfter;
              this.pendingBuffer = !cursorAfter ? 0 : from < to ? 1 : 2;
            }
          } else if (this.doc.lineAt(this.pos).from == this.pos) {
            this.getLine().addLineDeco(deco);
          }
          if (len) {
            if (this.textOff + len <= this.text.length) {
              this.textOff += len;
            } else {
              this.skip += len - (this.text.length - this.textOff);
              this.text = "";
              this.textOff = 0;
            }
            this.pos = to;
          }
          if (this.openStart < 0)
            this.openStart = openStart;
        }
        static build(text, from, to, decorations2, dynamicDecorationMap) {
          let builder = new ContentBuilder(text, from, to, dynamicDecorationMap);
          builder.openEnd = state.RangeSet.spans(decorations2, from, to, builder);
          if (builder.openStart < 0)
            builder.openStart = builder.openEnd;
          builder.finish(builder.openEnd);
          return builder;
        }
      };
      function wrapMarks(view, active) {
        for (let mark of active)
          view = new MarkView(mark, [view], view.length);
        return view;
      }
      var NullWidget = class extends WidgetType {
        constructor(tag) {
          super();
          this.tag = tag;
        }
        eq(other) {
          return other.tag == this.tag;
        }
        toDOM() {
          return document.createElement(this.tag);
        }
        updateDOM(elt) {
          return elt.nodeName.toLowerCase() == this.tag;
        }
      };
      var clickAddsSelectionRange = state.Facet.define();
      var dragMovesSelection$1 = state.Facet.define();
      var mouseSelectionStyle = state.Facet.define();
      var exceptionSink = state.Facet.define();
      var updateListener = state.Facet.define();
      var inputHandler = state.Facet.define();
      var perLineTextDirection = state.Facet.define({
        combine: (values) => values.some((x) => x)
      });
      var ScrollTarget = class {
        constructor(range, y = "nearest", x = "nearest", yMargin = 5, xMargin = 5) {
          this.range = range;
          this.y = y;
          this.x = x;
          this.yMargin = yMargin;
          this.xMargin = xMargin;
        }
        map(changes) {
          return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin);
        }
      };
      var scrollIntoView = state.StateEffect.define({ map: (t, ch) => t.map(ch) });
      function logException(state2, exception, context) {
        let handler = state2.facet(exceptionSink);
        if (handler.length)
          handler[0](exception);
        else if (window.onerror)
          window.onerror(String(exception), context, void 0, void 0, exception);
        else if (context)
          console.error(context + ":", exception);
        else
          console.error(exception);
      }
      var editable = state.Facet.define({ combine: (values) => values.length ? values[0] : true });
      var nextPluginID = 0;
      var viewPlugin = state.Facet.define();
      var ViewPlugin = class {
        constructor(id, create, domEventHandlers, buildExtensions) {
          this.id = id;
          this.create = create;
          this.domEventHandlers = domEventHandlers;
          this.extension = buildExtensions(this);
        }
        static define(create, spec) {
          const { eventHandlers, provide, decorations: deco } = spec || {};
          return new ViewPlugin(nextPluginID++, create, eventHandlers, (plugin2) => {
            let ext = [viewPlugin.of(plugin2)];
            if (deco)
              ext.push(decorations.of((view) => {
                let pluginInst = view.plugin(plugin2);
                return pluginInst ? deco(pluginInst) : Decoration.none;
              }));
            if (provide)
              ext.push(provide(plugin2));
            return ext;
          });
        }
        static fromClass(cls, spec) {
          return ViewPlugin.define((view) => new cls(view), spec);
        }
      };
      var PluginInstance = class {
        constructor(spec) {
          this.spec = spec;
          this.mustUpdate = null;
          this.value = null;
        }
        update(view) {
          if (!this.value) {
            if (this.spec) {
              try {
                this.value = this.spec.create(view);
              } catch (e) {
                logException(view.state, e, "CodeMirror plugin crashed");
                this.deactivate();
              }
            }
          } else if (this.mustUpdate) {
            let update = this.mustUpdate;
            this.mustUpdate = null;
            if (this.value.update) {
              try {
                this.value.update(update);
              } catch (e) {
                logException(update.state, e, "CodeMirror plugin crashed");
                if (this.value.destroy)
                  try {
                    this.value.destroy();
                  } catch (_) {
                  }
                this.deactivate();
              }
            }
          }
          return this;
        }
        destroy(view) {
          var _a;
          if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {
            try {
              this.value.destroy();
            } catch (e) {
              logException(view.state, e, "CodeMirror plugin crashed");
            }
          }
        }
        deactivate() {
          this.spec = this.value = null;
        }
      };
      var editorAttributes = state.Facet.define();
      var contentAttributes = state.Facet.define();
      var decorations = state.Facet.define();
      var atomicRanges = state.Facet.define();
      var scrollMargins = state.Facet.define();
      var styleModule = state.Facet.define();
      var ChangedRange = class {
        constructor(fromA, toA, fromB, toB) {
          this.fromA = fromA;
          this.toA = toA;
          this.fromB = fromB;
          this.toB = toB;
        }
        join(other) {
          return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
        }
        addToSet(set) {
          let i = set.length, me = this;
          for (; i > 0; i--) {
            let range = set[i - 1];
            if (range.fromA > me.toA)
              continue;
            if (range.toA < me.fromA)
              break;
            me = me.join(range);
            set.splice(i - 1, 1);
          }
          set.splice(i, 0, me);
          return set;
        }
        static extendWithRanges(diff, ranges) {
          if (ranges.length == 0)
            return diff;
          let result = [];
          for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
            let next = dI == diff.length ? null : diff[dI], off = posA - posB;
            let end = next ? next.fromB : 1e9;
            while (rI < ranges.length && ranges[rI] < end) {
              let from = ranges[rI], to = ranges[rI + 1];
              let fromB = Math.max(posB, from), toB = Math.min(end, to);
              if (fromB <= toB)
                new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
              if (to > end)
                break;
              else
                rI += 2;
            }
            if (!next)
              return result;
            new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
            posA = next.toA;
            posB = next.toB;
          }
        }
      };
      var ViewUpdate = class {
        constructor(view, state$1, transactions) {
          this.view = view;
          this.state = state$1;
          this.transactions = transactions;
          this.flags = 0;
          this.startState = view.state;
          this.changes = state.ChangeSet.empty(this.startState.doc.length);
          for (let tr of transactions)
            this.changes = this.changes.compose(tr.changes);
          let changedRanges = [];
          this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
          this.changedRanges = changedRanges;
          let focus = view.hasFocus;
          if (focus != view.inputState.notifiedFocused) {
            view.inputState.notifiedFocused = focus;
            this.flags |= 1;
          }
        }
        static create(view, state2, transactions) {
          return new ViewUpdate(view, state2, transactions);
        }
        get viewportChanged() {
          return (this.flags & 4) > 0;
        }
        get heightChanged() {
          return (this.flags & 2) > 0;
        }
        get geometryChanged() {
          return this.docChanged || (this.flags & (8 | 2)) > 0;
        }
        get focusChanged() {
          return (this.flags & 1) > 0;
        }
        get docChanged() {
          return !this.changes.empty;
        }
        get selectionSet() {
          return this.transactions.some((tr) => tr.selection);
        }
        get empty() {
          return this.flags == 0 && this.transactions.length == 0;
        }
      };
      exports.Direction = void 0;
      (function(Direction) {
        Direction[Direction["LTR"] = 0] = "LTR";
        Direction[Direction["RTL"] = 1] = "RTL";
      })(exports.Direction || (exports.Direction = {}));
      var LTR = exports.Direction.LTR;
      var RTL = exports.Direction.RTL;
      function dec(str) {
        let result = [];
        for (let i = 0; i < str.length; i++)
          result.push(1 << +str[i]);
        return result;
      }
      var LowTypes = dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
      var ArabicTypes = dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
      var Brackets = /* @__PURE__ */ Object.create(null);
      var BracketStack = [];
      for (let p of ["()", "[]", "{}"]) {
        let l = p.charCodeAt(0), r = p.charCodeAt(1);
        Brackets[l] = r;
        Brackets[r] = -l;
      }
      function charType(ch) {
        return ch <= 247 ? LowTypes[ch] : 1424 <= ch && ch <= 1524 ? 2 : 1536 <= ch && ch <= 1785 ? ArabicTypes[ch - 1536] : 1774 <= ch && ch <= 2220 ? 4 : 8192 <= ch && ch <= 8203 ? 256 : ch == 8204 ? 256 : 1;
      }
      var BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
      var BidiSpan = class {
        constructor(from, to, level) {
          this.from = from;
          this.to = to;
          this.level = level;
        }
        get dir() {
          return this.level % 2 ? RTL : LTR;
        }
        side(end, dir) {
          return this.dir == dir == end ? this.to : this.from;
        }
        static find(order, index, level, assoc) {
          let maybe = -1;
          for (let i = 0; i < order.length; i++) {
            let span = order[i];
            if (span.from <= index && span.to >= index) {
              if (span.level == level)
                return i;
              if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level))
                maybe = i;
            }
          }
          if (maybe < 0)
            throw new RangeError("Index out of range");
          return maybe;
        }
      };
      var types = [];
      function computeOrder(line, direction) {
        let len = line.length, outerType = direction == LTR ? 1 : 2, oppositeType = direction == LTR ? 2 : 1;
        if (!line || outerType == 1 && !BidiRE.test(line))
          return trivialOrder(len);
        for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
          let type = charType(line.charCodeAt(i));
          if (type == 512)
            type = prev;
          else if (type == 8 && prevStrong == 4)
            type = 16;
          types[i] = type == 4 ? 2 : type;
          if (type & 7)
            prevStrong = type;
          prev = type;
        }
        for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
          let type = types[i];
          if (type == 128) {
            if (i < len - 1 && prev == types[i + 1] && prev & 24)
              type = types[i] = prev;
            else
              types[i] = 256;
          } else if (type == 64) {
            let end = i + 1;
            while (end < len && types[end] == 64)
              end++;
            let replace = i && prev == 8 || end < len && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
            for (let j = i; j < end; j++)
              types[j] = replace;
            i = end - 1;
          } else if (type == 8 && prevStrong == 1) {
            types[i] = 1;
          }
          prev = type;
          if (type & 7)
            prevStrong = type;
        }
        for (let i = 0, sI = 0, context = 0, ch, br, type; i < len; i++) {
          if (br = Brackets[ch = line.charCodeAt(i)]) {
            if (br < 0) {
              for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
                if (BracketStack[sJ + 1] == -br) {
                  let flags = BracketStack[sJ + 2];
                  let type2 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
                  if (type2)
                    types[i] = types[BracketStack[sJ]] = type2;
                  sI = sJ;
                  break;
                }
              }
            } else if (BracketStack.length == 189) {
              break;
            } else {
              BracketStack[sI++] = i;
              BracketStack[sI++] = ch;
              BracketStack[sI++] = context;
            }
          } else if ((type = types[i]) == 2 || type == 1) {
            let embed = type == outerType;
            context = embed ? 0 : 1;
            for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
              let cur = BracketStack[sJ + 2];
              if (cur & 2)
                break;
              if (embed) {
                BracketStack[sJ + 2] |= 2;
              } else {
                if (cur & 4)
                  break;
                BracketStack[sJ + 2] |= 4;
              }
            }
          }
        }
        for (let i = 0; i < len; i++) {
          if (types[i] == 256) {
            let end = i + 1;
            while (end < len && types[end] == 256)
              end++;
            let beforeL = (i ? types[i - 1] : outerType) == 1;
            let afterL = (end < len ? types[end] : outerType) == 1;
            let replace = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
            for (let j = i; j < end; j++)
              types[j] = replace;
            i = end - 1;
          }
        }
        let order = [];
        if (outerType == 1) {
          for (let i = 0; i < len; ) {
            let start = i, rtl = types[i++] != 1;
            while (i < len && rtl == (types[i] != 1))
              i++;
            if (rtl) {
              for (let j = i; j > start; ) {
                let end = j, l = types[--j] != 2;
                while (j > start && l == (types[j - 1] != 2))
                  j--;
                order.push(new BidiSpan(j, end, l ? 2 : 1));
              }
            } else {
              order.push(new BidiSpan(start, i, 0));
            }
          }
        } else {
          for (let i = 0; i < len; ) {
            let start = i, rtl = types[i++] == 2;
            while (i < len && rtl == (types[i] == 2))
              i++;
            order.push(new BidiSpan(start, i, rtl ? 1 : 2));
          }
        }
        return order;
      }
      function trivialOrder(length) {
        return [new BidiSpan(0, length, 0)];
      }
      var movedOver = "";
      function moveVisually(line, order, dir, start, forward) {
        var _a;
        let startIndex = start.head - line.from, spanI = -1;
        if (startIndex == 0) {
          if (!forward || !line.length)
            return null;
          if (order[0].level != dir) {
            startIndex = order[0].side(false, dir);
            spanI = 0;
          }
        } else if (startIndex == line.length) {
          if (forward)
            return null;
          let last = order[order.length - 1];
          if (last.level != dir) {
            startIndex = last.side(true, dir);
            spanI = order.length - 1;
          }
        }
        if (spanI < 0)
          spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);
        let span = order[spanI];
        if (startIndex == span.side(forward, dir)) {
          span = order[spanI += forward ? 1 : -1];
          startIndex = span.side(!forward, dir);
        }
        let indexForward = forward == (span.dir == dir);
        let nextIndex = state.findClusterBreak(line.text, startIndex, indexForward);
        movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
        if (nextIndex != span.side(forward, dir))
          return state.EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);
        let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
        if (!nextSpan && span.level != dir)
          return state.EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);
        if (nextSpan && nextSpan.level < span.level)
          return state.EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);
        return state.EditorSelection.cursor(nextIndex + line.from, forward ? -1 : 1, span.level);
      }
      var LineBreakPlaceholder = "\uFFFF";
      var DOMReader = class {
        constructor(points, state$1) {
          this.points = points;
          this.text = "";
          this.lineSeparator = state$1.facet(state.EditorState.lineSeparator);
        }
        append(text) {
          this.text += text;
        }
        lineBreak() {
          this.text += LineBreakPlaceholder;
        }
        readRange(start, end) {
          if (!start)
            return this;
          let parent = start.parentNode;
          for (let cur = start; ; ) {
            this.findPointBefore(parent, cur);
            this.readNode(cur);
            let next = cur.nextSibling;
            if (next == end)
              break;
            let view = ContentView.get(cur), nextView = ContentView.get(next);
            if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur)) || isBlockElement(next) && (cur.nodeName != "BR" || cur.cmIgnore))
              this.lineBreak();
            cur = next;
          }
          this.findPointBefore(parent, end);
          return this;
        }
        readTextNode(node) {
          let text = node.nodeValue;
          for (let point of this.points)
            if (point.node == node)
              point.pos = this.text.length + Math.min(point.offset, text.length);
          for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
            let nextBreak = -1, breakSize = 1, m;
            if (this.lineSeparator) {
              nextBreak = text.indexOf(this.lineSeparator, off);
              breakSize = this.lineSeparator.length;
            } else if (m = re.exec(text)) {
              nextBreak = m.index;
              breakSize = m[0].length;
            }
            this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));
            if (nextBreak < 0)
              break;
            this.lineBreak();
            if (breakSize > 1) {
              for (let point of this.points)
                if (point.node == node && point.pos > this.text.length)
                  point.pos -= breakSize - 1;
            }
            off = nextBreak + breakSize;
          }
        }
        readNode(node) {
          if (node.cmIgnore)
            return;
          let view = ContentView.get(node);
          let fromView = view && view.overrideDOMText;
          if (fromView != null) {
            this.findPointInside(node, fromView.length);
            for (let i = fromView.iter(); !i.next().done; ) {
              if (i.lineBreak)
                this.lineBreak();
              else
                this.append(i.value);
            }
          } else if (node.nodeType == 3) {
            this.readTextNode(node);
          } else if (node.nodeName == "BR") {
            if (node.nextSibling)
              this.lineBreak();
          } else if (node.nodeType == 1) {
            this.readRange(node.firstChild, null);
          }
        }
        findPointBefore(node, next) {
          for (let point of this.points)
            if (point.node == node && node.childNodes[point.offset] == next)
              point.pos = this.text.length;
        }
        findPointInside(node, maxLen) {
          for (let point of this.points)
            if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
              point.pos = this.text.length + Math.min(maxLen, point.offset);
        }
      };
      function isBlockElement(node) {
        return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
      }
      var DOMPoint = class {
        constructor(node, offset) {
          this.node = node;
          this.offset = offset;
          this.pos = -1;
        }
      };
      var DocView = class extends ContentView {
        constructor(view) {
          super();
          this.view = view;
          this.compositionDeco = Decoration.none;
          this.decorations = [];
          this.dynamicDecorationMap = [];
          this.minWidth = 0;
          this.minWidthFrom = 0;
          this.minWidthTo = 0;
          this.impreciseAnchor = null;
          this.impreciseHead = null;
          this.forceSelection = false;
          this.lastUpdate = Date.now();
          this.setDOM(view.contentDOM);
          this.children = [new LineView()];
          this.children[0].setParent(this);
          this.updateDeco();
          this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0);
        }
        get editorView() {
          return this.view;
        }
        get length() {
          return this.view.state.doc.length;
        }
        update(update) {
          let changedRanges = update.changedRanges;
          if (this.minWidth > 0 && changedRanges.length) {
            if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
              this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
            } else {
              this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
              this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
            }
          }
          if (this.view.inputState.composing < 0)
            this.compositionDeco = Decoration.none;
          else if (update.transactions.length || this.dirty)
            this.compositionDeco = computeCompositionDeco(this.view, update.changes);
          if ((browser.ie || browser.chrome) && !this.compositionDeco.size && update && update.state.doc.lines != update.startState.doc.lines)
            this.forceSelection = true;
          let prevDeco = this.decorations, deco = this.updateDeco();
          let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
          changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
          if (this.dirty == 0 && changedRanges.length == 0) {
            return false;
          } else {
            this.updateInner(changedRanges, update.startState.doc.length);
            if (update.transactions.length)
              this.lastUpdate = Date.now();
            return true;
          }
        }
        updateInner(changes, oldLength) {
          this.view.viewState.mustMeasureContent = true;
          this.updateChildren(changes, oldLength);
          let { observer } = this.view;
          observer.ignore(() => {
            this.dom.style.height = this.view.viewState.contentHeight + "px";
            this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
            let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : void 0;
            this.sync(track);
            this.dirty = 0;
            if (track && (track.written || observer.selectionRange.focusNode != track.node))
              this.forceSelection = true;
            this.dom.style.height = "";
          });
          let gaps = [];
          if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
            for (let child of this.children)
              if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
                gaps.push(child.dom);
          }
          observer.updateGaps(gaps);
        }
        updateChildren(changes, oldLength) {
          let cursor = this.childCursor(oldLength);
          for (let i = changes.length - 1; ; i--) {
            let next = i >= 0 ? changes[i] : null;
            if (!next)
              break;
            let { fromA, toA, fromB, toB } = next;
            let { content, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap);
            let { i: toI, off: toOff } = cursor.findPos(toA, 1);
            let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);
            replaceRange(this, fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);
          }
        }
        updateSelection(mustRead = false, fromPointer = false) {
          if (mustRead || !this.view.observer.selectionRange.focusNode)
            this.view.observer.readSelectionRange();
          if (!(fromPointer || this.mayControlSelection()) || browser.ios && this.view.inputState.rapidCompositionStart)
            return;
          let force = this.forceSelection;
          this.forceSelection = false;
          let main = this.view.state.selection.main;
          let anchor = this.domAtPos(main.anchor);
          let head = main.empty ? anchor : this.domAtPos(main.head);
          if (browser.gecko && main.empty && betweenUneditable(anchor)) {
            let dummy = document.createTextNode("");
            this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
            anchor = head = new DOMPos(dummy, 0);
            force = true;
          }
          let domSel = this.view.observer.selectionRange;
          if (force || !domSel.focusNode || !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {
            this.view.observer.ignore(() => {
              if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
                this.dom.blur();
                this.dom.focus({ preventScroll: true });
              }
              let rawSel = getSelection(this.view.root);
              if (!rawSel)
                ;
              else if (main.empty) {
                if (browser.gecko) {
                  let nextTo = nextToUneditable(anchor.node, anchor.offset);
                  if (nextTo && nextTo != (1 | 2)) {
                    let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 ? 1 : -1);
                    if (text)
                      anchor = new DOMPos(text, nextTo == 1 ? 0 : text.nodeValue.length);
                  }
                }
                rawSel.collapse(anchor.node, anchor.offset);
                if (main.bidiLevel != null && domSel.cursorBidiLevel != null)
                  domSel.cursorBidiLevel = main.bidiLevel;
              } else if (rawSel.extend) {
                rawSel.collapse(anchor.node, anchor.offset);
                rawSel.extend(head.node, head.offset);
              } else {
                let range = document.createRange();
                if (main.anchor > main.head)
                  [anchor, head] = [head, anchor];
                range.setEnd(head.node, head.offset);
                range.setStart(anchor.node, anchor.offset);
                rawSel.removeAllRanges();
                rawSel.addRange(range);
              }
            });
            this.view.observer.setSelectionRange(anchor, head);
          }
          this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
          this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
        }
        enforceCursorAssoc() {
          if (this.compositionDeco.size)
            return;
          let cursor = this.view.state.selection.main;
          let sel = getSelection(this.view.root);
          if (!sel || !cursor.empty || !cursor.assoc || !sel.modify)
            return;
          let line = LineView.find(this, cursor.head);
          if (!line)
            return;
          let lineStart = line.posAtStart;
          if (cursor.head == lineStart || cursor.head == lineStart + line.length)
            return;
          let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);
          if (!before || !after || before.bottom > after.top)
            return;
          let dom = this.domAtPos(cursor.head + cursor.assoc);
          sel.collapse(dom.node, dom.offset);
          sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
        }
        mayControlSelection() {
          let active = this.view.root.activeElement;
          return active == this.dom || hasSelection(this.dom, this.view.observer.selectionRange) && !(active && this.dom.contains(active));
        }
        nearest(dom) {
          for (let cur = dom; cur; ) {
            let domView = ContentView.get(cur);
            if (domView && domView.rootView == this)
              return domView;
            cur = cur.parentNode;
          }
          return null;
        }
        posFromDOM(node, offset) {
          let view = this.nearest(node);
          if (!view)
            throw new RangeError("Trying to find position for a DOM position outside of the document");
          return view.localPosFromDOM(node, offset) + view.posAtStart;
        }
        domAtPos(pos) {
          let { i, off } = this.childCursor().findPos(pos, -1);
          for (; i < this.children.length - 1; ) {
            let child = this.children[i];
            if (off < child.length || child instanceof LineView)
              break;
            i++;
            off = 0;
          }
          return this.children[i].domAtPos(off);
        }
        coordsAt(pos, side) {
          for (let off = this.length, i = this.children.length - 1; ; i--) {
            let child = this.children[i], start = off - child.breakAfter - child.length;
            if (pos > start || pos == start && child.type != exports.BlockType.WidgetBefore && child.type != exports.BlockType.WidgetAfter && (!i || side == 2 || this.children[i - 1].breakAfter || this.children[i - 1].type == exports.BlockType.WidgetBefore && side > -2))
              return child.coordsAt(pos - start, side);
            off = start;
          }
        }
        measureVisibleLineHeights(viewport) {
          let result = [], { from, to } = viewport;
          let contentWidth = this.view.contentDOM.clientWidth;
          let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
          let widest = -1, ltr = this.view.textDirection == exports.Direction.LTR;
          for (let pos = 0, i = 0; i < this.children.length; i++) {
            let child = this.children[i], end = pos + child.length;
            if (end > to)
              break;
            if (pos >= from) {
              let childRect = child.dom.getBoundingClientRect();
              result.push(childRect.height);
              if (isWider) {
                let last = child.dom.lastChild;
                let rects = last ? clientRectsFor(last) : [];
                if (rects.length) {
                  let rect = rects[rects.length - 1];
                  let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
                  if (width > widest) {
                    widest = width;
                    this.minWidth = contentWidth;
                    this.minWidthFrom = pos;
                    this.minWidthTo = end;
                  }
                }
              }
            }
            pos = end + child.breakAfter;
          }
          return result;
        }
        textDirectionAt(pos) {
          let { i } = this.childPos(pos, 1);
          return getComputedStyle(this.children[i].dom).direction == "rtl" ? exports.Direction.RTL : exports.Direction.LTR;
        }
        measureTextSize() {
          for (let child of this.children) {
            if (child instanceof LineView) {
              let measure = child.measureTextSize();
              if (measure)
                return measure;
            }
          }
          let dummy = document.createElement("div"), lineHeight, charWidth;
          dummy.className = "cm-line";
          dummy.style.width = "99999px";
          dummy.textContent = "abc def ghi jkl mno pqr stu";
          this.view.observer.ignore(() => {
            this.dom.appendChild(dummy);
            let rect = clientRectsFor(dummy.firstChild)[0];
            lineHeight = dummy.getBoundingClientRect().height;
            charWidth = rect ? rect.width / 27 : 7;
            dummy.remove();
          });
          return { lineHeight, charWidth };
        }
        childCursor(pos = this.length) {
          let i = this.children.length;
          if (i)
            pos -= this.children[--i].length;
          return new ChildCursor(this.children, pos, i);
        }
        computeBlockGapDeco() {
          let deco = [], vs = this.view.viewState;
          for (let pos = 0, i = 0; ; i++) {
            let next = i == vs.viewports.length ? null : vs.viewports[i];
            let end = next ? next.from - 1 : this.length;
            if (end > pos) {
              let height = vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top;
              deco.push(Decoration.replace({
                widget: new BlockGapWidget(height),
                block: true,
                inclusive: true,
                isBlockGap: true
              }).range(pos, end));
            }
            if (!next)
              break;
            pos = next.to + 1;
          }
          return Decoration.set(deco);
        }
        updateDeco() {
          let allDeco = this.view.state.facet(decorations).map((d, i) => {
            let dynamic = this.dynamicDecorationMap[i] = typeof d == "function";
            return dynamic ? d(this.view) : d;
          });
          for (let i = allDeco.length; i < allDeco.length + 3; i++)
            this.dynamicDecorationMap[i] = false;
          return this.decorations = [
            ...allDeco,
            this.compositionDeco,
            this.computeBlockGapDeco(),
            this.view.viewState.lineGapDeco
          ];
        }
        scrollIntoView(target) {
          let { range } = target;
          let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;
          if (!rect)
            return;
          if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
            rect = {
              left: Math.min(rect.left, other.left),
              top: Math.min(rect.top, other.top),
              right: Math.max(rect.right, other.right),
              bottom: Math.max(rect.bottom, other.bottom)
            };
          let mLeft = 0, mRight = 0, mTop = 0, mBottom = 0;
          for (let margins of this.view.state.facet(scrollMargins).map((f) => f(this.view)))
            if (margins) {
              let { left, right, top, bottom } = margins;
              if (left != null)
                mLeft = Math.max(mLeft, left);
              if (right != null)
                mRight = Math.max(mRight, right);
              if (top != null)
                mTop = Math.max(mTop, top);
              if (bottom != null)
                mBottom = Math.max(mBottom, bottom);
            }
          let targetRect = {
            left: rect.left - mLeft,
            top: rect.top - mTop,
            right: rect.right + mRight,
            bottom: rect.bottom + mBottom
          };
          scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, target.xMargin, target.yMargin, this.view.textDirection == exports.Direction.LTR);
        }
      };
      function betweenUneditable(pos) {
        return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
      }
      var BlockGapWidget = class extends WidgetType {
        constructor(height) {
          super();
          this.height = height;
        }
        toDOM() {
          let elt = document.createElement("div");
          this.updateDOM(elt);
          return elt;
        }
        eq(other) {
          return other.height == this.height;
        }
        updateDOM(elt) {
          elt.style.height = this.height + "px";
          return true;
        }
        get estimatedHeight() {
          return this.height;
        }
      };
      function compositionSurroundingNode(view) {
        let sel = view.observer.selectionRange;
        let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);
        if (!textNode)
          return null;
        let cView = view.docView.nearest(textNode);
        if (!cView)
          return null;
        if (cView instanceof LineView) {
          let topNode = textNode;
          while (topNode.parentNode != cView.dom)
            topNode = topNode.parentNode;
          let prev = topNode.previousSibling;
          while (prev && !ContentView.get(prev))
            prev = prev.previousSibling;
          let pos = prev ? ContentView.get(prev).posAtEnd : cView.posAtStart;
          return { from: pos, to: pos, node: topNode, text: textNode };
        } else {
          for (; ; ) {
            let { parent } = cView;
            if (!parent)
              return null;
            if (parent instanceof LineView)
              break;
            cView = parent;
          }
          let from = cView.posAtStart;
          return { from, to: from + cView.length, node: cView.dom, text: textNode };
        }
      }
      function computeCompositionDeco(view, changes) {
        let surrounding = compositionSurroundingNode(view);
        if (!surrounding)
          return Decoration.none;
        let { from, to, node, text: textNode } = surrounding;
        let newFrom = changes.mapPos(from, 1), newTo = Math.max(newFrom, changes.mapPos(to, -1));
        let { state: state2 } = view, text = node.nodeType == 3 ? node.nodeValue : new DOMReader([], state2).readRange(node.firstChild, null).text;
        if (newTo - newFrom < text.length) {
          if (state2.doc.sliceString(newFrom, Math.min(state2.doc.length, newFrom + text.length), LineBreakPlaceholder) == text)
            newTo = newFrom + text.length;
          else if (state2.doc.sliceString(Math.max(0, newTo - text.length), newTo, LineBreakPlaceholder) == text)
            newFrom = newTo - text.length;
          else
            return Decoration.none;
        } else if (state2.doc.sliceString(newFrom, newTo, LineBreakPlaceholder) != text) {
          return Decoration.none;
        }
        let topView = ContentView.get(node);
        if (topView instanceof CompositionView)
          topView = topView.widget.topView;
        else if (topView)
          topView.parent = null;
        return Decoration.set(Decoration.replace({ widget: new CompositionWidget(node, textNode, topView), inclusive: true }).range(newFrom, newTo));
      }
      var CompositionWidget = class extends WidgetType {
        constructor(top, text, topView) {
          super();
          this.top = top;
          this.text = text;
          this.topView = topView;
        }
        eq(other) {
          return this.top == other.top && this.text == other.text;
        }
        toDOM() {
          return this.top;
        }
        ignoreEvent() {
          return false;
        }
        get customView() {
          return CompositionView;
        }
      };
      function nearbyTextNode(node, offset, side) {
        for (; ; ) {
          if (node.nodeType == 3)
            return node;
          if (node.nodeType == 1 && offset > 0 && side <= 0) {
            node = node.childNodes[offset - 1];
            offset = maxOffset(node);
          } else if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {
            node = node.childNodes[offset];
            offset = 0;
          } else {
            return null;
          }
        }
      }
      function nextToUneditable(node, offset) {
        if (node.nodeType != 1)
          return 0;
        return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 : 0);
      }
      var DecorationComparator$1 = class {
        constructor() {
          this.changes = [];
        }
        compareRange(from, to) {
          addRange(from, to, this.changes);
        }
        comparePoint(from, to) {
          addRange(from, to, this.changes);
        }
      };
      function findChangedDeco(a, b, diff) {
        let comp = new DecorationComparator$1();
        state.RangeSet.compare(a, b, diff, comp);
        return comp.changes;
      }
      function inUneditable(node, inside2) {
        for (let cur = node; cur && cur != inside2; cur = cur.assignedSlot || cur.parentNode) {
          if (cur.nodeType == 1 && cur.contentEditable == "false") {
            return true;
          }
        }
        return false;
      }
      function groupAt(state$1, pos, bias = 1) {
        let categorize = state$1.charCategorizer(pos);
        let line = state$1.doc.lineAt(pos), linePos = pos - line.from;
        if (line.length == 0)
          return state.EditorSelection.cursor(pos);
        if (linePos == 0)
          bias = 1;
        else if (linePos == line.length)
          bias = -1;
        let from = linePos, to = linePos;
        if (bias < 0)
          from = state.findClusterBreak(line.text, linePos, false);
        else
          to = state.findClusterBreak(line.text, linePos);
        let cat = categorize(line.text.slice(from, to));
        while (from > 0) {
          let prev = state.findClusterBreak(line.text, from, false);
          if (categorize(line.text.slice(prev, from)) != cat)
            break;
          from = prev;
        }
        while (to < line.length) {
          let next = state.findClusterBreak(line.text, to);
          if (categorize(line.text.slice(to, next)) != cat)
            break;
          to = next;
        }
        return state.EditorSelection.range(from + line.from, to + line.from);
      }
      function getdx(x, rect) {
        return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
      }
      function getdy(y, rect) {
        return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
      }
      function yOverlap(a, b) {
        return a.top < b.bottom - 1 && a.bottom > b.top + 1;
      }
      function upTop(rect, top) {
        return top < rect.top ? { top, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
      }
      function upBot(rect, bottom) {
        return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;
      }
      function domPosAtCoords(parent, x, y) {
        let closest, closestRect, closestX, closestY, closestOverlap = false;
        let above, below, aboveRect, belowRect;
        for (let child = parent.firstChild; child; child = child.nextSibling) {
          let rects = clientRectsFor(child);
          for (let i = 0; i < rects.length; i++) {
            let rect = rects[i];
            if (closestRect && yOverlap(closestRect, rect))
              rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
            let dx = getdx(x, rect), dy = getdy(y, rect);
            if (dx == 0 && dy == 0)
              return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
            if (!closest || closestY > dy || closestY == dy && closestX > dx) {
              closest = child;
              closestRect = rect;
              closestX = dx;
              closestY = dy;
              closestOverlap = !dx || (dx > 0 ? i < rects.length - 1 : i > 0);
            }
            if (dx == 0) {
              if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
                above = child;
                aboveRect = rect;
              } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
                below = child;
                belowRect = rect;
              }
            } else if (aboveRect && yOverlap(aboveRect, rect)) {
              aboveRect = upBot(aboveRect, rect.bottom);
            } else if (belowRect && yOverlap(belowRect, rect)) {
              belowRect = upTop(belowRect, rect.top);
            }
          }
        }
        if (aboveRect && aboveRect.bottom >= y) {
          closest = above;
          closestRect = aboveRect;
        } else if (belowRect && belowRect.top <= y) {
          closest = below;
          closestRect = belowRect;
        }
        if (!closest)
          return { node: parent, offset: 0 };
        let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
        if (closest.nodeType == 3)
          return domPosInText(closest, clipX, y);
        if (closestOverlap && closest.contentEditable != "false")
          return domPosAtCoords(closest, clipX, y);
        let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
        return { node: parent, offset };
      }
      function domPosInText(node, x, y) {
        let len = node.nodeValue.length;
        let closestOffset = -1, closestDY = 1e9, generalSide = 0;
        for (let i = 0; i < len; i++) {
          let rects = textRange(node, i, i + 1).getClientRects();
          for (let j = 0; j < rects.length; j++) {
            let rect = rects[j];
            if (rect.top == rect.bottom)
              continue;
            if (!generalSide)
              generalSide = x - rect.left;
            let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
            if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
              let right = x >= (rect.left + rect.right) / 2, after = right;
              if (browser.chrome || browser.gecko) {
                let rectBefore = textRange(node, i).getBoundingClientRect();
                if (rectBefore.left == rect.right)
                  after = !right;
              }
              if (dy <= 0)
                return { node, offset: i + (after ? 1 : 0) };
              closestOffset = i + (after ? 1 : 0);
              closestDY = dy;
            }
          }
        }
        return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };
      }
      function posAtCoords(view, { x, y }, precise, bias = -1) {
        var _a;
        let content = view.contentDOM.getBoundingClientRect(), docTop = content.top + view.viewState.paddingTop;
        let block, { docHeight } = view.viewState;
        let yOffset = y - docTop;
        if (yOffset < 0)
          return 0;
        if (yOffset > docHeight)
          return view.state.doc.length;
        for (let halfLine = view.defaultLineHeight / 2, bounced = false; ; ) {
          block = view.elementAtHeight(yOffset);
          if (block.type == exports.BlockType.Text)
            break;
          for (; ; ) {
            yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
            if (yOffset >= 0 && yOffset <= docHeight)
              break;
            if (bounced)
              return precise ? null : 0;
            bounced = true;
            bias = -bias;
          }
        }
        y = docTop + yOffset;
        let lineStart = block.from;
        if (lineStart < view.viewport.from)
          return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content, block, x, y);
        if (lineStart > view.viewport.to)
          return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content, block, x, y);
        let doc2 = view.dom.ownerDocument;
        let root = view.root.elementFromPoint ? view.root : doc2;
        let element = root.elementFromPoint(x, y);
        if (element && !view.contentDOM.contains(element))
          element = null;
        if (!element) {
          x = Math.max(content.left + 1, Math.min(content.right - 1, x));
          element = root.elementFromPoint(x, y);
          if (element && !view.contentDOM.contains(element))
            element = null;
        }
        let node, offset = -1;
        if (element && ((_a = view.docView.nearest(element)) === null || _a === void 0 ? void 0 : _a.isEditable) != false) {
          if (doc2.caretPositionFromPoint) {
            let pos = doc2.caretPositionFromPoint(x, y);
            if (pos)
              ({ offsetNode: node, offset } = pos);
          } else if (doc2.caretRangeFromPoint) {
            let range = doc2.caretRangeFromPoint(x, y);
            if (range) {
              ({ startContainer: node, startOffset: offset } = range);
              if (!view.contentDOM.contains(node) || browser.safari && isSuspiciousSafariCaretResult(node, offset, x) || browser.chrome && isSuspiciousChromeCaretResult(node, offset, x))
                node = void 0;
            }
          }
        }
        if (!node || !view.docView.dom.contains(node)) {
          let line = LineView.find(view.docView, lineStart);
          if (!line)
            return yOffset > block.top + block.height / 2 ? block.to : block.from;
          ({ node, offset } = domPosAtCoords(line.dom, x, y));
        }
        return view.docView.posFromDOM(node, offset);
      }
      function posAtCoordsImprecise(view, contentRect, block, x, y) {
        let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
        if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
          let line = Math.floor((y - block.top) / view.defaultLineHeight);
          into += line * view.viewState.heightOracle.lineLength;
        }
        let content = view.state.sliceDoc(block.from, block.to);
        return block.from + state.findColumn(content, into, view.state.tabSize);
      }
      function isSuspiciousSafariCaretResult(node, offset, x) {
        let len;
        if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
          return false;
        for (let next = node.nextSibling; next; next = next.nextSibling)
          if (next.nodeType != 1 || next.nodeName != "BR")
            return false;
        return textRange(node, len - 1, len).getBoundingClientRect().left > x;
      }
      function isSuspiciousChromeCaretResult(node, offset, x) {
        if (offset != 0)
          return false;
        for (let cur = node; ; ) {
          let parent = cur.parentNode;
          if (!parent || parent.nodeType != 1 || parent.firstChild != cur)
            return false;
          if (parent.classList.contains("cm-line"))
            break;
          cur = parent;
        }
        let rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
        return x - rect.left > 5;
      }
      function moveToLineBoundary(view, start, forward, includeWrap) {
        let line = view.state.doc.lineAt(start.head);
        let coords = !includeWrap || !view.lineWrapping ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
        if (coords) {
          let editorRect = view.dom.getBoundingClientRect();
          let direction = view.textDirectionAt(line.from);
          let pos = view.posAtCoords({
            x: forward == (direction == exports.Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
            y: (coords.top + coords.bottom) / 2
          });
          if (pos != null)
            return state.EditorSelection.cursor(pos, forward ? -1 : 1);
        }
        let lineView = LineView.find(view.docView, start.head);
        let end = lineView ? forward ? lineView.posAtEnd : lineView.posAtStart : forward ? line.to : line.from;
        return state.EditorSelection.cursor(end, forward ? -1 : 1);
      }
      function moveByChar(view, start, forward, by) {
        let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
        let direction = view.textDirectionAt(line.from);
        for (let cur = start, check = null; ; ) {
          let next = moveVisually(line, spans, direction, cur, forward), char = movedOver;
          if (!next) {
            if (line.number == (forward ? view.state.doc.lines : 1))
              return cur;
            char = "\n";
            line = view.state.doc.line(line.number + (forward ? 1 : -1));
            spans = view.bidiSpans(line);
            next = state.EditorSelection.cursor(forward ? line.from : line.to);
          }
          if (!check) {
            if (!by)
              return next;
            check = by(char);
          } else if (!check(char)) {
            return cur;
          }
          cur = next;
        }
      }
      function byGroup(view, pos, start) {
        let categorize = view.state.charCategorizer(pos);
        let cat = categorize(start);
        return (next) => {
          let nextCat = categorize(next);
          if (cat == state.CharCategory.Space)
            cat = nextCat;
          return cat == nextCat;
        };
      }
      function moveVertically(view, start, forward, distance) {
        let startPos = start.head, dir = forward ? 1 : -1;
        if (startPos == (forward ? view.state.doc.length : 0))
          return state.EditorSelection.cursor(startPos, start.assoc);
        let goal = start.goalColumn, startY;
        let rect = view.contentDOM.getBoundingClientRect();
        let startCoords = view.coordsAtPos(startPos), docTop = view.documentTop;
        if (startCoords) {
          if (goal == null)
            goal = startCoords.left - rect.left;
          startY = dir < 0 ? startCoords.top : startCoords.bottom;
        } else {
          let line = view.viewState.lineBlockAt(startPos);
          if (goal == null)
            goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
          startY = (dir < 0 ? line.top : line.bottom) + docTop;
        }
        let resolvedGoal = rect.left + goal;
        let dist = distance !== null && distance !== void 0 ? distance : view.defaultLineHeight >> 1;
        for (let extra = 0; ; extra += 10) {
          let curY = startY + (dist + extra) * dir;
          let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);
          if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos))
            return state.EditorSelection.cursor(pos, start.assoc, void 0, goal);
        }
      }
      function skipAtoms(view, oldPos, pos) {
        let atoms = view.state.facet(atomicRanges).map((f) => f(view));
        for (; ; ) {
          let moved = false;
          for (let set of atoms) {
            set.between(pos.from - 1, pos.from + 1, (from, to, value) => {
              if (pos.from > from && pos.from < to) {
                pos = oldPos.from > pos.from ? state.EditorSelection.cursor(from, 1) : state.EditorSelection.cursor(to, -1);
                moved = true;
              }
            });
          }
          if (!moved)
            return pos;
        }
      }
      var InputState = class {
        constructor(view) {
          this.lastKeyCode = 0;
          this.lastKeyTime = 0;
          this.lastTouchTime = 0;
          this.lastFocusTime = 0;
          this.lastScrollTop = 0;
          this.lastScrollLeft = 0;
          this.chromeScrollHack = -1;
          this.pendingIOSKey = void 0;
          this.lastSelectionOrigin = null;
          this.lastSelectionTime = 0;
          this.lastEscPress = 0;
          this.lastContextMenu = 0;
          this.scrollHandlers = [];
          this.registeredEvents = [];
          this.customHandlers = [];
          this.composing = -1;
          this.compositionFirstChange = null;
          this.compositionEndedAt = 0;
          this.rapidCompositionStart = false;
          this.mouseSelection = null;
          for (let type in handlers) {
            let handler = handlers[type];
            view.contentDOM.addEventListener(type, (event) => {
              if (!eventBelongsToEditor(view, event) || this.ignoreDuringComposition(event))
                return;
              if (type == "keydown" && this.keydown(view, event))
                return;
              if (this.mustFlushObserver(event))
                view.observer.forceFlush();
              if (this.runCustomHandlers(type, view, event))
                event.preventDefault();
              else
                handler(view, event);
            }, handlerOptions[type]);
            this.registeredEvents.push(type);
          }
          if (browser.chrome && browser.chrome_version == 102) {
            view.scrollDOM.addEventListener("wheel", () => {
              if (this.chromeScrollHack < 0)
                view.contentDOM.style.pointerEvents = "none";
              else
                window.clearTimeout(this.chromeScrollHack);
              this.chromeScrollHack = setTimeout(() => {
                this.chromeScrollHack = -1;
                view.contentDOM.style.pointerEvents = "";
              }, 100);
            }, { passive: true });
          }
          this.notifiedFocused = view.hasFocus;
          if (browser.safari)
            view.contentDOM.addEventListener("input", () => null);
        }
        setSelectionOrigin(origin) {
          this.lastSelectionOrigin = origin;
          this.lastSelectionTime = Date.now();
        }
        ensureHandlers(view, plugins) {
          var _a;
          let handlers2;
          this.customHandlers = [];
          for (let plugin2 of plugins)
            if (handlers2 = (_a = plugin2.update(view).spec) === null || _a === void 0 ? void 0 : _a.domEventHandlers) {
              this.customHandlers.push({ plugin: plugin2.value, handlers: handlers2 });
              for (let type in handlers2)
                if (this.registeredEvents.indexOf(type) < 0 && type != "scroll") {
                  this.registeredEvents.push(type);
                  view.contentDOM.addEventListener(type, (event) => {
                    if (!eventBelongsToEditor(view, event))
                      return;
                    if (this.runCustomHandlers(type, view, event))
                      event.preventDefault();
                  });
                }
            }
        }
        runCustomHandlers(type, view, event) {
          for (let set of this.customHandlers) {
            let handler = set.handlers[type];
            if (handler) {
              try {
                if (handler.call(set.plugin, event, view) || event.defaultPrevented)
                  return true;
              } catch (e) {
                logException(view.state, e);
              }
            }
          }
          return false;
        }
        runScrollHandlers(view, event) {
          this.lastScrollTop = view.scrollDOM.scrollTop;
          this.lastScrollLeft = view.scrollDOM.scrollLeft;
          for (let set of this.customHandlers) {
            let handler = set.handlers.scroll;
            if (handler) {
              try {
                handler.call(set.plugin, event, view);
              } catch (e) {
                logException(view.state, e);
              }
            }
          }
        }
        keydown(view, event) {
          this.lastKeyCode = event.keyCode;
          this.lastKeyTime = Date.now();
          if (event.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
            return true;
          if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {
            view.observer.delayAndroidKey(event.key, event.keyCode);
            return true;
          }
          let pending;
          if (browser.ios && (pending = PendingKeys.find((key) => key.keyCode == event.keyCode)) && !(event.ctrlKey || event.altKey || event.metaKey) && !event.synthetic) {
            this.pendingIOSKey = pending;
            setTimeout(() => this.flushIOSKey(view), 250);
            return true;
          }
          return false;
        }
        flushIOSKey(view) {
          let key = this.pendingIOSKey;
          if (!key)
            return false;
          this.pendingIOSKey = void 0;
          return dispatchKey(view.contentDOM, key.key, key.keyCode);
        }
        ignoreDuringComposition(event) {
          if (!/^key/.test(event.type))
            return false;
          if (this.composing > 0)
            return true;
          if (browser.safari && !browser.ios && Date.now() - this.compositionEndedAt < 100) {
            this.compositionEndedAt = 0;
            return true;
          }
          return false;
        }
        mustFlushObserver(event) {
          return event.type == "keydown" && event.keyCode != 229 || event.type == "compositionend" && !browser.ios;
        }
        startMouseSelection(mouseSelection) {
          if (this.mouseSelection)
            this.mouseSelection.destroy();
          this.mouseSelection = mouseSelection;
        }
        update(update) {
          if (this.mouseSelection)
            this.mouseSelection.update(update);
          if (update.transactions.length)
            this.lastKeyCode = this.lastSelectionTime = 0;
        }
        destroy() {
          if (this.mouseSelection)
            this.mouseSelection.destroy();
        }
      };
      var PendingKeys = [
        { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
        { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
        { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
      ];
      var modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
      var MouseSelection = class {
        constructor(view, startEvent, style, mustSelect) {
          this.view = view;
          this.style = style;
          this.mustSelect = mustSelect;
          this.lastEvent = startEvent;
          let doc2 = view.contentDOM.ownerDocument;
          doc2.addEventListener("mousemove", this.move = this.move.bind(this));
          doc2.addEventListener("mouseup", this.up = this.up.bind(this));
          this.extend = startEvent.shiftKey;
          this.multiple = view.state.facet(state.EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
          this.dragMove = dragMovesSelection(view, startEvent);
          this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
          if (this.dragging === false) {
            startEvent.preventDefault();
            this.select(startEvent);
          }
        }
        move(event) {
          if (event.buttons == 0)
            return this.destroy();
          if (this.dragging !== false)
            return;
          this.select(this.lastEvent = event);
        }
        up(event) {
          if (this.dragging == null)
            this.select(this.lastEvent);
          if (!this.dragging)
            event.preventDefault();
          this.destroy();
        }
        destroy() {
          let doc2 = this.view.contentDOM.ownerDocument;
          doc2.removeEventListener("mousemove", this.move);
          doc2.removeEventListener("mouseup", this.up);
          this.view.inputState.mouseSelection = null;
        }
        select(event) {
          let selection = this.style.get(event, this.extend, this.multiple);
          if (this.mustSelect || !selection.eq(this.view.state.selection) || selection.main.assoc != this.view.state.selection.main.assoc)
            this.view.dispatch({
              selection,
              userEvent: "select.pointer",
              scrollIntoView: true
            });
          this.mustSelect = false;
        }
        update(update) {
          if (update.docChanged && this.dragging)
            this.dragging = this.dragging.map(update.changes);
          if (this.style.update(update))
            setTimeout(() => this.select(this.lastEvent), 20);
        }
      };
      function addsSelectionRange(view, event) {
        let facet = view.state.facet(clickAddsSelectionRange);
        return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
      }
      function dragMovesSelection(view, event) {
        let facet = view.state.facet(dragMovesSelection$1);
        return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
      }
      function isInPrimarySelection(view, event) {
        let { main } = view.state.selection;
        if (main.empty)
          return false;
        let sel = getSelection(view.root);
        if (!sel || sel.rangeCount == 0)
          return true;
        let rects = sel.getRangeAt(0).getClientRects();
        for (let i = 0; i < rects.length; i++) {
          let rect = rects[i];
          if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY)
            return true;
        }
        return false;
      }
      function eventBelongsToEditor(view, event) {
        if (!event.bubbles)
          return true;
        if (event.defaultPrevented)
          return false;
        for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)
          if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event))
            return false;
        return true;
      }
      var handlers = /* @__PURE__ */ Object.create(null);
      var handlerOptions = /* @__PURE__ */ Object.create(null);
      var brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
      function capturePaste(view) {
        let parent = view.dom.parentNode;
        if (!parent)
          return;
        let target = parent.appendChild(document.createElement("textarea"));
        target.style.cssText = "position: fixed; left: -10000px; top: 10px";
        target.focus();
        setTimeout(() => {
          view.focus();
          target.remove();
          doPaste(view, target.value);
        }, 50);
      }
      function doPaste(view, input) {
        let { state: state$1 } = view, changes, i = 1, text = state$1.toText(input);
        let byLine = text.lines == state$1.selection.ranges.length;
        let linewise = lastLinewiseCopy != null && state$1.selection.ranges.every((r) => r.empty) && lastLinewiseCopy == text.toString();
        if (linewise) {
          let lastLine = -1;
          changes = state$1.changeByRange((range) => {
            let line = state$1.doc.lineAt(range.from);
            if (line.from == lastLine)
              return { range };
            lastLine = line.from;
            let insert = state$1.toText((byLine ? text.line(i++).text : input) + state$1.lineBreak);
            return {
              changes: { from: line.from, insert },
              range: state.EditorSelection.cursor(range.from + insert.length)
            };
          });
        } else if (byLine) {
          changes = state$1.changeByRange((range) => {
            let line = text.line(i++);
            return {
              changes: { from: range.from, to: range.to, insert: line.text },
              range: state.EditorSelection.cursor(range.from + line.length)
            };
          });
        } else {
          changes = state$1.replaceSelection(text);
        }
        view.dispatch(changes, {
          userEvent: "input.paste",
          scrollIntoView: true
        });
      }
      handlers.keydown = (view, event) => {
        view.inputState.setSelectionOrigin("select");
        if (event.keyCode == 27)
          view.inputState.lastEscPress = Date.now();
        else if (modifierCodes.indexOf(event.keyCode) < 0)
          view.inputState.lastEscPress = 0;
      };
      handlers.touchstart = (view, e) => {
        view.inputState.lastTouchTime = Date.now();
        view.inputState.setSelectionOrigin("select.pointer");
      };
      handlers.touchmove = (view) => {
        view.inputState.setSelectionOrigin("select.pointer");
      };
      handlerOptions.touchstart = handlerOptions.touchmove = { passive: true };
      handlers.mousedown = (view, event) => {
        view.observer.flush();
        if (view.inputState.lastTouchTime > Date.now() - 2e3 && getClickType(event) == 1)
          return;
        let style = null;
        for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
          style = makeStyle(view, event);
          if (style)
            break;
        }
        if (!style && event.button == 0)
          style = basicMouseSelection(view, event);
        if (style) {
          let mustFocus = view.root.activeElement != view.contentDOM;
          if (mustFocus)
            view.observer.ignore(() => focusPreventScroll(view.contentDOM));
          view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
        }
      };
      function rangeForClick(view, pos, bias, type) {
        if (type == 1) {
          return state.EditorSelection.cursor(pos, bias);
        } else if (type == 2) {
          return groupAt(view.state, pos, bias);
        } else {
          let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
          let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
          if (to < view.state.doc.length && to == line.to)
            to++;
          return state.EditorSelection.range(from, to);
        }
      }
      var insideY = (y, rect) => y >= rect.top && y <= rect.bottom;
      var inside = (x, y, rect) => insideY(y, rect) && x >= rect.left && x <= rect.right;
      function findPositionSide(view, pos, x, y) {
        let line = LineView.find(view.docView, pos);
        if (!line)
          return 1;
        let off = pos - line.posAtStart;
        if (off == 0)
          return 1;
        if (off == line.length)
          return -1;
        let before = line.coordsAt(off, -1);
        if (before && inside(x, y, before))
          return -1;
        let after = line.coordsAt(off, 1);
        if (after && inside(x, y, after))
          return 1;
        return before && insideY(y, before) ? -1 : 1;
      }
      function queryPos(view, event) {
        let pos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
        return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) };
      }
      var BadMouseDetail = browser.ie && browser.ie_version <= 11;
      var lastMouseDown = null;
      var lastMouseDownCount = 0;
      var lastMouseDownTime = 0;
      function getClickType(event) {
        if (!BadMouseDetail)
          return event.detail;
        let last = lastMouseDown, lastTime = lastMouseDownTime;
        lastMouseDown = event;
        lastMouseDownTime = Date.now();
        return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
      }
      function basicMouseSelection(view, event) {
        let start = queryPos(view, event), type = getClickType(event);
        let startSel = view.state.selection;
        let last = start, lastEvent = event;
        return {
          update(update) {
            if (update.docChanged) {
              if (start)
                start.pos = update.changes.mapPos(start.pos);
              startSel = startSel.map(update.changes);
              lastEvent = null;
            }
          },
          get(event2, extend, multiple) {
            let cur;
            if (lastEvent && event2.clientX == lastEvent.clientX && event2.clientY == lastEvent.clientY)
              cur = last;
            else {
              cur = last = queryPos(view, event2);
              lastEvent = event2;
            }
            if (!cur || !start)
              return startSel;
            let range = rangeForClick(view, cur.pos, cur.bias, type);
            if (start.pos != cur.pos && !extend) {
              let startRange = rangeForClick(view, start.pos, start.bias, type);
              let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);
              range = from < range.from ? state.EditorSelection.range(from, to) : state.EditorSelection.range(to, from);
            }
            if (extend)
              return startSel.replaceRange(startSel.main.extend(range.from, range.to));
            else if (multiple && startSel.ranges.length > 1 && startSel.ranges.some((r) => r.eq(range)))
              return removeRange(startSel, range);
            else if (multiple)
              return startSel.addRange(range);
            else
              return state.EditorSelection.create([range]);
          }
        };
      }
      function removeRange(sel, range) {
        for (let i = 0; ; i++) {
          if (sel.ranges[i].eq(range))
            return state.EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));
        }
      }
      handlers.dragstart = (view, event) => {
        let { selection: { main } } = view.state;
        let { mouseSelection } = view.inputState;
        if (mouseSelection)
          mouseSelection.dragging = main;
        if (event.dataTransfer) {
          event.dataTransfer.setData("Text", view.state.sliceDoc(main.from, main.to));
          event.dataTransfer.effectAllowed = "copyMove";
        }
      };
      function dropText(view, event, text, direct) {
        if (!text)
          return;
        let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
        event.preventDefault();
        let { mouseSelection } = view.inputState;
        let del = direct && mouseSelection && mouseSelection.dragging && mouseSelection.dragMove ? { from: mouseSelection.dragging.from, to: mouseSelection.dragging.to } : null;
        let ins = { from: dropPos, insert: text };
        let changes = view.state.changes(del ? [del, ins] : ins);
        view.focus();
        view.dispatch({
          changes,
          selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
          userEvent: del ? "move.drop" : "input.drop"
        });
      }
      handlers.drop = (view, event) => {
        if (!event.dataTransfer)
          return;
        if (view.state.readOnly)
          return event.preventDefault();
        let files = event.dataTransfer.files;
        if (files && files.length) {
          event.preventDefault();
          let text = Array(files.length), read = 0;
          let finishFile = () => {
            if (++read == files.length)
              dropText(view, event, text.filter((s) => s != null).join(view.state.lineBreak), false);
          };
          for (let i = 0; i < files.length; i++) {
            let reader = new FileReader();
            reader.onerror = finishFile;
            reader.onload = () => {
              if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
                text[i] = reader.result;
              finishFile();
            };
            reader.readAsText(files[i]);
          }
        } else {
          dropText(view, event, event.dataTransfer.getData("Text"), true);
        }
      };
      handlers.paste = (view, event) => {
        if (view.state.readOnly)
          return event.preventDefault();
        view.observer.flush();
        let data = brokenClipboardAPI ? null : event.clipboardData;
        if (data) {
          doPaste(view, data.getData("text/plain"));
          event.preventDefault();
        } else {
          capturePaste(view);
        }
      };
      function captureCopy(view, text) {
        let parent = view.dom.parentNode;
        if (!parent)
          return;
        let target = parent.appendChild(document.createElement("textarea"));
        target.style.cssText = "position: fixed; left: -10000px; top: 10px";
        target.value = text;
        target.focus();
        target.selectionEnd = text.length;
        target.selectionStart = 0;
        setTimeout(() => {
          target.remove();
          view.focus();
        }, 50);
      }
      function copiedRange(state2) {
        let content = [], ranges = [], linewise = false;
        for (let range of state2.selection.ranges)
          if (!range.empty) {
            content.push(state2.sliceDoc(range.from, range.to));
            ranges.push(range);
          }
        if (!content.length) {
          let upto = -1;
          for (let { from } of state2.selection.ranges) {
            let line = state2.doc.lineAt(from);
            if (line.number > upto) {
              content.push(line.text);
              ranges.push({ from: line.from, to: Math.min(state2.doc.length, line.to + 1) });
            }
            upto = line.number;
          }
          linewise = true;
        }
        return { text: content.join(state2.lineBreak), ranges, linewise };
      }
      var lastLinewiseCopy = null;
      handlers.copy = handlers.cut = (view, event) => {
        let { text, ranges, linewise } = copiedRange(view.state);
        if (!text && !linewise)
          return;
        lastLinewiseCopy = linewise ? text : null;
        let data = brokenClipboardAPI ? null : event.clipboardData;
        if (data) {
          event.preventDefault();
          data.clearData();
          data.setData("text/plain", text);
        } else {
          captureCopy(view, text);
        }
        if (event.type == "cut" && !view.state.readOnly)
          view.dispatch({
            changes: ranges,
            scrollIntoView: true,
            userEvent: "delete.cut"
          });
      };
      function updateForFocusChange(view) {
        setTimeout(() => {
          if (view.hasFocus != view.inputState.notifiedFocused)
            view.update([]);
        }, 10);
      }
      handlers.focus = (view) => {
        view.inputState.lastFocusTime = Date.now();
        if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
          view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
          view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
        }
        updateForFocusChange(view);
      };
      handlers.blur = (view) => {
        view.observer.clearSelectionRange();
        updateForFocusChange(view);
      };
      function forceClearComposition(view, rapid) {
        if (view.docView.compositionDeco.size) {
          view.inputState.rapidCompositionStart = rapid;
          try {
            view.update([]);
          } finally {
            view.inputState.rapidCompositionStart = false;
          }
        }
      }
      handlers.compositionstart = handlers.compositionupdate = (view) => {
        if (view.inputState.compositionFirstChange == null)
          view.inputState.compositionFirstChange = true;
        if (view.inputState.composing < 0) {
          view.inputState.composing = 0;
          if (view.docView.compositionDeco.size) {
            view.observer.flush();
            forceClearComposition(view, true);
          }
        }
      };
      handlers.compositionend = (view) => {
        view.inputState.composing = -1;
        view.inputState.compositionEndedAt = Date.now();
        view.inputState.compositionFirstChange = null;
        setTimeout(() => {
          if (view.inputState.composing < 0)
            forceClearComposition(view, false);
        }, 50);
      };
      handlers.contextmenu = (view) => {
        view.inputState.lastContextMenu = Date.now();
      };
      handlers.beforeinput = (view, event) => {
        var _a;
        let pending;
        if (browser.chrome && browser.android && (pending = PendingKeys.find((key) => key.inputType == event.inputType))) {
          view.observer.delayAndroidKey(pending.key, pending.keyCode);
          if (pending.key == "Backspace" || pending.key == "Delete") {
            let startViewHeight = ((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0;
            setTimeout(() => {
              var _a2;
              if ((((_a2 = window.visualViewport) === null || _a2 === void 0 ? void 0 : _a2.height) || 0) > startViewHeight + 10 && view.hasFocus) {
                view.contentDOM.blur();
                view.focus();
              }
            }, 100);
          }
        }
      };
      var wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
      var HeightOracle = class {
        constructor() {
          this.doc = state.Text.empty;
          this.lineWrapping = false;
          this.heightSamples = {};
          this.lineHeight = 14;
          this.charWidth = 7;
          this.lineLength = 30;
          this.heightChanged = false;
        }
        heightForGap(from, to) {
          let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
          if (this.lineWrapping)
            lines += Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength);
          return this.lineHeight * lines;
        }
        heightForLine(length) {
          if (!this.lineWrapping)
            return this.lineHeight;
          let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
          return lines * this.lineHeight;
        }
        setDoc(doc2) {
          this.doc = doc2;
          return this;
        }
        mustRefreshForWrapping(whiteSpace) {
          return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
        }
        mustRefreshForHeights(lineHeights) {
          let newHeight = false;
          for (let i = 0; i < lineHeights.length; i++) {
            let h = lineHeights[i];
            if (h < 0) {
              i++;
            } else if (!this.heightSamples[Math.floor(h * 10)]) {
              newHeight = true;
              this.heightSamples[Math.floor(h * 10)] = true;
            }
          }
          return newHeight;
        }
        refresh(whiteSpace, lineHeight, charWidth, lineLength, knownHeights) {
          let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
          let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
          this.lineWrapping = lineWrapping;
          this.lineHeight = lineHeight;
          this.charWidth = charWidth;
          this.lineLength = lineLength;
          if (changed) {
            this.heightSamples = {};
            for (let i = 0; i < knownHeights.length; i++) {
              let h = knownHeights[i];
              if (h < 0)
                i++;
              else
                this.heightSamples[Math.floor(h * 10)] = true;
            }
          }
          return changed;
        }
      };
      var MeasuredHeights = class {
        constructor(from, heights) {
          this.from = from;
          this.heights = heights;
          this.index = 0;
        }
        get more() {
          return this.index < this.heights.length;
        }
      };
      var BlockInfo = class {
        constructor(from, length, top, height, type) {
          this.from = from;
          this.length = length;
          this.top = top;
          this.height = height;
          this.type = type;
        }
        get to() {
          return this.from + this.length;
        }
        get bottom() {
          return this.top + this.height;
        }
        join(other) {
          let detail = (Array.isArray(this.type) ? this.type : [this]).concat(Array.isArray(other.type) ? other.type : [other]);
          return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);
        }
      };
      var QueryType;
      (function(QueryType2) {
        QueryType2[QueryType2["ByPos"] = 0] = "ByPos";
        QueryType2[QueryType2["ByHeight"] = 1] = "ByHeight";
        QueryType2[QueryType2["ByPosNoHeight"] = 2] = "ByPosNoHeight";
      })(QueryType || (QueryType = {}));
      var Epsilon = 1e-3;
      var HeightMap = class {
        constructor(length, height, flags = 2) {
          this.length = length;
          this.height = height;
          this.flags = flags;
        }
        get outdated() {
          return (this.flags & 2) > 0;
        }
        set outdated(value) {
          this.flags = (value ? 2 : 0) | this.flags & ~2;
        }
        setHeight(oracle, height) {
          if (this.height != height) {
            if (Math.abs(this.height - height) > Epsilon)
              oracle.heightChanged = true;
            this.height = height;
          }
        }
        replace(_from, _to, nodes) {
          return HeightMap.of(nodes);
        }
        decomposeLeft(_to, result) {
          result.push(this);
        }
        decomposeRight(_from, result) {
          result.push(this);
        }
        applyChanges(decorations2, oldDoc, oracle, changes) {
          let me = this;
          for (let i = changes.length - 1; i >= 0; i--) {
            let { fromA, toA, fromB, toB } = changes[i];
            let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
            let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
            toB += end.to - toA;
            toA = end.to;
            while (i > 0 && start.from <= changes[i - 1].toA) {
              fromA = changes[i - 1].fromA;
              fromB = changes[i - 1].fromB;
              i--;
              if (fromA < start.from)
                start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
            }
            fromB += start.from - fromA;
            fromA = start.from;
            let nodes = NodeBuilder.build(oracle, decorations2, fromB, toB);
            me = me.replace(fromA, toA, nodes);
          }
          return me.updateHeight(oracle, 0);
        }
        static empty() {
          return new HeightMapText(0, 0);
        }
        static of(nodes) {
          if (nodes.length == 1)
            return nodes[0];
          let i = 0, j = nodes.length, before = 0, after = 0;
          for (; ; ) {
            if (i == j) {
              if (before > after * 2) {
                let split = nodes[i - 1];
                if (split.break)
                  nodes.splice(--i, 1, split.left, null, split.right);
                else
                  nodes.splice(--i, 1, split.left, split.right);
                j += 1 + split.break;
                before -= split.size;
              } else if (after > before * 2) {
                let split = nodes[j];
                if (split.break)
                  nodes.splice(j, 1, split.left, null, split.right);
                else
                  nodes.splice(j, 1, split.left, split.right);
                j += 2 + split.break;
                after -= split.size;
              } else {
                break;
              }
            } else if (before < after) {
              let next = nodes[i++];
              if (next)
                before += next.size;
            } else {
              let next = nodes[--j];
              if (next)
                after += next.size;
            }
          }
          let brk = 0;
          if (nodes[i - 1] == null) {
            brk = 1;
            i--;
          } else if (nodes[i] == null) {
            brk = 1;
            j++;
          }
          return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));
        }
      };
      HeightMap.prototype.size = 1;
      var HeightMapBlock = class extends HeightMap {
        constructor(length, height, type) {
          super(length, height);
          this.type = type;
        }
        blockAt(_height, _doc, top, offset) {
          return new BlockInfo(offset, this.length, top, this.height, this.type);
        }
        lineAt(_value, _type, doc2, top, offset) {
          return this.blockAt(0, doc2, top, offset);
        }
        forEachLine(from, to, doc2, top, offset, f) {
          if (from <= offset + this.length && to >= offset)
            f(this.blockAt(0, doc2, top, offset));
        }
        updateHeight(oracle, offset = 0, _force = false, measured) {
          if (measured && measured.from <= offset && measured.more)
            this.setHeight(oracle, measured.heights[measured.index++]);
          this.outdated = false;
          return this;
        }
        toString() {
          return `block(${this.length})`;
        }
      };
      var HeightMapText = class extends HeightMapBlock {
        constructor(length, height) {
          super(length, height, exports.BlockType.Text);
          this.collapsed = 0;
          this.widgetHeight = 0;
        }
        replace(_from, _to, nodes) {
          let node = nodes[0];
          if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {
            if (node instanceof HeightMapGap)
              node = new HeightMapText(node.length, this.height);
            else
              node.height = this.height;
            if (!this.outdated)
              node.outdated = false;
            return node;
          } else {
            return HeightMap.of(nodes);
          }
        }
        updateHeight(oracle, offset = 0, force = false, measured) {
          if (measured && measured.from <= offset && measured.more)
            this.setHeight(oracle, measured.heights[measured.index++]);
          else if (force || this.outdated)
            this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));
          this.outdated = false;
          return this;
        }
        toString() {
          return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
        }
      };
      var HeightMapGap = class extends HeightMap {
        constructor(length) {
          super(length, 0);
        }
        lines(doc2, offset) {
          let firstLine = doc2.lineAt(offset).number, lastLine = doc2.lineAt(offset + this.length).number;
          return { firstLine, lastLine, lineHeight: this.height / (lastLine - firstLine + 1) };
        }
        blockAt(height, doc2, top, offset) {
          let { firstLine, lastLine, lineHeight } = this.lines(doc2, offset);
          let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / lineHeight)));
          let { from, length } = doc2.line(firstLine + line);
          return new BlockInfo(from, length, top + lineHeight * line, lineHeight, exports.BlockType.Text);
        }
        lineAt(value, type, doc2, top, offset) {
          if (type == QueryType.ByHeight)
            return this.blockAt(value, doc2, top, offset);
          if (type == QueryType.ByPosNoHeight) {
            let { from: from2, to } = doc2.lineAt(value);
            return new BlockInfo(from2, to - from2, 0, 0, exports.BlockType.Text);
          }
          let { firstLine, lineHeight } = this.lines(doc2, offset);
          let { from, length, number } = doc2.lineAt(value);
          return new BlockInfo(from, length, top + lineHeight * (number - firstLine), lineHeight, exports.BlockType.Text);
        }
        forEachLine(from, to, doc2, top, offset, f) {
          let { firstLine, lineHeight } = this.lines(doc2, offset);
          for (let pos = Math.max(from, offset), end = Math.min(offset + this.length, to); pos <= end; ) {
            let line = doc2.lineAt(pos);
            if (pos == from)
              top += lineHeight * (line.number - firstLine);
            f(new BlockInfo(line.from, line.length, top, lineHeight, exports.BlockType.Text));
            top += lineHeight;
            pos = line.to + 1;
          }
        }
        replace(from, to, nodes) {
          let after = this.length - to;
          if (after > 0) {
            let last = nodes[nodes.length - 1];
            if (last instanceof HeightMapGap)
              nodes[nodes.length - 1] = new HeightMapGap(last.length + after);
            else
              nodes.push(null, new HeightMapGap(after - 1));
          }
          if (from > 0) {
            let first = nodes[0];
            if (first instanceof HeightMapGap)
              nodes[0] = new HeightMapGap(from + first.length);
            else
              nodes.unshift(new HeightMapGap(from - 1), null);
          }
          return HeightMap.of(nodes);
        }
        decomposeLeft(to, result) {
          result.push(new HeightMapGap(to - 1), null);
        }
        decomposeRight(from, result) {
          result.push(null, new HeightMapGap(this.length - from - 1));
        }
        updateHeight(oracle, offset = 0, force = false, measured) {
          let end = offset + this.length;
          if (measured && measured.from <= offset + this.length && measured.more) {
            let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
            let wasChanged = oracle.heightChanged;
            if (measured.from > offset)
              nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
            while (pos <= end && measured.more) {
              let len = oracle.doc.lineAt(pos).length;
              if (nodes.length)
                nodes.push(null);
              let height = measured.heights[measured.index++];
              if (singleHeight == -1)
                singleHeight = height;
              else if (Math.abs(height - singleHeight) >= Epsilon)
                singleHeight = -2;
              let line = new HeightMapText(len, height);
              line.outdated = false;
              nodes.push(line);
              pos += len + 1;
            }
            if (pos <= end)
              nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
            let result = HeightMap.of(nodes);
            oracle.heightChanged = wasChanged || singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.lines(oracle.doc, offset).lineHeight) >= Epsilon;
            return result;
          } else if (force || this.outdated) {
            this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));
            this.outdated = false;
          }
          return this;
        }
        toString() {
          return `gap(${this.length})`;
        }
      };
      var HeightMapBranch = class extends HeightMap {
        constructor(left, brk, right) {
          super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
          this.left = left;
          this.right = right;
          this.size = left.size + right.size;
        }
        get break() {
          return this.flags & 1;
        }
        blockAt(height, doc2, top, offset) {
          let mid = top + this.left.height;
          return height < mid ? this.left.blockAt(height, doc2, top, offset) : this.right.blockAt(height, doc2, mid, offset + this.left.length + this.break);
        }
        lineAt(value, type, doc2, top, offset) {
          let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;
          let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;
          let base = left ? this.left.lineAt(value, type, doc2, top, offset) : this.right.lineAt(value, type, doc2, rightTop, rightOffset);
          if (this.break || (left ? base.to < rightOffset : base.from > rightOffset))
            return base;
          let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
          if (left)
            return base.join(this.right.lineAt(rightOffset, subQuery, doc2, rightTop, rightOffset));
          else
            return this.left.lineAt(rightOffset, subQuery, doc2, top, offset).join(base);
        }
        forEachLine(from, to, doc2, top, offset, f) {
          let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;
          if (this.break) {
            if (from < rightOffset)
              this.left.forEachLine(from, to, doc2, top, offset, f);
            if (to >= rightOffset)
              this.right.forEachLine(from, to, doc2, rightTop, rightOffset, f);
          } else {
            let mid = this.lineAt(rightOffset, QueryType.ByPos, doc2, top, offset);
            if (from < mid.from)
              this.left.forEachLine(from, mid.from - 1, doc2, top, offset, f);
            if (mid.to >= from && mid.from <= to)
              f(mid);
            if (to > mid.to)
              this.right.forEachLine(mid.to + 1, to, doc2, rightTop, rightOffset, f);
          }
        }
        replace(from, to, nodes) {
          let rightStart = this.left.length + this.break;
          if (to < rightStart)
            return this.balanced(this.left.replace(from, to, nodes), this.right);
          if (from > this.left.length)
            return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
          let result = [];
          if (from > 0)
            this.decomposeLeft(from, result);
          let left = result.length;
          for (let node of nodes)
            result.push(node);
          if (from > 0)
            mergeGaps(result, left - 1);
          if (to < this.length) {
            let right = result.length;
            this.decomposeRight(to, result);
            mergeGaps(result, right);
          }
          return HeightMap.of(result);
        }
        decomposeLeft(to, result) {
          let left = this.left.length;
          if (to <= left)
            return this.left.decomposeLeft(to, result);
          result.push(this.left);
          if (this.break) {
            left++;
            if (to >= left)
              result.push(null);
          }
          if (to > left)
            this.right.decomposeLeft(to - left, result);
        }
        decomposeRight(from, result) {
          let left = this.left.length, right = left + this.break;
          if (from >= right)
            return this.right.decomposeRight(from - right, result);
          if (from < left)
            this.left.decomposeRight(from, result);
          if (this.break && from < right)
            result.push(null);
          result.push(this.right);
        }
        balanced(left, right) {
          if (left.size > 2 * right.size || right.size > 2 * left.size)
            return HeightMap.of(this.break ? [left, null, right] : [left, right]);
          this.left = left;
          this.right = right;
          this.height = left.height + right.height;
          this.outdated = left.outdated || right.outdated;
          this.size = left.size + right.size;
          this.length = left.length + this.break + right.length;
          return this;
        }
        updateHeight(oracle, offset = 0, force = false, measured) {
          let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
          if (measured && measured.from <= offset + left.length && measured.more)
            rebalance = left = left.updateHeight(oracle, offset, force, measured);
          else
            left.updateHeight(oracle, offset, force);
          if (measured && measured.from <= rightStart + right.length && measured.more)
            rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
          else
            right.updateHeight(oracle, rightStart, force);
          if (rebalance)
            return this.balanced(left, right);
          this.height = this.left.height + this.right.height;
          this.outdated = false;
          return this;
        }
        toString() {
          return this.left + (this.break ? " " : "-") + this.right;
        }
      };
      function mergeGaps(nodes, around) {
        let before, after;
        if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
          nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
      }
      var relevantWidgetHeight = 5;
      var NodeBuilder = class {
        constructor(pos, oracle) {
          this.pos = pos;
          this.oracle = oracle;
          this.nodes = [];
          this.lineStart = -1;
          this.lineEnd = -1;
          this.covering = null;
          this.writtenTo = pos;
        }
        get isCovered() {
          return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
        }
        span(_from, to) {
          if (this.lineStart > -1) {
            let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];
            if (last instanceof HeightMapText)
              last.length += end - this.pos;
            else if (end > this.pos || !this.isCovered)
              this.nodes.push(new HeightMapText(end - this.pos, -1));
            this.writtenTo = end;
            if (to > end) {
              this.nodes.push(null);
              this.writtenTo++;
              this.lineStart = -1;
            }
          }
          this.pos = to;
        }
        point(from, to, deco) {
          if (from < to || deco.heightRelevant) {
            let height = deco.widget ? deco.widget.estimatedHeight : 0;
            if (height < 0)
              height = this.oracle.lineHeight;
            let len = to - from;
            if (deco.block) {
              this.addBlock(new HeightMapBlock(len, height, deco.type));
            } else if (len || height >= relevantWidgetHeight) {
              this.addLineDeco(height, len);
            }
          } else if (to > from) {
            this.span(from, to);
          }
          if (this.lineEnd > -1 && this.lineEnd < this.pos)
            this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
        }
        enterLine() {
          if (this.lineStart > -1)
            return;
          let { from, to } = this.oracle.doc.lineAt(this.pos);
          this.lineStart = from;
          this.lineEnd = to;
          if (this.writtenTo < from) {
            if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
              this.nodes.push(this.blankContent(this.writtenTo, from - 1));
            this.nodes.push(null);
          }
          if (this.pos > from)
            this.nodes.push(new HeightMapText(this.pos - from, -1));
          this.writtenTo = this.pos;
        }
        blankContent(from, to) {
          let gap = new HeightMapGap(to - from);
          if (this.oracle.doc.lineAt(from).to == to)
            gap.flags |= 4;
          return gap;
        }
        ensureLine() {
          this.enterLine();
          let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
          if (last instanceof HeightMapText)
            return last;
          let line = new HeightMapText(0, -1);
          this.nodes.push(line);
          return line;
        }
        addBlock(block) {
          this.enterLine();
          if (block.type == exports.BlockType.WidgetAfter && !this.isCovered)
            this.ensureLine();
          this.nodes.push(block);
          this.writtenTo = this.pos = this.pos + block.length;
          if (block.type != exports.BlockType.WidgetBefore)
            this.covering = block;
        }
        addLineDeco(height, length) {
          let line = this.ensureLine();
          line.length += length;
          line.collapsed += length;
          line.widgetHeight = Math.max(line.widgetHeight, height);
          this.writtenTo = this.pos = this.pos + length;
        }
        finish(from) {
          let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
          if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
            this.nodes.push(new HeightMapText(0, -1));
          else if (this.writtenTo < this.pos || last == null)
            this.nodes.push(this.blankContent(this.writtenTo, this.pos));
          let pos = from;
          for (let node of this.nodes) {
            if (node instanceof HeightMapText)
              node.updateHeight(this.oracle, pos);
            pos += node ? node.length : 1;
          }
          return this.nodes;
        }
        static build(oracle, decorations2, from, to) {
          let builder = new NodeBuilder(from, oracle);
          state.RangeSet.spans(decorations2, from, to, builder, 0);
          return builder.finish(from);
        }
      };
      function heightRelevantDecoChanges(a, b, diff) {
        let comp = new DecorationComparator();
        state.RangeSet.compare(a, b, diff, comp, 0);
        return comp.changes;
      }
      var DecorationComparator = class {
        constructor() {
          this.changes = [];
        }
        compareRange() {
        }
        comparePoint(from, to, a, b) {
          if (from < to || a && a.heightRelevant || b && b.heightRelevant)
            addRange(from, to, this.changes, 5);
        }
      };
      function visiblePixelRange(dom, paddingTop) {
        let rect = dom.getBoundingClientRect();
        let left = Math.max(0, rect.left), right = Math.min(innerWidth, rect.right);
        let top = Math.max(0, rect.top), bottom = Math.min(innerHeight, rect.bottom);
        let body = dom.ownerDocument.body;
        for (let parent = dom.parentNode; parent && parent != body; ) {
          if (parent.nodeType == 1) {
            let elt = parent;
            let style = window.getComputedStyle(elt);
            if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != "visible") {
              let parentRect = elt.getBoundingClientRect();
              left = Math.max(left, parentRect.left);
              right = Math.min(right, parentRect.right);
              top = Math.max(top, parentRect.top);
              bottom = parent == dom.parentNode ? parentRect.bottom : Math.min(bottom, parentRect.bottom);
            }
            parent = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
          } else if (parent.nodeType == 11) {
            parent = parent.host;
          } else {
            break;
          }
        }
        return {
          left: left - rect.left,
          right: Math.max(left, right) - rect.left,
          top: top - (rect.top + paddingTop),
          bottom: Math.max(top, bottom) - (rect.top + paddingTop)
        };
      }
      function fullPixelRange(dom, paddingTop) {
        let rect = dom.getBoundingClientRect();
        return {
          left: 0,
          right: rect.right - rect.left,
          top: paddingTop,
          bottom: rect.bottom - (rect.top + paddingTop)
        };
      }
      var LineGap = class {
        constructor(from, to, size) {
          this.from = from;
          this.to = to;
          this.size = size;
        }
        static same(a, b) {
          if (a.length != b.length)
            return false;
          for (let i = 0; i < a.length; i++) {
            let gA = a[i], gB = b[i];
            if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
              return false;
          }
          return true;
        }
        draw(wrapping) {
          return Decoration.replace({ widget: new LineGapWidget(this.size, wrapping) }).range(this.from, this.to);
        }
      };
      var LineGapWidget = class extends WidgetType {
        constructor(size, vertical) {
          super();
          this.size = size;
          this.vertical = vertical;
        }
        eq(other) {
          return other.size == this.size && other.vertical == this.vertical;
        }
        toDOM() {
          let elt = document.createElement("div");
          if (this.vertical) {
            elt.style.height = this.size + "px";
          } else {
            elt.style.width = this.size + "px";
            elt.style.height = "2px";
            elt.style.display = "inline-block";
          }
          return elt;
        }
        get estimatedHeight() {
          return this.vertical ? this.size : -1;
        }
      };
      var ViewState = class {
        constructor(state$1) {
          this.state = state$1;
          this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
          this.inView = true;
          this.paddingTop = 0;
          this.paddingBottom = 0;
          this.contentDOMWidth = 0;
          this.contentDOMHeight = 0;
          this.editorHeight = 0;
          this.editorWidth = 0;
          this.heightOracle = new HeightOracle();
          this.scaler = IdScaler;
          this.scrollTarget = null;
          this.printing = false;
          this.mustMeasureContent = true;
          this.defaultTextDirection = exports.Direction.RTL;
          this.visibleRanges = [];
          this.mustEnforceCursorAssoc = false;
          this.stateDeco = state$1.facet(decorations).filter((d) => typeof d != "function");
          this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, state.Text.empty, this.heightOracle.setDoc(state$1.doc), [new ChangedRange(0, 0, 0, state$1.doc.length)]);
          this.viewport = this.getViewport(0, null);
          this.updateViewportLines();
          this.updateForViewport();
          this.lineGaps = this.ensureLineGaps([]);
          this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(false)));
          this.computeVisibleRanges();
        }
        updateForViewport() {
          let viewports = [this.viewport], { main } = this.state.selection;
          for (let i = 0; i <= 1; i++) {
            let pos = i ? main.head : main.anchor;
            if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {
              let { from, to } = this.lineBlockAt(pos);
              viewports.push(new Viewport(from, to));
            }
          }
          this.viewports = viewports.sort((a, b) => a.from - b.from);
          this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle.doc, this.heightMap, this.viewports);
        }
        updateViewportLines() {
          this.viewportLines = [];
          this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, (block) => {
            this.viewportLines.push(this.scaler.scale == 1 ? block : scaleBlock(block, this.scaler));
          });
        }
        update(update, scrollTarget = null) {
          this.state = update.state;
          let prevDeco = this.stateDeco;
          this.stateDeco = this.state.facet(decorations).filter((d) => typeof d != "function");
          let contentChanges = update.changedRanges;
          let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : state.ChangeSet.empty(this.state.doc.length)));
          let prevHeight = this.heightMap.height;
          this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
          if (this.heightMap.height != prevHeight)
            update.flags |= 2;
          let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
          if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport))
            viewport = this.getViewport(0, scrollTarget);
          let updateLines = !update.changes.empty || update.flags & 2 || viewport.from != this.viewport.from || viewport.to != this.viewport.to;
          this.viewport = viewport;
          this.updateForViewport();
          if (updateLines)
            this.updateViewportLines();
          if (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3)
            this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
          update.flags |= this.computeVisibleRanges();
          if (scrollTarget)
            this.scrollTarget = scrollTarget;
          if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc)
            this.mustEnforceCursorAssoc = true;
        }
        measure(view) {
          let dom = view.contentDOM, style = window.getComputedStyle(dom);
          let oracle = this.heightOracle;
          let whiteSpace = style.whiteSpace;
          this.defaultTextDirection = style.direction == "rtl" ? exports.Direction.RTL : exports.Direction.LTR;
          let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
          let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != dom.clientHeight;
          this.contentDOMHeight = dom.clientHeight;
          this.mustMeasureContent = false;
          let result = 0, bias = 0;
          let paddingTop = parseInt(style.paddingTop) || 0, paddingBottom = parseInt(style.paddingBottom) || 0;
          if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
            this.paddingTop = paddingTop;
            this.paddingBottom = paddingBottom;
            result |= 8 | 2;
          }
          if (this.editorWidth != view.scrollDOM.clientWidth) {
            if (oracle.lineWrapping)
              measureContent = true;
            this.editorWidth = view.scrollDOM.clientWidth;
            result |= 8;
          }
          let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
          let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
          this.pixelViewport = pixelViewport;
          let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
          if (inView != this.inView) {
            this.inView = inView;
            if (inView)
              measureContent = true;
          }
          if (!this.inView)
            return 0;
          let contentWidth = dom.clientWidth;
          if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
            this.contentDOMWidth = contentWidth;
            this.editorHeight = view.scrollDOM.clientHeight;
            result |= 8;
          }
          if (measureContent) {
            let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
            if (oracle.mustRefreshForHeights(lineHeights))
              refresh = true;
            if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
              let { lineHeight, charWidth } = view.docView.measureTextSize();
              refresh = oracle.refresh(whiteSpace, lineHeight, charWidth, contentWidth / charWidth, lineHeights);
              if (refresh) {
                view.docView.minWidth = 0;
                result |= 8;
              }
            }
            if (dTop > 0 && dBottom > 0)
              bias = Math.max(dTop, dBottom);
            else if (dTop < 0 && dBottom < 0)
              bias = Math.min(dTop, dBottom);
            oracle.heightChanged = false;
            for (let vp of this.viewports) {
              let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
              this.heightMap = this.heightMap.updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
            }
            if (oracle.heightChanged)
              result |= 2;
          }
          let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
          if (viewportChange)
            this.viewport = this.getViewport(bias, this.scrollTarget);
          this.updateForViewport();
          if (result & 2 || viewportChange)
            this.updateViewportLines();
          if (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3)
            this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps));
          result |= this.computeVisibleRanges();
          if (this.mustEnforceCursorAssoc) {
            this.mustEnforceCursorAssoc = false;
            view.docView.enforceCursorAssoc();
          }
          return result;
        }
        get visibleTop() {
          return this.scaler.fromDOM(this.pixelViewport.top);
        }
        get visibleBottom() {
          return this.scaler.fromDOM(this.pixelViewport.bottom);
        }
        getViewport(bias, scrollTarget) {
          let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
          let map = this.heightMap, doc2 = this.state.doc, { visibleTop, visibleBottom } = this;
          let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, doc2, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, doc2, 0, 0).to);
          if (scrollTarget) {
            let { head } = scrollTarget.range;
            if (head < viewport.from || head > viewport.to) {
              let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
              let block = map.lineAt(head, QueryType.ByPos, doc2, 0, 0), topPos;
              if (scrollTarget.y == "center")
                topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
              else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
                topPos = block.top;
              else
                topPos = block.bottom - viewHeight;
              viewport = new Viewport(map.lineAt(topPos - 1e3 / 2, QueryType.ByHeight, doc2, 0, 0).from, map.lineAt(topPos + viewHeight + 1e3 / 2, QueryType.ByHeight, doc2, 0, 0).to);
            }
          }
          return viewport;
        }
        mapViewport(viewport, changes) {
          let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
          return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0).to);
        }
        viewportIsAppropriate({ from, to }, bias = 0) {
          if (!this.inView)
            return true;
          let { top } = this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0);
          let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0);
          let { visibleTop, visibleBottom } = this;
          return (from == 0 || top <= visibleTop - Math.max(10, Math.min(-bias, 250))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(bias, 250))) && (top > visibleTop - 2 * 1e3 && bottom < visibleBottom + 2 * 1e3);
        }
        mapLineGaps(gaps, changes) {
          if (!gaps.length || changes.empty)
            return gaps;
          let mapped = [];
          for (let gap of gaps)
            if (!changes.touchesRange(gap.from, gap.to))
              mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));
          return mapped;
        }
        ensureLineGaps(current) {
          let gaps = [];
          if (this.defaultTextDirection != exports.Direction.LTR)
            return gaps;
          for (let line of this.viewportLines) {
            if (line.length < 4e3)
              continue;
            let structure = lineStructure(line.from, line.to, this.stateDeco);
            if (structure.total < 4e3)
              continue;
            let viewFrom, viewTo;
            if (this.heightOracle.lineWrapping) {
              let marginHeight = 2e3 / this.heightOracle.lineLength * this.heightOracle.lineHeight;
              viewFrom = findPosition(structure, (this.visibleTop - line.top - marginHeight) / line.height);
              viewTo = findPosition(structure, (this.visibleBottom - line.top + marginHeight) / line.height);
            } else {
              let totalWidth = structure.total * this.heightOracle.charWidth;
              let marginWidth = 2e3 * this.heightOracle.charWidth;
              viewFrom = findPosition(structure, (this.pixelViewport.left - marginWidth) / totalWidth);
              viewTo = findPosition(structure, (this.pixelViewport.right + marginWidth) / totalWidth);
            }
            let outside = [];
            if (viewFrom > line.from)
              outside.push({ from: line.from, to: viewFrom });
            if (viewTo < line.to)
              outside.push({ from: viewTo, to: line.to });
            let sel = this.state.selection.main;
            if (sel.from >= line.from && sel.from <= line.to)
              cutRange(outside, sel.from - 10, sel.from + 10);
            if (!sel.empty && sel.to >= line.from && sel.to <= line.to)
              cutRange(outside, sel.to - 10, sel.to + 10);
            for (let { from, to } of outside)
              if (to - from > 1e3) {
                gaps.push(find(current, (gap) => gap.from >= line.from && gap.to <= line.to && Math.abs(gap.from - from) < 1e3 && Math.abs(gap.to - to) < 1e3) || new LineGap(from, to, this.gapSize(line, from, to, structure)));
              }
          }
          return gaps;
        }
        gapSize(line, from, to, structure) {
          let fraction = findFraction(structure, to) - findFraction(structure, from);
          if (this.heightOracle.lineWrapping) {
            return line.height * fraction;
          } else {
            return structure.total * this.heightOracle.charWidth * fraction;
          }
        }
        updateLineGaps(gaps) {
          if (!LineGap.same(gaps, this.lineGaps)) {
            this.lineGaps = gaps;
            this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this.heightOracle.lineWrapping)));
          }
        }
        computeVisibleRanges() {
          let deco = this.stateDeco;
          if (this.lineGaps.length)
            deco = deco.concat(this.lineGapDeco);
          let ranges = [];
          state.RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
            span(from, to) {
              ranges.push({ from, to });
            },
            point() {
            }
          }, 20);
          let changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r, i) => r.from != ranges[i].from || r.to != ranges[i].to);
          this.visibleRanges = ranges;
          return changed ? 4 : 0;
        }
        lineBlockAt(pos) {
          return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b) => b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.state.doc, 0, 0), this.scaler);
        }
        lineBlockAtHeight(height) {
          return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.state.doc, 0, 0), this.scaler);
        }
        elementAtHeight(height) {
          return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.state.doc, 0, 0), this.scaler);
        }
        get docHeight() {
          return this.scaler.toDOM(this.heightMap.height);
        }
        get contentHeight() {
          return this.docHeight + this.paddingTop + this.paddingBottom;
        }
      };
      var Viewport = class {
        constructor(from, to) {
          this.from = from;
          this.to = to;
        }
      };
      function lineStructure(from, to, stateDeco) {
        let ranges = [], pos = from, total = 0;
        state.RangeSet.spans(stateDeco, from, to, {
          span() {
          },
          point(from2, to2) {
            if (from2 > pos) {
              ranges.push({ from: pos, to: from2 });
              total += from2 - pos;
            }
            pos = to2;
          }
        }, 20);
        if (pos < to) {
          ranges.push({ from: pos, to });
          total += to - pos;
        }
        return { total, ranges };
      }
      function findPosition({ total, ranges }, ratio) {
        if (ratio <= 0)
          return ranges[0].from;
        if (ratio >= 1)
          return ranges[ranges.length - 1].to;
        let dist = Math.floor(total * ratio);
        for (let i = 0; ; i++) {
          let { from, to } = ranges[i], size = to - from;
          if (dist <= size)
            return from + dist;
          dist -= size;
        }
      }
      function findFraction(structure, pos) {
        let counted = 0;
        for (let { from, to } of structure.ranges) {
          if (pos <= to) {
            counted += pos - from;
            break;
          }
          counted += to - from;
        }
        return counted / structure.total;
      }
      function cutRange(ranges, from, to) {
        for (let i = 0; i < ranges.length; i++) {
          let r = ranges[i];
          if (r.from < to && r.to > from) {
            let pieces = [];
            if (r.from < from)
              pieces.push({ from: r.from, to: from });
            if (r.to > to)
              pieces.push({ from: to, to: r.to });
            ranges.splice(i, 1, ...pieces);
            i += pieces.length - 1;
          }
        }
      }
      function find(array, f) {
        for (let val of array)
          if (f(val))
            return val;
        return void 0;
      }
      var IdScaler = {
        toDOM(n) {
          return n;
        },
        fromDOM(n) {
          return n;
        },
        scale: 1
      };
      var BigScaler = class {
        constructor(doc2, heightMap, viewports) {
          let vpHeight = 0, base = 0, domBase = 0;
          this.viewports = viewports.map(({ from, to }) => {
            let top = heightMap.lineAt(from, QueryType.ByPos, doc2, 0, 0).top;
            let bottom = heightMap.lineAt(to, QueryType.ByPos, doc2, 0, 0).bottom;
            vpHeight += bottom - top;
            return { from, to, top, bottom, domTop: 0, domBottom: 0 };
          });
          this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
          for (let obj of this.viewports) {
            obj.domTop = domBase + (obj.top - base) * this.scale;
            domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
            base = obj.bottom;
          }
        }
        toDOM(n) {
          for (let i = 0, base = 0, domBase = 0; ; i++) {
            let vp = i < this.viewports.length ? this.viewports[i] : null;
            if (!vp || n < vp.top)
              return domBase + (n - base) * this.scale;
            if (n <= vp.bottom)
              return vp.domTop + (n - vp.top);
            base = vp.bottom;
            domBase = vp.domBottom;
          }
        }
        fromDOM(n) {
          for (let i = 0, base = 0, domBase = 0; ; i++) {
            let vp = i < this.viewports.length ? this.viewports[i] : null;
            if (!vp || n < vp.domTop)
              return base + (n - domBase) / this.scale;
            if (n <= vp.domBottom)
              return vp.top + (n - vp.domTop);
            base = vp.bottom;
            domBase = vp.domBottom;
          }
        }
      };
      function scaleBlock(block, scaler) {
        if (scaler.scale == 1)
          return block;
        let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
        return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block.type) ? block.type.map((b) => scaleBlock(b, scaler)) : block.type);
      }
      var theme = state.Facet.define({ combine: (strs) => strs.join(" ") });
      var darkTheme = state.Facet.define({ combine: (values) => values.indexOf(true) > -1 });
      var baseThemeID = styleMod.StyleModule.newName();
      var baseLightID = styleMod.StyleModule.newName();
      var baseDarkID = styleMod.StyleModule.newName();
      var lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
      function buildTheme(main, spec, scopes) {
        return new styleMod.StyleModule(spec, {
          finish(sel) {
            return /&/.test(sel) ? sel.replace(/&\w*/, (m) => {
              if (m == "&")
                return main;
              if (!scopes || !scopes[m])
                throw new RangeError(`Unsupported selector: ${m}`);
              return scopes[m];
            }) : main + " " + sel;
          }
        });
      }
      var baseTheme$1 = buildTheme("." + baseThemeID, {
        "&.cm-editor": {
          position: "relative !important",
          boxSizing: "border-box",
          "&.cm-focused": {
            outline: "1px dotted #212121"
          },
          display: "flex !important",
          flexDirection: "column"
        },
        ".cm-scroller": {
          display: "flex !important",
          alignItems: "flex-start !important",
          fontFamily: "monospace",
          lineHeight: 1.4,
          height: "100%",
          overflowX: "auto",
          position: "relative",
          zIndex: 0
        },
        ".cm-content": {
          margin: 0,
          flexGrow: 2,
          flexShrink: 0,
          minHeight: "100%",
          display: "block",
          whiteSpace: "pre",
          wordWrap: "normal",
          boxSizing: "border-box",
          padding: "4px 0",
          outline: "none",
          "&[contenteditable=true]": {
            WebkitUserModify: "read-write-plaintext-only"
          }
        },
        ".cm-lineWrapping": {
          whiteSpace_fallback: "pre-wrap",
          whiteSpace: "break-spaces",
          wordBreak: "break-word",
          overflowWrap: "anywhere",
          flexShrink: 1
        },
        "&light .cm-content": { caretColor: "black" },
        "&dark .cm-content": { caretColor: "white" },
        ".cm-line": {
          display: "block",
          padding: "0 2px 0 4px"
        },
        ".cm-selectionLayer": {
          zIndex: -1,
          contain: "size style"
        },
        ".cm-selectionBackground": {
          position: "absolute"
        },
        "&light .cm-selectionBackground": {
          background: "#d9d9d9"
        },
        "&dark .cm-selectionBackground": {
          background: "#222"
        },
        "&light.cm-focused .cm-selectionBackground": {
          background: "#d7d4f0"
        },
        "&dark.cm-focused .cm-selectionBackground": {
          background: "#233"
        },
        ".cm-cursorLayer": {
          zIndex: 100,
          contain: "size style",
          pointerEvents: "none"
        },
        "&.cm-focused .cm-cursorLayer": {
          animation: "steps(1) cm-blink 1.2s infinite"
        },
        "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
        "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
        ".cm-cursor, .cm-dropCursor": {
          position: "absolute",
          borderLeft: "1.2px solid black",
          marginLeft: "-0.6px",
          pointerEvents: "none"
        },
        ".cm-cursor": {
          display: "none"
        },
        "&dark .cm-cursor": {
          borderLeftColor: "#444"
        },
        "&.cm-focused .cm-cursor": {
          display: "block"
        },
        "&light .cm-activeLine": { backgroundColor: "#f3f9ff" },
        "&dark .cm-activeLine": { backgroundColor: "#223039" },
        "&light .cm-specialChar": { color: "red" },
        "&dark .cm-specialChar": { color: "#f78" },
        ".cm-gutters": {
          flexShrink: 0,
          display: "flex",
          height: "100%",
          boxSizing: "border-box",
          left: 0,
          zIndex: 200
        },
        "&light .cm-gutters": {
          backgroundColor: "#f5f5f5",
          color: "#6c6c6c",
          borderRight: "1px solid #ddd"
        },
        "&dark .cm-gutters": {
          backgroundColor: "#333338",
          color: "#ccc"
        },
        ".cm-gutter": {
          display: "flex !important",
          flexDirection: "column",
          flexShrink: 0,
          boxSizing: "border-box",
          minHeight: "100%",
          overflow: "hidden"
        },
        ".cm-gutterElement": {
          boxSizing: "border-box"
        },
        ".cm-lineNumbers .cm-gutterElement": {
          padding: "0 3px 0 5px",
          minWidth: "20px",
          textAlign: "right",
          whiteSpace: "nowrap"
        },
        "&light .cm-activeLineGutter": {
          backgroundColor: "#e2f2ff"
        },
        "&dark .cm-activeLineGutter": {
          backgroundColor: "#222227"
        },
        ".cm-panels": {
          boxSizing: "border-box",
          position: "sticky",
          left: 0,
          right: 0
        },
        "&light .cm-panels": {
          backgroundColor: "#f5f5f5",
          color: "black"
        },
        "&light .cm-panels-top": {
          borderBottom: "1px solid #ddd"
        },
        "&light .cm-panels-bottom": {
          borderTop: "1px solid #ddd"
        },
        "&dark .cm-panels": {
          backgroundColor: "#333338",
          color: "white"
        },
        ".cm-tab": {
          display: "inline-block",
          overflow: "hidden",
          verticalAlign: "bottom"
        },
        ".cm-widgetBuffer": {
          verticalAlign: "text-top",
          height: "1em",
          width: 0,
          display: "inline"
        },
        ".cm-placeholder": {
          color: "#888",
          display: "inline-block",
          verticalAlign: "top"
        },
        ".cm-button": {
          verticalAlign: "middle",
          color: "inherit",
          fontSize: "70%",
          padding: ".2em 1em",
          borderRadius: "1px"
        },
        "&light .cm-button": {
          backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
          border: "1px solid #888",
          "&:active": {
            backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
          }
        },
        "&dark .cm-button": {
          backgroundImage: "linear-gradient(#393939, #111)",
          border: "1px solid #888",
          "&:active": {
            backgroundImage: "linear-gradient(#111, #333)"
          }
        },
        ".cm-textfield": {
          verticalAlign: "middle",
          color: "inherit",
          fontSize: "70%",
          border: "1px solid silver",
          padding: ".2em .5em"
        },
        "&light .cm-textfield": {
          backgroundColor: "white"
        },
        "&dark .cm-textfield": {
          border: "1px solid #555",
          backgroundColor: "inherit"
        }
      }, lightDarkIDs);
      var observeOptions = {
        childList: true,
        characterData: true,
        subtree: true,
        attributes: true,
        characterDataOldValue: true
      };
      var useCharData = browser.ie && browser.ie_version <= 11;
      var DOMObserver = class {
        constructor(view, onChange, onScrollChanged) {
          this.view = view;
          this.onChange = onChange;
          this.onScrollChanged = onScrollChanged;
          this.active = false;
          this.selectionRange = new DOMSelectionState();
          this.selectionChanged = false;
          this.delayedFlush = -1;
          this.resizeTimeout = -1;
          this.queue = [];
          this.delayedAndroidKey = null;
          this.scrollTargets = [];
          this.intersection = null;
          this.resize = null;
          this.intersecting = false;
          this.gapIntersection = null;
          this.gaps = [];
          this.parentCheck = -1;
          this.dom = view.contentDOM;
          this.observer = new MutationObserver((mutations) => {
            for (let mut of mutations)
              this.queue.push(mut);
            if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
              this.flushSoon();
            else
              this.flush();
          });
          if (useCharData)
            this.onCharData = (event) => {
              this.queue.push({
                target: event.target,
                type: "characterData",
                oldValue: event.prevValue
              });
              this.flushSoon();
            };
          this.onSelectionChange = this.onSelectionChange.bind(this);
          this.onResize = this.onResize.bind(this);
          this.onPrint = this.onPrint.bind(this);
          this.onScroll = this.onScroll.bind(this);
          if (typeof ResizeObserver == "function") {
            this.resize = new ResizeObserver(() => {
              if (this.view.docView.lastUpdate < Date.now() - 75)
                this.onResize();
            });
            this.resize.observe(view.scrollDOM);
          }
          this.win = view.dom.ownerDocument.defaultView;
          this.addWindowListeners(this.win);
          this.start();
          if (typeof IntersectionObserver == "function") {
            this.intersection = new IntersectionObserver((entries) => {
              if (this.parentCheck < 0)
                this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
              if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
                this.intersecting = !this.intersecting;
                if (this.intersecting != this.view.inView)
                  this.onScrollChanged(document.createEvent("Event"));
              }
            }, {});
            this.intersection.observe(this.dom);
            this.gapIntersection = new IntersectionObserver((entries) => {
              if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
                this.onScrollChanged(document.createEvent("Event"));
            }, {});
          }
          this.listenForScroll();
          this.readSelectionRange();
        }
        onScroll(e) {
          if (this.intersecting)
            this.flush(false);
          this.onScrollChanged(e);
        }
        onResize() {
          if (this.resizeTimeout < 0)
            this.resizeTimeout = setTimeout(() => {
              this.resizeTimeout = -1;
              this.view.requestMeasure();
            }, 50);
        }
        onPrint() {
          this.view.viewState.printing = true;
          this.view.measure();
          setTimeout(() => {
            this.view.viewState.printing = false;
            this.view.requestMeasure();
          }, 500);
        }
        updateGaps(gaps) {
          if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {
            this.gapIntersection.disconnect();
            for (let gap of gaps)
              this.gapIntersection.observe(gap);
            this.gaps = gaps;
          }
        }
        onSelectionChange(event) {
          if (!this.readSelectionRange() || this.delayedAndroidKey)
            return;
          let { view } = this, sel = this.selectionRange;
          if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel))
            return;
          let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
          if (context && context.ignoreEvent(event))
            return;
          if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
            this.flushSoon();
          else
            this.flush(false);
        }
        readSelectionRange() {
          let { view } = this;
          let range = browser.safari && view.root.nodeType == 11 && deepActiveElement() == this.dom && safariSelectionRangeHack(this.view) || getSelection(view.root);
          if (!range || this.selectionRange.eq(range))
            return false;
          let local = hasSelection(this.dom, range);
          if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {
            this.view.inputState.lastFocusTime = 0;
            view.docView.updateSelection();
            return false;
          }
          this.selectionRange.setRange(range);
          if (local)
            this.selectionChanged = true;
          return true;
        }
        setSelectionRange(anchor, head) {
          this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
          this.selectionChanged = false;
        }
        clearSelectionRange() {
          this.selectionRange.set(null, 0, null, 0);
        }
        listenForScroll() {
          this.parentCheck = -1;
          let i = 0, changed = null;
          for (let dom = this.dom; dom; ) {
            if (dom.nodeType == 1) {
              if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)
                i++;
              else if (!changed)
                changed = this.scrollTargets.slice(0, i);
              if (changed)
                changed.push(dom);
              dom = dom.assignedSlot || dom.parentNode;
            } else if (dom.nodeType == 11) {
              dom = dom.host;
            } else {
              break;
            }
          }
          if (i < this.scrollTargets.length && !changed)
            changed = this.scrollTargets.slice(0, i);
          if (changed) {
            for (let dom of this.scrollTargets)
              dom.removeEventListener("scroll", this.onScroll);
            for (let dom of this.scrollTargets = changed)
              dom.addEventListener("scroll", this.onScroll);
          }
        }
        ignore(f) {
          if (!this.active)
            return f();
          try {
            this.stop();
            return f();
          } finally {
            this.start();
            this.clear();
          }
        }
        start() {
          if (this.active)
            return;
          this.observer.observe(this.dom, observeOptions);
          if (useCharData)
            this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
          this.active = true;
        }
        stop() {
          if (!this.active)
            return;
          this.active = false;
          this.observer.disconnect();
          if (useCharData)
            this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
        }
        clear() {
          this.processRecords();
          this.queue.length = 0;
          this.selectionChanged = false;
        }
        delayAndroidKey(key, keyCode) {
          if (!this.delayedAndroidKey)
            requestAnimationFrame(() => {
              let key2 = this.delayedAndroidKey;
              this.delayedAndroidKey = null;
              this.delayedFlush = -1;
              if (!this.flush())
                dispatchKey(this.dom, key2.key, key2.keyCode);
            });
          if (!this.delayedAndroidKey || key == "Enter")
            this.delayedAndroidKey = { key, keyCode };
        }
        flushSoon() {
          if (this.delayedFlush < 0)
            this.delayedFlush = window.setTimeout(() => {
              this.delayedFlush = -1;
              this.flush();
            }, 20);
        }
        forceFlush() {
          if (this.delayedFlush >= 0) {
            window.clearTimeout(this.delayedFlush);
            this.delayedFlush = -1;
          }
          this.flush();
        }
        processRecords() {
          let records = this.queue;
          for (let mut of this.observer.takeRecords())
            records.push(mut);
          if (records.length)
            this.queue = [];
          let from = -1, to = -1, typeOver = false;
          for (let record of records) {
            let range = this.readMutation(record);
            if (!range)
              continue;
            if (range.typeOver)
              typeOver = true;
            if (from == -1) {
              ({ from, to } = range);
            } else {
              from = Math.min(range.from, from);
              to = Math.max(range.to, to);
            }
          }
          return { from, to, typeOver };
        }
        flush(readSelection = true) {
          if (this.delayedFlush >= 0 || this.delayedAndroidKey)
            return;
          if (readSelection)
            this.readSelectionRange();
          let { from, to, typeOver } = this.processRecords();
          let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
          if (from < 0 && !newSel)
            return;
          this.view.inputState.lastFocusTime = 0;
          this.selectionChanged = false;
          let startState = this.view.state;
          let handled = this.onChange(from, to, typeOver);
          if (this.view.state == startState)
            this.view.update([]);
          return handled;
        }
        readMutation(rec) {
          let cView = this.view.docView.nearest(rec.target);
          if (!cView || cView.ignoreMutation(rec))
            return null;
          cView.markDirty(rec.type == "attributes");
          if (rec.type == "attributes")
            cView.dirty |= 4;
          if (rec.type == "childList") {
            let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
            let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
            return {
              from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
              to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
              typeOver: false
            };
          } else if (rec.type == "characterData") {
            return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
          } else {
            return null;
          }
        }
        setWindow(win) {
          if (win != this.win) {
            this.removeWindowListeners(this.win);
            this.win = win;
            this.addWindowListeners(this.win);
          }
        }
        addWindowListeners(win) {
          win.addEventListener("resize", this.onResize);
          win.addEventListener("beforeprint", this.onPrint);
          win.addEventListener("scroll", this.onScroll);
          win.document.addEventListener("selectionchange", this.onSelectionChange);
        }
        removeWindowListeners(win) {
          win.removeEventListener("scroll", this.onScroll);
          win.removeEventListener("resize", this.onResize);
          win.removeEventListener("beforeprint", this.onPrint);
          win.document.removeEventListener("selectionchange", this.onSelectionChange);
        }
        destroy() {
          var _a, _b, _c;
          this.stop();
          (_a = this.intersection) === null || _a === void 0 ? void 0 : _a.disconnect();
          (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
          (_c = this.resize) === null || _c === void 0 ? void 0 : _c.disconnect();
          for (let dom of this.scrollTargets)
            dom.removeEventListener("scroll", this.onScroll);
          this.removeWindowListeners(this.win);
          clearTimeout(this.parentCheck);
          clearTimeout(this.resizeTimeout);
        }
      };
      function findChild(cView, dom, dir) {
        while (dom) {
          let curView = ContentView.get(dom);
          if (curView && curView.parent == cView)
            return curView;
          let parent = dom.parentNode;
          dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
        }
        return null;
      }
      function safariSelectionRangeHack(view) {
        let found = null;
        function read(event) {
          event.preventDefault();
          event.stopImmediatePropagation();
          found = event.getTargetRanges()[0];
        }
        view.contentDOM.addEventListener("beforeinput", read, true);
        document.execCommand("indent");
        view.contentDOM.removeEventListener("beforeinput", read, true);
        if (!found)
          return null;
        let anchorNode = found.startContainer, anchorOffset = found.startOffset;
        let focusNode = found.endContainer, focusOffset = found.endOffset;
        let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
        if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
          [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
        return { anchorNode, anchorOffset, focusNode, focusOffset };
      }
      function applyDOMChange(view, start, end, typeOver) {
        let change, newSel;
        let sel = view.state.selection.main;
        if (start > -1) {
          let bounds = view.docView.domBoundsAround(start, end, 0);
          if (!bounds || view.state.readOnly)
            return false;
          let { from, to } = bounds;
          let selPoints = view.docView.impreciseHead || view.docView.impreciseAnchor ? [] : selectionPoints(view);
          let reader = new DOMReader(selPoints, view.state);
          reader.readRange(bounds.startDOM, bounds.endDOM);
          let preferredPos = sel.from, preferredSide = null;
          if (view.inputState.lastKeyCode === 8 && view.inputState.lastKeyTime > Date.now() - 100 || browser.android && reader.text.length < to - from) {
            preferredPos = sel.to;
            preferredSide = "end";
          }
          let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), reader.text, preferredPos - from, preferredSide);
          if (diff) {
            if (browser.chrome && view.inputState.lastKeyCode == 13 && diff.toB == diff.from + 2 && reader.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
              diff.toB--;
            change = {
              from: from + diff.from,
              to: from + diff.toA,
              insert: state.Text.of(reader.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
            };
          }
          newSel = selectionFromPoints(selPoints, from);
        } else if (view.hasFocus || !view.state.facet(editable)) {
          let domSel = view.observer.selectionRange;
          let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
          let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
          let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
          if (head != sel.head || anchor != sel.anchor)
            newSel = state.EditorSelection.single(anchor, head);
        }
        if (!change && !newSel)
          return false;
        if (!change && typeOver && !sel.empty && newSel && newSel.main.empty)
          change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
        else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4)
          change = {
            from: sel.from,
            to: sel.to,
            insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
          };
        else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && change.insert.toString() == ".")
          change = { from: sel.from, to: sel.to, insert: state.Text.of([" "]) };
        if (change) {
          let startState = view.state;
          if (browser.ios && view.inputState.flushIOSKey(view))
            return true;
          if (browser.android && (change.from == sel.from && change.to == sel.to && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)))
            return true;
          let text = change.insert.toString();
          if (view.state.facet(inputHandler).some((h) => h(view, change.from, change.to, text)))
            return true;
          if (view.inputState.composing >= 0)
            view.inputState.composing++;
          let tr;
          if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {
            let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
            let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
            tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, void 0, view.state.lineBreak) + after));
          } else {
            let changes = startState.changes(change);
            let mainSel = newSel && !startState.selection.main.eq(newSel.main) && newSel.main.to <= changes.newLength ? newSel.main : void 0;
            if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {
              let replaced = view.state.sliceDoc(change.from, change.to);
              let compositionRange = compositionSurroundingNode(view) || view.state.doc.lineAt(sel.head);
              let offset = sel.to - change.to, size = sel.to - sel.from;
              tr = startState.changeByRange((range) => {
                if (range.from == sel.from && range.to == sel.to)
                  return { changes, range: mainSel || range.map(changes) };
                let to = range.to - offset, from = to - replaced.length;
                if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced || compositionRange && range.to >= compositionRange.from && range.from <= compositionRange.to)
                  return { range };
                let rangeChanges = startState.changes({ from, to, insert: change.insert }), selOff = range.to - sel.to;
                return {
                  changes: rangeChanges,
                  range: !mainSel ? range.map(rangeChanges) : state.EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
                };
              });
            } else {
              tr = {
                changes,
                selection: mainSel && startState.selection.replaceRange(mainSel)
              };
            }
          }
          let userEvent = "input.type";
          if (view.composing) {
            userEvent += ".compose";
            if (view.inputState.compositionFirstChange) {
              userEvent += ".start";
              view.inputState.compositionFirstChange = false;
            }
          }
          view.dispatch(tr, { scrollIntoView: true, userEvent });
          return true;
        } else if (newSel && !newSel.main.eq(sel)) {
          let scrollIntoView2 = false, userEvent = "select";
          if (view.inputState.lastSelectionTime > Date.now() - 50) {
            if (view.inputState.lastSelectionOrigin == "select")
              scrollIntoView2 = true;
            userEvent = view.inputState.lastSelectionOrigin;
          }
          view.dispatch({ selection: newSel, scrollIntoView: scrollIntoView2, userEvent });
          return true;
        } else {
          return false;
        }
      }
      function findDiff(a, b, preferredPos, preferredSide) {
        let minLen = Math.min(a.length, b.length);
        let from = 0;
        while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))
          from++;
        if (from == minLen && a.length == b.length)
          return null;
        let toA = a.length, toB = b.length;
        while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
          toA--;
          toB--;
        }
        if (preferredSide == "end") {
          let adjust = Math.max(0, from - Math.min(toA, toB));
          preferredPos -= toA + adjust - from;
        }
        if (toA < from && a.length < b.length) {
          let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
          from -= move;
          toB = from + (toB - toA);
          toA = from;
        } else if (toB < from) {
          let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
          from -= move;
          toA = from + (toA - toB);
          toB = from;
        }
        return { from, toA, toB };
      }
      function selectionPoints(view) {
        let result = [];
        if (view.root.activeElement != view.contentDOM)
          return result;
        let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
        if (anchorNode) {
          result.push(new DOMPoint(anchorNode, anchorOffset));
          if (focusNode != anchorNode || focusOffset != anchorOffset)
            result.push(new DOMPoint(focusNode, focusOffset));
        }
        return result;
      }
      function selectionFromPoints(points, base) {
        if (points.length == 0)
          return null;
        let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
        return anchor > -1 && head > -1 ? state.EditorSelection.single(anchor + base, head + base) : null;
      }
      var EditorView2 = class {
        constructor(config = {}) {
          this.plugins = [];
          this.pluginMap = /* @__PURE__ */ new Map();
          this.editorAttrs = {};
          this.contentAttrs = {};
          this.bidiCache = [];
          this.destroyed = false;
          this.updateState = 2;
          this.measureScheduled = -1;
          this.measureRequests = [];
          this.contentDOM = document.createElement("div");
          this.scrollDOM = document.createElement("div");
          this.scrollDOM.tabIndex = -1;
          this.scrollDOM.className = "cm-scroller";
          this.scrollDOM.appendChild(this.contentDOM);
          this.announceDOM = document.createElement("div");
          this.announceDOM.style.cssText = "position: absolute; top: -10000px";
          this.announceDOM.setAttribute("aria-live", "polite");
          this.dom = document.createElement("div");
          this.dom.appendChild(this.announceDOM);
          this.dom.appendChild(this.scrollDOM);
          this._dispatch = config.dispatch || ((tr) => this.update([tr]));
          this.dispatch = this.dispatch.bind(this);
          this._root = config.root || getRoot(config.parent) || document;
          this.viewState = new ViewState(config.state || state.EditorState.create(config));
          this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
          for (let plugin2 of this.plugins)
            plugin2.update(this);
          this.observer = new DOMObserver(this, (from, to, typeOver) => {
            return applyDOMChange(this, from, to, typeOver);
          }, (event) => {
            this.inputState.runScrollHandlers(this, event);
            if (this.observer.intersecting)
              this.measure();
          });
          this.inputState = new InputState(this);
          this.inputState.ensureHandlers(this, this.plugins);
          this.docView = new DocView(this);
          this.mountStyles();
          this.updateAttrs();
          this.updateState = 0;
          this.requestMeasure();
          if (config.parent)
            config.parent.appendChild(this.dom);
        }
        get state() {
          return this.viewState.state;
        }
        get viewport() {
          return this.viewState.viewport;
        }
        get visibleRanges() {
          return this.viewState.visibleRanges;
        }
        get inView() {
          return this.viewState.inView;
        }
        get composing() {
          return this.inputState.composing > 0;
        }
        get compositionStarted() {
          return this.inputState.composing >= 0;
        }
        get root() {
          return this._root;
        }
        dispatch(...input) {
          this._dispatch(input.length == 1 && input[0] instanceof state.Transaction ? input[0] : this.state.update(...input));
        }
        update(transactions) {
          if (this.updateState != 0)
            throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
          let redrawn = false, attrsChanged = false, update;
          let state$1 = this.state;
          for (let tr of transactions) {
            if (tr.startState != state$1)
              throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
            state$1 = tr.state;
          }
          if (this.destroyed) {
            this.viewState.state = state$1;
            return;
          }
          this.observer.clear();
          if (state$1.facet(state.EditorState.phrases) != this.state.facet(state.EditorState.phrases))
            return this.setState(state$1);
          update = ViewUpdate.create(this, state$1, transactions);
          let scrollTarget = this.viewState.scrollTarget;
          try {
            this.updateState = 2;
            for (let tr of transactions) {
              if (scrollTarget)
                scrollTarget = scrollTarget.map(tr.changes);
              if (tr.scrollIntoView) {
                let { main } = tr.state.selection;
                scrollTarget = new ScrollTarget(main.empty ? main : state.EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
              }
              for (let e of tr.effects)
                if (e.is(scrollIntoView))
                  scrollTarget = e.value;
            }
            this.viewState.update(update, scrollTarget);
            this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
            if (!update.empty) {
              this.updatePlugins(update);
              this.inputState.update(update);
            }
            redrawn = this.docView.update(update);
            if (this.state.facet(styleModule) != this.styleModules)
              this.mountStyles();
            attrsChanged = this.updateAttrs();
            this.showAnnouncements(transactions);
            this.docView.updateSelection(redrawn, transactions.some((tr) => tr.isUserEvent("select.pointer")));
          } finally {
            this.updateState = 0;
          }
          if (update.startState.facet(theme) != update.state.facet(theme))
            this.viewState.mustMeasureContent = true;
          if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
            this.requestMeasure();
          if (!update.empty)
            for (let listener of this.state.facet(updateListener))
              listener(update);
        }
        setState(newState) {
          if (this.updateState != 0)
            throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
          if (this.destroyed) {
            this.viewState.state = newState;
            return;
          }
          this.updateState = 2;
          let hadFocus = this.hasFocus;
          try {
            for (let plugin2 of this.plugins)
              plugin2.destroy(this);
            this.viewState = new ViewState(newState);
            this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
            this.pluginMap.clear();
            for (let plugin2 of this.plugins)
              plugin2.update(this);
            this.docView = new DocView(this);
            this.inputState.ensureHandlers(this, this.plugins);
            this.mountStyles();
            this.updateAttrs();
            this.bidiCache = [];
          } finally {
            this.updateState = 0;
          }
          if (hadFocus)
            this.focus();
          this.requestMeasure();
        }
        updatePlugins(update) {
          let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
          if (prevSpecs != specs) {
            let newPlugins = [];
            for (let spec of specs) {
              let found = prevSpecs.indexOf(spec);
              if (found < 0) {
                newPlugins.push(new PluginInstance(spec));
              } else {
                let plugin2 = this.plugins[found];
                plugin2.mustUpdate = update;
                newPlugins.push(plugin2);
              }
            }
            for (let plugin2 of this.plugins)
              if (plugin2.mustUpdate != update)
                plugin2.destroy(this);
            this.plugins = newPlugins;
            this.pluginMap.clear();
            this.inputState.ensureHandlers(this, this.plugins);
          } else {
            for (let p of this.plugins)
              p.mustUpdate = update;
          }
          for (let i = 0; i < this.plugins.length; i++)
            this.plugins[i].update(this);
        }
        measure(flush = true) {
          if (this.destroyed)
            return;
          if (this.measureScheduled > -1)
            cancelAnimationFrame(this.measureScheduled);
          this.measureScheduled = 0;
          if (flush)
            this.observer.forceFlush();
          let updated = null;
          let { scrollHeight, scrollTop, clientHeight } = this.scrollDOM;
          let refHeight = scrollTop > scrollHeight - clientHeight - 4 ? scrollHeight : scrollTop;
          try {
            for (let i = 0; ; i++) {
              this.updateState = 1;
              let oldViewport = this.viewport;
              let refBlock = this.viewState.lineBlockAtHeight(refHeight);
              let changed = this.viewState.measure(this);
              if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
                break;
              if (i > 5) {
                console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
                break;
              }
              let measuring = [];
              if (!(changed & 4))
                [this.measureRequests, measuring] = [measuring, this.measureRequests];
              let measured = measuring.map((m) => {
                try {
                  return m.read(this);
                } catch (e) {
                  logException(this.state, e);
                  return BadMeasure;
                }
              });
              let update = ViewUpdate.create(this, this.state, []), redrawn = false, scrolled = false;
              update.flags |= changed;
              if (!updated)
                updated = update;
              else
                updated.flags |= changed;
              this.updateState = 2;
              if (!update.empty) {
                this.updatePlugins(update);
                this.inputState.update(update);
                this.updateAttrs();
                redrawn = this.docView.update(update);
              }
              for (let i2 = 0; i2 < measuring.length; i2++)
                if (measured[i2] != BadMeasure) {
                  try {
                    let m = measuring[i2];
                    if (m.write)
                      m.write(measured[i2], this);
                  } catch (e) {
                    logException(this.state, e);
                  }
                }
              if (this.viewState.scrollTarget) {
                this.docView.scrollIntoView(this.viewState.scrollTarget);
                this.viewState.scrollTarget = null;
                scrolled = true;
              } else {
                let diff = this.viewState.lineBlockAt(refBlock.from).top - refBlock.top;
                if (diff > 1 || diff < -1) {
                  this.scrollDOM.scrollTop += diff;
                  scrolled = true;
                }
              }
              if (redrawn)
                this.docView.updateSelection(true);
              if (this.viewport.from == oldViewport.from && this.viewport.to == oldViewport.to && !scrolled && this.measureRequests.length == 0)
                break;
            }
          } finally {
            this.updateState = 0;
            this.measureScheduled = -1;
          }
          if (updated && !updated.empty)
            for (let listener of this.state.facet(updateListener))
              listener(updated);
        }
        get themeClasses() {
          return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
        }
        updateAttrs() {
          let editorAttrs = attrsFromFacet(this, editorAttributes, {
            class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
          });
          let contentAttrs = {
            spellcheck: "false",
            autocorrect: "off",
            autocapitalize: "off",
            translate: "no",
            contenteditable: !this.state.facet(editable) ? "false" : "true",
            class: "cm-content",
            style: `${browser.tabSize}: ${this.state.tabSize}`,
            role: "textbox",
            "aria-multiline": "true"
          };
          if (this.state.readOnly)
            contentAttrs["aria-readonly"] = "true";
          attrsFromFacet(this, contentAttributes, contentAttrs);
          let changed = this.observer.ignore(() => {
            let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
            let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
            return changedContent || changedEditor;
          });
          this.editorAttrs = editorAttrs;
          this.contentAttrs = contentAttrs;
          return changed;
        }
        showAnnouncements(trs) {
          let first = true;
          for (let tr of trs)
            for (let effect of tr.effects)
              if (effect.is(EditorView2.announce)) {
                if (first)
                  this.announceDOM.textContent = "";
                first = false;
                let div = this.announceDOM.appendChild(document.createElement("div"));
                div.textContent = effect.value;
              }
        }
        mountStyles() {
          this.styleModules = this.state.facet(styleModule);
          styleMod.StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse());
        }
        readMeasured() {
          if (this.updateState == 2)
            throw new Error("Reading the editor layout isn't allowed during an update");
          if (this.updateState == 0 && this.measureScheduled > -1)
            this.measure(false);
        }
        requestMeasure(request) {
          if (this.measureScheduled < 0)
            this.measureScheduled = requestAnimationFrame(() => this.measure());
          if (request) {
            if (request.key != null)
              for (let i = 0; i < this.measureRequests.length; i++) {
                if (this.measureRequests[i].key === request.key) {
                  this.measureRequests[i] = request;
                  return;
                }
              }
            this.measureRequests.push(request);
          }
        }
        plugin(plugin2) {
          let known = this.pluginMap.get(plugin2);
          if (known === void 0 || known && known.spec != plugin2)
            this.pluginMap.set(plugin2, known = this.plugins.find((p) => p.spec == plugin2) || null);
          return known && known.update(this).value;
        }
        get documentTop() {
          return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
        }
        get documentPadding() {
          return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
        }
        elementAtHeight(height) {
          this.readMeasured();
          return this.viewState.elementAtHeight(height);
        }
        lineBlockAtHeight(height) {
          this.readMeasured();
          return this.viewState.lineBlockAtHeight(height);
        }
        get viewportLineBlocks() {
          return this.viewState.viewportLines;
        }
        lineBlockAt(pos) {
          return this.viewState.lineBlockAt(pos);
        }
        get contentHeight() {
          return this.viewState.contentHeight;
        }
        moveByChar(start, forward, by) {
          return skipAtoms(this, start, moveByChar(this, start, forward, by));
        }
        moveByGroup(start, forward) {
          return skipAtoms(this, start, moveByChar(this, start, forward, (initial) => byGroup(this, start.head, initial)));
        }
        moveToLineBoundary(start, forward, includeWrap = true) {
          return moveToLineBoundary(this, start, forward, includeWrap);
        }
        moveVertically(start, forward, distance) {
          return skipAtoms(this, start, moveVertically(this, start, forward, distance));
        }
        domAtPos(pos) {
          return this.docView.domAtPos(pos);
        }
        posAtDOM(node, offset = 0) {
          return this.docView.posFromDOM(node, offset);
        }
        posAtCoords(coords, precise = true) {
          this.readMeasured();
          return posAtCoords(this, coords, precise);
        }
        coordsAtPos(pos, side = 1) {
          this.readMeasured();
          let rect = this.docView.coordsAt(pos, side);
          if (!rect || rect.left == rect.right)
            return rect;
          let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
          let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
          return flattenRect(rect, span.dir == exports.Direction.LTR == side > 0);
        }
        get defaultCharacterWidth() {
          return this.viewState.heightOracle.charWidth;
        }
        get defaultLineHeight() {
          return this.viewState.heightOracle.lineHeight;
        }
        get textDirection() {
          return this.viewState.defaultTextDirection;
        }
        textDirectionAt(pos) {
          let perLine = this.state.facet(perLineTextDirection);
          if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
            return this.textDirection;
          this.readMeasured();
          return this.docView.textDirectionAt(pos);
        }
        get lineWrapping() {
          return this.viewState.heightOracle.lineWrapping;
        }
        bidiSpans(line) {
          if (line.length > MaxBidiLine)
            return trivialOrder(line.length);
          let dir = this.textDirectionAt(line.from);
          for (let entry of this.bidiCache)
            if (entry.from == line.from && entry.dir == dir)
              return entry.order;
          let order = computeOrder(line.text, dir);
          this.bidiCache.push(new CachedOrder(line.from, line.to, dir, order));
          return order;
        }
        get hasFocus() {
          var _a;
          return (document.hasFocus() || browser.safari && ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
        }
        focus() {
          this.observer.ignore(() => {
            focusPreventScroll(this.contentDOM);
            this.docView.updateSelection();
          });
        }
        setRoot(root) {
          if (this._root != root) {
            this._root = root;
            this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView);
            this.mountStyles();
          }
        }
        destroy() {
          for (let plugin2 of this.plugins)
            plugin2.destroy(this);
          this.plugins = [];
          this.inputState.destroy();
          this.dom.remove();
          this.observer.destroy();
          if (this.measureScheduled > -1)
            cancelAnimationFrame(this.measureScheduled);
          this.destroyed = true;
        }
        static scrollIntoView(pos, options = {}) {
          return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? state.EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
        }
        static domEventHandlers(handlers2) {
          return ViewPlugin.define(() => ({}), { eventHandlers: handlers2 });
        }
        static theme(spec, options) {
          let prefix = styleMod.StyleModule.newName();
          let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
          if (options && options.dark)
            result.push(darkTheme.of(true));
          return result;
        }
        static baseTheme(spec) {
          return state.Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
        }
        static findFromDOM(dom) {
          var _a;
          let content = dom.querySelector(".cm-content");
          let cView = content && ContentView.get(content) || ContentView.get(dom);
          return ((_a = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a === void 0 ? void 0 : _a.view) || null;
        }
      };
      EditorView2.styleModule = styleModule;
      EditorView2.inputHandler = inputHandler;
      EditorView2.perLineTextDirection = perLineTextDirection;
      EditorView2.exceptionSink = exceptionSink;
      EditorView2.updateListener = updateListener;
      EditorView2.editable = editable;
      EditorView2.mouseSelectionStyle = mouseSelectionStyle;
      EditorView2.dragMovesSelection = dragMovesSelection$1;
      EditorView2.clickAddsSelectionRange = clickAddsSelectionRange;
      EditorView2.decorations = decorations;
      EditorView2.atomicRanges = atomicRanges;
      EditorView2.scrollMargins = scrollMargins;
      EditorView2.darkTheme = darkTheme;
      EditorView2.contentAttributes = contentAttributes;
      EditorView2.editorAttributes = editorAttributes;
      EditorView2.lineWrapping = EditorView2.contentAttributes.of({ "class": "cm-lineWrapping" });
      EditorView2.announce = state.StateEffect.define();
      var MaxBidiLine = 4096;
      var BadMeasure = {};
      var CachedOrder = class {
        constructor(from, to, dir, order) {
          this.from = from;
          this.to = to;
          this.dir = dir;
          this.order = order;
        }
        static update(cache, changes) {
          if (changes.empty)
            return cache;
          let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : exports.Direction.LTR;
          for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {
            let entry = cache[i];
            if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
              result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.order));
          }
          return result;
        }
      };
      function attrsFromFacet(view, facet, base) {
        for (let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {
          let source = sources[i], value = typeof source == "function" ? source(view) : source;
          if (value)
            combineAttrs(value, base);
        }
        return base;
      }
      var currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
      function normalizeKeyName(name, platform) {
        const parts = name.split(/-(?!$)/);
        let result = parts[parts.length - 1];
        if (result == "Space")
          result = " ";
        let alt, ctrl, shift, meta;
        for (let i = 0; i < parts.length - 1; ++i) {
          const mod = parts[i];
          if (/^(cmd|meta|m)$/i.test(mod))
            meta = true;
          else if (/^a(lt)?$/i.test(mod))
            alt = true;
          else if (/^(c|ctrl|control)$/i.test(mod))
            ctrl = true;
          else if (/^s(hift)?$/i.test(mod))
            shift = true;
          else if (/^mod$/i.test(mod)) {
            if (platform == "mac")
              meta = true;
            else
              ctrl = true;
          } else
            throw new Error("Unrecognized modifier name: " + mod);
        }
        if (alt)
          result = "Alt-" + result;
        if (ctrl)
          result = "Ctrl-" + result;
        if (meta)
          result = "Meta-" + result;
        if (shift)
          result = "Shift-" + result;
        return result;
      }
      function modifiers(name, event, shift) {
        if (event.altKey)
          name = "Alt-" + name;
        if (event.ctrlKey)
          name = "Ctrl-" + name;
        if (event.metaKey)
          name = "Meta-" + name;
        if (shift !== false && event.shiftKey)
          name = "Shift-" + name;
        return name;
      }
      var handleKeyEvents = state.Prec.default(EditorView2.domEventHandlers({
        keydown(event, view) {
          return runHandlers(getKeymap(view.state), event, view, "editor");
        }
      }));
      var keymap = state.Facet.define({ enables: handleKeyEvents });
      var Keymaps = /* @__PURE__ */ new WeakMap();
      function getKeymap(state2) {
        let bindings = state2.facet(keymap);
        let map = Keymaps.get(bindings);
        if (!map)
          Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));
        return map;
      }
      function runScopeHandlers(view, event, scope) {
        return runHandlers(getKeymap(view.state), event, view, scope);
      }
      var storedPrefix = null;
      var PrefixTimeout = 4e3;
      function buildKeymap(bindings, platform = currentPlatform) {
        let bound = /* @__PURE__ */ Object.create(null);
        let isPrefix = /* @__PURE__ */ Object.create(null);
        let checkPrefix = (name, is) => {
          let current = isPrefix[name];
          if (current == null)
            isPrefix[name] = is;
          else if (current != is)
            throw new Error("Key binding " + name + " is used both as a regular binding and as a multi-stroke prefix");
        };
        let add = (scope, key, command, preventDefault) => {
          let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
          let parts = key.split(/ (?!$)/).map((k) => normalizeKeyName(k, platform));
          for (let i = 1; i < parts.length; i++) {
            let prefix = parts.slice(0, i).join(" ");
            checkPrefix(prefix, true);
            if (!scopeObj[prefix])
              scopeObj[prefix] = {
                preventDefault: true,
                commands: [(view) => {
                  let ourObj = storedPrefix = { view, prefix, scope };
                  setTimeout(() => {
                    if (storedPrefix == ourObj)
                      storedPrefix = null;
                  }, PrefixTimeout);
                  return true;
                }]
              };
          }
          let full = parts.join(" ");
          checkPrefix(full, false);
          let binding = scopeObj[full] || (scopeObj[full] = { preventDefault: false, commands: [] });
          binding.commands.push(command);
          if (preventDefault)
            binding.preventDefault = true;
        };
        for (let b of bindings) {
          let name = b[platform] || b.key;
          if (!name)
            continue;
          for (let scope of b.scope ? b.scope.split(" ") : ["editor"]) {
            add(scope, name, b.run, b.preventDefault);
            if (b.shift)
              add(scope, "Shift-" + name, b.shift, b.preventDefault);
          }
        }
        return bound;
      }
      function runHandlers(map, event, view, scope) {
        let name = w3cKeyname.keyName(event);
        let charCode = state.codePointAt(name, 0), isChar = state.codePointSize(charCode) == name.length && name != " ";
        let prefix = "", fallthrough = false;
        if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
          prefix = storedPrefix.prefix + " ";
          if (fallthrough = modifierCodes.indexOf(event.keyCode) < 0)
            storedPrefix = null;
        }
        let runFor = (binding) => {
          if (binding) {
            for (let cmd of binding.commands)
              if (cmd(view))
                return true;
            if (binding.preventDefault)
              fallthrough = true;
          }
          return false;
        };
        let scopeObj = map[scope], baseName;
        if (scopeObj) {
          if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)]))
            return true;
          if (isChar && (event.shiftKey || event.altKey || event.metaKey || charCode > 127) && (baseName = w3cKeyname.base[event.keyCode]) && baseName != name) {
            if (runFor(scopeObj[prefix + modifiers(baseName, event, true)]))
              return true;
            else if (event.shiftKey && w3cKeyname.shift[event.keyCode] != baseName && runFor(scopeObj[prefix + modifiers(w3cKeyname.shift[event.keyCode], event, false)]))
              return true;
          } else if (isChar && event.shiftKey) {
            if (runFor(scopeObj[prefix + modifiers(name, event, true)]))
              return true;
          }
        }
        return fallthrough;
      }
      var CanHidePrimary = !browser.ios;
      var selectionConfig = state.Facet.define({
        combine(configs) {
          return state.combineConfig(configs, {
            cursorBlinkRate: 1200,
            drawRangeCursor: true
          }, {
            cursorBlinkRate: (a, b) => Math.min(a, b),
            drawRangeCursor: (a, b) => a || b
          });
        }
      });
      function drawSelection(config = {}) {
        return [
          selectionConfig.of(config),
          drawSelectionPlugin,
          hideNativeSelection
        ];
      }
      var Piece = class {
        constructor(left, top, width, height, className) {
          this.left = left;
          this.top = top;
          this.width = width;
          this.height = height;
          this.className = className;
        }
        draw() {
          let elt = document.createElement("div");
          elt.className = this.className;
          this.adjust(elt);
          return elt;
        }
        adjust(elt) {
          elt.style.left = this.left + "px";
          elt.style.top = this.top + "px";
          if (this.width >= 0)
            elt.style.width = this.width + "px";
          elt.style.height = this.height + "px";
        }
        eq(p) {
          return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;
        }
      };
      var drawSelectionPlugin = ViewPlugin.fromClass(class {
        constructor(view) {
          this.view = view;
          this.rangePieces = [];
          this.cursors = [];
          this.measureReq = { read: this.readPos.bind(this), write: this.drawSel.bind(this) };
          this.selectionLayer = view.scrollDOM.appendChild(document.createElement("div"));
          this.selectionLayer.className = "cm-selectionLayer";
          this.selectionLayer.setAttribute("aria-hidden", "true");
          this.cursorLayer = view.scrollDOM.appendChild(document.createElement("div"));
          this.cursorLayer.className = "cm-cursorLayer";
          this.cursorLayer.setAttribute("aria-hidden", "true");
          view.requestMeasure(this.measureReq);
          this.setBlinkRate();
        }
        setBlinkRate() {
          this.cursorLayer.style.animationDuration = this.view.state.facet(selectionConfig).cursorBlinkRate + "ms";
        }
        update(update) {
          let confChanged = update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
          if (confChanged || update.selectionSet || update.geometryChanged || update.viewportChanged)
            this.view.requestMeasure(this.measureReq);
          if (update.transactions.some((tr) => tr.scrollIntoView))
            this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
          if (confChanged)
            this.setBlinkRate();
        }
        readPos() {
          let { state: state2 } = this.view, conf = state2.facet(selectionConfig);
          let rangePieces = state2.selection.ranges.map((r) => r.empty ? [] : measureRange(this.view, r)).reduce((a, b) => a.concat(b));
          let cursors = [];
          for (let r of state2.selection.ranges) {
            let prim = r == state2.selection.main;
            if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
              let piece = measureCursor(this.view, r, prim);
              if (piece)
                cursors.push(piece);
            }
          }
          return { rangePieces, cursors };
        }
        drawSel({ rangePieces, cursors }) {
          if (rangePieces.length != this.rangePieces.length || rangePieces.some((p, i) => !p.eq(this.rangePieces[i]))) {
            this.selectionLayer.textContent = "";
            for (let p of rangePieces)
              this.selectionLayer.appendChild(p.draw());
            this.rangePieces = rangePieces;
          }
          if (cursors.length != this.cursors.length || cursors.some((c, i) => !c.eq(this.cursors[i]))) {
            let oldCursors = this.cursorLayer.children;
            if (oldCursors.length !== cursors.length) {
              this.cursorLayer.textContent = "";
              for (const c of cursors)
                this.cursorLayer.appendChild(c.draw());
            } else {
              cursors.forEach((c, idx) => c.adjust(oldCursors[idx]));
            }
            this.cursors = cursors;
          }
        }
        destroy() {
          this.selectionLayer.remove();
          this.cursorLayer.remove();
        }
      });
      var themeSpec = {
        ".cm-line": {
          "& ::selection": { backgroundColor: "transparent !important" },
          "&::selection": { backgroundColor: "transparent !important" }
        }
      };
      if (CanHidePrimary)
        themeSpec[".cm-line"].caretColor = "transparent !important";
      var hideNativeSelection = state.Prec.highest(EditorView2.theme(themeSpec));
      function getBase(view) {
        let rect = view.scrollDOM.getBoundingClientRect();
        let left = view.textDirection == exports.Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;
        return { left: left - view.scrollDOM.scrollLeft, top: rect.top - view.scrollDOM.scrollTop };
      }
      function wrappedLine(view, pos, inside2) {
        let range = state.EditorSelection.cursor(pos);
        return {
          from: Math.max(inside2.from, view.moveToLineBoundary(range, false, true).from),
          to: Math.min(inside2.to, view.moveToLineBoundary(range, true, true).from),
          type: exports.BlockType.Text
        };
      }
      function blockAt(view, pos) {
        let line = view.lineBlockAt(pos);
        if (Array.isArray(line.type))
          for (let l of line.type) {
            if (l.to > pos || l.to == pos && (l.to == line.to || l.type == exports.BlockType.Text))
              return l;
          }
        return line;
      }
      function measureRange(view, range) {
        if (range.to <= view.viewport.from || range.from >= view.viewport.to)
          return [];
        let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);
        let ltr = view.textDirection == exports.Direction.LTR;
        let content = view.contentDOM, contentRect = content.getBoundingClientRect(), base = getBase(view);
        let lineStyle = window.getComputedStyle(content.firstChild);
        let leftSide = contentRect.left + parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent));
        let rightSide = contentRect.right - parseInt(lineStyle.paddingRight);
        let startBlock = blockAt(view, from), endBlock = blockAt(view, to);
        let visualStart = startBlock.type == exports.BlockType.Text ? startBlock : null;
        let visualEnd = endBlock.type == exports.BlockType.Text ? endBlock : null;
        if (view.lineWrapping) {
          if (visualStart)
            visualStart = wrappedLine(view, from, visualStart);
          if (visualEnd)
            visualEnd = wrappedLine(view, to, visualEnd);
        }
        if (visualStart && visualEnd && visualStart.from == visualEnd.from) {
          return pieces(drawForLine(range.from, range.to, visualStart));
        } else {
          let top = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
          let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
          let between = [];
          if ((visualStart || startBlock).to < (visualEnd || endBlock).from - 1)
            between.push(piece(leftSide, top.bottom, rightSide, bottom.top));
          else if (top.bottom < bottom.top && view.elementAtHeight((top.bottom + bottom.top) / 2).type == exports.BlockType.Text)
            top.bottom = bottom.top = (top.bottom + bottom.top) / 2;
          return pieces(top).concat(between).concat(pieces(bottom));
        }
        function piece(left, top, right, bottom) {
          return new Piece(left - base.left, top - base.top - 0.01, right - left, bottom - top + 0.01, "cm-selectionBackground");
        }
        function pieces({ top, bottom, horizontal }) {
          let pieces2 = [];
          for (let i = 0; i < horizontal.length; i += 2)
            pieces2.push(piece(horizontal[i], top, horizontal[i + 1], bottom));
          return pieces2;
        }
        function drawForLine(from2, to2, line) {
          let top = 1e9, bottom = -1e9, horizontal = [];
          function addSpan(from3, fromOpen, to3, toOpen, dir) {
            let fromCoords = view.coordsAtPos(from3, from3 == line.to ? -2 : 2);
            let toCoords = view.coordsAtPos(to3, to3 == line.from ? 2 : -2);
            top = Math.min(fromCoords.top, toCoords.top, top);
            bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
            if (dir == exports.Direction.LTR)
              horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
            else
              horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
          }
          let start = from2 !== null && from2 !== void 0 ? from2 : line.from, end = to2 !== null && to2 !== void 0 ? to2 : line.to;
          for (let r of view.visibleRanges)
            if (r.to > start && r.from < end) {
              for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end); ; ) {
                let docLine = view.state.doc.lineAt(pos);
                for (let span of view.bidiSpans(docLine)) {
                  let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
                  if (spanFrom >= endPos)
                    break;
                  if (spanTo > pos)
                    addSpan(Math.max(spanFrom, pos), from2 == null && spanFrom <= start, Math.min(spanTo, endPos), to2 == null && spanTo >= end, span.dir);
                }
                pos = docLine.to + 1;
                if (pos >= endPos)
                  break;
              }
            }
          if (horizontal.length == 0)
            addSpan(start, from2 == null, end, to2 == null, view.textDirection);
          return { top, bottom, horizontal };
        }
        function drawForWidget(block, top) {
          let y = contentRect.top + (top ? block.top : block.bottom);
          return { top: y, bottom: y, horizontal: [] };
        }
      }
      function measureCursor(view, cursor, primary) {
        let pos = view.coordsAtPos(cursor.head, cursor.assoc || 1);
        if (!pos)
          return null;
        let base = getBase(view);
        return new Piece(pos.left - base.left, pos.top - base.top, -1, pos.bottom - pos.top, primary ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary");
      }
      var setDropCursorPos = state.StateEffect.define({
        map(pos, mapping) {
          return pos == null ? null : mapping.mapPos(pos);
        }
      });
      var dropCursorPos = state.StateField.define({
        create() {
          return null;
        },
        update(pos, tr) {
          if (pos != null)
            pos = tr.changes.mapPos(pos);
          return tr.effects.reduce((pos2, e) => e.is(setDropCursorPos) ? e.value : pos2, pos);
        }
      });
      var drawDropCursor = ViewPlugin.fromClass(class {
        constructor(view) {
          this.view = view;
          this.cursor = null;
          this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
        }
        update(update) {
          var _a;
          let cursorPos = update.state.field(dropCursorPos);
          if (cursorPos == null) {
            if (this.cursor != null) {
              (_a = this.cursor) === null || _a === void 0 ? void 0 : _a.remove();
              this.cursor = null;
            }
          } else {
            if (!this.cursor) {
              this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
              this.cursor.className = "cm-dropCursor";
            }
            if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged)
              this.view.requestMeasure(this.measureReq);
          }
        }
        readPos() {
          let pos = this.view.state.field(dropCursorPos);
          let rect = pos != null && this.view.coordsAtPos(pos);
          if (!rect)
            return null;
          let outer = this.view.scrollDOM.getBoundingClientRect();
          return {
            left: rect.left - outer.left + this.view.scrollDOM.scrollLeft,
            top: rect.top - outer.top + this.view.scrollDOM.scrollTop,
            height: rect.bottom - rect.top
          };
        }
        drawCursor(pos) {
          if (this.cursor) {
            if (pos) {
              this.cursor.style.left = pos.left + "px";
              this.cursor.style.top = pos.top + "px";
              this.cursor.style.height = pos.height + "px";
            } else {
              this.cursor.style.left = "-100000px";
            }
          }
        }
        destroy() {
          if (this.cursor)
            this.cursor.remove();
        }
        setDropPos(pos) {
          if (this.view.state.field(dropCursorPos) != pos)
            this.view.dispatch({ effects: setDropCursorPos.of(pos) });
        }
      }, {
        eventHandlers: {
          dragover(event) {
            this.setDropPos(this.view.posAtCoords({ x: event.clientX, y: event.clientY }));
          },
          dragleave(event) {
            if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget))
              this.setDropPos(null);
          },
          dragend() {
            this.setDropPos(null);
          },
          drop() {
            this.setDropPos(null);
          }
        }
      });
      function dropCursor() {
        return [dropCursorPos, drawDropCursor];
      }
      function iterMatches(doc2, re, from, to, f) {
        re.lastIndex = 0;
        for (let cursor = doc2.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length) {
          if (!cursor.lineBreak)
            while (m = re.exec(cursor.value))
              f(pos + m.index, m);
        }
      }
      function matchRanges(view, maxLength) {
        let visible = view.visibleRanges;
        if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to)
          return visible;
        let result = [];
        for (let { from, to } of visible) {
          from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);
          to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);
          if (result.length && result[result.length - 1].to >= from)
            result[result.length - 1].to = to;
          else
            result.push({ from, to });
        }
        return result;
      }
      var MatchDecorator = class {
        constructor(config) {
          const { regexp, decoration, decorate, boundary, maxLength = 1e3 } = config;
          if (!regexp.global)
            throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
          this.regexp = regexp;
          if (decorate) {
            this.addMatch = (match, view, from, add) => decorate(add, from, from + match[0].length, match, view);
          } else if (decoration) {
            let getDeco = typeof decoration == "function" ? decoration : () => decoration;
            this.addMatch = (match, view, from, add) => add(from, from + match[0].length, getDeco(match, view, from));
          } else {
            throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
          }
          this.boundary = boundary;
          this.maxLength = maxLength;
        }
        createDeco(view) {
          let build = new state.RangeSetBuilder(), add = build.add.bind(build);
          for (let { from, to } of matchRanges(view, this.maxLength))
            iterMatches(view.state.doc, this.regexp, from, to, (from2, m) => this.addMatch(m, view, from2, add));
          return build.finish();
        }
        updateDeco(update, deco) {
          let changeFrom = 1e9, changeTo = -1;
          if (update.docChanged)
            update.changes.iterChanges((_f, _t, from, to) => {
              if (to > update.view.viewport.from && from < update.view.viewport.to) {
                changeFrom = Math.min(from, changeFrom);
                changeTo = Math.max(to, changeTo);
              }
            });
          if (update.viewportChanged || changeTo - changeFrom > 1e3)
            return this.createDeco(update.view);
          if (changeTo > -1)
            return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
          return deco;
        }
        updateRange(view, deco, updateFrom, updateTo) {
          for (let r of view.visibleRanges) {
            let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);
            if (to > from) {
              let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;
              let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);
              if (this.boundary) {
                for (; from > fromLine.from; from--)
                  if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
                    start = from;
                    break;
                  }
                for (; to < toLine.to; to++)
                  if (this.boundary.test(toLine.text[to - toLine.from])) {
                    end = to;
                    break;
                  }
              }
              let ranges = [], m;
              let add = (from2, to2, deco2) => ranges.push(deco2.range(from2, to2));
              if (fromLine == toLine) {
                this.regexp.lastIndex = start - fromLine.from;
                while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from)
                  this.addMatch(m, view, m.index + fromLine.from, add);
              } else {
                iterMatches(view.state.doc, this.regexp, start, end, (from2, m2) => this.addMatch(m2, view, from2, add));
              }
              deco = deco.update({ filterFrom: start, filterTo: end, filter: (from2, to2) => from2 < start || to2 > end, add: ranges });
            }
          }
          return deco;
        }
      };
      var UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
      var Specials = new RegExp("[\0-\b\n-\x7F-\x9F\xAD\u061C\u200B\u200E\u200F\u2028\u2029\u202D\u202E\u2066\u2067\u2069\uFEFF\uFFF9-\uFFFC]", UnicodeRegexpSupport);
      var Names = {
        0: "null",
        7: "bell",
        8: "backspace",
        10: "newline",
        11: "vertical tab",
        13: "carriage return",
        27: "escape",
        8203: "zero width space",
        8204: "zero width non-joiner",
        8205: "zero width joiner",
        8206: "left-to-right mark",
        8207: "right-to-left mark",
        8232: "line separator",
        8237: "left-to-right override",
        8238: "right-to-left override",
        8294: "left-to-right isolate",
        8295: "right-to-left isolate",
        8297: "pop directional isolate",
        8233: "paragraph separator",
        65279: "zero width no-break space",
        65532: "object replacement"
      };
      var _supportsTabSize = null;
      function supportsTabSize() {
        var _a;
        if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
          let styles = document.body.style;
          _supportsTabSize = ((_a = styles.tabSize) !== null && _a !== void 0 ? _a : styles.MozTabSize) != null;
        }
        return _supportsTabSize || false;
      }
      var specialCharConfig = state.Facet.define({
        combine(configs) {
          let config = state.combineConfig(configs, {
            render: null,
            specialChars: Specials,
            addSpecialChars: null
          });
          if (config.replaceTabs = !supportsTabSize())
            config.specialChars = new RegExp("	|" + config.specialChars.source, UnicodeRegexpSupport);
          if (config.addSpecialChars)
            config.specialChars = new RegExp(config.specialChars.source + "|" + config.addSpecialChars.source, UnicodeRegexpSupport);
          return config;
        }
      });
      function highlightSpecialChars(config = {}) {
        return [specialCharConfig.of(config), specialCharPlugin()];
      }
      var _plugin = null;
      function specialCharPlugin() {
        return _plugin || (_plugin = ViewPlugin.fromClass(class {
          constructor(view) {
            this.view = view;
            this.decorations = Decoration.none;
            this.decorationCache = /* @__PURE__ */ Object.create(null);
            this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
            this.decorations = this.decorator.createDeco(view);
          }
          makeDecorator(conf) {
            return new MatchDecorator({
              regexp: conf.specialChars,
              decoration: (m, view, pos) => {
                let { doc: doc2 } = view.state;
                let code = state.codePointAt(m[0], 0);
                if (code == 9) {
                  let line = doc2.lineAt(pos);
                  let size = view.state.tabSize, col = state.countColumn(line.text, size, pos - line.from);
                  return Decoration.replace({ widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth) });
                }
                return this.decorationCache[code] || (this.decorationCache[code] = Decoration.replace({ widget: new SpecialCharWidget(conf, code) }));
              },
              boundary: conf.replaceTabs ? void 0 : /[^]/
            });
          }
          update(update) {
            let conf = update.state.facet(specialCharConfig);
            if (update.startState.facet(specialCharConfig) != conf) {
              this.decorator = this.makeDecorator(conf);
              this.decorations = this.decorator.createDeco(update.view);
            } else {
              this.decorations = this.decorator.updateDeco(update, this.decorations);
            }
          }
        }, {
          decorations: (v) => v.decorations
        }));
      }
      var DefaultPlaceholder = "\u2022";
      function placeholder$1(code) {
        if (code >= 32)
          return DefaultPlaceholder;
        if (code == 10)
          return "\u2424";
        return String.fromCharCode(9216 + code);
      }
      var SpecialCharWidget = class extends WidgetType {
        constructor(options, code) {
          super();
          this.options = options;
          this.code = code;
        }
        eq(other) {
          return other.code == this.code;
        }
        toDOM(view) {
          let ph = placeholder$1(this.code);
          let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
          let custom = this.options.render && this.options.render(this.code, desc, ph);
          if (custom)
            return custom;
          let span = document.createElement("span");
          span.textContent = ph;
          span.title = desc;
          span.setAttribute("aria-label", desc);
          span.className = "cm-specialChar";
          return span;
        }
        ignoreEvent() {
          return false;
        }
      };
      var TabWidget = class extends WidgetType {
        constructor(width) {
          super();
          this.width = width;
        }
        eq(other) {
          return other.width == this.width;
        }
        toDOM() {
          let span = document.createElement("span");
          span.textContent = "	";
          span.className = "cm-tab";
          span.style.width = this.width + "px";
          return span;
        }
        ignoreEvent() {
          return false;
        }
      };
      var plugin = ViewPlugin.fromClass(class {
        constructor() {
          this.height = 1e3;
          this.attrs = { style: "padding-bottom: 1000px" };
        }
        update(update) {
          let height = update.view.viewState.editorHeight - update.view.defaultLineHeight;
          if (height != this.height) {
            this.height = height;
            this.attrs = { style: `padding-bottom: ${height}px` };
          }
        }
      });
      function scrollPastEnd() {
        return [plugin, contentAttributes.of((view) => {
          var _a;
          return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.attrs) || null;
        })];
      }
      function highlightActiveLine() {
        return activeLineHighlighter;
      }
      var lineDeco = Decoration.line({ class: "cm-activeLine" });
      var activeLineHighlighter = ViewPlugin.fromClass(class {
        constructor(view) {
          this.decorations = this.getDeco(view);
        }
        update(update) {
          if (update.docChanged || update.selectionSet)
            this.decorations = this.getDeco(update.view);
        }
        getDeco(view) {
          let lastLineStart = -1, deco = [];
          for (let r of view.state.selection.ranges) {
            if (!r.empty)
              return Decoration.none;
            let line = view.lineBlockAt(r.head);
            if (line.from > lastLineStart) {
              deco.push(lineDeco.range(line.from));
              lastLineStart = line.from;
            }
          }
          return Decoration.set(deco);
        }
      }, {
        decorations: (v) => v.decorations
      });
      var Placeholder = class extends WidgetType {
        constructor(content) {
          super();
          this.content = content;
        }
        toDOM() {
          let wrap = document.createElement("span");
          wrap.className = "cm-placeholder";
          wrap.style.pointerEvents = "none";
          wrap.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : this.content);
          if (typeof this.content == "string")
            wrap.setAttribute("aria-label", "placeholder " + this.content);
          else
            wrap.setAttribute("aria-hidden", "true");
          return wrap;
        }
        ignoreEvent() {
          return false;
        }
      };
      function placeholder(content) {
        return ViewPlugin.fromClass(class {
          constructor(view) {
            this.view = view;
            this.placeholder = Decoration.set([Decoration.widget({ widget: new Placeholder(content), side: 1 }).range(0)]);
          }
          get decorations() {
            return this.view.state.doc.length ? Decoration.none : this.placeholder;
          }
        }, { decorations: (v) => v.decorations });
      }
      var MaxOff = 2e3;
      function rectangleFor(state$1, a, b) {
        let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);
        let ranges = [];
        if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {
          let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);
          for (let i = startLine; i <= endLine; i++) {
            let line = state$1.doc.line(i);
            if (line.length <= endOff)
              ranges.push(state.EditorSelection.range(line.from + startOff, line.to + endOff));
          }
        } else {
          let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);
          for (let i = startLine; i <= endLine; i++) {
            let line = state$1.doc.line(i);
            let start = state.findColumn(line.text, startCol, state$1.tabSize, true);
            if (start > -1) {
              let end = state.findColumn(line.text, endCol, state$1.tabSize);
              ranges.push(state.EditorSelection.range(line.from + start, line.from + end));
            }
          }
        }
        return ranges;
      }
      function absoluteColumn(view, x) {
        let ref = view.coordsAtPos(view.viewport.from);
        return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;
      }
      function getPos(view, event) {
        let offset = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
        let line = view.state.doc.lineAt(offset), off = offset - line.from;
        let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : state.countColumn(line.text, view.state.tabSize, offset - line.from);
        return { line: line.number, col, off };
      }
      function rectangleSelectionStyle(view, event) {
        let start = getPos(view, event), startSel = view.state.selection;
        if (!start)
          return null;
        return {
          update(update) {
            if (update.docChanged) {
              let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);
              let newLine = update.state.doc.lineAt(newStart);
              start = { line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length) };
              startSel = startSel.map(update.changes);
            }
          },
          get(event2, _extend, multiple) {
            let cur = getPos(view, event2);
            if (!cur)
              return startSel;
            let ranges = rectangleFor(view.state, start, cur);
            if (!ranges.length)
              return startSel;
            if (multiple)
              return state.EditorSelection.create(ranges.concat(startSel.ranges));
            else
              return state.EditorSelection.create(ranges);
          }
        };
      }
      function rectangularSelection(options) {
        let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || ((e) => e.altKey && e.button == 0);
        return EditorView2.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);
      }
      var keys = {
        Alt: [18, (e) => e.altKey],
        Control: [17, (e) => e.ctrlKey],
        Shift: [16, (e) => e.shiftKey],
        Meta: [91, (e) => e.metaKey]
      };
      var showCrosshair = { style: "cursor: crosshair" };
      function crosshairCursor(options = {}) {
        let [code, getter] = keys[options.key || "Alt"];
        let plugin2 = ViewPlugin.fromClass(class {
          constructor(view) {
            this.view = view;
            this.isDown = false;
          }
          set(isDown) {
            if (this.isDown != isDown) {
              this.isDown = isDown;
              this.view.update([]);
            }
          }
        }, {
          eventHandlers: {
            keydown(e) {
              this.set(e.keyCode == code || getter(e));
            },
            keyup(e) {
              if (e.keyCode == code || !getter(e))
                this.set(false);
            }
          }
        });
        return [
          plugin2,
          EditorView2.contentAttributes.of((view) => {
            var _a;
            return ((_a = view.plugin(plugin2)) === null || _a === void 0 ? void 0 : _a.isDown) ? showCrosshair : null;
          })
        ];
      }
      var Outside = "-10000px";
      var TooltipViewManager = class {
        constructor(view, facet, createTooltipView) {
          this.facet = facet;
          this.createTooltipView = createTooltipView;
          this.input = view.state.facet(facet);
          this.tooltips = this.input.filter((t) => t);
          this.tooltipViews = this.tooltips.map(createTooltipView);
        }
        update(update) {
          let input = update.state.facet(this.facet);
          let tooltips2 = input.filter((x) => x);
          if (input === this.input) {
            for (let t of this.tooltipViews)
              if (t.update)
                t.update(update);
            return false;
          }
          let tooltipViews = [];
          for (let i = 0; i < tooltips2.length; i++) {
            let tip = tooltips2[i], known = -1;
            if (!tip)
              continue;
            for (let i2 = 0; i2 < this.tooltips.length; i2++) {
              let other = this.tooltips[i2];
              if (other && other.create == tip.create)
                known = i2;
            }
            if (known < 0) {
              tooltipViews[i] = this.createTooltipView(tip);
            } else {
              let tooltipView = tooltipViews[i] = this.tooltipViews[known];
              if (tooltipView.update)
                tooltipView.update(update);
            }
          }
          for (let t of this.tooltipViews)
            if (tooltipViews.indexOf(t) < 0)
              t.dom.remove();
          this.input = input;
          this.tooltips = tooltips2;
          this.tooltipViews = tooltipViews;
          return true;
        }
      };
      function tooltips(config = {}) {
        return tooltipConfig.of(config);
      }
      function windowSpace() {
        return { top: 0, left: 0, bottom: innerHeight, right: innerWidth };
      }
      var tooltipConfig = state.Facet.define({
        combine: (values) => {
          var _a, _b, _c;
          return {
            position: browser.ios ? "absolute" : ((_a = values.find((conf) => conf.position)) === null || _a === void 0 ? void 0 : _a.position) || "fixed",
            parent: ((_b = values.find((conf) => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
            tooltipSpace: ((_c = values.find((conf) => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace
          };
        }
      });
      var tooltipPlugin = ViewPlugin.fromClass(class {
        constructor(view) {
          var _a;
          this.view = view;
          this.inView = true;
          this.lastTransaction = 0;
          this.measureTimeout = -1;
          let config = view.state.facet(tooltipConfig);
          this.position = config.position;
          this.parent = config.parent;
          this.classes = view.themeClasses;
          this.createContainer();
          this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
          this.manager = new TooltipViewManager(view, showTooltip, (t) => this.createTooltip(t));
          this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((entries) => {
            if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)
              this.measureSoon();
          }, { threshold: [1] }) : null;
          this.observeIntersection();
          (_a = view.dom.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
          this.maybeMeasure();
        }
        createContainer() {
          if (this.parent) {
            this.container = document.createElement("div");
            this.container.style.position = "relative";
            this.container.className = this.view.themeClasses;
            this.parent.appendChild(this.container);
          } else {
            this.container = this.view.dom;
          }
        }
        observeIntersection() {
          if (this.intersectionObserver) {
            this.intersectionObserver.disconnect();
            for (let tooltip of this.manager.tooltipViews)
              this.intersectionObserver.observe(tooltip.dom);
          }
        }
        measureSoon() {
          if (this.measureTimeout < 0)
            this.measureTimeout = setTimeout(() => {
              this.measureTimeout = -1;
              this.maybeMeasure();
            }, 50);
        }
        update(update) {
          if (update.transactions.length)
            this.lastTransaction = Date.now();
          let updated = this.manager.update(update);
          if (updated)
            this.observeIntersection();
          let shouldMeasure = updated || update.geometryChanged;
          let newConfig = update.state.facet(tooltipConfig);
          if (newConfig.position != this.position) {
            this.position = newConfig.position;
            for (let t of this.manager.tooltipViews)
              t.dom.style.position = this.position;
            shouldMeasure = true;
          }
          if (newConfig.parent != this.parent) {
            if (this.parent)
              this.container.remove();
            this.parent = newConfig.parent;
            this.createContainer();
            for (let t of this.manager.tooltipViews)
              this.container.appendChild(t.dom);
            shouldMeasure = true;
          } else if (this.parent && this.view.themeClasses != this.classes) {
            this.classes = this.container.className = this.view.themeClasses;
          }
          if (shouldMeasure)
            this.maybeMeasure();
        }
        createTooltip(tooltip) {
          let tooltipView = tooltip.create(this.view);
          tooltipView.dom.classList.add("cm-tooltip");
          if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
            let arrow = document.createElement("div");
            arrow.className = "cm-tooltip-arrow";
            tooltipView.dom.appendChild(arrow);
          }
          tooltipView.dom.style.position = this.position;
          tooltipView.dom.style.top = Outside;
          this.container.appendChild(tooltipView.dom);
          if (tooltipView.mount)
            tooltipView.mount(this.view);
          return tooltipView;
        }
        destroy() {
          var _a, _b;
          (_a = this.view.dom.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.removeEventListener("resize", this.measureSoon);
          for (let { dom } of this.manager.tooltipViews)
            dom.remove();
          (_b = this.intersectionObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
          clearTimeout(this.measureTimeout);
        }
        readMeasure() {
          let editor = this.view.dom.getBoundingClientRect();
          return {
            editor,
            parent: this.parent ? this.container.getBoundingClientRect() : editor,
            pos: this.manager.tooltips.map((t, i) => {
              let tv = this.manager.tooltipViews[i];
              return tv.getCoords ? tv.getCoords(t.pos) : this.view.coordsAtPos(t.pos);
            }),
            size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
            space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view)
          };
        }
        writeMeasure(measured) {
          let { editor, space } = measured;
          let others = [];
          for (let i = 0; i < this.manager.tooltips.length; i++) {
            let tooltip = this.manager.tooltips[i], tView = this.manager.tooltipViews[i], { dom } = tView;
            let pos = measured.pos[i], size = measured.size[i];
            if (!pos || pos.bottom <= Math.max(editor.top, space.top) || pos.top >= Math.min(editor.bottom, space.bottom) || pos.right < Math.max(editor.left, space.left) - 0.1 || pos.left > Math.min(editor.right, space.right) + 0.1) {
              dom.style.top = Outside;
              continue;
            }
            let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
            let arrowHeight = arrow ? 7 : 0;
            let width = size.right - size.left, height = size.bottom - size.top;
            let offset = tView.offset || noOffset, ltr = this.view.textDirection == exports.Direction.LTR;
            let left = size.width > space.right - space.left ? ltr ? space.left : space.right - size.width : ltr ? Math.min(pos.left - (arrow ? 14 : 0) + offset.x, space.right - width) : Math.max(space.left, pos.left - width + (arrow ? 14 : 0) - offset.x);
            let above = !!tooltip.above;
            if (!tooltip.strictSide && (above ? pos.top - (size.bottom - size.top) - offset.y < space.top : pos.bottom + (size.bottom - size.top) + offset.y > space.bottom) && above == space.bottom - pos.bottom > pos.top - space.top)
              above = !above;
            let top = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
            let right = left + width;
            if (tView.overlap !== true) {
              for (let r of others)
                if (r.left < right && r.right > left && r.top < top + height && r.bottom > top)
                  top = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;
            }
            if (this.position == "absolute") {
              dom.style.top = top - measured.parent.top + "px";
              dom.style.left = left - measured.parent.left + "px";
            } else {
              dom.style.top = top + "px";
              dom.style.left = left + "px";
            }
            if (arrow)
              arrow.style.left = `${pos.left + (ltr ? offset.x : -offset.x) - (left + 14 - 7)}px`;
            if (tView.overlap !== true)
              others.push({ left, top, right, bottom: top + height });
            dom.classList.toggle("cm-tooltip-above", above);
            dom.classList.toggle("cm-tooltip-below", !above);
            if (tView.positioned)
              tView.positioned();
          }
        }
        maybeMeasure() {
          if (this.manager.tooltips.length) {
            if (this.view.inView)
              this.view.requestMeasure(this.measureReq);
            if (this.inView != this.view.inView) {
              this.inView = this.view.inView;
              if (!this.inView)
                for (let tv of this.manager.tooltipViews)
                  tv.dom.style.top = Outside;
            }
          }
        }
      }, {
        eventHandlers: {
          scroll() {
            this.maybeMeasure();
          }
        }
      });
      var baseTheme = EditorView2.baseTheme({
        ".cm-tooltip": {
          zIndex: 100
        },
        "&light .cm-tooltip": {
          border: "1px solid #bbb",
          backgroundColor: "#f5f5f5"
        },
        "&light .cm-tooltip-section:not(:first-child)": {
          borderTop: "1px solid #bbb"
        },
        "&dark .cm-tooltip": {
          backgroundColor: "#333338",
          color: "white"
        },
        ".cm-tooltip-arrow": {
          height: `${7}px`,
          width: `${7 * 2}px`,
          position: "absolute",
          zIndex: -1,
          overflow: "hidden",
          "&:before, &:after": {
            content: "''",
            position: "absolute",
            width: 0,
            height: 0,
            borderLeft: `${7}px solid transparent`,
            borderRight: `${7}px solid transparent`
          },
          ".cm-tooltip-above &": {
            bottom: `-${7}px`,
            "&:before": {
              borderTop: `${7}px solid #bbb`
            },
            "&:after": {
              borderTop: `${7}px solid #f5f5f5`,
              bottom: "1px"
            }
          },
          ".cm-tooltip-below &": {
            top: `-${7}px`,
            "&:before": {
              borderBottom: `${7}px solid #bbb`
            },
            "&:after": {
              borderBottom: `${7}px solid #f5f5f5`,
              top: "1px"
            }
          }
        },
        "&dark .cm-tooltip .cm-tooltip-arrow": {
          "&:before": {
            borderTopColor: "#333338",
            borderBottomColor: "#333338"
          },
          "&:after": {
            borderTopColor: "transparent",
            borderBottomColor: "transparent"
          }
        }
      });
      var noOffset = { x: 0, y: 0 };
      var showTooltip = state.Facet.define({
        enables: [tooltipPlugin, baseTheme]
      });
      var showHoverTooltip = state.Facet.define();
      var HoverTooltipHost = class {
        constructor(view) {
          this.view = view;
          this.mounted = false;
          this.dom = document.createElement("div");
          this.dom.classList.add("cm-tooltip-hover");
          this.manager = new TooltipViewManager(view, showHoverTooltip, (t) => this.createHostedView(t));
        }
        static create(view) {
          return new HoverTooltipHost(view);
        }
        createHostedView(tooltip) {
          let hostedView = tooltip.create(this.view);
          hostedView.dom.classList.add("cm-tooltip-section");
          this.dom.appendChild(hostedView.dom);
          if (this.mounted && hostedView.mount)
            hostedView.mount(this.view);
          return hostedView;
        }
        mount(view) {
          for (let hostedView of this.manager.tooltipViews) {
            if (hostedView.mount)
              hostedView.mount(view);
          }
          this.mounted = true;
        }
        positioned() {
          for (let hostedView of this.manager.tooltipViews) {
            if (hostedView.positioned)
              hostedView.positioned();
          }
        }
        update(update) {
          this.manager.update(update);
        }
      };
      var showHoverTooltipHost = showTooltip.compute([showHoverTooltip], (state2) => {
        let tooltips2 = state2.facet(showHoverTooltip).filter((t) => t);
        if (tooltips2.length === 0)
          return null;
        return {
          pos: Math.min(...tooltips2.map((t) => t.pos)),
          end: Math.max(...tooltips2.filter((t) => t.end != null).map((t) => t.end)),
          create: HoverTooltipHost.create,
          above: tooltips2[0].above,
          arrow: tooltips2.some((t) => t.arrow)
        };
      });
      var HoverPlugin = class {
        constructor(view, source, field, setHover, hoverTime) {
          this.view = view;
          this.source = source;
          this.field = field;
          this.setHover = setHover;
          this.hoverTime = hoverTime;
          this.hoverTimeout = -1;
          this.restartTimeout = -1;
          this.pending = null;
          this.lastMove = { x: 0, y: 0, target: view.dom, time: 0 };
          this.checkHover = this.checkHover.bind(this);
          view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
          view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
        }
        update() {
          if (this.pending) {
            this.pending = null;
            clearTimeout(this.restartTimeout);
            this.restartTimeout = setTimeout(() => this.startHover(), 20);
          }
        }
        get active() {
          return this.view.state.field(this.field);
        }
        checkHover() {
          this.hoverTimeout = -1;
          if (this.active)
            return;
          let hovered = Date.now() - this.lastMove.time;
          if (hovered < this.hoverTime)
            this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
          else
            this.startHover();
        }
        startHover() {
          clearTimeout(this.restartTimeout);
          let { lastMove } = this;
          let pos = this.view.contentDOM.contains(lastMove.target) ? this.view.posAtCoords(lastMove) : null;
          if (pos == null)
            return;
          let posCoords = this.view.coordsAtPos(pos);
          if (posCoords == null || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - this.view.defaultCharacterWidth || lastMove.x > posCoords.right + this.view.defaultCharacterWidth)
            return;
          let bidi = this.view.bidiSpans(this.view.state.doc.lineAt(pos)).find((s) => s.from <= pos && s.to >= pos);
          let rtl = bidi && bidi.dir == exports.Direction.RTL ? -1 : 1;
          let open2 = this.source(this.view, pos, lastMove.x < posCoords.left ? -rtl : rtl);
          if (open2 === null || open2 === void 0 ? void 0 : open2.then) {
            let pending = this.pending = { pos };
            open2.then((result) => {
              if (this.pending == pending) {
                this.pending = null;
                if (result)
                  this.view.dispatch({ effects: this.setHover.of(result) });
              }
            }, (e) => logException(this.view.state, e, "hover tooltip"));
          } else if (open2) {
            this.view.dispatch({ effects: this.setHover.of(open2) });
          }
        }
        mousemove(event) {
          var _a;
          this.lastMove = { x: event.clientX, y: event.clientY, target: event.target, time: Date.now() };
          if (this.hoverTimeout < 0)
            this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
          let tooltip = this.active;
          if (tooltip && !isInTooltip(this.lastMove.target) || this.pending) {
            let { pos } = tooltip || this.pending, end = (_a = tooltip === null || tooltip === void 0 ? void 0 : tooltip.end) !== null && _a !== void 0 ? _a : pos;
            if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY, 6)) {
              this.view.dispatch({ effects: this.setHover.of(null) });
              this.pending = null;
            }
          }
        }
        mouseleave() {
          clearTimeout(this.hoverTimeout);
          this.hoverTimeout = -1;
          if (this.active)
            this.view.dispatch({ effects: this.setHover.of(null) });
        }
        destroy() {
          clearTimeout(this.hoverTimeout);
          this.view.dom.removeEventListener("mouseleave", this.mouseleave);
          this.view.dom.removeEventListener("mousemove", this.mousemove);
        }
      };
      function isInTooltip(elt) {
        for (let cur = elt; cur; cur = cur.parentNode)
          if (cur.nodeType == 1 && cur.classList.contains("cm-tooltip"))
            return true;
        return false;
      }
      function isOverRange(view, from, to, x, y, margin) {
        let range = document.createRange();
        let fromDOM = view.domAtPos(from), toDOM = view.domAtPos(to);
        range.setEnd(toDOM.node, toDOM.offset);
        range.setStart(fromDOM.node, fromDOM.offset);
        let rects = range.getClientRects();
        range.detach();
        for (let i = 0; i < rects.length; i++) {
          let rect = rects[i];
          let dist = Math.max(rect.top - y, y - rect.bottom, rect.left - x, x - rect.right);
          if (dist <= margin)
            return true;
        }
        return false;
      }
      function hoverTooltip(source, options = {}) {
        let setHover = state.StateEffect.define();
        let hoverState = state.StateField.define({
          create() {
            return null;
          },
          update(value, tr) {
            if (value && (options.hideOnChange && (tr.docChanged || tr.selection) || options.hideOn && options.hideOn(tr, value)))
              return null;
            if (value && tr.docChanged) {
              let newPos = tr.changes.mapPos(value.pos, -1, state.MapMode.TrackDel);
              if (newPos == null)
                return null;
              let copy = Object.assign(/* @__PURE__ */ Object.create(null), value);
              copy.pos = newPos;
              if (value.end != null)
                copy.end = tr.changes.mapPos(value.end);
              value = copy;
            }
            for (let effect of tr.effects) {
              if (effect.is(setHover))
                value = effect.value;
              if (effect.is(closeHoverTooltipEffect))
                value = null;
            }
            return value;
          },
          provide: (f) => showHoverTooltip.from(f)
        });
        return [
          hoverState,
          ViewPlugin.define((view) => new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || 300)),
          showHoverTooltipHost
        ];
      }
      function getTooltip(view, tooltip) {
        let plugin2 = view.plugin(tooltipPlugin);
        if (!plugin2)
          return null;
        let found = plugin2.manager.tooltips.indexOf(tooltip);
        return found < 0 ? null : plugin2.manager.tooltipViews[found];
      }
      function hasHoverTooltips(state2) {
        return state2.facet(showHoverTooltip).some((x) => x);
      }
      var closeHoverTooltipEffect = state.StateEffect.define();
      var closeHoverTooltips = closeHoverTooltipEffect.of(null);
      function repositionTooltips(view) {
        var _a;
        (_a = view.plugin(tooltipPlugin)) === null || _a === void 0 ? void 0 : _a.maybeMeasure();
      }
      var panelConfig = state.Facet.define({
        combine(configs) {
          let topContainer, bottomContainer;
          for (let c of configs) {
            topContainer = topContainer || c.topContainer;
            bottomContainer = bottomContainer || c.bottomContainer;
          }
          return { topContainer, bottomContainer };
        }
      });
      function panels(config) {
        return config ? [panelConfig.of(config)] : [];
      }
      function getPanel(view, panel) {
        let plugin2 = view.plugin(panelPlugin);
        let index = plugin2 ? plugin2.specs.indexOf(panel) : -1;
        return index > -1 ? plugin2.panels[index] : null;
      }
      var panelPlugin = ViewPlugin.fromClass(class {
        constructor(view) {
          this.input = view.state.facet(showPanel);
          this.specs = this.input.filter((s) => s);
          this.panels = this.specs.map((spec) => spec(view));
          let conf = view.state.facet(panelConfig);
          this.top = new PanelGroup(view, true, conf.topContainer);
          this.bottom = new PanelGroup(view, false, conf.bottomContainer);
          this.top.sync(this.panels.filter((p) => p.top));
          this.bottom.sync(this.panels.filter((p) => !p.top));
          for (let p of this.panels) {
            p.dom.classList.add("cm-panel");
            if (p.mount)
              p.mount();
          }
        }
        update(update) {
          let conf = update.state.facet(panelConfig);
          if (this.top.container != conf.topContainer) {
            this.top.sync([]);
            this.top = new PanelGroup(update.view, true, conf.topContainer);
          }
          if (this.bottom.container != conf.bottomContainer) {
            this.bottom.sync([]);
            this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
          }
          this.top.syncClasses();
          this.bottom.syncClasses();
          let input = update.state.facet(showPanel);
          if (input != this.input) {
            let specs = input.filter((x) => x);
            let panels2 = [], top = [], bottom = [], mount = [];
            for (let spec of specs) {
              let known = this.specs.indexOf(spec), panel;
              if (known < 0) {
                panel = spec(update.view);
                mount.push(panel);
              } else {
                panel = this.panels[known];
                if (panel.update)
                  panel.update(update);
              }
              panels2.push(panel);
              (panel.top ? top : bottom).push(panel);
            }
            this.specs = specs;
            this.panels = panels2;
            this.top.sync(top);
            this.bottom.sync(bottom);
            for (let p of mount) {
              p.dom.classList.add("cm-panel");
              if (p.mount)
                p.mount();
            }
          } else {
            for (let p of this.panels)
              if (p.update)
                p.update(update);
          }
        }
        destroy() {
          this.top.sync([]);
          this.bottom.sync([]);
        }
      }, {
        provide: (plugin2) => EditorView2.scrollMargins.of((view) => {
          let value = view.plugin(plugin2);
          return value && { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() };
        })
      });
      var PanelGroup = class {
        constructor(view, top, container) {
          this.view = view;
          this.top = top;
          this.container = container;
          this.dom = void 0;
          this.classes = "";
          this.panels = [];
          this.syncClasses();
        }
        sync(panels2) {
          for (let p of this.panels)
            if (p.destroy && panels2.indexOf(p) < 0)
              p.destroy();
          this.panels = panels2;
          this.syncDOM();
        }
        syncDOM() {
          if (this.panels.length == 0) {
            if (this.dom) {
              this.dom.remove();
              this.dom = void 0;
            }
            return;
          }
          if (!this.dom) {
            this.dom = document.createElement("div");
            this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
            this.dom.style[this.top ? "top" : "bottom"] = "0";
            let parent = this.container || this.view.dom;
            parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
          }
          let curDOM = this.dom.firstChild;
          for (let panel of this.panels) {
            if (panel.dom.parentNode == this.dom) {
              while (curDOM != panel.dom)
                curDOM = rm(curDOM);
              curDOM = curDOM.nextSibling;
            } else {
              this.dom.insertBefore(panel.dom, curDOM);
            }
          }
          while (curDOM)
            curDOM = rm(curDOM);
        }
        scrollMargin() {
          return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
        }
        syncClasses() {
          if (!this.container || this.classes == this.view.themeClasses)
            return;
          for (let cls of this.classes.split(" "))
            if (cls)
              this.container.classList.remove(cls);
          for (let cls of (this.classes = this.view.themeClasses).split(" "))
            if (cls)
              this.container.classList.add(cls);
        }
      };
      function rm(node) {
        let next = node.nextSibling;
        node.remove();
        return next;
      }
      var showPanel = state.Facet.define({
        enables: panelPlugin
      });
      var GutterMarker = class extends state.RangeValue {
        compare(other) {
          return this == other || this.constructor == other.constructor && this.eq(other);
        }
        eq(other) {
          return false;
        }
        destroy(dom) {
        }
      };
      GutterMarker.prototype.elementClass = "";
      GutterMarker.prototype.toDOM = void 0;
      GutterMarker.prototype.mapMode = state.MapMode.TrackBefore;
      GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
      GutterMarker.prototype.point = true;
      var gutterLineClass = state.Facet.define();
      var defaults = {
        class: "",
        renderEmptyElements: false,
        elementStyle: "",
        markers: () => state.RangeSet.empty,
        lineMarker: () => null,
        lineMarkerChange: null,
        initialSpacer: null,
        updateSpacer: null,
        domEventHandlers: {}
      };
      var activeGutters = state.Facet.define();
      function gutter(config) {
        return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config))];
      }
      var unfixGutters = state.Facet.define({
        combine: (values) => values.some((x) => x)
      });
      function gutters(config) {
        let result = [
          gutterView
        ];
        if (config && config.fixed === false)
          result.push(unfixGutters.of(true));
        return result;
      }
      var gutterView = ViewPlugin.fromClass(class {
        constructor(view) {
          this.view = view;
          this.prevViewport = view.viewport;
          this.dom = document.createElement("div");
          this.dom.className = "cm-gutters";
          this.dom.setAttribute("aria-hidden", "true");
          this.dom.style.minHeight = this.view.contentHeight + "px";
          this.gutters = view.state.facet(activeGutters).map((conf) => new SingleGutterView(view, conf));
          for (let gutter2 of this.gutters)
            this.dom.appendChild(gutter2.dom);
          this.fixed = !view.state.facet(unfixGutters);
          if (this.fixed) {
            this.dom.style.position = "sticky";
          }
          this.syncGutters(false);
          view.scrollDOM.insertBefore(this.dom, view.contentDOM);
        }
        update(update) {
          if (this.updateGutters(update)) {
            let vpA = this.prevViewport, vpB = update.view.viewport;
            let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
            this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
          }
          if (update.geometryChanged)
            this.dom.style.minHeight = this.view.contentHeight + "px";
          if (this.view.state.facet(unfixGutters) != !this.fixed) {
            this.fixed = !this.fixed;
            this.dom.style.position = this.fixed ? "sticky" : "";
          }
          this.prevViewport = update.view.viewport;
        }
        syncGutters(detach) {
          let after = this.dom.nextSibling;
          if (detach)
            this.dom.remove();
          let lineClasses = state.RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
          let classSet = [];
          let contexts2 = this.gutters.map((gutter2) => new UpdateContext(gutter2, this.view.viewport, -this.view.documentPadding.top));
          for (let line of this.view.viewportLineBlocks) {
            let text;
            if (Array.isArray(line.type)) {
              for (let b of line.type)
                if (b.type == exports.BlockType.Text) {
                  text = b;
                  break;
                }
            } else {
              text = line.type == exports.BlockType.Text ? line : void 0;
            }
            if (!text)
              continue;
            if (classSet.length)
              classSet = [];
            advanceCursor(lineClasses, classSet, line.from);
            for (let cx of contexts2)
              cx.line(this.view, text, classSet);
          }
          for (let cx of contexts2)
            cx.finish();
          if (detach)
            this.view.scrollDOM.insertBefore(this.dom, after);
        }
        updateGutters(update) {
          let prev = update.startState.facet(activeGutters), cur = update.state.facet(activeGutters);
          let change = update.docChanged || update.heightChanged || update.viewportChanged || !state.RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
          if (prev == cur) {
            for (let gutter2 of this.gutters)
              if (gutter2.update(update))
                change = true;
          } else {
            change = true;
            let gutters2 = [];
            for (let conf of cur) {
              let known = prev.indexOf(conf);
              if (known < 0) {
                gutters2.push(new SingleGutterView(this.view, conf));
              } else {
                this.gutters[known].update(update);
                gutters2.push(this.gutters[known]);
              }
            }
            for (let g of this.gutters) {
              g.dom.remove();
              if (gutters2.indexOf(g) < 0)
                g.destroy();
            }
            for (let g of gutters2)
              this.dom.appendChild(g.dom);
            this.gutters = gutters2;
          }
          return change;
        }
        destroy() {
          for (let view of this.gutters)
            view.destroy();
          this.dom.remove();
        }
      }, {
        provide: (plugin2) => EditorView2.scrollMargins.of((view) => {
          let value = view.plugin(plugin2);
          if (!value || value.gutters.length == 0 || !value.fixed)
            return null;
          return view.textDirection == exports.Direction.LTR ? { left: value.dom.offsetWidth } : { right: value.dom.offsetWidth };
        })
      });
      function asArray(val) {
        return Array.isArray(val) ? val : [val];
      }
      function advanceCursor(cursor, collect, pos) {
        while (cursor.value && cursor.from <= pos) {
          if (cursor.from == pos)
            collect.push(cursor.value);
          cursor.next();
        }
      }
      var UpdateContext = class {
        constructor(gutter2, viewport, height) {
          this.gutter = gutter2;
          this.height = height;
          this.localMarkers = [];
          this.i = 0;
          this.cursor = state.RangeSet.iter(gutter2.markers, viewport.from);
        }
        line(view, line, extraMarkers) {
          if (this.localMarkers.length)
            this.localMarkers = [];
          advanceCursor(this.cursor, this.localMarkers, line.from);
          let localMarkers = extraMarkers.length ? this.localMarkers.concat(extraMarkers) : this.localMarkers;
          let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
          if (forLine)
            localMarkers.unshift(forLine);
          let gutter2 = this.gutter;
          if (localMarkers.length == 0 && !gutter2.config.renderEmptyElements)
            return;
          let above = line.top - this.height;
          if (this.i == gutter2.elements.length) {
            let newElt = new GutterElement(view, line.height, above, localMarkers);
            gutter2.elements.push(newElt);
            gutter2.dom.appendChild(newElt.dom);
          } else {
            gutter2.elements[this.i].update(view, line.height, above, localMarkers);
          }
          this.height = line.bottom;
          this.i++;
        }
        finish() {
          let gutter2 = this.gutter;
          while (gutter2.elements.length > this.i) {
            let last = gutter2.elements.pop();
            gutter2.dom.removeChild(last.dom);
            last.destroy();
          }
        }
      };
      var SingleGutterView = class {
        constructor(view, config) {
          this.view = view;
          this.config = config;
          this.elements = [];
          this.spacer = null;
          this.dom = document.createElement("div");
          this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
          for (let prop in config.domEventHandlers) {
            this.dom.addEventListener(prop, (event) => {
              let line = view.lineBlockAtHeight(event.clientY - view.documentTop);
              if (config.domEventHandlers[prop](view, line, event))
                event.preventDefault();
            });
          }
          this.markers = asArray(config.markers(view));
          if (config.initialSpacer) {
            this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);
            this.dom.appendChild(this.spacer.dom);
            this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
          }
        }
        update(update) {
          let prevMarkers = this.markers;
          this.markers = asArray(this.config.markers(update.view));
          if (this.spacer && this.config.updateSpacer) {
            let updated = this.config.updateSpacer(this.spacer.markers[0], update);
            if (updated != this.spacer.markers[0])
              this.spacer.update(update.view, 0, 0, [updated]);
          }
          let vp = update.view.viewport;
          return !state.RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
        }
        destroy() {
          for (let elt of this.elements)
            elt.destroy();
        }
      };
      var GutterElement = class {
        constructor(view, height, above, markers) {
          this.height = -1;
          this.above = 0;
          this.markers = [];
          this.dom = document.createElement("div");
          this.dom.className = "cm-gutterElement";
          this.update(view, height, above, markers);
        }
        update(view, height, above, markers) {
          if (this.height != height)
            this.dom.style.height = (this.height = height) + "px";
          if (this.above != above)
            this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
          if (!sameMarkers(this.markers, markers))
            this.setMarkers(view, markers);
        }
        setMarkers(view, markers) {
          let cls = "cm-gutterElement", domPos = this.dom.firstChild;
          for (let iNew = 0, iOld = 0; ; ) {
            let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
            if (marker) {
              let c = marker.elementClass;
              if (c)
                cls += " " + c;
              for (let i = iOld; i < this.markers.length; i++)
                if (this.markers[i].compare(marker)) {
                  skipTo = i;
                  matched = true;
                  break;
                }
            } else {
              skipTo = this.markers.length;
            }
            while (iOld < skipTo) {
              let next = this.markers[iOld++];
              if (next.toDOM) {
                next.destroy(domPos);
                let after = domPos.nextSibling;
                domPos.remove();
                domPos = after;
              }
            }
            if (!marker)
              break;
            if (marker.toDOM) {
              if (matched)
                domPos = domPos.nextSibling;
              else
                this.dom.insertBefore(marker.toDOM(view), domPos);
            }
            if (matched)
              iOld++;
          }
          this.dom.className = cls;
          this.markers = markers;
        }
        destroy() {
          this.setMarkers(null, []);
        }
      };
      function sameMarkers(a, b) {
        if (a.length != b.length)
          return false;
        for (let i = 0; i < a.length; i++)
          if (!a[i].compare(b[i]))
            return false;
        return true;
      }
      var lineNumberMarkers = state.Facet.define();
      var lineNumberConfig = state.Facet.define({
        combine(values) {
          return state.combineConfig(values, { formatNumber: String, domEventHandlers: {} }, {
            domEventHandlers(a, b) {
              let result = Object.assign({}, a);
              for (let event in b) {
                let exists = result[event], add = b[event];
                result[event] = exists ? (view, line, event2) => exists(view, line, event2) || add(view, line, event2) : add;
              }
              return result;
            }
          });
        }
      });
      var NumberMarker = class extends GutterMarker {
        constructor(number) {
          super();
          this.number = number;
        }
        eq(other) {
          return this.number == other.number;
        }
        toDOM() {
          return document.createTextNode(this.number);
        }
      };
      function formatNumber(view, number) {
        return view.state.facet(lineNumberConfig).formatNumber(number, view.state);
      }
      var lineNumberGutter = activeGutters.compute([lineNumberConfig], (state2) => ({
        class: "cm-lineNumbers",
        renderEmptyElements: false,
        markers(view) {
          return view.state.facet(lineNumberMarkers);
        },
        lineMarker(view, line, others) {
          if (others.some((m) => m.toDOM))
            return null;
          return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
        },
        lineMarkerChange: (update) => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
        initialSpacer(view) {
          return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
        },
        updateSpacer(spacer, update) {
          let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
          return max == spacer.number ? spacer : new NumberMarker(max);
        },
        domEventHandlers: state2.facet(lineNumberConfig).domEventHandlers
      }));
      function lineNumbers(config = {}) {
        return [
          lineNumberConfig.of(config),
          gutters(),
          lineNumberGutter
        ];
      }
      function maxLineNumber(lines) {
        let last = 9;
        while (last < lines)
          last = last * 10 + 9;
        return last;
      }
      var activeLineGutterMarker = new class extends GutterMarker {
        constructor() {
          super(...arguments);
          this.elementClass = "cm-activeLineGutter";
        }
      }();
      var activeLineGutterHighlighter = gutterLineClass.compute(["selection"], (state$1) => {
        let marks = [], last = -1;
        for (let range of state$1.selection.ranges)
          if (range.empty) {
            let linePos = state$1.doc.lineAt(range.head).from;
            if (linePos > last) {
              last = linePos;
              marks.push(activeLineGutterMarker.range(linePos));
            }
          }
        return state.RangeSet.of(marks);
      });
      function highlightActiveLineGutter() {
        return activeLineGutterHighlighter;
      }
      var __test = { HeightMap, HeightOracle, MeasuredHeights, QueryType, ChangedRange, computeOrder, moveVisually };
      exports.BidiSpan = BidiSpan;
      exports.BlockInfo = BlockInfo;
      exports.Decoration = Decoration;
      exports.EditorView = EditorView2;
      exports.GutterMarker = GutterMarker;
      exports.MatchDecorator = MatchDecorator;
      exports.ViewPlugin = ViewPlugin;
      exports.ViewUpdate = ViewUpdate;
      exports.WidgetType = WidgetType;
      exports.__test = __test;
      exports.closeHoverTooltips = closeHoverTooltips;
      exports.crosshairCursor = crosshairCursor;
      exports.drawSelection = drawSelection;
      exports.dropCursor = dropCursor;
      exports.getPanel = getPanel;
      exports.getTooltip = getTooltip;
      exports.gutter = gutter;
      exports.gutterLineClass = gutterLineClass;
      exports.gutters = gutters;
      exports.hasHoverTooltips = hasHoverTooltips;
      exports.highlightActiveLine = highlightActiveLine;
      exports.highlightActiveLineGutter = highlightActiveLineGutter;
      exports.highlightSpecialChars = highlightSpecialChars;
      exports.hoverTooltip = hoverTooltip;
      exports.keymap = keymap;
      exports.lineNumberMarkers = lineNumberMarkers;
      exports.lineNumbers = lineNumbers;
      exports.logException = logException;
      exports.panels = panels;
      exports.placeholder = placeholder;
      exports.rectangularSelection = rectangularSelection;
      exports.repositionTooltips = repositionTooltips;
      exports.runScopeHandlers = runScopeHandlers;
      exports.scrollPastEnd = scrollPastEnd;
      exports.showPanel = showPanel;
      exports.showTooltip = showTooltip;
      exports.tooltips = tooltips;
    }
  });

  // node_modules/@lezer/common/dist/index.cjs
  var require_dist3 = __commonJS({
    "node_modules/@lezer/common/dist/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var DefaultBufferLength = 1024;
      var nextPropID = 0;
      var Range = class {
        constructor(from, to) {
          this.from = from;
          this.to = to;
        }
      };
      var NodeProp = class {
        constructor(config = {}) {
          this.id = nextPropID++;
          this.perNode = !!config.perNode;
          this.deserialize = config.deserialize || (() => {
            throw new Error("This node type doesn't define a deserialize function");
          });
        }
        add(match) {
          if (this.perNode)
            throw new RangeError("Can't add per-node props to node types");
          if (typeof match != "function")
            match = NodeType.match(match);
          return (type) => {
            let result = match(type);
            return result === void 0 ? null : [this, result];
          };
        }
      };
      NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
      NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
      NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
      NodeProp.contextHash = new NodeProp({ perNode: true });
      NodeProp.lookAhead = new NodeProp({ perNode: true });
      NodeProp.mounted = new NodeProp({ perNode: true });
      var MountedTree = class {
        constructor(tree, overlay, parser) {
          this.tree = tree;
          this.overlay = overlay;
          this.parser = parser;
        }
      };
      var noProps = /* @__PURE__ */ Object.create(null);
      var NodeType = class {
        constructor(name, props, id, flags = 0) {
          this.name = name;
          this.props = props;
          this.id = id;
          this.flags = flags;
        }
        static define(spec) {
          let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
          let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
          let type = new NodeType(spec.name || "", props, spec.id, flags);
          if (spec.props)
            for (let src of spec.props) {
              if (!Array.isArray(src))
                src = src(type);
              if (src) {
                if (src[0].perNode)
                  throw new RangeError("Can't store a per-node prop on a node type");
                props[src[0].id] = src[1];
              }
            }
          return type;
        }
        prop(prop) {
          return this.props[prop.id];
        }
        get isTop() {
          return (this.flags & 1) > 0;
        }
        get isSkipped() {
          return (this.flags & 2) > 0;
        }
        get isError() {
          return (this.flags & 4) > 0;
        }
        get isAnonymous() {
          return (this.flags & 8) > 0;
        }
        is(name) {
          if (typeof name == "string") {
            if (this.name == name)
              return true;
            let group = this.prop(NodeProp.group);
            return group ? group.indexOf(name) > -1 : false;
          }
          return this.id == name;
        }
        static match(map) {
          let direct = /* @__PURE__ */ Object.create(null);
          for (let prop in map)
            for (let name of prop.split(" "))
              direct[name] = map[prop];
          return (node) => {
            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
              let found = direct[i < 0 ? node.name : groups[i]];
              if (found)
                return found;
            }
          };
        }
      };
      NodeType.none = new NodeType("", /* @__PURE__ */ Object.create(null), 0, 8);
      var NodeSet = class {
        constructor(types) {
          this.types = types;
          for (let i = 0; i < types.length; i++)
            if (types[i].id != i)
              throw new RangeError("Node type ids should correspond to array positions when creating a node set");
        }
        extend(...props) {
          let newTypes = [];
          for (let type of this.types) {
            let newProps = null;
            for (let source of props) {
              let add = source(type);
              if (add) {
                if (!newProps)
                  newProps = Object.assign({}, type.props);
                newProps[add[0].id] = add[1];
              }
            }
            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
          }
          return new NodeSet(newTypes);
        }
      };
      var CachedNode = /* @__PURE__ */ new WeakMap();
      var CachedInnerNode = /* @__PURE__ */ new WeakMap();
      exports.IterMode = void 0;
      (function(IterMode) {
        IterMode[IterMode["ExcludeBuffers"] = 1] = "ExcludeBuffers";
        IterMode[IterMode["IncludeAnonymous"] = 2] = "IncludeAnonymous";
        IterMode[IterMode["IgnoreMounts"] = 4] = "IgnoreMounts";
        IterMode[IterMode["IgnoreOverlays"] = 8] = "IgnoreOverlays";
      })(exports.IterMode || (exports.IterMode = {}));
      var Tree = class {
        constructor(type, children, positions, length, props) {
          this.type = type;
          this.children = children;
          this.positions = positions;
          this.length = length;
          this.props = null;
          if (props && props.length) {
            this.props = /* @__PURE__ */ Object.create(null);
            for (let [prop, value] of props)
              this.props[typeof prop == "number" ? prop : prop.id] = value;
          }
        }
        toString() {
          let mounted = this.prop(NodeProp.mounted);
          if (mounted && !mounted.overlay)
            return mounted.tree.toString();
          let children = "";
          for (let ch of this.children) {
            let str = ch.toString();
            if (str) {
              if (children)
                children += ",";
              children += str;
            }
          }
          return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
        }
        cursor(mode = 0) {
          return new TreeCursor(this.topNode, mode);
        }
        cursorAt(pos, side = 0, mode = 0) {
          let scope = CachedNode.get(this) || this.topNode;
          let cursor = new TreeCursor(scope);
          cursor.moveTo(pos, side);
          CachedNode.set(this, cursor._tree);
          return cursor;
        }
        get topNode() {
          return new TreeNode(this, 0, 0, null);
        }
        resolve(pos, side = 0) {
          let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
          CachedNode.set(this, node);
          return node;
        }
        resolveInner(pos, side = 0) {
          let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
          CachedInnerNode.set(this, node);
          return node;
        }
        iterate(spec) {
          let { enter, leave, from = 0, to = this.length } = spec;
          for (let c = this.cursor((spec.mode || 0) | exports.IterMode.IncludeAnonymous); ; ) {
            let entered = false;
            if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c) !== false)) {
              if (c.firstChild())
                continue;
              entered = true;
            }
            for (; ; ) {
              if (entered && leave && !c.type.isAnonymous)
                leave(c);
              if (c.nextSibling())
                break;
              if (!c.parent())
                return;
              entered = true;
            }
          }
        }
        prop(prop) {
          return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
        }
        get propValues() {
          let result = [];
          if (this.props)
            for (let id in this.props)
              result.push([+id, this.props[id]]);
          return result;
        }
        balance(config = {}) {
          return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
        }
        static build(data) {
          return buildTree(data);
        }
      };
      Tree.empty = new Tree(NodeType.none, [], [], 0);
      var FlatBufferCursor = class {
        constructor(buffer, index) {
          this.buffer = buffer;
          this.index = index;
        }
        get id() {
          return this.buffer[this.index - 4];
        }
        get start() {
          return this.buffer[this.index - 3];
        }
        get end() {
          return this.buffer[this.index - 2];
        }
        get size() {
          return this.buffer[this.index - 1];
        }
        get pos() {
          return this.index;
        }
        next() {
          this.index -= 4;
        }
        fork() {
          return new FlatBufferCursor(this.buffer, this.index);
        }
      };
      var TreeBuffer = class {
        constructor(buffer, length, set) {
          this.buffer = buffer;
          this.length = length;
          this.set = set;
        }
        get type() {
          return NodeType.none;
        }
        toString() {
          let result = [];
          for (let index = 0; index < this.buffer.length; ) {
            result.push(this.childString(index));
            index = this.buffer[index + 3];
          }
          return result.join(",");
        }
        childString(index) {
          let id = this.buffer[index], endIndex = this.buffer[index + 3];
          let type = this.set.types[id], result = type.name;
          if (/\W/.test(result) && !type.isError)
            result = JSON.stringify(result);
          index += 4;
          if (endIndex == index)
            return result;
          let children = [];
          while (index < endIndex) {
            children.push(this.childString(index));
            index = this.buffer[index + 3];
          }
          return result + "(" + children.join(",") + ")";
        }
        findChild(startIndex, endIndex, dir, pos, side) {
          let { buffer } = this, pick = -1;
          for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
              pick = i;
              if (dir > 0)
                break;
            }
          }
          return pick;
        }
        slice(startI, endI, from, to) {
          let b = this.buffer;
          let copy = new Uint16Array(endI - startI);
          for (let i = startI, j = 0; i < endI; ) {
            copy[j++] = b[i++];
            copy[j++] = b[i++] - from;
            copy[j++] = b[i++] - from;
            copy[j++] = b[i++] - startI;
          }
          return new TreeBuffer(copy, to - from, this.set);
        }
      };
      function checkSide(side, pos, from, to) {
        switch (side) {
          case -2:
            return from < pos;
          case -1:
            return to >= pos && from < pos;
          case 0:
            return from < pos && to > pos;
          case 1:
            return from <= pos && to > pos;
          case 2:
            return to > pos;
          case 4:
            return true;
        }
      }
      function enterUnfinishedNodesBefore(node, pos) {
        let scan = node.childBefore(pos);
        while (scan) {
          let last = scan.lastChild;
          if (!last || last.to != scan.to)
            break;
          if (last.type.isError && last.from == last.to) {
            node = scan;
            scan = last.prevSibling;
          } else {
            scan = last;
          }
        }
        return node;
      }
      function resolveNode(node, pos, side, overlays) {
        var _a;
        while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
          let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
          if (!parent)
            return node;
          node = parent;
        }
        let mode = overlays ? 0 : exports.IterMode.IgnoreOverlays;
        if (overlays)
          for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
            if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)
              node = parent;
          }
        for (; ; ) {
          let inner = node.enter(pos, side, mode);
          if (!inner)
            return node;
          node = inner;
        }
      }
      var TreeNode = class {
        constructor(_tree, from, index, _parent) {
          this._tree = _tree;
          this.from = from;
          this.index = index;
          this._parent = _parent;
        }
        get type() {
          return this._tree.type;
        }
        get name() {
          return this._tree.type.name;
        }
        get to() {
          return this.from + this._tree.length;
        }
        nextChild(i, dir, pos, side, mode = 0) {
          for (let parent = this; ; ) {
            for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {
              let next = children[i], start = positions[i] + parent.from;
              if (!checkSide(side, pos, start, start + next.length))
                continue;
              if (next instanceof TreeBuffer) {
                if (mode & exports.IterMode.ExcludeBuffers)
                  continue;
                let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
                if (index > -1)
                  return new BufferNode(new BufferContext(parent, next, i, start), null, index);
              } else if (mode & exports.IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
                let mounted;
                if (!(mode & exports.IterMode.IgnoreMounts) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)
                  return new TreeNode(mounted.tree, start, i, parent);
                let inner = new TreeNode(next, start, i, parent);
                return mode & exports.IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
              }
            }
            if (mode & exports.IterMode.IncludeAnonymous || !parent.type.isAnonymous)
              return null;
            if (parent.index >= 0)
              i = parent.index + dir;
            else
              i = dir < 0 ? -1 : parent._parent._tree.children.length;
            parent = parent._parent;
            if (!parent)
              return null;
          }
        }
        get firstChild() {
          return this.nextChild(0, 1, 0, 4);
        }
        get lastChild() {
          return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
        }
        childAfter(pos) {
          return this.nextChild(0, 1, pos, 2);
        }
        childBefore(pos) {
          return this.nextChild(this._tree.children.length - 1, -1, pos, -2);
        }
        enter(pos, side, mode = 0) {
          let mounted;
          if (!(mode & exports.IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {
            let rPos = pos - this.from;
            for (let { from, to } of mounted.overlay) {
              if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos))
                return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
            }
          }
          return this.nextChild(0, 1, pos, side, mode);
        }
        nextSignificantParent() {
          let val = this;
          while (val.type.isAnonymous && val._parent)
            val = val._parent;
          return val;
        }
        get parent() {
          return this._parent ? this._parent.nextSignificantParent() : null;
        }
        get nextSibling() {
          return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
        }
        get prevSibling() {
          return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
        }
        cursor(mode = 0) {
          return new TreeCursor(this, mode);
        }
        get tree() {
          return this._tree;
        }
        toTree() {
          return this._tree;
        }
        resolve(pos, side = 0) {
          return resolveNode(this, pos, side, false);
        }
        resolveInner(pos, side = 0) {
          return resolveNode(this, pos, side, true);
        }
        enterUnfinishedNodesBefore(pos) {
          return enterUnfinishedNodesBefore(this, pos);
        }
        getChild(type, before = null, after = null) {
          let r = getChildren(this, type, before, after);
          return r.length ? r[0] : null;
        }
        getChildren(type, before = null, after = null) {
          return getChildren(this, type, before, after);
        }
        toString() {
          return this._tree.toString();
        }
        get node() {
          return this;
        }
        matchContext(context) {
          return matchNodeContext(this, context);
        }
      };
      function getChildren(node, type, before, after) {
        let cur = node.cursor(), result = [];
        if (!cur.firstChild())
          return result;
        if (before != null) {
          while (!cur.type.is(before))
            if (!cur.nextSibling())
              return result;
        }
        for (; ; ) {
          if (after != null && cur.type.is(after))
            return result;
          if (cur.type.is(type))
            result.push(cur.node);
          if (!cur.nextSibling())
            return after == null ? result : [];
        }
      }
      function matchNodeContext(node, context, i = context.length - 1) {
        for (let p = node.parent; i >= 0; p = p.parent) {
          if (!p)
            return false;
          if (!p.type.isAnonymous) {
            if (context[i] && context[i] != p.name)
              return false;
            i--;
          }
        }
        return true;
      }
      var BufferContext = class {
        constructor(parent, buffer, index, start) {
          this.parent = parent;
          this.buffer = buffer;
          this.index = index;
          this.start = start;
        }
      };
      var BufferNode = class {
        constructor(context, _parent, index) {
          this.context = context;
          this._parent = _parent;
          this.index = index;
          this.type = context.buffer.set.types[context.buffer.buffer[index]];
        }
        get name() {
          return this.type.name;
        }
        get from() {
          return this.context.start + this.context.buffer.buffer[this.index + 1];
        }
        get to() {
          return this.context.start + this.context.buffer.buffer[this.index + 2];
        }
        child(dir, pos, side) {
          let { buffer } = this.context;
          let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
          return index < 0 ? null : new BufferNode(this.context, this, index);
        }
        get firstChild() {
          return this.child(1, 0, 4);
        }
        get lastChild() {
          return this.child(-1, 0, 4);
        }
        childAfter(pos) {
          return this.child(1, pos, 2);
        }
        childBefore(pos) {
          return this.child(-1, pos, -2);
        }
        enter(pos, side, mode = 0) {
          if (mode & exports.IterMode.ExcludeBuffers)
            return null;
          let { buffer } = this.context;
          let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
          return index < 0 ? null : new BufferNode(this.context, this, index);
        }
        get parent() {
          return this._parent || this.context.parent.nextSignificantParent();
        }
        externalSibling(dir) {
          return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4);
        }
        get nextSibling() {
          let { buffer } = this.context;
          let after = buffer.buffer[this.index + 3];
          if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
            return new BufferNode(this.context, this._parent, after);
          return this.externalSibling(1);
        }
        get prevSibling() {
          let { buffer } = this.context;
          let parentStart = this._parent ? this._parent.index + 4 : 0;
          if (this.index == parentStart)
            return this.externalSibling(-1);
          return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4));
        }
        cursor(mode = 0) {
          return new TreeCursor(this, mode);
        }
        get tree() {
          return null;
        }
        toTree() {
          let children = [], positions = [];
          let { buffer } = this.context;
          let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
          if (endI > startI) {
            let from = buffer.buffer[this.index + 1], to = buffer.buffer[this.index + 2];
            children.push(buffer.slice(startI, endI, from, to));
            positions.push(0);
          }
          return new Tree(this.type, children, positions, this.to - this.from);
        }
        resolve(pos, side = 0) {
          return resolveNode(this, pos, side, false);
        }
        resolveInner(pos, side = 0) {
          return resolveNode(this, pos, side, true);
        }
        enterUnfinishedNodesBefore(pos) {
          return enterUnfinishedNodesBefore(this, pos);
        }
        toString() {
          return this.context.buffer.childString(this.index);
        }
        getChild(type, before = null, after = null) {
          let r = getChildren(this, type, before, after);
          return r.length ? r[0] : null;
        }
        getChildren(type, before = null, after = null) {
          return getChildren(this, type, before, after);
        }
        get node() {
          return this;
        }
        matchContext(context) {
          return matchNodeContext(this, context);
        }
      };
      var TreeCursor = class {
        constructor(node, mode = 0) {
          this.mode = mode;
          this.buffer = null;
          this.stack = [];
          this.index = 0;
          this.bufferNode = null;
          if (node instanceof TreeNode) {
            this.yieldNode(node);
          } else {
            this._tree = node.context.parent;
            this.buffer = node.context;
            for (let n = node._parent; n; n = n._parent)
              this.stack.unshift(n.index);
            this.bufferNode = node;
            this.yieldBuf(node.index);
          }
        }
        get name() {
          return this.type.name;
        }
        yieldNode(node) {
          if (!node)
            return false;
          this._tree = node;
          this.type = node.type;
          this.from = node.from;
          this.to = node.to;
          return true;
        }
        yieldBuf(index, type) {
          this.index = index;
          let { start, buffer } = this.buffer;
          this.type = type || buffer.set.types[buffer.buffer[index]];
          this.from = start + buffer.buffer[index + 1];
          this.to = start + buffer.buffer[index + 2];
          return true;
        }
        yield(node) {
          if (!node)
            return false;
          if (node instanceof TreeNode) {
            this.buffer = null;
            return this.yieldNode(node);
          }
          this.buffer = node.context;
          return this.yieldBuf(node.index, node.type);
        }
        toString() {
          return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
        }
        enterChild(dir, pos, side) {
          if (!this.buffer)
            return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
          let { buffer } = this.buffer;
          let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
          if (index < 0)
            return false;
          this.stack.push(this.index);
          return this.yieldBuf(index);
        }
        firstChild() {
          return this.enterChild(1, 0, 4);
        }
        lastChild() {
          return this.enterChild(-1, 0, 4);
        }
        childAfter(pos) {
          return this.enterChild(1, pos, 2);
        }
        childBefore(pos) {
          return this.enterChild(-1, pos, -2);
        }
        enter(pos, side, mode = this.mode) {
          if (!this.buffer)
            return this.yield(this._tree.enter(pos, side, mode));
          return mode & exports.IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
        }
        parent() {
          if (!this.buffer)
            return this.yieldNode(this.mode & exports.IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
          if (this.stack.length)
            return this.yieldBuf(this.stack.pop());
          let parent = this.mode & exports.IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
          this.buffer = null;
          return this.yieldNode(parent);
        }
        sibling(dir) {
          if (!this.buffer)
            return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
          let { buffer } = this.buffer, d = this.stack.length - 1;
          if (dir < 0) {
            let parentStart = d < 0 ? 0 : this.stack[d] + 4;
            if (this.index != parentStart)
              return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4));
          } else {
            let after = buffer.buffer[this.index + 3];
            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
              return this.yieldBuf(after);
          }
          return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
        }
        nextSibling() {
          return this.sibling(1);
        }
        prevSibling() {
          return this.sibling(-1);
        }
        atLastNode(dir) {
          let index, parent, { buffer } = this;
          if (buffer) {
            if (dir > 0) {
              if (this.index < buffer.buffer.buffer.length)
                return false;
            } else {
              for (let i = 0; i < this.index; i++)
                if (buffer.buffer.buffer[i + 3] < this.index)
                  return false;
            }
            ({ index, parent } = buffer);
          } else {
            ({ index, _parent: parent } = this._tree);
          }
          for (; parent; { index, _parent: parent } = parent) {
            if (index > -1)
              for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
                let child = parent._tree.children[i];
                if (this.mode & exports.IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
                  return false;
              }
          }
          return true;
        }
        move(dir, enter) {
          if (enter && this.enterChild(dir, 0, 4))
            return true;
          for (; ; ) {
            if (this.sibling(dir))
              return true;
            if (this.atLastNode(dir) || !this.parent())
              return false;
          }
        }
        next(enter = true) {
          return this.move(1, enter);
        }
        prev(enter = true) {
          return this.move(-1, enter);
        }
        moveTo(pos, side = 0) {
          while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
            if (!this.parent())
              break;
          while (this.enterChild(1, pos, side)) {
          }
          return this;
        }
        get node() {
          if (!this.buffer)
            return this._tree;
          let cache = this.bufferNode, result = null, depth = 0;
          if (cache && cache.context == this.buffer) {
            scan:
              for (let index = this.index, d = this.stack.length; d >= 0; ) {
                for (let c = cache; c; c = c._parent)
                  if (c.index == index) {
                    if (index == this.index)
                      return c;
                    result = c;
                    depth = d + 1;
                    break scan;
                  }
                index = this.stack[--d];
              }
          }
          for (let i = depth; i < this.stack.length; i++)
            result = new BufferNode(this.buffer, result, this.stack[i]);
          return this.bufferNode = new BufferNode(this.buffer, result, this.index);
        }
        get tree() {
          return this.buffer ? null : this._tree._tree;
        }
        iterate(enter, leave) {
          for (let depth = 0; ; ) {
            let mustLeave = false;
            if (this.type.isAnonymous || enter(this) !== false) {
              if (this.firstChild()) {
                depth++;
                continue;
              }
              if (!this.type.isAnonymous)
                mustLeave = true;
            }
            for (; ; ) {
              if (mustLeave && leave)
                leave(this);
              mustLeave = this.type.isAnonymous;
              if (this.nextSibling())
                break;
              if (!depth)
                return;
              this.parent();
              depth--;
              mustLeave = true;
            }
          }
        }
        matchContext(context) {
          if (!this.buffer)
            return matchNodeContext(this.node, context);
          let { buffer } = this.buffer, { types } = buffer.set;
          for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
            if (d < 0)
              return matchNodeContext(this.node, context, i);
            let type = types[buffer.buffer[this.stack[d]]];
            if (!type.isAnonymous) {
              if (context[i] && context[i] != type.name)
                return false;
              i--;
            }
          }
          return true;
        }
      };
      function hasChild(tree) {
        return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
      }
      function buildTree(data) {
        var _a;
        let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
        let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
        let types = nodeSet.types;
        let contextHash = 0, lookAhead = 0;
        function takeNode(parentStart, minPos, children2, positions2, inRepeat) {
          let { id, start, end, size } = cursor;
          let lookAheadAtStart = lookAhead;
          while (size < 0) {
            cursor.next();
            if (size == -1) {
              let node2 = reused[id];
              children2.push(node2);
              positions2.push(start - parentStart);
              return;
            } else if (size == -3) {
              contextHash = id;
              return;
            } else if (size == -4) {
              lookAhead = id;
              return;
            } else {
              throw new RangeError(`Unrecognized record size: ${size}`);
            }
          }
          let type = types[id], node, buffer2;
          let startPos = start - parentStart;
          if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor.pos - minPos, inRepeat))) {
            let data2 = new Uint16Array(buffer2.size - buffer2.skip);
            let endPos = cursor.pos - buffer2.size, index = data2.length;
            while (cursor.pos > endPos)
              index = copyToBuffer(buffer2.start, data2, index);
            node = new TreeBuffer(data2, end - buffer2.start, nodeSet);
            startPos = buffer2.start - parentStart;
          } else {
            let endPos = cursor.pos - size;
            cursor.next();
            let localChildren = [], localPositions = [];
            let localInRepeat = id >= minRepeatType ? id : -1;
            let lastGroup = 0, lastEnd = end;
            while (cursor.pos > endPos) {
              if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
                if (cursor.end <= lastEnd - maxBufferLength) {
                  makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
                  lastGroup = localChildren.length;
                  lastEnd = cursor.end;
                }
                cursor.next();
              } else {
                takeNode(start, endPos, localChildren, localPositions, localInRepeat);
              }
            }
            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
              makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);
            localChildren.reverse();
            localPositions.reverse();
            if (localInRepeat > -1 && lastGroup > 0) {
              let make = makeBalanced(type);
              node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
            } else {
              node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);
            }
          }
          children2.push(node);
          positions2.push(startPos);
        }
        function makeBalanced(type) {
          return (children2, positions2, length2) => {
            let lookAhead2 = 0, lastI = children2.length - 1, last, lookAheadProp;
            if (lastI >= 0 && (last = children2[lastI]) instanceof Tree) {
              if (!lastI && last.type == type && last.length == length2)
                return last;
              if (lookAheadProp = last.prop(NodeProp.lookAhead))
                lookAhead2 = positions2[lastI] + last.length + lookAheadProp;
            }
            return makeTree(type, children2, positions2, length2, lookAhead2);
          };
        }
        function makeRepeatLeaf(children2, positions2, base, i, from, to, type, lookAhead2) {
          let localChildren = [], localPositions = [];
          while (children2.length > i) {
            localChildren.push(children2.pop());
            localPositions.push(positions2.pop() + base - from);
          }
          children2.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead2 - to));
          positions2.push(from - base);
        }
        function makeTree(type, children2, positions2, length2, lookAhead2 = 0, props) {
          if (contextHash) {
            let pair = [NodeProp.contextHash, contextHash];
            props = props ? [pair].concat(props) : [pair];
          }
          if (lookAhead2 > 25) {
            let pair = [NodeProp.lookAhead, lookAhead2];
            props = props ? [pair].concat(props) : [pair];
          }
          return new Tree(type, children2, positions2, length2, props);
        }
        function findBufferSize(maxSize, inRepeat) {
          let fork = cursor.fork();
          let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
          let result = { size: 0, start: 0, skip: 0 };
          scan:
            for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
              let nodeSize2 = fork.size;
              if (fork.id == inRepeat && nodeSize2 >= 0) {
                result.size = size;
                result.start = start;
                result.skip = skip;
                skip += 4;
                size += 4;
                fork.next();
                continue;
              }
              let startPos = fork.pos - nodeSize2;
              if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
                break;
              let localSkipped = fork.id >= minRepeatType ? 4 : 0;
              let nodeStart = fork.start;
              fork.next();
              while (fork.pos > startPos) {
                if (fork.size < 0) {
                  if (fork.size == -3)
                    localSkipped += 4;
                  else
                    break scan;
                } else if (fork.id >= minRepeatType) {
                  localSkipped += 4;
                }
                fork.next();
              }
              start = nodeStart;
              size += nodeSize2;
              skip += localSkipped;
            }
          if (inRepeat < 0 || size == maxSize) {
            result.size = size;
            result.start = start;
            result.skip = skip;
          }
          return result.size > 4 ? result : void 0;
        }
        function copyToBuffer(bufferStart, buffer2, index) {
          let { id, start, end, size } = cursor;
          cursor.next();
          if (size >= 0 && id < minRepeatType) {
            let startIndex = index;
            if (size > 4) {
              let endPos = cursor.pos - (size - 4);
              while (cursor.pos > endPos)
                index = copyToBuffer(bufferStart, buffer2, index);
            }
            buffer2[--index] = startIndex;
            buffer2[--index] = end - bufferStart;
            buffer2[--index] = start - bufferStart;
            buffer2[--index] = id;
          } else if (size == -3) {
            contextHash = id;
          } else if (size == -4) {
            lookAhead = id;
          }
          return index;
        }
        let children = [], positions = [];
        while (cursor.pos > 0)
          takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);
        let length = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;
        return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);
      }
      var nodeSizeCache = /* @__PURE__ */ new WeakMap();
      function nodeSize(balanceType, node) {
        if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
          return 1;
        let size = nodeSizeCache.get(node);
        if (size == null) {
          size = 1;
          for (let child of node.children) {
            if (child.type != balanceType || !(child instanceof Tree)) {
              size = 1;
              break;
            }
            size += nodeSize(balanceType, child);
          }
          nodeSizeCache.set(node, size);
        }
        return size;
      }
      function balanceRange(balanceType, children, positions, from, to, start, length, mkTop, mkTree) {
        let total = 0;
        for (let i = from; i < to; i++)
          total += nodeSize(balanceType, children[i]);
        let maxChild = Math.ceil(total * 1.5 / 8);
        let localChildren = [], localPositions = [];
        function divide(children2, positions2, from2, to2, offset) {
          for (let i = from2; i < to2; ) {
            let groupFrom = i, groupStart = positions2[i], groupSize = nodeSize(balanceType, children2[i]);
            i++;
            for (; i < to2; i++) {
              let nextSize = nodeSize(balanceType, children2[i]);
              if (groupSize + nextSize >= maxChild)
                break;
              groupSize += nextSize;
            }
            if (i == groupFrom + 1) {
              if (groupSize > maxChild) {
                let only = children2[groupFrom];
                divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
                continue;
              }
              localChildren.push(children2[groupFrom]);
            } else {
              let length2 = positions2[i - 1] + children2[i - 1].length - groupStart;
              localChildren.push(balanceRange(balanceType, children2, positions2, groupFrom, i, groupStart, length2, null, mkTree));
            }
            localPositions.push(groupStart + offset - start);
          }
        }
        divide(children, positions, from, to, 0);
        return (mkTop || mkTree)(localChildren, localPositions, length);
      }
      var NodeWeakMap = class {
        constructor() {
          this.map = /* @__PURE__ */ new WeakMap();
        }
        setBuffer(buffer, index, value) {
          let inner = this.map.get(buffer);
          if (!inner)
            this.map.set(buffer, inner = /* @__PURE__ */ new Map());
          inner.set(index, value);
        }
        getBuffer(buffer, index) {
          let inner = this.map.get(buffer);
          return inner && inner.get(index);
        }
        set(node, value) {
          if (node instanceof BufferNode)
            this.setBuffer(node.context.buffer, node.index, value);
          else if (node instanceof TreeNode)
            this.map.set(node.tree, value);
        }
        get(node) {
          return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index) : node instanceof TreeNode ? this.map.get(node.tree) : void 0;
        }
        cursorSet(cursor, value) {
          if (cursor.buffer)
            this.setBuffer(cursor.buffer.buffer, cursor.index, value);
          else
            this.map.set(cursor.tree, value);
        }
        cursorGet(cursor) {
          return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);
        }
      };
      var TreeFragment = class {
        constructor(from, to, tree, offset, openStart = false, openEnd = false) {
          this.from = from;
          this.to = to;
          this.tree = tree;
          this.offset = offset;
          this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
        }
        get openStart() {
          return (this.open & 1) > 0;
        }
        get openEnd() {
          return (this.open & 2) > 0;
        }
        static addTree(tree, fragments = [], partial = false) {
          let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
          for (let f of fragments)
            if (f.to > tree.length)
              result.push(f);
          return result;
        }
        static applyChanges(fragments, changes, minGap = 128) {
          if (!changes.length)
            return fragments;
          let result = [];
          let fI = 1, nextF = fragments.length ? fragments[0] : null;
          for (let cI = 0, pos = 0, off = 0; ; cI++) {
            let nextC = cI < changes.length ? changes[cI] : null;
            let nextPos = nextC ? nextC.fromA : 1e9;
            if (nextPos - pos >= minGap)
              while (nextF && nextF.from < nextPos) {
                let cut = nextF;
                if (pos >= cut.from || nextPos <= cut.to || off) {
                  let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
                  cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
                }
                if (cut)
                  result.push(cut);
                if (nextF.to > nextPos)
                  break;
                nextF = fI < fragments.length ? fragments[fI++] : null;
              }
            if (!nextC)
              break;
            pos = nextC.toA;
            off = nextC.toA - nextC.toB;
          }
          return result;
        }
      };
      var Parser = class {
        startParse(input, fragments, ranges) {
          if (typeof input == "string")
            input = new StringInput(input);
          ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map((r) => new Range(r.from, r.to)) : [new Range(0, 0)];
          return this.createParse(input, fragments || [], ranges);
        }
        parse(input, fragments, ranges) {
          let parse = this.startParse(input, fragments, ranges);
          for (; ; ) {
            let done = parse.advance();
            if (done)
              return done;
          }
        }
      };
      var StringInput = class {
        constructor(string) {
          this.string = string;
        }
        get length() {
          return this.string.length;
        }
        chunk(from) {
          return this.string.slice(from);
        }
        get lineChunks() {
          return false;
        }
        read(from, to) {
          return this.string.slice(from, to);
        }
      };
      function parseMixed(nest) {
        return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);
      }
      var InnerParse = class {
        constructor(parser, parse, overlay, target, ranges) {
          this.parser = parser;
          this.parse = parse;
          this.overlay = overlay;
          this.target = target;
          this.ranges = ranges;
        }
      };
      var ActiveOverlay = class {
        constructor(parser, predicate, mounts, index, start, target, prev) {
          this.parser = parser;
          this.predicate = predicate;
          this.mounts = mounts;
          this.index = index;
          this.start = start;
          this.target = target;
          this.prev = prev;
          this.depth = 0;
          this.ranges = [];
        }
      };
      var stoppedInner = new NodeProp({ perNode: true });
      var MixedParse = class {
        constructor(base, nest, input, fragments, ranges) {
          this.nest = nest;
          this.input = input;
          this.fragments = fragments;
          this.ranges = ranges;
          this.inner = [];
          this.innerDone = 0;
          this.baseTree = null;
          this.stoppedAt = null;
          this.baseParse = base;
        }
        advance() {
          if (this.baseParse) {
            let done2 = this.baseParse.advance();
            if (!done2)
              return null;
            this.baseParse = null;
            this.baseTree = done2;
            this.startInner();
            if (this.stoppedAt != null)
              for (let inner2 of this.inner)
                inner2.parse.stopAt(this.stoppedAt);
          }
          if (this.innerDone == this.inner.length) {
            let result = this.baseTree;
            if (this.stoppedAt != null)
              result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));
            return result;
          }
          let inner = this.inner[this.innerDone], done = inner.parse.advance();
          if (done) {
            this.innerDone++;
            let props = Object.assign(/* @__PURE__ */ Object.create(null), inner.target.props);
            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);
            inner.target.props = props;
          }
          return null;
        }
        get parsedPos() {
          if (this.baseParse)
            return 0;
          let pos = this.input.length;
          for (let i = this.innerDone; i < this.inner.length; i++) {
            if (this.inner[i].ranges[0].from < pos)
              pos = Math.min(pos, this.inner[i].parse.parsedPos);
          }
          return pos;
        }
        stopAt(pos) {
          this.stoppedAt = pos;
          if (this.baseParse)
            this.baseParse.stopAt(pos);
          else
            for (let i = this.innerDone; i < this.inner.length; i++)
              this.inner[i].parse.stopAt(pos);
        }
        startInner() {
          let fragmentCursor = new FragmentCursor(this.fragments);
          let overlay = null;
          let covered = null;
          let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), exports.IterMode.IncludeAnonymous | exports.IterMode.IgnoreMounts);
          scan:
            for (let nest, isCovered; this.stoppedAt == null || cursor.from < this.stoppedAt; ) {
              let enter = true, range;
              if (fragmentCursor.hasNode(cursor)) {
                if (overlay) {
                  let match = overlay.mounts.find((m) => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);
                  if (match)
                    for (let r of match.mount.overlay) {
                      let from = r.from + match.pos, to = r.to + match.pos;
                      if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some((r2) => r2.from < to && r2.to > from))
                        overlay.ranges.push({ from, to });
                    }
                }
                enter = false;
              } else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {
                enter = isCovered != 2;
              } else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {
                if (!cursor.tree)
                  materialize(cursor);
                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);
                if (typeof nest.overlay == "function") {
                  overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);
                } else {
                  let ranges = punchRanges(this.ranges, nest.overlay || [new Range(cursor.from, cursor.to)]);
                  if (ranges.length)
                    this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map((r) => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges));
                  if (!nest.overlay)
                    enter = false;
                  else if (ranges.length)
                    covered = { ranges, depth: 0, prev: covered };
                }
              } else if (overlay && (range = overlay.predicate(cursor))) {
                if (range === true)
                  range = new Range(cursor.from, cursor.to);
                if (range.from < range.to)
                  overlay.ranges.push(range);
              }
              if (enter && cursor.firstChild()) {
                if (overlay)
                  overlay.depth++;
                if (covered)
                  covered.depth++;
              } else {
                for (; ; ) {
                  if (cursor.nextSibling())
                    break;
                  if (!cursor.parent())
                    break scan;
                  if (overlay && !--overlay.depth) {
                    let ranges = punchRanges(this.ranges, overlay.ranges);
                    if (ranges.length)
                      this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map((r) => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges));
                    overlay = overlay.prev;
                  }
                  if (covered && !--covered.depth)
                    covered = covered.prev;
                }
              }
            }
        }
      };
      function checkCover(covered, from, to) {
        for (let range of covered) {
          if (range.from >= to)
            break;
          if (range.to > from)
            return range.from <= from && range.to >= to ? 2 : 1;
        }
        return 0;
      }
      function sliceBuf(buf, startI, endI, nodes, positions, off) {
        if (startI < endI) {
          let from = buf.buffer[startI + 1], to = buf.buffer[endI - 2];
          nodes.push(buf.slice(startI, endI, from, to));
          positions.push(from - off);
        }
      }
      function materialize(cursor) {
        let { node } = cursor, depth = 0;
        do {
          cursor.parent();
          depth++;
        } while (!cursor.tree);
        let i = 0, base = cursor.tree, off = 0;
        for (; ; i++) {
          off = base.positions[i] + cursor.from;
          if (off <= node.from && off + base.children[i].length >= node.to)
            break;
        }
        let buf = base.children[i], b = buf.buffer;
        function split(startI, endI, type, innerOffset, length) {
          let i2 = startI;
          while (b[i2 + 2] + off <= node.from)
            i2 = b[i2 + 3];
          let children = [], positions = [];
          sliceBuf(buf, startI, i2, children, positions, innerOffset);
          let from = b[i2 + 1], to = b[i2 + 2];
          let isTarget = from + off == node.from && to + off == node.to && b[i2] == node.type.id;
          children.push(isTarget ? node.toTree() : split(i2 + 4, b[i2 + 3], buf.set.types[b[i2]], from, to - from));
          positions.push(from - innerOffset);
          sliceBuf(buf, b[i2 + 3], endI, children, positions, innerOffset);
          return new Tree(type, children, positions, length);
        }
        base.children[i] = split(0, b.length, NodeType.none, 0, buf.length);
        for (let d = 0; d <= depth; d++)
          cursor.childAfter(node.from);
      }
      var StructureCursor = class {
        constructor(root, offset) {
          this.offset = offset;
          this.done = false;
          this.cursor = root.cursor(exports.IterMode.IncludeAnonymous | exports.IterMode.IgnoreMounts);
        }
        moveTo(pos) {
          let { cursor } = this, p = pos - this.offset;
          while (!this.done && cursor.from < p) {
            if (cursor.to >= pos && cursor.enter(p, 1, exports.IterMode.IgnoreOverlays | exports.IterMode.ExcludeBuffers))
              ;
            else if (!cursor.next(false))
              this.done = true;
          }
        }
        hasNode(cursor) {
          this.moveTo(cursor.from);
          if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {
            for (let tree = this.cursor.tree; ; ) {
              if (tree == cursor.tree)
                return true;
              if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)
                tree = tree.children[0];
              else
                break;
            }
          }
          return false;
        }
      };
      var FragmentCursor = class {
        constructor(fragments) {
          var _a;
          this.fragments = fragments;
          this.curTo = 0;
          this.fragI = 0;
          if (fragments.length) {
            let first = this.curFrag = fragments[0];
            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;
            this.inner = new StructureCursor(first.tree, -first.offset);
          } else {
            this.curFrag = this.inner = null;
          }
        }
        hasNode(node) {
          while (this.curFrag && node.from >= this.curTo)
            this.nextFrag();
          return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);
        }
        nextFrag() {
          var _a;
          this.fragI++;
          if (this.fragI == this.fragments.length) {
            this.curFrag = this.inner = null;
          } else {
            let frag = this.curFrag = this.fragments[this.fragI];
            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;
            this.inner = new StructureCursor(frag.tree, -frag.offset);
          }
        }
        findMounts(pos, parser) {
          var _a;
          let result = [];
          if (this.inner) {
            this.inner.cursor.moveTo(pos, 1);
            for (let pos2 = this.inner.cursor.node; pos2; pos2 = pos2.parent) {
              let mount = (_a = pos2.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);
              if (mount && mount.parser == parser) {
                for (let i = this.fragI; i < this.fragments.length; i++) {
                  let frag = this.fragments[i];
                  if (frag.from >= pos2.to)
                    break;
                  if (frag.tree == this.curFrag.tree)
                    result.push({
                      frag,
                      pos: pos2.from - frag.offset,
                      mount
                    });
                }
              }
            }
          }
          return result;
        }
      };
      function punchRanges(outer, ranges) {
        let copy = null, current = ranges;
        for (let i = 1, j = 0; i < outer.length; i++) {
          let gapFrom = outer[i - 1].to, gapTo = outer[i].from;
          for (; j < current.length; j++) {
            let r = current[j];
            if (r.from >= gapTo)
              break;
            if (r.to <= gapFrom)
              continue;
            if (!copy)
              current = copy = ranges.slice();
            if (r.from < gapFrom) {
              copy[j] = new Range(r.from, gapFrom);
              if (r.to > gapTo)
                copy.splice(j + 1, 0, new Range(gapTo, r.to));
            } else if (r.to > gapTo) {
              copy[j--] = new Range(gapTo, r.to);
            } else {
              copy.splice(j--, 1);
            }
          }
        }
        return current;
      }
      function findCoverChanges(a, b, from, to) {
        let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;
        let result = [];
        for (; ; ) {
          let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;
          let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;
          if (inA != inB) {
            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);
            if (start < end)
              result.push(new Range(start, end));
          }
          pos = Math.min(nextA, nextB);
          if (pos == 1e9)
            break;
          if (nextA == pos) {
            if (!inA)
              inA = true;
            else {
              inA = false;
              iA++;
            }
          }
          if (nextB == pos) {
            if (!inB)
              inB = true;
            else {
              inB = false;
              iB++;
            }
          }
        }
        return result;
      }
      function enterFragments(mounts, ranges) {
        let result = [];
        for (let { pos, mount, frag } of mounts) {
          let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;
          let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);
          if (mount.overlay) {
            let overlay = mount.overlay.map((r) => new Range(r.from + pos, r.to + pos));
            let changes = findCoverChanges(ranges, overlay, from, to);
            for (let i = 0, pos2 = from; ; i++) {
              let last = i == changes.length, end = last ? to : changes[i].from;
              if (end > pos2)
                result.push(new TreeFragment(pos2, end, mount.tree, -startPos, frag.from >= pos2, frag.to <= end));
              if (last)
                break;
              pos2 = changes[i].to;
            }
          } else {
            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos, frag.to <= endPos));
          }
        }
        return result;
      }
      exports.DefaultBufferLength = DefaultBufferLength;
      exports.MountedTree = MountedTree;
      exports.NodeProp = NodeProp;
      exports.NodeSet = NodeSet;
      exports.NodeType = NodeType;
      exports.NodeWeakMap = NodeWeakMap;
      exports.Parser = Parser;
      exports.Tree = Tree;
      exports.TreeBuffer = TreeBuffer;
      exports.TreeCursor = TreeCursor;
      exports.TreeFragment = TreeFragment;
      exports.parseMixed = parseMixed;
    }
  });

  // node_modules/@lezer/highlight/dist/index.cjs
  var require_dist4 = __commonJS({
    "node_modules/@lezer/highlight/dist/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var common = require_dist3();
      var nextTagID = 0;
      var Tag = class {
        constructor(set, base, modified) {
          this.set = set;
          this.base = base;
          this.modified = modified;
          this.id = nextTagID++;
        }
        static define(parent) {
          if (parent === null || parent === void 0 ? void 0 : parent.base)
            throw new Error("Can not derive from a modified tag");
          let tag = new Tag([], null, []);
          tag.set.push(tag);
          if (parent)
            for (let t2 of parent.set)
              tag.set.push(t2);
          return tag;
        }
        static defineModifier() {
          let mod = new Modifier();
          return (tag) => {
            if (tag.modified.indexOf(mod) > -1)
              return tag;
            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
          };
        }
      };
      var nextModifierID = 0;
      var Modifier = class {
        constructor() {
          this.instances = [];
          this.id = nextModifierID++;
        }
        static get(base, mods) {
          if (!mods.length)
            return base;
          let exists = mods[0].instances.find((t2) => t2.base == base && sameArray(mods, t2.modified));
          if (exists)
            return exists;
          let set = [], tag = new Tag(set, base, mods);
          for (let m of mods)
            m.instances.push(tag);
          let configs = permute(mods);
          for (let parent of base.set)
            for (let config of configs)
              set.push(Modifier.get(parent, config));
          return tag;
        }
      };
      function sameArray(a, b) {
        return a.length == b.length && a.every((x, i) => x == b[i]);
      }
      function permute(array) {
        let result = [array];
        for (let i = 0; i < array.length; i++) {
          for (let a of permute(array.slice(0, i).concat(array.slice(i + 1))))
            result.push(a);
        }
        return result;
      }
      function styleTags(spec) {
        let byName = /* @__PURE__ */ Object.create(null);
        for (let prop in spec) {
          let tags2 = spec[prop];
          if (!Array.isArray(tags2))
            tags2 = [tags2];
          for (let part of prop.split(" "))
            if (part) {
              let pieces = [], mode = 2, rest = part;
              for (let pos = 0; ; ) {
                if (rest == "..." && pos > 0 && pos + 3 == part.length) {
                  mode = 1;
                  break;
                }
                let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
                if (!m)
                  throw new RangeError("Invalid path: " + part);
                pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
                pos += m[0].length;
                if (pos == part.length)
                  break;
                let next = part[pos++];
                if (pos == part.length && next == "!") {
                  mode = 0;
                  break;
                }
                if (next != "/")
                  throw new RangeError("Invalid path: " + part);
                rest = part.slice(pos);
              }
              let last = pieces.length - 1, inner = pieces[last];
              if (!inner)
                throw new RangeError("Invalid path: " + part);
              let rule = new Rule(tags2, mode, last > 0 ? pieces.slice(0, last) : null);
              byName[inner] = rule.sort(byName[inner]);
            }
        }
        return ruleNodeProp.add(byName);
      }
      var ruleNodeProp = new common.NodeProp();
      var Rule = class {
        constructor(tags2, mode, context, next) {
          this.tags = tags2;
          this.mode = mode;
          this.context = context;
          this.next = next;
        }
        sort(other) {
          if (!other || other.depth < this.depth) {
            this.next = other;
            return this;
          }
          other.next = this.sort(other.next);
          return other;
        }
        get depth() {
          return this.context ? this.context.length : 0;
        }
      };
      function tagHighlighter(tags2, options) {
        let map = /* @__PURE__ */ Object.create(null);
        for (let style of tags2) {
          if (!Array.isArray(style.tag))
            map[style.tag.id] = style.class;
          else
            for (let tag of style.tag)
              map[tag.id] = style.class;
        }
        let { scope, all = null } = options || {};
        return {
          style: (tags3) => {
            let cls = all;
            for (let tag of tags3) {
              for (let sub of tag.set) {
                let tagClass = map[sub.id];
                if (tagClass) {
                  cls = cls ? cls + " " + tagClass : tagClass;
                  break;
                }
              }
            }
            return cls;
          },
          scope
        };
      }
      function highlightTags(highlighters, tags2) {
        let result = null;
        for (let highlighter of highlighters) {
          let value = highlighter.style(tags2);
          if (value)
            result = result ? result + " " + value : value;
        }
        return result;
      }
      function highlightTree(tree, highlighter, putStyle, from = 0, to = tree.length) {
        let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
        builder.highlightRange(tree.cursor(), from, to, "", builder.highlighters);
        builder.flush(to);
      }
      var HighlightBuilder = class {
        constructor(at, highlighters, span) {
          this.at = at;
          this.highlighters = highlighters;
          this.span = span;
          this.class = "";
        }
        startSpan(at, cls) {
          if (cls != this.class) {
            this.flush(at);
            if (at > this.at)
              this.at = at;
            this.class = cls;
          }
        }
        flush(to) {
          if (to > this.at && this.class)
            this.span(this.at, to, this.class);
        }
        highlightRange(cursor, from, to, inheritedClass, highlighters) {
          let { type, from: start, to: end } = cursor;
          if (start >= to || end <= from)
            return;
          if (type.isTop)
            highlighters = this.highlighters.filter((h) => !h.scope || h.scope(type));
          let cls = inheritedClass;
          let rule = type.prop(ruleNodeProp), opaque = false;
          while (rule) {
            if (!rule.context || cursor.matchContext(rule.context)) {
              let tagCls = highlightTags(highlighters, rule.tags);
              if (tagCls) {
                if (cls)
                  cls += " ";
                cls += tagCls;
                if (rule.mode == 1)
                  inheritedClass += (inheritedClass ? " " : "") + tagCls;
                else if (rule.mode == 0)
                  opaque = true;
              }
              break;
            }
            rule = rule.next;
          }
          this.startSpan(cursor.from, cls);
          if (opaque)
            return;
          let mounted = cursor.tree && cursor.tree.prop(common.NodeProp.mounted);
          if (mounted && mounted.overlay) {
            let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);
            let innerHighlighters = this.highlighters.filter((h) => !h.scope || h.scope(mounted.tree.type));
            let hasChild = cursor.firstChild();
            for (let i = 0, pos = start; ; i++) {
              let next = i < mounted.overlay.length ? mounted.overlay[i] : null;
              let nextPos = next ? next.from + start : end;
              let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);
              if (rangeFrom < rangeTo && hasChild) {
                while (cursor.from < rangeTo) {
                  this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);
                  this.startSpan(Math.min(to, cursor.to), cls);
                  if (cursor.to >= nextPos || !cursor.nextSibling())
                    break;
                }
              }
              if (!next || nextPos > to)
                break;
              pos = next.to + start;
              if (pos > from) {
                this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), inheritedClass, innerHighlighters);
                this.startSpan(pos, cls);
              }
            }
            if (hasChild)
              cursor.parent();
          } else if (cursor.firstChild()) {
            do {
              if (cursor.to <= from)
                continue;
              if (cursor.from >= to)
                break;
              this.highlightRange(cursor, from, to, inheritedClass, highlighters);
              this.startSpan(Math.min(to, cursor.to), cls);
            } while (cursor.nextSibling());
            cursor.parent();
          }
        }
      };
      var t = Tag.define;
      var comment = t();
      var name = t();
      var typeName = t(name);
      var propertyName = t(name);
      var literal = t();
      var string = t(literal);
      var number = t(literal);
      var content = t();
      var heading = t(content);
      var keyword = t();
      var operator = t();
      var punctuation = t();
      var bracket = t(punctuation);
      var meta = t();
      var tags = {
        comment,
        lineComment: t(comment),
        blockComment: t(comment),
        docComment: t(comment),
        name,
        variableName: t(name),
        typeName,
        tagName: t(typeName),
        propertyName,
        attributeName: t(propertyName),
        className: t(name),
        labelName: t(name),
        namespace: t(name),
        macroName: t(name),
        literal,
        string,
        docString: t(string),
        character: t(string),
        attributeValue: t(string),
        number,
        integer: t(number),
        float: t(number),
        bool: t(literal),
        regexp: t(literal),
        escape: t(literal),
        color: t(literal),
        url: t(literal),
        keyword,
        self: t(keyword),
        null: t(keyword),
        atom: t(keyword),
        unit: t(keyword),
        modifier: t(keyword),
        operatorKeyword: t(keyword),
        controlKeyword: t(keyword),
        definitionKeyword: t(keyword),
        moduleKeyword: t(keyword),
        operator,
        derefOperator: t(operator),
        arithmeticOperator: t(operator),
        logicOperator: t(operator),
        bitwiseOperator: t(operator),
        compareOperator: t(operator),
        updateOperator: t(operator),
        definitionOperator: t(operator),
        typeOperator: t(operator),
        controlOperator: t(operator),
        punctuation,
        separator: t(punctuation),
        bracket,
        angleBracket: t(bracket),
        squareBracket: t(bracket),
        paren: t(bracket),
        brace: t(bracket),
        content,
        heading,
        heading1: t(heading),
        heading2: t(heading),
        heading3: t(heading),
        heading4: t(heading),
        heading5: t(heading),
        heading6: t(heading),
        contentSeparator: t(content),
        list: t(content),
        quote: t(content),
        emphasis: t(content),
        strong: t(content),
        link: t(content),
        monospace: t(content),
        strikethrough: t(content),
        inserted: t(),
        deleted: t(),
        changed: t(),
        invalid: t(),
        meta,
        documentMeta: t(meta),
        annotation: t(meta),
        processingInstruction: t(meta),
        definition: Tag.defineModifier(),
        constant: Tag.defineModifier(),
        function: Tag.defineModifier(),
        standard: Tag.defineModifier(),
        local: Tag.defineModifier(),
        special: Tag.defineModifier()
      };
      var classHighlighter = tagHighlighter([
        { tag: tags.link, class: "tok-link" },
        { tag: tags.heading, class: "tok-heading" },
        { tag: tags.emphasis, class: "tok-emphasis" },
        { tag: tags.strong, class: "tok-strong" },
        { tag: tags.keyword, class: "tok-keyword" },
        { tag: tags.atom, class: "tok-atom" },
        { tag: tags.bool, class: "tok-bool" },
        { tag: tags.url, class: "tok-url" },
        { tag: tags.labelName, class: "tok-labelName" },
        { tag: tags.inserted, class: "tok-inserted" },
        { tag: tags.deleted, class: "tok-deleted" },
        { tag: tags.literal, class: "tok-literal" },
        { tag: tags.string, class: "tok-string" },
        { tag: tags.number, class: "tok-number" },
        { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
        { tag: tags.variableName, class: "tok-variableName" },
        { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
        { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
        { tag: tags.special(tags.variableName), class: "tok-variableName2" },
        { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
        { tag: tags.typeName, class: "tok-typeName" },
        { tag: tags.namespace, class: "tok-namespace" },
        { tag: tags.className, class: "tok-className" },
        { tag: tags.macroName, class: "tok-macroName" },
        { tag: tags.propertyName, class: "tok-propertyName" },
        { tag: tags.operator, class: "tok-operator" },
        { tag: tags.comment, class: "tok-comment" },
        { tag: tags.meta, class: "tok-meta" },
        { tag: tags.invalid, class: "tok-invalid" },
        { tag: tags.punctuation, class: "tok-punctuation" }
      ]);
      exports.Tag = Tag;
      exports.classHighlighter = classHighlighter;
      exports.highlightTree = highlightTree;
      exports.styleTags = styleTags;
      exports.tagHighlighter = tagHighlighter;
      exports.tags = tags;
    }
  });

  // node_modules/@codemirror/language/dist/index.cjs
  var require_dist5 = __commonJS({
    "node_modules/@codemirror/language/dist/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var common = require_dist3();
      var state = require_dist();
      var view = require_dist2();
      var highlight = require_dist4();
      var styleMod = require_style_mod();
      var _a;
      var languageDataProp = new common.NodeProp();
      function defineLanguageFacet(baseData) {
        return state.Facet.define({
          combine: baseData ? (values) => values.concat(baseData) : void 0
        });
      }
      var Language = class {
        constructor(data, parser, extraExtensions = []) {
          this.data = data;
          if (!state.EditorState.prototype.hasOwnProperty("tree"))
            Object.defineProperty(state.EditorState.prototype, "tree", { get() {
              return syntaxTree(this);
            } });
          this.parser = parser;
          this.extension = [
            language.of(this),
            state.EditorState.languageData.of((state2, pos, side) => state2.facet(languageDataFacetAt(state2, pos, side)))
          ].concat(extraExtensions);
        }
        isActiveAt(state2, pos, side = -1) {
          return languageDataFacetAt(state2, pos, side) == this.data;
        }
        findRegions(state2) {
          let lang = state2.facet(language);
          if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
            return [{ from: 0, to: state2.doc.length }];
          if (!lang || !lang.allowsNesting)
            return [];
          let result = [];
          let explore = (tree, from) => {
            if (tree.prop(languageDataProp) == this.data) {
              result.push({ from, to: from + tree.length });
              return;
            }
            let mount = tree.prop(common.NodeProp.mounted);
            if (mount) {
              if (mount.tree.prop(languageDataProp) == this.data) {
                if (mount.overlay)
                  for (let r of mount.overlay)
                    result.push({ from: r.from + from, to: r.to + from });
                else
                  result.push({ from, to: from + tree.length });
                return;
              } else if (mount.overlay) {
                let size = result.length;
                explore(mount.tree, mount.overlay[0].from + from);
                if (result.length > size)
                  return;
              }
            }
            for (let i = 0; i < tree.children.length; i++) {
              let ch = tree.children[i];
              if (ch instanceof common.Tree)
                explore(ch, tree.positions[i] + from);
            }
          };
          explore(syntaxTree(state2), 0);
          return result;
        }
        get allowsNesting() {
          return true;
        }
      };
      Language.setState = state.StateEffect.define();
      function languageDataFacetAt(state2, pos, side) {
        let topLang = state2.facet(language);
        if (!topLang)
          return null;
        let facet = topLang.data;
        if (topLang.allowsNesting) {
          for (let node = syntaxTree(state2).topNode; node; node = node.enter(pos, side, common.IterMode.ExcludeBuffers))
            facet = node.type.prop(languageDataProp) || facet;
        }
        return facet;
      }
      var LRLanguage = class extends Language {
        constructor(data, parser) {
          super(data, parser);
          this.parser = parser;
        }
        static define(spec) {
          let data = defineLanguageFacet(spec.languageData);
          return new LRLanguage(data, spec.parser.configure({
            props: [languageDataProp.add((type) => type.isTop ? data : void 0)]
          }));
        }
        configure(options) {
          return new LRLanguage(this.data, this.parser.configure(options));
        }
        get allowsNesting() {
          return this.parser.hasWrappers();
        }
      };
      function syntaxTree(state2) {
        let field = state2.field(Language.state, false);
        return field ? field.tree : common.Tree.empty;
      }
      function ensureSyntaxTree(state2, upto, timeout = 50) {
        var _a2;
        let parse = (_a2 = state2.field(Language.state, false)) === null || _a2 === void 0 ? void 0 : _a2.context;
        return !parse ? null : parse.isDone(upto) || parse.work(timeout, upto) ? parse.tree : null;
      }
      function syntaxTreeAvailable(state2, upto = state2.doc.length) {
        var _a2;
        return ((_a2 = state2.field(Language.state, false)) === null || _a2 === void 0 ? void 0 : _a2.context.isDone(upto)) || false;
      }
      function forceParsing(view2, upto = view2.viewport.to, timeout = 100) {
        let success = ensureSyntaxTree(view2.state, upto, timeout);
        if (success != syntaxTree(view2.state))
          view2.dispatch({});
        return !!success;
      }
      function syntaxParserRunning(view2) {
        var _a2;
        return ((_a2 = view2.plugin(parseWorker)) === null || _a2 === void 0 ? void 0 : _a2.isWorking()) || false;
      }
      var DocInput = class {
        constructor(doc, length = doc.length) {
          this.doc = doc;
          this.length = length;
          this.cursorPos = 0;
          this.string = "";
          this.cursor = doc.iter();
        }
        syncTo(pos) {
          this.string = this.cursor.next(pos - this.cursorPos).value;
          this.cursorPos = pos + this.string.length;
          return this.cursorPos - this.string.length;
        }
        chunk(pos) {
          this.syncTo(pos);
          return this.string;
        }
        get lineChunks() {
          return true;
        }
        read(from, to) {
          let stringStart = this.cursorPos - this.string.length;
          if (from < stringStart || to >= this.cursorPos)
            return this.doc.sliceString(from, to);
          else
            return this.string.slice(from - stringStart, to - stringStart);
        }
      };
      var currentContext = null;
      var ParseContext = class {
        constructor(parser, state2, fragments = [], tree, treeLen, viewport, skipped, scheduleOn) {
          this.parser = parser;
          this.state = state2;
          this.fragments = fragments;
          this.tree = tree;
          this.treeLen = treeLen;
          this.viewport = viewport;
          this.skipped = skipped;
          this.scheduleOn = scheduleOn;
          this.parse = null;
          this.tempSkipped = [];
        }
        static create(parser, state2, viewport) {
          return new ParseContext(parser, state2, [], common.Tree.empty, 0, viewport, [], null);
        }
        startParse() {
          return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
        }
        work(until, upto) {
          if (upto != null && upto >= this.state.doc.length)
            upto = void 0;
          if (this.tree != common.Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
            this.takeTree();
            return true;
          }
          return this.withContext(() => {
            var _a2;
            if (typeof until == "number") {
              let endTime = Date.now() + until;
              until = () => Date.now() > endTime;
            }
            if (!this.parse)
              this.parse = this.startParse();
            if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length)
              this.parse.stopAt(upto);
            for (; ; ) {
              let done = this.parse.advance();
              if (done) {
                this.fragments = this.withoutTempSkipped(common.TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
                this.treeLen = (_a2 = this.parse.stoppedAt) !== null && _a2 !== void 0 ? _a2 : this.state.doc.length;
                this.tree = done;
                this.parse = null;
                if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
                  this.parse = this.startParse();
                else
                  return true;
              }
              if (until())
                return false;
            }
          });
        }
        takeTree() {
          let pos, tree;
          if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
            if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
              this.parse.stopAt(pos);
            this.withContext(() => {
              while (!(tree = this.parse.advance())) {
              }
            });
            this.treeLen = pos;
            this.tree = tree;
            this.fragments = this.withoutTempSkipped(common.TreeFragment.addTree(this.tree, this.fragments, true));
            this.parse = null;
          }
        }
        withContext(f) {
          let prev = currentContext;
          currentContext = this;
          try {
            return f();
          } finally {
            currentContext = prev;
          }
        }
        withoutTempSkipped(fragments) {
          for (let r; r = this.tempSkipped.pop(); )
            fragments = cutFragments(fragments, r.from, r.to);
          return fragments;
        }
        changes(changes, newState) {
          let { fragments, tree, treeLen, viewport, skipped } = this;
          this.takeTree();
          if (!changes.empty) {
            let ranges = [];
            changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
            fragments = common.TreeFragment.applyChanges(fragments, ranges);
            tree = common.Tree.empty;
            treeLen = 0;
            viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
            if (this.skipped.length) {
              skipped = [];
              for (let r of this.skipped) {
                let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);
                if (from < to)
                  skipped.push({ from, to });
              }
            }
          }
          return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
        }
        updateViewport(viewport) {
          if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
            return false;
          this.viewport = viewport;
          let startLen = this.skipped.length;
          for (let i = 0; i < this.skipped.length; i++) {
            let { from, to } = this.skipped[i];
            if (from < viewport.to && to > viewport.from) {
              this.fragments = cutFragments(this.fragments, from, to);
              this.skipped.splice(i--, 1);
            }
          }
          if (this.skipped.length >= startLen)
            return false;
          this.reset();
          return true;
        }
        reset() {
          if (this.parse) {
            this.takeTree();
            this.parse = null;
          }
        }
        skipUntilInView(from, to) {
          this.skipped.push({ from, to });
        }
        static getSkippingParser(until) {
          return new class extends common.Parser {
            createParse(input, fragments, ranges) {
              let from = ranges[0].from, to = ranges[ranges.length - 1].to;
              let parser = {
                parsedPos: from,
                advance() {
                  let cx = currentContext;
                  if (cx) {
                    for (let r of ranges)
                      cx.tempSkipped.push(r);
                    if (until)
                      cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
                  }
                  this.parsedPos = to;
                  return new common.Tree(common.NodeType.none, [], [], to - from);
                },
                stoppedAt: null,
                stopAt() {
                }
              };
              return parser;
            }
          }();
        }
        isDone(upto) {
          upto = Math.min(upto, this.state.doc.length);
          let frags = this.fragments;
          return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
        }
        static get() {
          return currentContext;
        }
      };
      function cutFragments(fragments, from, to) {
        return common.TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);
      }
      var LanguageState = class {
        constructor(context) {
          this.context = context;
          this.tree = context.tree;
        }
        apply(tr) {
          if (!tr.docChanged && this.tree == this.context.tree)
            return this;
          let newCx = this.context.changes(tr.changes, tr.state);
          let upto = this.context.treeLen == tr.startState.doc.length ? void 0 : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
          if (!newCx.work(20, upto))
            newCx.takeTree();
          return new LanguageState(newCx);
        }
        static init(state2) {
          let vpTo = Math.min(3e3, state2.doc.length);
          let parseState = ParseContext.create(state2.facet(language).parser, state2, { from: 0, to: vpTo });
          if (!parseState.work(20, vpTo))
            parseState.takeTree();
          return new LanguageState(parseState);
        }
      };
      Language.state = state.StateField.define({
        create: LanguageState.init,
        update(value, tr) {
          for (let e of tr.effects)
            if (e.is(Language.setState))
              return e.value;
          if (tr.startState.facet(language) != tr.state.facet(language))
            return LanguageState.init(tr.state);
          return value.apply(tr);
        }
      });
      var requestIdle = (callback) => {
        let timeout = setTimeout(() => callback(), 500);
        return () => clearTimeout(timeout);
      };
      if (typeof requestIdleCallback != "undefined")
        requestIdle = (callback) => {
          let idle = -1, timeout = setTimeout(() => {
            idle = requestIdleCallback(callback, { timeout: 500 - 100 });
          }, 100);
          return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
        };
      var isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
      var parseWorker = view.ViewPlugin.fromClass(class ParseWorker {
        constructor(view2) {
          this.view = view2;
          this.working = null;
          this.workScheduled = 0;
          this.chunkEnd = -1;
          this.chunkBudget = -1;
          this.work = this.work.bind(this);
          this.scheduleWork();
        }
        update(update) {
          let cx = this.view.state.field(Language.state).context;
          if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)
            this.scheduleWork();
          if (update.docChanged) {
            if (this.view.hasFocus)
              this.chunkBudget += 50;
            this.scheduleWork();
          }
          this.checkAsyncSchedule(cx);
        }
        scheduleWork() {
          if (this.working)
            return;
          let { state: state2 } = this.view, field = state2.field(Language.state);
          if (field.tree != field.context.tree || !field.context.isDone(state2.doc.length))
            this.working = requestIdle(this.work);
        }
        work(deadline) {
          this.working = null;
          let now = Date.now();
          if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
            this.chunkEnd = now + 3e4;
            this.chunkBudget = 3e3;
          }
          if (this.chunkBudget <= 0)
            return;
          let { state: state2, viewport: { to: vpTo } } = this.view, field = state2.field(Language.state);
          if (field.tree == field.context.tree && field.context.isDone(vpTo + 1e5))
            return;
          let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
          let viewportFirst = field.context.treeLen < vpTo && state2.doc.length > vpTo + 1e3;
          let done = field.context.work(() => {
            return isInputPending && isInputPending() || Date.now() > endTime;
          }, vpTo + (viewportFirst ? 0 : 1e5));
          this.chunkBudget -= Date.now() - now;
          if (done || this.chunkBudget <= 0) {
            field.context.takeTree();
            this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
          }
          if (this.chunkBudget > 0 && !(done && !viewportFirst))
            this.scheduleWork();
          this.checkAsyncSchedule(field.context);
        }
        checkAsyncSchedule(cx) {
          if (cx.scheduleOn) {
            this.workScheduled++;
            cx.scheduleOn.then(() => this.scheduleWork()).catch((err) => view.logException(this.view.state, err)).then(() => this.workScheduled--);
            cx.scheduleOn = null;
          }
        }
        destroy() {
          if (this.working)
            this.working();
        }
        isWorking() {
          return !!(this.working || this.workScheduled > 0);
        }
      }, {
        eventHandlers: { focus() {
          this.scheduleWork();
        } }
      });
      var language = state.Facet.define({
        combine(languages) {
          return languages.length ? languages[0] : null;
        },
        enables: [Language.state, parseWorker]
      });
      var LanguageSupport = class {
        constructor(language2, support = []) {
          this.language = language2;
          this.support = support;
          this.extension = [language2, support];
        }
      };
      var LanguageDescription = class {
        constructor(name, alias, extensions, filename, loadFunc, support = void 0) {
          this.name = name;
          this.alias = alias;
          this.extensions = extensions;
          this.filename = filename;
          this.loadFunc = loadFunc;
          this.support = support;
          this.loading = null;
        }
        load() {
          return this.loading || (this.loading = this.loadFunc().then((support) => this.support = support, (err) => {
            this.loading = null;
            throw err;
          }));
        }
        static of(spec) {
          let { load, support } = spec;
          if (!load) {
            if (!support)
              throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
            load = () => Promise.resolve(support);
          }
          return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map((s) => s.toLowerCase()), spec.extensions || [], spec.filename, load, support);
        }
        static matchFilename(descs, filename) {
          for (let d of descs)
            if (d.filename && d.filename.test(filename))
              return d;
          let ext = /\.([^.]+)$/.exec(filename);
          if (ext) {
            for (let d of descs)
              if (d.extensions.indexOf(ext[1]) > -1)
                return d;
          }
          return null;
        }
        static matchLanguageName(descs, name, fuzzy = true) {
          name = name.toLowerCase();
          for (let d of descs)
            if (d.alias.some((a) => a == name))
              return d;
          if (fuzzy)
            for (let d of descs)
              for (let a of d.alias) {
                let found = name.indexOf(a);
                if (found > -1 && (a.length > 2 || !/\w/.test(name[found - 1]) && !/\w/.test(name[found + a.length])))
                  return d;
              }
          return null;
        }
      };
      var indentService = state.Facet.define();
      var indentUnit = state.Facet.define({
        combine: (values) => {
          if (!values.length)
            return "  ";
          if (!/^(?: +|\t+)$/.test(values[0]))
            throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
          return values[0];
        }
      });
      function getIndentUnit(state2) {
        let unit = state2.facet(indentUnit);
        return unit.charCodeAt(0) == 9 ? state2.tabSize * unit.length : unit.length;
      }
      function indentString(state2, cols) {
        let result = "", ts = state2.tabSize;
        if (state2.facet(indentUnit).charCodeAt(0) == 9)
          while (cols >= ts) {
            result += "	";
            cols -= ts;
          }
        for (let i = 0; i < cols; i++)
          result += " ";
        return result;
      }
      function getIndentation(context, pos) {
        if (context instanceof state.EditorState)
          context = new IndentContext(context);
        for (let service of context.state.facet(indentService)) {
          let result = service(context, pos);
          if (result != null)
            return result;
        }
        let tree = syntaxTree(context.state);
        return tree ? syntaxIndentation(context, tree, pos) : null;
      }
      function indentRange(state2, from, to) {
        let updated = /* @__PURE__ */ Object.create(null);
        let context = new IndentContext(state2, { overrideIndentation: (start) => {
          var _a2;
          return (_a2 = updated[start]) !== null && _a2 !== void 0 ? _a2 : -1;
        } });
        let changes = [];
        for (let pos = from; pos <= to; ) {
          let line = state2.doc.lineAt(pos);
          pos = line.to + 1;
          let indent = getIndentation(context, line.from);
          if (indent == null)
            continue;
          if (!/\S/.test(line.text))
            indent = 0;
          let cur = /^\s*/.exec(line.text)[0];
          let norm = indentString(state2, indent);
          if (cur != norm) {
            updated[line.from] = indent;
            changes.push({ from: line.from, to: line.from + cur.length, insert: norm });
          }
        }
        return state2.changes(changes);
      }
      var IndentContext = class {
        constructor(state2, options = {}) {
          this.state = state2;
          this.options = options;
          this.unit = getIndentUnit(state2);
        }
        lineAt(pos, bias = 1) {
          let line = this.state.doc.lineAt(pos);
          let { simulateBreak, simulateDoubleBreak } = this.options;
          if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
            if (simulateDoubleBreak && simulateBreak == pos)
              return { text: "", from: pos };
            else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
              return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };
            else
              return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };
          }
          return line;
        }
        textAfterPos(pos, bias = 1) {
          if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
            return "";
          let { text, from } = this.lineAt(pos, bias);
          return text.slice(pos - from, Math.min(text.length, pos + 100 - from));
        }
        column(pos, bias = 1) {
          let { text, from } = this.lineAt(pos, bias);
          let result = this.countColumn(text, pos - from);
          let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
          if (override > -1)
            result += override - this.countColumn(text, text.search(/\S|$/));
          return result;
        }
        countColumn(line, pos = line.length) {
          return state.countColumn(line, this.state.tabSize, pos);
        }
        lineIndent(pos, bias = 1) {
          let { text, from } = this.lineAt(pos, bias);
          let override = this.options.overrideIndentation;
          if (override) {
            let overriden = override(from);
            if (overriden > -1)
              return overriden;
          }
          return this.countColumn(text, text.search(/\S|$/));
        }
        get simulatedBreak() {
          return this.options.simulateBreak || null;
        }
      };
      var indentNodeProp = new common.NodeProp();
      function syntaxIndentation(cx, ast, pos) {
        return indentFrom(ast.resolveInner(pos).enterUnfinishedNodesBefore(pos), pos, cx);
      }
      function ignoreClosed(cx) {
        return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
      }
      function indentStrategy(tree) {
        let strategy = tree.type.prop(indentNodeProp);
        if (strategy)
          return strategy;
        let first = tree.firstChild, close;
        if (first && (close = first.type.prop(common.NodeProp.closedBy))) {
          let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;
          return (cx) => delimitedStrategy(cx, true, 1, void 0, closed && !ignoreClosed(cx) ? last.from : void 0);
        }
        return tree.parent == null ? topIndent : null;
      }
      function indentFrom(node, pos, base) {
        for (; node; node = node.parent) {
          let strategy = indentStrategy(node);
          if (strategy)
            return strategy(TreeIndentContext.create(base, pos, node));
        }
        return null;
      }
      function topIndent() {
        return 0;
      }
      var TreeIndentContext = class extends IndentContext {
        constructor(base, pos, node) {
          super(base.state, base.options);
          this.base = base;
          this.pos = pos;
          this.node = node;
        }
        static create(base, pos, node) {
          return new TreeIndentContext(base, pos, node);
        }
        get textAfter() {
          return this.textAfterPos(this.pos);
        }
        get baseIndent() {
          let line = this.state.doc.lineAt(this.node.from);
          for (; ; ) {
            let atBreak = this.node.resolve(line.from);
            while (atBreak.parent && atBreak.parent.from == atBreak.from)
              atBreak = atBreak.parent;
            if (isParent(atBreak, this.node))
              break;
            line = this.state.doc.lineAt(atBreak.from);
          }
          return this.lineIndent(line.from);
        }
        continue() {
          let parent = this.node.parent;
          return parent ? indentFrom(parent, this.pos, this.base) : 0;
        }
      };
      function isParent(parent, of) {
        for (let cur = of; cur; cur = cur.parent)
          if (parent == cur)
            return true;
        return false;
      }
      function bracketedAligned(context) {
        let tree = context.node;
        let openToken = tree.childAfter(tree.from), last = tree.lastChild;
        if (!openToken)
          return null;
        let sim = context.options.simulateBreak;
        let openLine = context.state.doc.lineAt(openToken.from);
        let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
        for (let pos = openToken.to; ; ) {
          let next = tree.childAfter(pos);
          if (!next || next == last)
            return null;
          if (!next.type.isSkipped)
            return next.from < lineEnd ? openToken : null;
          pos = next.to;
        }
      }
      function delimitedIndent({ closing, align = true, units = 1 }) {
        return (context) => delimitedStrategy(context, align, units, closing);
      }
      function delimitedStrategy(context, align, units, closing, closedAt) {
        let after = context.textAfter, space = after.match(/^\s*/)[0].length;
        let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;
        let aligned = align ? bracketedAligned(context) : null;
        if (aligned)
          return closed ? context.column(aligned.from) : context.column(aligned.to);
        return context.baseIndent + (closed ? 0 : context.unit * units);
      }
      var flatIndent = (context) => context.baseIndent;
      function continuedIndent({ except, units = 1 } = {}) {
        return (context) => {
          let matchExcept = except && except.test(context.textAfter);
          return context.baseIndent + (matchExcept ? 0 : units * context.unit);
        };
      }
      var DontIndentBeyond = 200;
      function indentOnInput() {
        return state.EditorState.transactionFilter.of((tr) => {
          if (!tr.docChanged || !tr.isUserEvent("input.type") && !tr.isUserEvent("input.complete"))
            return tr;
          let rules = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
          if (!rules.length)
            return tr;
          let doc = tr.newDoc, { head } = tr.newSelection.main, line = doc.lineAt(head);
          if (head > line.from + DontIndentBeyond)
            return tr;
          let lineStart = doc.sliceString(line.from, head);
          if (!rules.some((r) => r.test(lineStart)))
            return tr;
          let { state: state2 } = tr, last = -1, changes = [];
          for (let { head: head2 } of state2.selection.ranges) {
            let line2 = state2.doc.lineAt(head2);
            if (line2.from == last)
              continue;
            last = line2.from;
            let indent = getIndentation(state2, line2.from);
            if (indent == null)
              continue;
            let cur = /^\s*/.exec(line2.text)[0];
            let norm = indentString(state2, indent);
            if (cur != norm)
              changes.push({ from: line2.from, to: line2.from + cur.length, insert: norm });
          }
          return changes.length ? [tr, { changes, sequential: true }] : tr;
        });
      }
      var foldService = state.Facet.define();
      var foldNodeProp = new common.NodeProp();
      function foldInside(node) {
        let first = node.firstChild, last = node.lastChild;
        return first && first.to < last.from ? { from: first.to, to: last.type.isError ? node.to : last.from } : null;
      }
      function syntaxFolding(state2, start, end) {
        let tree = syntaxTree(state2);
        if (tree.length < end)
          return null;
        let inner = tree.resolveInner(end);
        let found = null;
        for (let cur = inner; cur; cur = cur.parent) {
          if (cur.to <= end || cur.from > end)
            continue;
          if (found && cur.from < start)
            break;
          let prop = cur.type.prop(foldNodeProp);
          if (prop && (cur.to < tree.length - 50 || tree.length == state2.doc.length || !isUnfinished(cur))) {
            let value = prop(cur, state2);
            if (value && value.from <= end && value.from >= start && value.to > end)
              found = value;
          }
        }
        return found;
      }
      function isUnfinished(node) {
        let ch = node.lastChild;
        return ch && ch.to == node.to && ch.type.isError;
      }
      function foldable(state2, lineStart, lineEnd) {
        for (let service of state2.facet(foldService)) {
          let result = service(state2, lineStart, lineEnd);
          if (result)
            return result;
        }
        return syntaxFolding(state2, lineStart, lineEnd);
      }
      function mapRange(range, mapping) {
        let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);
        return from >= to ? void 0 : { from, to };
      }
      var foldEffect = state.StateEffect.define({ map: mapRange });
      var unfoldEffect = state.StateEffect.define({ map: mapRange });
      function selectedLines(view2) {
        let lines = [];
        for (let { head } of view2.state.selection.ranges) {
          if (lines.some((l) => l.from <= head && l.to >= head))
            continue;
          lines.push(view2.lineBlockAt(head));
        }
        return lines;
      }
      var foldState = state.StateField.define({
        create() {
          return view.Decoration.none;
        },
        update(folded, tr) {
          folded = folded.map(tr.changes);
          for (let e of tr.effects) {
            if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to))
              folded = folded.update({ add: [foldWidget.range(e.value.from, e.value.to)] });
            else if (e.is(unfoldEffect))
              folded = folded.update({
                filter: (from, to) => e.value.from != from || e.value.to != to,
                filterFrom: e.value.from,
                filterTo: e.value.to
              });
          }
          if (tr.selection) {
            let onSelection = false, { head } = tr.selection.main;
            folded.between(head, head, (a, b) => {
              if (a < head && b > head)
                onSelection = true;
            });
            if (onSelection)
              folded = folded.update({
                filterFrom: head,
                filterTo: head,
                filter: (a, b) => b <= head || a >= head
              });
          }
          return folded;
        },
        provide: (f) => view.EditorView.decorations.from(f),
        toJSON(folded, state2) {
          let ranges = [];
          folded.between(0, state2.doc.length, (from, to) => {
            ranges.push(from, to);
          });
          return ranges;
        },
        fromJSON(value) {
          if (!Array.isArray(value) || value.length % 2)
            throw new RangeError("Invalid JSON for fold state");
          let ranges = [];
          for (let i = 0; i < value.length; ) {
            let from = value[i++], to = value[i++];
            if (typeof from != "number" || typeof to != "number")
              throw new RangeError("Invalid JSON for fold state");
            ranges.push(foldWidget.range(from, to));
          }
          return view.Decoration.set(ranges, true);
        }
      });
      function foldedRanges(state$1) {
        return state$1.field(foldState, false) || state.RangeSet.empty;
      }
      function findFold(state2, from, to) {
        var _a2;
        let found = null;
        (_a2 = state2.field(foldState, false)) === null || _a2 === void 0 ? void 0 : _a2.between(from, to, (from2, to2) => {
          if (!found || found.from > from2)
            found = { from: from2, to: to2 };
        });
        return found;
      }
      function foldExists(folded, from, to) {
        let found = false;
        folded.between(from, from, (a, b) => {
          if (a == from && b == to)
            found = true;
        });
        return found;
      }
      function maybeEnable(state$1, other) {
        return state$1.field(foldState, false) ? other : other.concat(state.StateEffect.appendConfig.of(codeFolding()));
      }
      var foldCode = (view2) => {
        for (let line of selectedLines(view2)) {
          let range = foldable(view2.state, line.from, line.to);
          if (range) {
            view2.dispatch({ effects: maybeEnable(view2.state, [foldEffect.of(range), announceFold(view2, range)]) });
            return true;
          }
        }
        return false;
      };
      var unfoldCode = (view2) => {
        if (!view2.state.field(foldState, false))
          return false;
        let effects = [];
        for (let line of selectedLines(view2)) {
          let folded = findFold(view2.state, line.from, line.to);
          if (folded)
            effects.push(unfoldEffect.of(folded), announceFold(view2, folded, false));
        }
        if (effects.length)
          view2.dispatch({ effects });
        return effects.length > 0;
      };
      function announceFold(view$1, range, fold = true) {
        let lineFrom = view$1.state.doc.lineAt(range.from).number, lineTo = view$1.state.doc.lineAt(range.to).number;
        return view.EditorView.announce.of(`${view$1.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view$1.state.phrase("to")} ${lineTo}.`);
      }
      var foldAll = (view2) => {
        let { state: state2 } = view2, effects = [];
        for (let pos = 0; pos < state2.doc.length; ) {
          let line = view2.lineBlockAt(pos), range = foldable(state2, line.from, line.to);
          if (range)
            effects.push(foldEffect.of(range));
          pos = (range ? view2.lineBlockAt(range.to) : line).to + 1;
        }
        if (effects.length)
          view2.dispatch({ effects: maybeEnable(view2.state, effects) });
        return !!effects.length;
      };
      var unfoldAll = (view2) => {
        let field = view2.state.field(foldState, false);
        if (!field || !field.size)
          return false;
        let effects = [];
        field.between(0, view2.state.doc.length, (from, to) => {
          effects.push(unfoldEffect.of({ from, to }));
        });
        view2.dispatch({ effects });
        return true;
      };
      var foldKeymap = [
        { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: foldCode },
        { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: unfoldCode },
        { key: "Ctrl-Alt-[", run: foldAll },
        { key: "Ctrl-Alt-]", run: unfoldAll }
      ];
      var defaultConfig = {
        placeholderDOM: null,
        placeholderText: "\u2026"
      };
      var foldConfig = state.Facet.define({
        combine(values) {
          return state.combineConfig(values, defaultConfig);
        }
      });
      function codeFolding(config) {
        let result = [foldState, baseTheme$1];
        if (config)
          result.push(foldConfig.of(config));
        return result;
      }
      var foldWidget = view.Decoration.replace({ widget: new class extends view.WidgetType {
        toDOM(view2) {
          let { state: state2 } = view2, conf = state2.facet(foldConfig);
          let onclick = (event) => {
            let line = view2.lineBlockAt(view2.posAtDOM(event.target));
            let folded = findFold(view2.state, line.from, line.to);
            if (folded)
              view2.dispatch({ effects: unfoldEffect.of(folded) });
            event.preventDefault();
          };
          if (conf.placeholderDOM)
            return conf.placeholderDOM(view2, onclick);
          let element = document.createElement("span");
          element.textContent = conf.placeholderText;
          element.setAttribute("aria-label", state2.phrase("folded code"));
          element.title = state2.phrase("unfold");
          element.className = "cm-foldPlaceholder";
          element.onclick = onclick;
          return element;
        }
      }() });
      var foldGutterDefaults = {
        openText: "\u2304",
        closedText: "\u203A",
        markerDOM: null,
        domEventHandlers: {},
        foldingChanged: () => false
      };
      var FoldMarker = class extends view.GutterMarker {
        constructor(config, open2) {
          super();
          this.config = config;
          this.open = open2;
        }
        eq(other) {
          return this.config == other.config && this.open == other.open;
        }
        toDOM(view2) {
          if (this.config.markerDOM)
            return this.config.markerDOM(this.open);
          let span = document.createElement("span");
          span.textContent = this.open ? this.config.openText : this.config.closedText;
          span.title = view2.state.phrase(this.open ? "Fold line" : "Unfold line");
          return span;
        }
      };
      function foldGutter(config = {}) {
        let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);
        let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);
        let markers = view.ViewPlugin.fromClass(class {
          constructor(view2) {
            this.from = view2.viewport.from;
            this.markers = this.buildMarkers(view2);
          }
          update(update) {
            if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false) || syntaxTree(update.startState) != syntaxTree(update.state) || fullConfig.foldingChanged(update))
              this.markers = this.buildMarkers(update.view);
          }
          buildMarkers(view2) {
            let builder = new state.RangeSetBuilder();
            for (let line of view2.viewportLineBlocks) {
              let mark = findFold(view2.state, line.from, line.to) ? canUnfold : foldable(view2.state, line.from, line.to) ? canFold : null;
              if (mark)
                builder.add(line.from, line.from, mark);
            }
            return builder.finish();
          }
        });
        let { domEventHandlers } = fullConfig;
        return [
          markers,
          view.gutter({
            class: "cm-foldGutter",
            markers(view2) {
              var _a2;
              return ((_a2 = view2.plugin(markers)) === null || _a2 === void 0 ? void 0 : _a2.markers) || state.RangeSet.empty;
            },
            initialSpacer() {
              return new FoldMarker(fullConfig, false);
            },
            domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), { click: (view2, line, event) => {
              if (domEventHandlers.click && domEventHandlers.click(view2, line, event))
                return true;
              let folded = findFold(view2.state, line.from, line.to);
              if (folded) {
                view2.dispatch({ effects: unfoldEffect.of(folded) });
                return true;
              }
              let range = foldable(view2.state, line.from, line.to);
              if (range) {
                view2.dispatch({ effects: foldEffect.of(range) });
                return true;
              }
              return false;
            } })
          }),
          codeFolding()
        ];
      }
      var baseTheme$1 = view.EditorView.baseTheme({
        ".cm-foldPlaceholder": {
          backgroundColor: "#eee",
          border: "1px solid #ddd",
          color: "#888",
          borderRadius: ".2em",
          margin: "0 1px",
          padding: "0 1px",
          cursor: "pointer"
        },
        ".cm-foldGutter span": {
          padding: "0 1px",
          cursor: "pointer"
        }
      });
      var HighlightStyle = class {
        constructor(spec, options) {
          let modSpec;
          function def(spec2) {
            let cls = styleMod.StyleModule.newName();
            (modSpec || (modSpec = /* @__PURE__ */ Object.create(null)))["." + cls] = spec2;
            return cls;
          }
          const all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : void 0;
          const scopeOpt = options.scope;
          this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type) => type == scopeOpt : void 0;
          this.style = highlight.tagHighlighter(spec.map((style) => ({
            tag: style.tag,
            class: style.class || def(Object.assign({}, style, { tag: null }))
          })), {
            all
          }).style;
          this.module = modSpec ? new styleMod.StyleModule(modSpec) : null;
          this.themeType = options.themeType;
        }
        static define(specs, options) {
          return new HighlightStyle(specs, options || {});
        }
      };
      var highlighterFacet = state.Facet.define();
      var fallbackHighlighter = state.Facet.define({
        combine(values) {
          return values.length ? [values[0]] : null;
        }
      });
      function getHighlighters(state2) {
        let main = state2.facet(highlighterFacet);
        return main.length ? main : state2.facet(fallbackHighlighter);
      }
      function syntaxHighlighting2(highlighter, options) {
        let ext = [treeHighlighter], themeType;
        if (highlighter instanceof HighlightStyle) {
          if (highlighter.module)
            ext.push(view.EditorView.styleModule.of(highlighter.module));
          themeType = highlighter.themeType;
        }
        if (options === null || options === void 0 ? void 0 : options.fallback)
          ext.push(fallbackHighlighter.of(highlighter));
        else if (themeType)
          ext.push(highlighterFacet.computeN([view.EditorView.darkTheme], (state2) => {
            return state2.facet(view.EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
          }));
        else
          ext.push(highlighterFacet.of(highlighter));
        return ext;
      }
      function highlightingFor(state2, tags, scope) {
        let highlighters = getHighlighters(state2);
        let result = null;
        if (highlighters)
          for (let highlighter of highlighters) {
            if (!highlighter.scope || scope && highlighter.scope(scope)) {
              let cls = highlighter.style(tags);
              if (cls)
                result = result ? result + " " + cls : cls;
            }
          }
        return result;
      }
      var TreeHighlighter = class {
        constructor(view2) {
          this.markCache = /* @__PURE__ */ Object.create(null);
          this.tree = syntaxTree(view2.state);
          this.decorations = this.buildDeco(view2, getHighlighters(view2.state));
        }
        update(update) {
          let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);
          let styleChange = highlighters != getHighlighters(update.startState);
          if (tree.length < update.view.viewport.to && !styleChange && tree.type == this.tree.type) {
            this.decorations = this.decorations.map(update.changes);
          } else if (tree != this.tree || update.viewportChanged || styleChange) {
            this.tree = tree;
            this.decorations = this.buildDeco(update.view, highlighters);
          }
        }
        buildDeco(view$1, highlighters) {
          if (!highlighters || !this.tree.length)
            return view.Decoration.none;
          let builder = new state.RangeSetBuilder();
          for (let { from, to } of view$1.visibleRanges) {
            highlight.highlightTree(this.tree, highlighters, (from2, to2, style) => {
              builder.add(from2, to2, this.markCache[style] || (this.markCache[style] = view.Decoration.mark({ class: style })));
            }, from, to);
          }
          return builder.finish();
        }
      };
      var treeHighlighter = state.Prec.high(view.ViewPlugin.fromClass(TreeHighlighter, {
        decorations: (v) => v.decorations
      }));
      var defaultHighlightStyle2 = HighlightStyle.define([
        {
          tag: highlight.tags.meta,
          color: "#7a757a"
        },
        {
          tag: highlight.tags.link,
          textDecoration: "underline"
        },
        {
          tag: highlight.tags.heading,
          textDecoration: "underline",
          fontWeight: "bold"
        },
        {
          tag: highlight.tags.emphasis,
          fontStyle: "italic"
        },
        {
          tag: highlight.tags.strong,
          fontWeight: "bold"
        },
        {
          tag: highlight.tags.strikethrough,
          textDecoration: "line-through"
        },
        {
          tag: highlight.tags.keyword,
          color: "#708"
        },
        {
          tag: [highlight.tags.atom, highlight.tags.bool, highlight.tags.url, highlight.tags.contentSeparator, highlight.tags.labelName],
          color: "#219"
        },
        {
          tag: [highlight.tags.literal, highlight.tags.inserted],
          color: "#164"
        },
        {
          tag: [highlight.tags.string, highlight.tags.deleted],
          color: "#a11"
        },
        {
          tag: [highlight.tags.regexp, highlight.tags.escape, highlight.tags.special(highlight.tags.string)],
          color: "#e40"
        },
        {
          tag: highlight.tags.definition(highlight.tags.variableName),
          color: "#00f"
        },
        {
          tag: highlight.tags.local(highlight.tags.variableName),
          color: "#30a"
        },
        {
          tag: [highlight.tags.typeName, highlight.tags.namespace],
          color: "#085"
        },
        {
          tag: highlight.tags.className,
          color: "#167"
        },
        {
          tag: [highlight.tags.special(highlight.tags.variableName), highlight.tags.macroName],
          color: "#256"
        },
        {
          tag: highlight.tags.definition(highlight.tags.propertyName),
          color: "#00c"
        },
        {
          tag: highlight.tags.comment,
          color: "#940"
        },
        {
          tag: highlight.tags.invalid,
          color: "#f00"
        }
      ]);
      var baseTheme = view.EditorView.baseTheme({
        "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
        "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
      });
      var DefaultScanDist = 1e4;
      var DefaultBrackets = "()[]{}";
      var bracketMatchingConfig = state.Facet.define({
        combine(configs) {
          return state.combineConfig(configs, {
            afterCursor: true,
            brackets: DefaultBrackets,
            maxScanDistance: DefaultScanDist,
            renderMatch: defaultRenderMatch
          });
        }
      });
      var matchingMark = view.Decoration.mark({ class: "cm-matchingBracket" });
      var nonmatchingMark = view.Decoration.mark({ class: "cm-nonmatchingBracket" });
      function defaultRenderMatch(match) {
        let decorations = [];
        let mark = match.matched ? matchingMark : nonmatchingMark;
        decorations.push(mark.range(match.start.from, match.start.to));
        if (match.end)
          decorations.push(mark.range(match.end.from, match.end.to));
        return decorations;
      }
      var bracketMatchingState = state.StateField.define({
        create() {
          return view.Decoration.none;
        },
        update(deco, tr) {
          if (!tr.docChanged && !tr.selection)
            return deco;
          let decorations = [];
          let config = tr.state.facet(bracketMatchingConfig);
          for (let range of tr.state.selection.ranges) {
            if (!range.empty)
              continue;
            let match = matchBrackets(tr.state, range.head, -1, config) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config) || config.afterCursor && (matchBrackets(tr.state, range.head, 1, config) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config));
            if (match)
              decorations = decorations.concat(config.renderMatch(match, tr.state));
          }
          return view.Decoration.set(decorations, true);
        },
        provide: (f) => view.EditorView.decorations.from(f)
      });
      var bracketMatchingUnique = [
        bracketMatchingState,
        baseTheme
      ];
      function bracketMatching(config = {}) {
        return [bracketMatchingConfig.of(config), bracketMatchingUnique];
      }
      function matchingNodes(node, dir, brackets) {
        let byProp = node.prop(dir < 0 ? common.NodeProp.openedBy : common.NodeProp.closedBy);
        if (byProp)
          return byProp;
        if (node.name.length == 1) {
          let index = brackets.indexOf(node.name);
          if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))
            return [brackets[index + dir]];
        }
        return null;
      }
      function matchBrackets(state2, pos, dir, config = {}) {
        let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;
        let tree = syntaxTree(state2), node = tree.resolveInner(pos, dir);
        for (let cur = node; cur; cur = cur.parent) {
          let matches = matchingNodes(cur.type, dir, brackets);
          if (matches && cur.from < cur.to)
            return matchMarkedBrackets(state2, pos, dir, cur, matches, brackets);
        }
        return matchPlainBrackets(state2, pos, dir, tree, node.type, maxScanDistance, brackets);
      }
      function matchMarkedBrackets(_state, _pos, dir, token, matching, brackets) {
        let parent = token.parent, firstToken = { from: token.from, to: token.to };
        let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();
        if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))
          do {
            if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {
              if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {
                return { start: firstToken, end: { from: cursor.from, to: cursor.to }, matched: true };
              } else if (matchingNodes(cursor.type, dir, brackets)) {
                depth++;
              } else if (matchingNodes(cursor.type, -dir, brackets)) {
                if (depth == 0)
                  return {
                    start: firstToken,
                    end: cursor.from == cursor.to ? void 0 : { from: cursor.from, to: cursor.to },
                    matched: false
                  };
                depth--;
              }
            }
          } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());
        return { start: firstToken, matched: false };
      }
      function matchPlainBrackets(state2, pos, dir, tree, tokenType, maxScanDistance, brackets) {
        let startCh = dir < 0 ? state2.sliceDoc(pos - 1, pos) : state2.sliceDoc(pos, pos + 1);
        let bracket = brackets.indexOf(startCh);
        if (bracket < 0 || bracket % 2 == 0 != dir > 0)
          return null;
        let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };
        let iter = state2.doc.iterRange(pos, dir > 0 ? state2.doc.length : 0), depth = 0;
        for (let distance = 0; !iter.next().done && distance <= maxScanDistance; ) {
          let text = iter.value;
          if (dir < 0)
            distance += text.length;
          let basePos = pos + distance * dir;
          for (let pos2 = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos2 != end; pos2 += dir) {
            let found = brackets.indexOf(text[pos2]);
            if (found < 0 || tree.resolveInner(basePos + pos2, 1).type != tokenType)
              continue;
            if (found % 2 == 0 == dir > 0) {
              depth++;
            } else if (depth == 1) {
              return { start: startToken, end: { from: basePos + pos2, to: basePos + pos2 + 1 }, matched: found >> 1 == bracket >> 1 };
            } else {
              depth--;
            }
          }
          if (dir > 0)
            distance += text.length;
        }
        return iter.done ? { start: startToken, matched: false } : null;
      }
      function countCol(string, end, tabSize, startIndex = 0, startValue = 0) {
        if (end == null) {
          end = string.search(/[^\s\u00a0]/);
          if (end == -1)
            end = string.length;
        }
        let n = startValue;
        for (let i = startIndex; i < end; i++) {
          if (string.charCodeAt(i) == 9)
            n += tabSize - n % tabSize;
          else
            n++;
        }
        return n;
      }
      var StringStream = class {
        constructor(string, tabSize, indentUnit2) {
          this.string = string;
          this.tabSize = tabSize;
          this.indentUnit = indentUnit2;
          this.pos = 0;
          this.start = 0;
          this.lastColumnPos = 0;
          this.lastColumnValue = 0;
        }
        eol() {
          return this.pos >= this.string.length;
        }
        sol() {
          return this.pos == 0;
        }
        peek() {
          return this.string.charAt(this.pos) || void 0;
        }
        next() {
          if (this.pos < this.string.length)
            return this.string.charAt(this.pos++);
        }
        eat(match) {
          let ch = this.string.charAt(this.pos);
          let ok;
          if (typeof match == "string")
            ok = ch == match;
          else
            ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));
          if (ok) {
            ++this.pos;
            return ch;
          }
        }
        eatWhile(match) {
          let start = this.pos;
          while (this.eat(match)) {
          }
          return this.pos > start;
        }
        eatSpace() {
          let start = this.pos;
          while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
            ++this.pos;
          return this.pos > start;
        }
        skipToEnd() {
          this.pos = this.string.length;
        }
        skipTo(ch) {
          let found = this.string.indexOf(ch, this.pos);
          if (found > -1) {
            this.pos = found;
            return true;
          }
        }
        backUp(n) {
          this.pos -= n;
        }
        column() {
          if (this.lastColumnPos < this.start) {
            this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
            this.lastColumnPos = this.start;
          }
          return this.lastColumnValue;
        }
        indentation() {
          return countCol(this.string, null, this.tabSize);
        }
        match(pattern, consume, caseInsensitive) {
          if (typeof pattern == "string") {
            let cased = (str) => caseInsensitive ? str.toLowerCase() : str;
            let substr = this.string.substr(this.pos, pattern.length);
            if (cased(substr) == cased(pattern)) {
              if (consume !== false)
                this.pos += pattern.length;
              return true;
            } else
              return null;
          } else {
            let match = this.string.slice(this.pos).match(pattern);
            if (match && match.index > 0)
              return null;
            if (match && consume !== false)
              this.pos += match[0].length;
            return match;
          }
        }
        current() {
          return this.string.slice(this.start, this.pos);
        }
      };
      function fullParser(spec) {
        return {
          token: spec.token,
          blankLine: spec.blankLine || (() => {
          }),
          startState: spec.startState || (() => true),
          copyState: spec.copyState || defaultCopyState,
          indent: spec.indent || (() => null),
          languageData: spec.languageData || {},
          tokenTable: spec.tokenTable || noTokens
        };
      }
      function defaultCopyState(state2) {
        if (typeof state2 != "object")
          return state2;
        let newState = {};
        for (let prop in state2) {
          let val = state2[prop];
          newState[prop] = val instanceof Array ? val.slice() : val;
        }
        return newState;
      }
      var StreamLanguage = class extends Language {
        constructor(parser) {
          let data = defineLanguageFacet(parser.languageData);
          let p = fullParser(parser), self2;
          let impl = new class extends common.Parser {
            createParse(input, fragments, ranges) {
              return new Parse(self2, input, fragments, ranges);
            }
          }();
          super(data, impl, [indentService.of((cx, pos) => this.getIndent(cx, pos))]);
          this.topNode = docID(data);
          self2 = this;
          this.streamParser = p;
          this.stateAfter = new common.NodeProp({ perNode: true });
          this.tokenTable = parser.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable;
        }
        static define(spec) {
          return new StreamLanguage(spec);
        }
        getIndent(cx, pos) {
          let tree = syntaxTree(cx.state), at = tree.resolve(pos);
          while (at && at.type != this.topNode)
            at = at.parent;
          if (!at)
            return null;
          let start = findState(this, tree, 0, at.from, pos), statePos, state2;
          if (start) {
            state2 = start.state;
            statePos = start.pos + 1;
          } else {
            state2 = this.streamParser.startState(cx.unit);
            statePos = 0;
          }
          if (pos - statePos > 1e4)
            return null;
          while (statePos < pos) {
            let line = cx.state.doc.lineAt(statePos), end = Math.min(pos, line.to);
            if (line.length) {
              let stream = new StringStream(line.text, cx.state.tabSize, cx.unit);
              while (stream.pos < end - line.from)
                readToken(this.streamParser.token, stream, state2);
            } else {
              this.streamParser.blankLine(state2, cx.unit);
            }
            if (end == pos)
              break;
            statePos = line.to + 1;
          }
          let { text } = cx.lineAt(pos);
          return this.streamParser.indent(state2, /^\s*(.*)/.exec(text)[1], cx);
        }
        get allowsNesting() {
          return false;
        }
      };
      function findState(lang, tree, off, startPos, before) {
        let state2 = off >= startPos && off + tree.length <= before && tree.prop(lang.stateAfter);
        if (state2)
          return { state: lang.streamParser.copyState(state2), pos: off + tree.length };
        for (let i = tree.children.length - 1; i >= 0; i--) {
          let child = tree.children[i], pos = off + tree.positions[i];
          let found = child instanceof common.Tree && pos < before && findState(lang, child, pos, startPos, before);
          if (found)
            return found;
        }
        return null;
      }
      function cutTree(lang, tree, from, to, inside) {
        if (inside && from <= 0 && to >= tree.length)
          return tree;
        if (!inside && tree.type == lang.topNode)
          inside = true;
        for (let i = tree.children.length - 1; i >= 0; i--) {
          let pos = tree.positions[i], child = tree.children[i], inner;
          if (pos < to && child instanceof common.Tree) {
            if (!(inner = cutTree(lang, child, from - pos, to - pos, inside)))
              break;
            return !inside ? inner : new common.Tree(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);
          }
        }
        return null;
      }
      function findStartInFragments(lang, fragments, startPos, editorState) {
        for (let f of fragments) {
          let from = f.from + (f.openStart ? 25 : 0), to = f.to - (f.openEnd ? 25 : 0);
          let found = from <= startPos && to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, to), tree;
          if (found && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false)))
            return { state: found.state, tree };
        }
        return { state: lang.streamParser.startState(editorState ? getIndentUnit(editorState) : 4), tree: common.Tree.empty };
      }
      var Parse = class {
        constructor(lang, input, fragments, ranges) {
          this.lang = lang;
          this.input = input;
          this.fragments = fragments;
          this.ranges = ranges;
          this.stoppedAt = null;
          this.chunks = [];
          this.chunkPos = [];
          this.chunk = [];
          this.chunkReused = void 0;
          this.rangeIndex = 0;
          this.to = ranges[ranges.length - 1].to;
          let context = ParseContext.get(), from = ranges[0].from;
          let { state: state2, tree } = findStartInFragments(lang, fragments, from, context === null || context === void 0 ? void 0 : context.state);
          this.state = state2;
          this.parsedPos = this.chunkStart = from + tree.length;
          for (let i = 0; i < tree.children.length; i++) {
            this.chunks.push(tree.children[i]);
            this.chunkPos.push(tree.positions[i]);
          }
          if (context && this.parsedPos < context.viewport.from - 1e5) {
            this.state = this.lang.streamParser.startState(getIndentUnit(context.state));
            context.skipUntilInView(this.parsedPos, context.viewport.from);
            this.parsedPos = context.viewport.from;
          }
          this.moveRangeIndex();
        }
        advance() {
          let context = ParseContext.get();
          let parseEnd = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt);
          let end = Math.min(parseEnd, this.chunkStart + 2048);
          if (context)
            end = Math.min(end, context.viewport.to);
          while (this.parsedPos < end)
            this.parseLine(context);
          if (this.chunkStart < this.parsedPos)
            this.finishChunk();
          if (this.parsedPos >= parseEnd)
            return this.finish();
          if (context && this.parsedPos >= context.viewport.to) {
            context.skipUntilInView(this.parsedPos, parseEnd);
            return this.finish();
          }
          return null;
        }
        stopAt(pos) {
          this.stoppedAt = pos;
        }
        lineAfter(pos) {
          let chunk = this.input.chunk(pos);
          if (!this.input.lineChunks) {
            let eol = chunk.indexOf("\n");
            if (eol > -1)
              chunk = chunk.slice(0, eol);
          } else if (chunk == "\n") {
            chunk = "";
          }
          return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);
        }
        nextLine() {
          let from = this.parsedPos, line = this.lineAfter(from), end = from + line.length;
          for (let index = this.rangeIndex; ; ) {
            let rangeEnd = this.ranges[index].to;
            if (rangeEnd >= end)
              break;
            line = line.slice(0, rangeEnd - (end - line.length));
            index++;
            if (index == this.ranges.length)
              break;
            let rangeStart = this.ranges[index].from;
            let after = this.lineAfter(rangeStart);
            line += after;
            end = rangeStart + after.length;
          }
          return { line, end };
        }
        skipGapsTo(pos, offset, side) {
          for (; ; ) {
            let end = this.ranges[this.rangeIndex].to, offPos = pos + offset;
            if (side > 0 ? end > offPos : end >= offPos)
              break;
            let start = this.ranges[++this.rangeIndex].from;
            offset += start - end;
          }
          return offset;
        }
        moveRangeIndex() {
          while (this.ranges[this.rangeIndex].to < this.parsedPos)
            this.rangeIndex++;
        }
        emitToken(id, from, to, size, offset) {
          if (this.ranges.length > 1) {
            offset = this.skipGapsTo(from, offset, 1);
            from += offset;
            let len0 = this.chunk.length;
            offset = this.skipGapsTo(to, offset, -1);
            to += offset;
            size += this.chunk.length - len0;
          }
          this.chunk.push(id, from, to, size);
          return offset;
        }
        parseLine(context) {
          let { line, end } = this.nextLine(), offset = 0, { streamParser } = this.lang;
          let stream = new StringStream(line, context ? context.state.tabSize : 4, context ? getIndentUnit(context.state) : 2);
          if (stream.eol()) {
            streamParser.blankLine(this.state, stream.indentUnit);
          } else {
            while (!stream.eol()) {
              let token = readToken(streamParser.token, stream, this.state);
              if (token)
                offset = this.emitToken(this.lang.tokenTable.resolve(token), this.parsedPos + stream.start, this.parsedPos + stream.pos, 4, offset);
              if (stream.start > 1e4)
                break;
            }
          }
          this.parsedPos = end;
          this.moveRangeIndex();
          if (this.parsedPos < this.to)
            this.parsedPos++;
        }
        finishChunk() {
          let tree = common.Tree.build({
            buffer: this.chunk,
            start: this.chunkStart,
            length: this.parsedPos - this.chunkStart,
            nodeSet,
            topID: 0,
            maxBufferLength: 2048,
            reused: this.chunkReused
          });
          tree = new common.Tree(tree.type, tree.children, tree.positions, tree.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]);
          this.chunks.push(tree);
          this.chunkPos.push(this.chunkStart - this.ranges[0].from);
          this.chunk = [];
          this.chunkReused = void 0;
          this.chunkStart = this.parsedPos;
        }
        finish() {
          return new common.Tree(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();
        }
      };
      function readToken(token, stream, state2) {
        stream.start = stream.pos;
        for (let i = 0; i < 10; i++) {
          let result = token(stream, state2);
          if (stream.pos > stream.start)
            return result;
        }
        throw new Error("Stream parser failed to advance stream.");
      }
      var noTokens = /* @__PURE__ */ Object.create(null);
      var typeArray = [common.NodeType.none];
      var nodeSet = new common.NodeSet(typeArray);
      var warned = [];
      var defaultTable = /* @__PURE__ */ Object.create(null);
      for (let [legacyName, name] of [
        ["variable", "variableName"],
        ["variable-2", "variableName.special"],
        ["string-2", "string.special"],
        ["def", "variableName.definition"],
        ["tag", "tagName"],
        ["attribute", "attributeName"],
        ["type", "typeName"],
        ["builtin", "variableName.standard"],
        ["qualifier", "modifier"],
        ["error", "invalid"],
        ["header", "heading"],
        ["property", "propertyName"]
      ])
        defaultTable[legacyName] = createTokenType(noTokens, name);
      var TokenTable = class {
        constructor(extra) {
          this.extra = extra;
          this.table = Object.assign(/* @__PURE__ */ Object.create(null), defaultTable);
        }
        resolve(tag) {
          return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));
        }
      };
      var defaultTokenTable = new TokenTable(noTokens);
      function warnForPart(part, msg) {
        if (warned.indexOf(part) > -1)
          return;
        warned.push(part);
        console.warn(msg);
      }
      function createTokenType(extra, tagStr) {
        let tag = null;
        for (let part of tagStr.split(".")) {
          let value = extra[part] || highlight.tags[part];
          if (!value) {
            warnForPart(part, `Unknown highlighting tag ${part}`);
          } else if (typeof value == "function") {
            if (!tag)
              warnForPart(part, `Modifier ${part} used at start of tag`);
            else
              tag = value(tag);
          } else {
            if (tag)
              warnForPart(part, `Tag ${part} used as modifier`);
            else
              tag = value;
          }
        }
        if (!tag)
          return 0;
        let name = tagStr.replace(/ /g, "_"), type = common.NodeType.define({
          id: typeArray.length,
          name,
          props: [highlight.styleTags({ [name]: tag })]
        });
        typeArray.push(type);
        return type.id;
      }
      function docID(data) {
        let type = common.NodeType.define({ id: typeArray.length, name: "Document", props: [languageDataProp.add(() => data)] });
        typeArray.push(type);
        return type;
      }
      exports.HighlightStyle = HighlightStyle;
      exports.IndentContext = IndentContext;
      exports.LRLanguage = LRLanguage;
      exports.Language = Language;
      exports.LanguageDescription = LanguageDescription;
      exports.LanguageSupport = LanguageSupport;
      exports.ParseContext = ParseContext;
      exports.StreamLanguage = StreamLanguage;
      exports.StringStream = StringStream;
      exports.TreeIndentContext = TreeIndentContext;
      exports.bracketMatching = bracketMatching;
      exports.codeFolding = codeFolding;
      exports.continuedIndent = continuedIndent;
      exports.defaultHighlightStyle = defaultHighlightStyle2;
      exports.defineLanguageFacet = defineLanguageFacet;
      exports.delimitedIndent = delimitedIndent;
      exports.ensureSyntaxTree = ensureSyntaxTree;
      exports.flatIndent = flatIndent;
      exports.foldAll = foldAll;
      exports.foldCode = foldCode;
      exports.foldEffect = foldEffect;
      exports.foldGutter = foldGutter;
      exports.foldInside = foldInside;
      exports.foldKeymap = foldKeymap;
      exports.foldNodeProp = foldNodeProp;
      exports.foldService = foldService;
      exports.foldState = foldState;
      exports.foldable = foldable;
      exports.foldedRanges = foldedRanges;
      exports.forceParsing = forceParsing;
      exports.getIndentUnit = getIndentUnit;
      exports.getIndentation = getIndentation;
      exports.highlightingFor = highlightingFor;
      exports.indentNodeProp = indentNodeProp;
      exports.indentOnInput = indentOnInput;
      exports.indentRange = indentRange;
      exports.indentService = indentService;
      exports.indentString = indentString;
      exports.indentUnit = indentUnit;
      exports.language = language;
      exports.languageDataProp = languageDataProp;
      exports.matchBrackets = matchBrackets;
      exports.syntaxHighlighting = syntaxHighlighting2;
      exports.syntaxParserRunning = syntaxParserRunning;
      exports.syntaxTree = syntaxTree;
      exports.syntaxTreeAvailable = syntaxTreeAvailable;
      exports.unfoldAll = unfoldAll;
      exports.unfoldCode = unfoldCode;
      exports.unfoldEffect = unfoldEffect;
    }
  });

  // node_modules/@codemirror/commands/dist/index.cjs
  var require_dist6 = __commonJS({
    "node_modules/@codemirror/commands/dist/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var state = require_dist();
      var view = require_dist2();
      var language = require_dist5();
      var common = require_dist3();
      var toggleComment = (target) => {
        let config = getConfig(target.state);
        return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;
      };
      function command(f, option) {
        return ({ state: state2, dispatch }) => {
          if (state2.readOnly)
            return false;
          let tr = f(option, state2);
          if (!tr)
            return false;
          dispatch(state2.update(tr));
          return true;
        };
      }
      var toggleLineComment = command(changeLineComment, 0);
      var lineComment = command(changeLineComment, 1);
      var lineUncomment = command(changeLineComment, 2);
      var toggleBlockComment = command(changeBlockComment, 0);
      var blockComment = command(changeBlockComment, 1);
      var blockUncomment = command(changeBlockComment, 2);
      var toggleBlockCommentByLine = command((o, s) => changeBlockComment(o, s, selectedLineRanges(s)), 0);
      function getConfig(state2, pos = state2.selection.main.head) {
        let data = state2.languageDataAt("commentTokens", pos);
        return data.length ? data[0] : {};
      }
      var SearchMargin = 50;
      function findBlockComment(state2, { open: open2, close }, from, to) {
        let textBefore = state2.sliceDoc(from - SearchMargin, from);
        let textAfter = state2.sliceDoc(to, to + SearchMargin);
        let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
        let beforeOff = textBefore.length - spaceBefore;
        if (textBefore.slice(beforeOff - open2.length, beforeOff) == open2 && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
          return {
            open: { pos: from - spaceBefore, margin: spaceBefore && 1 },
            close: { pos: to + spaceAfter, margin: spaceAfter && 1 }
          };
        }
        let startText, endText;
        if (to - from <= 2 * SearchMargin) {
          startText = endText = state2.sliceDoc(from, to);
        } else {
          startText = state2.sliceDoc(from, from + SearchMargin);
          endText = state2.sliceDoc(to - SearchMargin, to);
        }
        let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
        let endOff = endText.length - endSpace - close.length;
        if (startText.slice(startSpace, startSpace + open2.length) == open2 && endText.slice(endOff, endOff + close.length) == close) {
          return {
            open: {
              pos: from + startSpace + open2.length,
              margin: /\s/.test(startText.charAt(startSpace + open2.length)) ? 1 : 0
            },
            close: {
              pos: to - endSpace - close.length,
              margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
            }
          };
        }
        return null;
      }
      function selectedLineRanges(state2) {
        let ranges = [];
        for (let r of state2.selection.ranges) {
          let fromLine = state2.doc.lineAt(r.from);
          let toLine = r.to <= fromLine.to ? fromLine : state2.doc.lineAt(r.to);
          let last = ranges.length - 1;
          if (last >= 0 && ranges[last].to > fromLine.from)
            ranges[last].to = toLine.to;
          else
            ranges.push({ from: fromLine.from, to: toLine.to });
        }
        return ranges;
      }
      function changeBlockComment(option, state2, ranges = state2.selection.ranges) {
        let tokens = ranges.map((r) => getConfig(state2, r.from).block);
        if (!tokens.every((c) => c))
          return null;
        let comments = ranges.map((r, i) => findBlockComment(state2, tokens[i], r.from, r.to));
        if (option != 2 && !comments.every((c) => c)) {
          return { changes: state2.changes(ranges.map((range, i) => {
            if (comments[i])
              return [];
            return [{ from: range.from, insert: tokens[i].open + " " }, { from: range.to, insert: " " + tokens[i].close }];
          })) };
        } else if (option != 1 && comments.some((c) => c)) {
          let changes = [];
          for (let i = 0, comment; i < comments.length; i++)
            if (comment = comments[i]) {
              let token = tokens[i], { open: open2, close } = comment;
              changes.push({ from: open2.pos - token.open.length, to: open2.pos + open2.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });
            }
          return { changes };
        }
        return null;
      }
      function changeLineComment(option, state2, ranges = state2.selection.ranges) {
        let lines = [];
        let prevLine = -1;
        for (let { from, to } of ranges) {
          let startI = lines.length, minIndent = 1e9;
          for (let pos = from; pos <= to; ) {
            let line = state2.doc.lineAt(pos);
            if (line.from > prevLine && (from == to || to > line.from)) {
              prevLine = line.from;
              let token = getConfig(state2, pos).line;
              if (!token)
                continue;
              let indent = /^\s*/.exec(line.text)[0].length;
              let empty = indent == line.length;
              let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;
              if (indent < line.text.length && indent < minIndent)
                minIndent = indent;
              lines.push({ line, comment, token, indent, empty, single: false });
            }
            pos = line.to + 1;
          }
          if (minIndent < 1e9) {
            for (let i = startI; i < lines.length; i++)
              if (lines[i].indent < lines[i].line.text.length)
                lines[i].indent = minIndent;
          }
          if (lines.length == startI + 1)
            lines[startI].single = true;
        }
        if (option != 2 && lines.some((l) => l.comment < 0 && (!l.empty || l.single))) {
          let changes = [];
          for (let { line, token, indent, empty, single } of lines)
            if (single || !empty)
              changes.push({ from: line.from + indent, insert: token + " " });
          let changeSet = state2.changes(changes);
          return { changes: changeSet, selection: state2.selection.map(changeSet, 1) };
        } else if (option != 1 && lines.some((l) => l.comment >= 0)) {
          let changes = [];
          for (let { line, comment, token } of lines)
            if (comment >= 0) {
              let from = line.from + comment, to = from + token.length;
              if (line.text[to - line.from] == " ")
                to++;
              changes.push({ from, to });
            }
          return { changes };
        }
        return null;
      }
      var fromHistory = state.Annotation.define();
      var isolateHistory = state.Annotation.define();
      var invertedEffects = state.Facet.define();
      var historyConfig = state.Facet.define({
        combine(configs) {
          return state.combineConfig(configs, {
            minDepth: 100,
            newGroupDelay: 500
          }, { minDepth: Math.max, newGroupDelay: Math.min });
        }
      });
      function changeEnd(changes) {
        let end = 0;
        changes.iterChangedRanges((_, to) => end = to);
        return end;
      }
      var historyField_ = state.StateField.define({
        create() {
          return HistoryState.empty;
        },
        update(state$1, tr) {
          let config = tr.state.facet(historyConfig);
          let fromHist = tr.annotation(fromHistory);
          if (fromHist) {
            let selection = tr.docChanged ? state.EditorSelection.single(changeEnd(tr.changes)) : void 0;
            let item = HistEvent.fromTransaction(tr, selection), from = fromHist.side;
            let other = from == 0 ? state$1.undone : state$1.done;
            if (item)
              other = updateBranch(other, other.length, config.minDepth, item);
            else
              other = addSelection(other, tr.startState.selection);
            return new HistoryState(from == 0 ? fromHist.rest : other, from == 0 ? other : fromHist.rest);
          }
          let isolate = tr.annotation(isolateHistory);
          if (isolate == "full" || isolate == "before")
            state$1 = state$1.isolate();
          if (tr.annotation(state.Transaction.addToHistory) === false)
            return !tr.changes.empty ? state$1.addMapping(tr.changes.desc) : state$1;
          let event = HistEvent.fromTransaction(tr);
          let time = tr.annotation(state.Transaction.time), userEvent = tr.annotation(state.Transaction.userEvent);
          if (event)
            state$1 = state$1.addChanges(event, time, userEvent, config.newGroupDelay, config.minDepth);
          else if (tr.selection)
            state$1 = state$1.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);
          if (isolate == "full" || isolate == "after")
            state$1 = state$1.isolate();
          return state$1;
        },
        toJSON(value) {
          return { done: value.done.map((e) => e.toJSON()), undone: value.undone.map((e) => e.toJSON()) };
        },
        fromJSON(json) {
          return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
        }
      });
      function history(config = {}) {
        return [
          historyField_,
          historyConfig.of(config),
          view.EditorView.domEventHandlers({
            beforeinput(e, view2) {
              let command2 = e.inputType == "historyUndo" ? undo : e.inputType == "historyRedo" ? redo : null;
              if (!command2)
                return false;
              e.preventDefault();
              return command2(view2);
            }
          })
        ];
      }
      var historyField = historyField_;
      function cmd(side, selection) {
        return function({ state: state2, dispatch }) {
          if (!selection && state2.readOnly)
            return false;
          let historyState = state2.field(historyField_, false);
          if (!historyState)
            return false;
          let tr = historyState.pop(side, state2, selection);
          if (!tr)
            return false;
          dispatch(tr);
          return true;
        };
      }
      var undo = cmd(0, false);
      var redo = cmd(1, false);
      var undoSelection = cmd(0, true);
      var redoSelection = cmd(1, true);
      function depth(side) {
        return function(state2) {
          let histState = state2.field(historyField_, false);
          if (!histState)
            return 0;
          let branch = side == 0 ? histState.done : histState.undone;
          return branch.length - (branch.length && !branch[0].changes ? 1 : 0);
        };
      }
      var undoDepth = depth(0);
      var redoDepth = depth(1);
      var HistEvent = class {
        constructor(changes, effects, mapped, startSelection, selectionsAfter) {
          this.changes = changes;
          this.effects = effects;
          this.mapped = mapped;
          this.startSelection = startSelection;
          this.selectionsAfter = selectionsAfter;
        }
        setSelAfter(after) {
          return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
        }
        toJSON() {
          var _a, _b, _c;
          return {
            changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),
            mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
            startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
            selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
          };
        }
        static fromJSON(json) {
          return new HistEvent(json.changes && state.ChangeSet.fromJSON(json.changes), [], json.mapped && state.ChangeDesc.fromJSON(json.mapped), json.startSelection && state.EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(state.EditorSelection.fromJSON));
        }
        static fromTransaction(tr, selection) {
          let effects = none;
          for (let invert of tr.startState.facet(invertedEffects)) {
            let result = invert(tr);
            if (result.length)
              effects = effects.concat(result);
          }
          if (!effects.length && tr.changes.empty)
            return null;
          return new HistEvent(tr.changes.invert(tr.startState.doc), effects, void 0, selection || tr.startState.selection, none);
        }
        static selection(selections) {
          return new HistEvent(void 0, none, void 0, void 0, selections);
        }
      };
      function updateBranch(branch, to, maxLen, newEvent) {
        let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
        let newBranch = branch.slice(start, to);
        newBranch.push(newEvent);
        return newBranch;
      }
      function isAdjacent(a, b) {
        let ranges = [], isAdjacent2 = false;
        a.iterChangedRanges((f, t) => ranges.push(f, t));
        b.iterChangedRanges((_f, _t, f, t) => {
          for (let i = 0; i < ranges.length; ) {
            let from = ranges[i++], to = ranges[i++];
            if (t >= from && f <= to)
              isAdjacent2 = true;
          }
        });
        return isAdjacent2;
      }
      function eqSelectionShape(a, b) {
        return a.ranges.length == b.ranges.length && a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;
      }
      function conc(a, b) {
        return !a.length ? b : !b.length ? a : a.concat(b);
      }
      var none = [];
      var MaxSelectionsPerEvent = 200;
      function addSelection(branch, selection) {
        if (!branch.length) {
          return [HistEvent.selection([selection])];
        } else {
          let lastEvent = branch[branch.length - 1];
          let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
          if (sels.length && sels[sels.length - 1].eq(selection))
            return branch;
          sels.push(selection);
          return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
        }
      }
      function popSelection(branch) {
        let last = branch[branch.length - 1];
        let newBranch = branch.slice();
        newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
        return newBranch;
      }
      function addMappingToBranch(branch, mapping) {
        if (!branch.length)
          return branch;
        let length = branch.length, selections = none;
        while (length) {
          let event = mapEvent(branch[length - 1], mapping, selections);
          if (event.changes && !event.changes.empty || event.effects.length) {
            let result = branch.slice(0, length);
            result[length - 1] = event;
            return result;
          } else {
            mapping = event.mapped;
            length--;
            selections = event.selectionsAfter;
          }
        }
        return selections.length ? [HistEvent.selection(selections)] : none;
      }
      function mapEvent(event, mapping, extraSelections) {
        let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s) => s.map(mapping)) : none, extraSelections);
        if (!event.changes)
          return HistEvent.selection(selections);
        let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
        let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
        return new HistEvent(mappedChanges, state.StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
      }
      var joinableUserEvent = /^(input\.type|delete)($|\.)/;
      var HistoryState = class {
        constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
          this.done = done;
          this.undone = undone;
          this.prevTime = prevTime;
          this.prevUserEvent = prevUserEvent;
        }
        isolate() {
          return this.prevTime ? new HistoryState(this.done, this.undone) : this;
        }
        addChanges(event, time, userEvent, newGroupDelay, maxLen) {
          let done = this.done, lastEvent = done[done.length - 1];
          if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < newGroupDelay && isAdjacent(lastEvent.changes, event.changes) || userEvent == "input.type.compose")) {
            done = updateBranch(done, done.length - 1, maxLen, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));
          } else {
            done = updateBranch(done, done.length, maxLen, event);
          }
          return new HistoryState(done, none, time, userEvent);
        }
        addSelection(selection, time, userEvent, newGroupDelay) {
          let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;
          if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection))
            return this;
          return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);
        }
        addMapping(mapping) {
          return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
        }
        pop(side, state2, selection) {
          let branch = side == 0 ? this.done : this.undone;
          if (branch.length == 0)
            return null;
          let event = branch[branch.length - 1];
          if (selection && event.selectionsAfter.length) {
            return state2.update({
              selection: event.selectionsAfter[event.selectionsAfter.length - 1],
              annotations: fromHistory.of({ side, rest: popSelection(branch) }),
              userEvent: side == 0 ? "select.undo" : "select.redo",
              scrollIntoView: true
            });
          } else if (!event.changes) {
            return null;
          } else {
            let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);
            if (event.mapped)
              rest = addMappingToBranch(rest, event.mapped);
            return state2.update({
              changes: event.changes,
              selection: event.startSelection,
              effects: event.effects,
              annotations: fromHistory.of({ side, rest }),
              filter: false,
              userEvent: side == 0 ? "undo" : "redo",
              scrollIntoView: true
            });
          }
        }
      };
      HistoryState.empty = new HistoryState(none, none);
      var historyKeymap = [
        { key: "Mod-z", run: undo, preventDefault: true },
        { key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true },
        { linux: "Ctrl-Shift-z", run: redo, preventDefault: true },
        { key: "Mod-u", run: undoSelection, preventDefault: true },
        { key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true }
      ];
      function updateSel(sel, by) {
        return state.EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
      }
      function setSel(state2, selection) {
        return state2.update({ selection, scrollIntoView: true, userEvent: "select" });
      }
      function moveSel({ state: state2, dispatch }, how) {
        let selection = updateSel(state2.selection, how);
        if (selection.eq(state2.selection))
          return false;
        dispatch(setSel(state2, selection));
        return true;
      }
      function rangeEnd(range, forward) {
        return state.EditorSelection.cursor(forward ? range.to : range.from);
      }
      function cursorByChar(view2, forward) {
        return moveSel(view2, (range) => range.empty ? view2.moveByChar(range, forward) : rangeEnd(range, forward));
      }
      function ltrAtCursor(view$1) {
        return view$1.textDirectionAt(view$1.state.selection.main.head) == view.Direction.LTR;
      }
      var cursorCharLeft = (view2) => cursorByChar(view2, !ltrAtCursor(view2));
      var cursorCharRight = (view2) => cursorByChar(view2, ltrAtCursor(view2));
      var cursorCharForward = (view2) => cursorByChar(view2, true);
      var cursorCharBackward = (view2) => cursorByChar(view2, false);
      function cursorByGroup(view2, forward) {
        return moveSel(view2, (range) => range.empty ? view2.moveByGroup(range, forward) : rangeEnd(range, forward));
      }
      var cursorGroupLeft = (view2) => cursorByGroup(view2, !ltrAtCursor(view2));
      var cursorGroupRight = (view2) => cursorByGroup(view2, ltrAtCursor(view2));
      var cursorGroupForward = (view2) => cursorByGroup(view2, true);
      var cursorGroupBackward = (view2) => cursorByGroup(view2, false);
      function moveBySubword(view2, range, forward) {
        let categorize = view2.state.charCategorizer(range.from);
        return view2.moveByChar(range, forward, (start) => {
          let cat = state.CharCategory.Space, pos = range.from;
          let done = false, sawUpper = false, sawLower = false;
          let step = (next) => {
            if (done)
              return false;
            pos += forward ? next.length : -next.length;
            let nextCat = categorize(next), ahead;
            if (cat == state.CharCategory.Space)
              cat = nextCat;
            if (cat != nextCat)
              return false;
            if (cat == state.CharCategory.Word) {
              if (next.toLowerCase() == next) {
                if (!forward && sawUpper)
                  return false;
                sawLower = true;
              } else if (sawLower) {
                if (forward)
                  return false;
                done = true;
              } else {
                if (sawUpper && forward && categorize(ahead = view2.state.sliceDoc(pos, pos + 1)) == state.CharCategory.Word && ahead.toLowerCase() == ahead)
                  return false;
                sawUpper = true;
              }
            }
            return true;
          };
          step(start);
          return step;
        });
      }
      function cursorBySubword(view2, forward) {
        return moveSel(view2, (range) => range.empty ? moveBySubword(view2, range, forward) : rangeEnd(range, forward));
      }
      var cursorSubwordForward = (view2) => cursorBySubword(view2, true);
      var cursorSubwordBackward = (view2) => cursorBySubword(view2, false);
      function interestingNode(state2, node, bracketProp) {
        if (node.type.prop(bracketProp))
          return true;
        let len = node.to - node.from;
        return len && (len > 2 || /[^\s,.;:]/.test(state2.sliceDoc(node.from, node.to))) || node.firstChild;
      }
      function moveBySyntax(state$1, start, forward) {
        let pos = language.syntaxTree(state$1).resolveInner(start.head);
        let bracketProp = forward ? common.NodeProp.closedBy : common.NodeProp.openedBy;
        for (let at = start.head; ; ) {
          let next = forward ? pos.childAfter(at) : pos.childBefore(at);
          if (!next)
            break;
          if (interestingNode(state$1, next, bracketProp))
            pos = next;
          else
            at = forward ? next.to : next.from;
        }
        let bracket = pos.type.prop(bracketProp), match, newPos;
        if (bracket && (match = forward ? language.matchBrackets(state$1, pos.from, 1) : language.matchBrackets(state$1, pos.to, -1)) && match.matched)
          newPos = forward ? match.end.to : match.end.from;
        else
          newPos = forward ? pos.to : pos.from;
        return state.EditorSelection.cursor(newPos, forward ? -1 : 1);
      }
      var cursorSyntaxLeft = (view2) => moveSel(view2, (range) => moveBySyntax(view2.state, range, !ltrAtCursor(view2)));
      var cursorSyntaxRight = (view2) => moveSel(view2, (range) => moveBySyntax(view2.state, range, ltrAtCursor(view2)));
      function cursorByLine(view2, forward) {
        return moveSel(view2, (range) => {
          if (!range.empty)
            return rangeEnd(range, forward);
          let moved = view2.moveVertically(range, forward);
          return moved.head != range.head ? moved : view2.moveToLineBoundary(range, forward);
        });
      }
      var cursorLineUp = (view2) => cursorByLine(view2, false);
      var cursorLineDown = (view2) => cursorByLine(view2, true);
      function pageHeight(view2) {
        return Math.max(view2.defaultLineHeight, Math.min(view2.dom.clientHeight, innerHeight) - 5);
      }
      function cursorByPage(view$1, forward) {
        let { state: state2 } = view$1, selection = updateSel(state2.selection, (range) => {
          return range.empty ? view$1.moveVertically(range, forward, pageHeight(view$1)) : rangeEnd(range, forward);
        });
        if (selection.eq(state2.selection))
          return false;
        let startPos = view$1.coordsAtPos(state2.selection.main.head);
        let scrollRect = view$1.scrollDOM.getBoundingClientRect();
        let effect;
        if (startPos && startPos.top > scrollRect.top && startPos.bottom < scrollRect.bottom && startPos.top - scrollRect.top <= view$1.scrollDOM.scrollHeight - view$1.scrollDOM.scrollTop - view$1.scrollDOM.clientHeight)
          effect = view.EditorView.scrollIntoView(selection.main.head, { y: "start", yMargin: startPos.top - scrollRect.top });
        view$1.dispatch(setSel(state2, selection), { effects: effect });
        return true;
      }
      var cursorPageUp = (view2) => cursorByPage(view2, false);
      var cursorPageDown = (view2) => cursorByPage(view2, true);
      function moveByLineBoundary(view2, start, forward) {
        let line = view2.lineBlockAt(start.head), moved = view2.moveToLineBoundary(start, forward);
        if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
          moved = view2.moveToLineBoundary(start, forward, false);
        if (!forward && moved.head == line.from && line.length) {
          let space = /^\s*/.exec(view2.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
          if (space && start.head != line.from + space)
            moved = state.EditorSelection.cursor(line.from + space);
        }
        return moved;
      }
      var cursorLineBoundaryForward = (view2) => moveSel(view2, (range) => moveByLineBoundary(view2, range, true));
      var cursorLineBoundaryBackward = (view2) => moveSel(view2, (range) => moveByLineBoundary(view2, range, false));
      var cursorLineStart = (view2) => moveSel(view2, (range) => state.EditorSelection.cursor(view2.lineBlockAt(range.head).from, 1));
      var cursorLineEnd = (view2) => moveSel(view2, (range) => state.EditorSelection.cursor(view2.lineBlockAt(range.head).to, -1));
      function toMatchingBracket(state$1, dispatch, extend) {
        let found = false, selection = updateSel(state$1.selection, (range) => {
          let matching = language.matchBrackets(state$1, range.head, -1) || language.matchBrackets(state$1, range.head, 1) || range.head > 0 && language.matchBrackets(state$1, range.head - 1, 1) || range.head < state$1.doc.length && language.matchBrackets(state$1, range.head + 1, -1);
          if (!matching || !matching.end)
            return range;
          found = true;
          let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
          return extend ? state.EditorSelection.range(range.anchor, head) : state.EditorSelection.cursor(head);
        });
        if (!found)
          return false;
        dispatch(setSel(state$1, selection));
        return true;
      }
      var cursorMatchingBracket = ({ state: state2, dispatch }) => toMatchingBracket(state2, dispatch, false);
      var selectMatchingBracket = ({ state: state2, dispatch }) => toMatchingBracket(state2, dispatch, true);
      function extendSel(view2, how) {
        let selection = updateSel(view2.state.selection, (range) => {
          let head = how(range);
          return state.EditorSelection.range(range.anchor, head.head, head.goalColumn);
        });
        if (selection.eq(view2.state.selection))
          return false;
        view2.dispatch(setSel(view2.state, selection));
        return true;
      }
      function selectByChar(view2, forward) {
        return extendSel(view2, (range) => view2.moveByChar(range, forward));
      }
      var selectCharLeft = (view2) => selectByChar(view2, !ltrAtCursor(view2));
      var selectCharRight = (view2) => selectByChar(view2, ltrAtCursor(view2));
      var selectCharForward = (view2) => selectByChar(view2, true);
      var selectCharBackward = (view2) => selectByChar(view2, false);
      function selectByGroup(view2, forward) {
        return extendSel(view2, (range) => view2.moveByGroup(range, forward));
      }
      var selectGroupLeft = (view2) => selectByGroup(view2, !ltrAtCursor(view2));
      var selectGroupRight = (view2) => selectByGroup(view2, ltrAtCursor(view2));
      var selectGroupForward = (view2) => selectByGroup(view2, true);
      var selectGroupBackward = (view2) => selectByGroup(view2, false);
      function selectBySubword(view2, forward) {
        return extendSel(view2, (range) => moveBySubword(view2, range, forward));
      }
      var selectSubwordForward = (view2) => selectBySubword(view2, true);
      var selectSubwordBackward = (view2) => selectBySubword(view2, false);
      var selectSyntaxLeft = (view2) => extendSel(view2, (range) => moveBySyntax(view2.state, range, !ltrAtCursor(view2)));
      var selectSyntaxRight = (view2) => extendSel(view2, (range) => moveBySyntax(view2.state, range, ltrAtCursor(view2)));
      function selectByLine(view2, forward) {
        return extendSel(view2, (range) => view2.moveVertically(range, forward));
      }
      var selectLineUp = (view2) => selectByLine(view2, false);
      var selectLineDown = (view2) => selectByLine(view2, true);
      function selectByPage(view2, forward) {
        return extendSel(view2, (range) => view2.moveVertically(range, forward, pageHeight(view2)));
      }
      var selectPageUp = (view2) => selectByPage(view2, false);
      var selectPageDown = (view2) => selectByPage(view2, true);
      var selectLineBoundaryForward = (view2) => extendSel(view2, (range) => moveByLineBoundary(view2, range, true));
      var selectLineBoundaryBackward = (view2) => extendSel(view2, (range) => moveByLineBoundary(view2, range, false));
      var selectLineStart = (view2) => extendSel(view2, (range) => state.EditorSelection.cursor(view2.lineBlockAt(range.head).from));
      var selectLineEnd = (view2) => extendSel(view2, (range) => state.EditorSelection.cursor(view2.lineBlockAt(range.head).to));
      var cursorDocStart = ({ state: state2, dispatch }) => {
        dispatch(setSel(state2, { anchor: 0 }));
        return true;
      };
      var cursorDocEnd = ({ state: state2, dispatch }) => {
        dispatch(setSel(state2, { anchor: state2.doc.length }));
        return true;
      };
      var selectDocStart = ({ state: state2, dispatch }) => {
        dispatch(setSel(state2, { anchor: state2.selection.main.anchor, head: 0 }));
        return true;
      };
      var selectDocEnd = ({ state: state2, dispatch }) => {
        dispatch(setSel(state2, { anchor: state2.selection.main.anchor, head: state2.doc.length }));
        return true;
      };
      var selectAll = ({ state: state2, dispatch }) => {
        dispatch(state2.update({ selection: { anchor: 0, head: state2.doc.length }, userEvent: "select" }));
        return true;
      };
      var selectLine = ({ state: state$1, dispatch }) => {
        let ranges = selectedLineBlocks(state$1).map(({ from, to }) => state.EditorSelection.range(from, Math.min(to + 1, state$1.doc.length)));
        dispatch(state$1.update({ selection: state.EditorSelection.create(ranges), userEvent: "select" }));
        return true;
      };
      var selectParentSyntax = ({ state: state$1, dispatch }) => {
        let selection = updateSel(state$1.selection, (range) => {
          var _a;
          let context = language.syntaxTree(state$1).resolveInner(range.head, 1);
          while (!(context.from < range.from && context.to >= range.to || context.to > range.to && context.from <= range.from || !((_a = context.parent) === null || _a === void 0 ? void 0 : _a.parent)))
            context = context.parent;
          return state.EditorSelection.range(context.to, context.from);
        });
        dispatch(setSel(state$1, selection));
        return true;
      };
      var simplifySelection = ({ state: state$1, dispatch }) => {
        let cur = state$1.selection, selection = null;
        if (cur.ranges.length > 1)
          selection = state.EditorSelection.create([cur.main]);
        else if (!cur.main.empty)
          selection = state.EditorSelection.create([state.EditorSelection.cursor(cur.main.head)]);
        if (!selection)
          return false;
        dispatch(setSel(state$1, selection));
        return true;
      };
      function deleteBy({ state: state$1, dispatch }, by) {
        if (state$1.readOnly)
          return false;
        let event = "delete.selection";
        let changes = state$1.changeByRange((range) => {
          let { from, to } = range;
          if (from == to) {
            let towards = by(from);
            if (towards < from)
              event = "delete.backward";
            else if (towards > from)
              event = "delete.forward";
            from = Math.min(from, towards);
            to = Math.max(to, towards);
          }
          return from == to ? { range } : { changes: { from, to }, range: state.EditorSelection.cursor(from) };
        });
        if (changes.changes.empty)
          return false;
        dispatch(state$1.update(changes, {
          scrollIntoView: true,
          userEvent: event,
          effects: event == "delete.selection" ? view.EditorView.announce.of(state$1.phrase("Selection deleted")) : void 0
        }));
        return true;
      }
      function skipAtomic(target, pos, forward) {
        if (target instanceof view.EditorView)
          for (let ranges of target.state.facet(view.EditorView.atomicRanges).map((f) => f(target)))
            ranges.between(pos, pos, (from, to) => {
              if (from < pos && to > pos)
                pos = forward ? to : from;
            });
        return pos;
      }
      var deleteByChar = (target, forward) => deleteBy(target, (pos) => {
        let { state: state$1 } = target, line = state$1.doc.lineAt(pos), before, targetPos;
        if (!forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
          if (before[before.length - 1] == "	")
            return pos - 1;
          let col = state.countColumn(before, state$1.tabSize), drop = col % language.getIndentUnit(state$1) || language.getIndentUnit(state$1);
          for (let i = 0; i < drop && before[before.length - 1 - i] == " "; i++)
            pos--;
          targetPos = pos;
        } else {
          targetPos = state.findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;
          if (targetPos == pos && line.number != (forward ? state$1.doc.lines : 1))
            targetPos += forward ? 1 : -1;
        }
        return skipAtomic(target, targetPos, forward);
      });
      var deleteCharBackward = (view2) => deleteByChar(view2, false);
      var deleteCharForward = (view2) => deleteByChar(view2, true);
      var deleteByGroup = (target, forward) => deleteBy(target, (start) => {
        let pos = start, { state: state$1 } = target, line = state$1.doc.lineAt(pos);
        let categorize = state$1.charCategorizer(pos);
        for (let cat = null; ; ) {
          if (pos == (forward ? line.to : line.from)) {
            if (pos == start && line.number != (forward ? state$1.doc.lines : 1))
              pos += forward ? 1 : -1;
            break;
          }
          let next = state.findClusterBreak(line.text, pos - line.from, forward) + line.from;
          let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
          let nextCat = categorize(nextChar);
          if (cat != null && nextCat != cat)
            break;
          if (nextChar != " " || pos != start)
            cat = nextCat;
          pos = next;
        }
        return skipAtomic(target, pos, forward);
      });
      var deleteGroupBackward = (target) => deleteByGroup(target, false);
      var deleteGroupForward = (target) => deleteByGroup(target, true);
      var deleteToLineEnd = (view2) => deleteBy(view2, (pos) => {
        let lineEnd = view2.lineBlockAt(pos).to;
        return skipAtomic(view2, pos < lineEnd ? lineEnd : Math.min(view2.state.doc.length, pos + 1), true);
      });
      var deleteToLineStart = (view2) => deleteBy(view2, (pos) => {
        let lineStart = view2.lineBlockAt(pos).from;
        return skipAtomic(view2, pos > lineStart ? lineStart : Math.max(0, pos - 1), false);
      });
      var deleteTrailingWhitespace = ({ state: state2, dispatch }) => {
        if (state2.readOnly)
          return false;
        let changes = [];
        for (let pos = 0, prev = "", iter = state2.doc.iter(); ; ) {
          iter.next();
          if (iter.lineBreak || iter.done) {
            let trailing = prev.search(/\s+$/);
            if (trailing > -1)
              changes.push({ from: pos - (prev.length - trailing), to: pos });
            if (iter.done)
              break;
            prev = "";
          } else {
            prev = iter.value;
          }
          pos += iter.value.length;
        }
        if (!changes.length)
          return false;
        dispatch(state2.update({ changes, userEvent: "delete" }));
        return true;
      };
      var splitLine = ({ state: state$1, dispatch }) => {
        if (state$1.readOnly)
          return false;
        let changes = state$1.changeByRange((range) => {
          return {
            changes: { from: range.from, to: range.to, insert: state.Text.of(["", ""]) },
            range: state.EditorSelection.cursor(range.from)
          };
        });
        dispatch(state$1.update(changes, { scrollIntoView: true, userEvent: "input" }));
        return true;
      };
      var transposeChars = ({ state: state$1, dispatch }) => {
        if (state$1.readOnly)
          return false;
        let changes = state$1.changeByRange((range) => {
          if (!range.empty || range.from == 0 || range.from == state$1.doc.length)
            return { range };
          let pos = range.from, line = state$1.doc.lineAt(pos);
          let from = pos == line.from ? pos - 1 : state.findClusterBreak(line.text, pos - line.from, false) + line.from;
          let to = pos == line.to ? pos + 1 : state.findClusterBreak(line.text, pos - line.from, true) + line.from;
          return {
            changes: { from, to, insert: state$1.doc.slice(pos, to).append(state$1.doc.slice(from, pos)) },
            range: state.EditorSelection.cursor(to)
          };
        });
        if (changes.changes.empty)
          return false;
        dispatch(state$1.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
        return true;
      };
      function selectedLineBlocks(state2) {
        let blocks = [], upto = -1;
        for (let range of state2.selection.ranges) {
          let startLine = state2.doc.lineAt(range.from), endLine = state2.doc.lineAt(range.to);
          if (!range.empty && range.to == endLine.from)
            endLine = state2.doc.lineAt(range.to - 1);
          if (upto >= startLine.number) {
            let prev = blocks[blocks.length - 1];
            prev.to = endLine.to;
            prev.ranges.push(range);
          } else {
            blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });
          }
          upto = endLine.number + 1;
        }
        return blocks;
      }
      function moveLine(state$1, dispatch, forward) {
        if (state$1.readOnly)
          return false;
        let changes = [], ranges = [];
        for (let block of selectedLineBlocks(state$1)) {
          if (forward ? block.to == state$1.doc.length : block.from == 0)
            continue;
          let nextLine = state$1.doc.lineAt(forward ? block.to + 1 : block.from - 1);
          let size = nextLine.length + 1;
          if (forward) {
            changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state$1.lineBreak });
            for (let r of block.ranges)
              ranges.push(state.EditorSelection.range(Math.min(state$1.doc.length, r.anchor + size), Math.min(state$1.doc.length, r.head + size)));
          } else {
            changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state$1.lineBreak + nextLine.text });
            for (let r of block.ranges)
              ranges.push(state.EditorSelection.range(r.anchor - size, r.head - size));
          }
        }
        if (!changes.length)
          return false;
        dispatch(state$1.update({
          changes,
          scrollIntoView: true,
          selection: state.EditorSelection.create(ranges, state$1.selection.mainIndex),
          userEvent: "move.line"
        }));
        return true;
      }
      var moveLineUp = ({ state: state2, dispatch }) => moveLine(state2, dispatch, false);
      var moveLineDown = ({ state: state2, dispatch }) => moveLine(state2, dispatch, true);
      function copyLine(state2, dispatch, forward) {
        if (state2.readOnly)
          return false;
        let changes = [];
        for (let block of selectedLineBlocks(state2)) {
          if (forward)
            changes.push({ from: block.from, insert: state2.doc.slice(block.from, block.to) + state2.lineBreak });
          else
            changes.push({ from: block.to, insert: state2.lineBreak + state2.doc.slice(block.from, block.to) });
        }
        dispatch(state2.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
        return true;
      }
      var copyLineUp = ({ state: state2, dispatch }) => copyLine(state2, dispatch, false);
      var copyLineDown = ({ state: state2, dispatch }) => copyLine(state2, dispatch, true);
      var deleteLine = (view2) => {
        if (view2.state.readOnly)
          return false;
        let { state: state2 } = view2, changes = state2.changes(selectedLineBlocks(state2).map(({ from, to }) => {
          if (from > 0)
            from--;
          else if (to < state2.doc.length)
            to++;
          return { from, to };
        }));
        let selection = updateSel(state2.selection, (range) => view2.moveVertically(range, true)).map(changes);
        view2.dispatch({ changes, selection, scrollIntoView: true, userEvent: "delete.line" });
        return true;
      };
      var insertNewline = ({ state: state2, dispatch }) => {
        dispatch(state2.update(state2.replaceSelection(state2.lineBreak), { scrollIntoView: true, userEvent: "input" }));
        return true;
      };
      function isBetweenBrackets(state2, pos) {
        if (/\(\)|\[\]|\{\}/.test(state2.sliceDoc(pos - 1, pos + 1)))
          return { from: pos, to: pos };
        let context = language.syntaxTree(state2).resolveInner(pos);
        let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
        if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(common.NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state2.doc.lineAt(before.to).from == state2.doc.lineAt(after.from).from)
          return { from: before.to, to: after.from };
        return null;
      }
      var insertNewlineAndIndent = newlineAndIndent(false);
      var insertBlankLine = newlineAndIndent(true);
      function newlineAndIndent(atEof) {
        return ({ state: state$1, dispatch }) => {
          if (state$1.readOnly)
            return false;
          let changes = state$1.changeByRange((range) => {
            let { from, to } = range, line = state$1.doc.lineAt(from);
            let explode = !atEof && from == to && isBetweenBrackets(state$1, from);
            if (atEof)
              from = to = (to <= line.to ? line : state$1.doc.lineAt(to)).to;
            let cx = new language.IndentContext(state$1, { simulateBreak: from, simulateDoubleBreak: !!explode });
            let indent = language.getIndentation(cx, from);
            if (indent == null)
              indent = /^\s*/.exec(state$1.doc.lineAt(from).text)[0].length;
            while (to < line.to && /\s/.test(line.text[to - line.from]))
              to++;
            if (explode)
              ({ from, to } = explode);
            else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
              from = line.from;
            let insert = ["", language.indentString(state$1, indent)];
            if (explode)
              insert.push(language.indentString(state$1, cx.lineIndent(line.from, -1)));
            return {
              changes: { from, to, insert: state.Text.of(insert) },
              range: state.EditorSelection.cursor(from + 1 + insert[1].length)
            };
          });
          dispatch(state$1.update(changes, { scrollIntoView: true, userEvent: "input" }));
          return true;
        };
      }
      function changeBySelectedLine(state$1, f) {
        let atLine = -1;
        return state$1.changeByRange((range) => {
          let changes = [];
          for (let pos = range.from; pos <= range.to; ) {
            let line = state$1.doc.lineAt(pos);
            if (line.number > atLine && (range.empty || range.to > line.from)) {
              f(line, changes, range);
              atLine = line.number;
            }
            pos = line.to + 1;
          }
          let changeSet = state$1.changes(changes);
          return {
            changes,
            range: state.EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
          };
        });
      }
      var indentSelection = ({ state: state2, dispatch }) => {
        if (state2.readOnly)
          return false;
        let updated = /* @__PURE__ */ Object.create(null);
        let context = new language.IndentContext(state2, { overrideIndentation: (start) => {
          let found = updated[start];
          return found == null ? -1 : found;
        } });
        let changes = changeBySelectedLine(state2, (line, changes2, range) => {
          let indent = language.getIndentation(context, line.from);
          if (indent == null)
            return;
          if (!/\S/.test(line.text))
            indent = 0;
          let cur = /^\s*/.exec(line.text)[0];
          let norm = language.indentString(state2, indent);
          if (cur != norm || range.from < line.from + cur.length) {
            updated[line.from] = indent;
            changes2.push({ from: line.from, to: line.from + cur.length, insert: norm });
          }
        });
        if (!changes.changes.empty)
          dispatch(state2.update(changes, { userEvent: "indent" }));
        return true;
      };
      var indentMore = ({ state: state2, dispatch }) => {
        if (state2.readOnly)
          return false;
        dispatch(state2.update(changeBySelectedLine(state2, (line, changes) => {
          changes.push({ from: line.from, insert: state2.facet(language.indentUnit) });
        }), { userEvent: "input.indent" }));
        return true;
      };
      var indentLess = ({ state: state$1, dispatch }) => {
        if (state$1.readOnly)
          return false;
        dispatch(state$1.update(changeBySelectedLine(state$1, (line, changes) => {
          let space = /^\s*/.exec(line.text)[0];
          if (!space)
            return;
          let col = state.countColumn(space, state$1.tabSize), keep = 0;
          let insert = language.indentString(state$1, Math.max(0, col - language.getIndentUnit(state$1)));
          while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep))
            keep++;
          changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert.slice(keep) });
        }), { userEvent: "delete.dedent" }));
        return true;
      };
      var insertTab = ({ state: state2, dispatch }) => {
        if (state2.selection.ranges.some((r) => !r.empty))
          return indentMore({ state: state2, dispatch });
        dispatch(state2.update(state2.replaceSelection("	"), { scrollIntoView: true, userEvent: "input" }));
        return true;
      };
      var emacsStyleKeymap = [
        { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
        { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
        { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
        { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
        { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
        { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
        { key: "Ctrl-d", run: deleteCharForward },
        { key: "Ctrl-h", run: deleteCharBackward },
        { key: "Ctrl-k", run: deleteToLineEnd },
        { key: "Ctrl-Alt-h", run: deleteGroupBackward },
        { key: "Ctrl-o", run: splitLine },
        { key: "Ctrl-t", run: transposeChars },
        { key: "Ctrl-v", run: cursorPageDown }
      ];
      var standardKeymap = [
        { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
        { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft },
        { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward },
        { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
        { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight },
        { mac: "Cmd-ArrowRight", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward },
        { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
        { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
        { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
        { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
        { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
        { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
        { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
        { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
        { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
        { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
        { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
        { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
        { key: "Enter", run: insertNewlineAndIndent },
        { key: "Mod-a", run: selectAll },
        { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward },
        { key: "Delete", run: deleteCharForward },
        { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward },
        { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward },
        { mac: "Mod-Backspace", run: deleteToLineStart },
        { mac: "Mod-Delete", run: deleteToLineEnd }
      ].concat(emacsStyleKeymap.map((b) => ({ mac: b.key, run: b.run, shift: b.shift })));
      var defaultKeymap = [
        { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
        { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
        { key: "Alt-ArrowUp", run: moveLineUp },
        { key: "Shift-Alt-ArrowUp", run: copyLineUp },
        { key: "Alt-ArrowDown", run: moveLineDown },
        { key: "Shift-Alt-ArrowDown", run: copyLineDown },
        { key: "Escape", run: simplifySelection },
        { key: "Mod-Enter", run: insertBlankLine },
        { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
        { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
        { key: "Mod-[", run: indentLess },
        { key: "Mod-]", run: indentMore },
        { key: "Mod-Alt-\\", run: indentSelection },
        { key: "Shift-Mod-k", run: deleteLine },
        { key: "Shift-Mod-\\", run: cursorMatchingBracket },
        { key: "Mod-/", run: toggleComment },
        { key: "Alt-A", run: toggleBlockComment }
      ].concat(standardKeymap);
      var indentWithTab = { key: "Tab", run: indentMore, shift: indentLess };
      exports.blockComment = blockComment;
      exports.blockUncomment = blockUncomment;
      exports.copyLineDown = copyLineDown;
      exports.copyLineUp = copyLineUp;
      exports.cursorCharBackward = cursorCharBackward;
      exports.cursorCharForward = cursorCharForward;
      exports.cursorCharLeft = cursorCharLeft;
      exports.cursorCharRight = cursorCharRight;
      exports.cursorDocEnd = cursorDocEnd;
      exports.cursorDocStart = cursorDocStart;
      exports.cursorGroupBackward = cursorGroupBackward;
      exports.cursorGroupForward = cursorGroupForward;
      exports.cursorGroupLeft = cursorGroupLeft;
      exports.cursorGroupRight = cursorGroupRight;
      exports.cursorLineBoundaryBackward = cursorLineBoundaryBackward;
      exports.cursorLineBoundaryForward = cursorLineBoundaryForward;
      exports.cursorLineDown = cursorLineDown;
      exports.cursorLineEnd = cursorLineEnd;
      exports.cursorLineStart = cursorLineStart;
      exports.cursorLineUp = cursorLineUp;
      exports.cursorMatchingBracket = cursorMatchingBracket;
      exports.cursorPageDown = cursorPageDown;
      exports.cursorPageUp = cursorPageUp;
      exports.cursorSubwordBackward = cursorSubwordBackward;
      exports.cursorSubwordForward = cursorSubwordForward;
      exports.cursorSyntaxLeft = cursorSyntaxLeft;
      exports.cursorSyntaxRight = cursorSyntaxRight;
      exports.defaultKeymap = defaultKeymap;
      exports.deleteCharBackward = deleteCharBackward;
      exports.deleteCharForward = deleteCharForward;
      exports.deleteGroupBackward = deleteGroupBackward;
      exports.deleteGroupForward = deleteGroupForward;
      exports.deleteLine = deleteLine;
      exports.deleteToLineEnd = deleteToLineEnd;
      exports.deleteToLineStart = deleteToLineStart;
      exports.deleteTrailingWhitespace = deleteTrailingWhitespace;
      exports.emacsStyleKeymap = emacsStyleKeymap;
      exports.history = history;
      exports.historyField = historyField;
      exports.historyKeymap = historyKeymap;
      exports.indentLess = indentLess;
      exports.indentMore = indentMore;
      exports.indentSelection = indentSelection;
      exports.indentWithTab = indentWithTab;
      exports.insertBlankLine = insertBlankLine;
      exports.insertNewline = insertNewline;
      exports.insertNewlineAndIndent = insertNewlineAndIndent;
      exports.insertTab = insertTab;
      exports.invertedEffects = invertedEffects;
      exports.isolateHistory = isolateHistory;
      exports.lineComment = lineComment;
      exports.lineUncomment = lineUncomment;
      exports.moveLineDown = moveLineDown;
      exports.moveLineUp = moveLineUp;
      exports.redo = redo;
      exports.redoDepth = redoDepth;
      exports.redoSelection = redoSelection;
      exports.selectAll = selectAll;
      exports.selectCharBackward = selectCharBackward;
      exports.selectCharForward = selectCharForward;
      exports.selectCharLeft = selectCharLeft;
      exports.selectCharRight = selectCharRight;
      exports.selectDocEnd = selectDocEnd;
      exports.selectDocStart = selectDocStart;
      exports.selectGroupBackward = selectGroupBackward;
      exports.selectGroupForward = selectGroupForward;
      exports.selectGroupLeft = selectGroupLeft;
      exports.selectGroupRight = selectGroupRight;
      exports.selectLine = selectLine;
      exports.selectLineBoundaryBackward = selectLineBoundaryBackward;
      exports.selectLineBoundaryForward = selectLineBoundaryForward;
      exports.selectLineDown = selectLineDown;
      exports.selectLineEnd = selectLineEnd;
      exports.selectLineStart = selectLineStart;
      exports.selectLineUp = selectLineUp;
      exports.selectMatchingBracket = selectMatchingBracket;
      exports.selectPageDown = selectPageDown;
      exports.selectPageUp = selectPageUp;
      exports.selectParentSyntax = selectParentSyntax;
      exports.selectSubwordBackward = selectSubwordBackward;
      exports.selectSubwordForward = selectSubwordForward;
      exports.selectSyntaxLeft = selectSyntaxLeft;
      exports.selectSyntaxRight = selectSyntaxRight;
      exports.simplifySelection = simplifySelection;
      exports.splitLine = splitLine;
      exports.standardKeymap = standardKeymap;
      exports.toggleBlockComment = toggleBlockComment;
      exports.toggleBlockCommentByLine = toggleBlockCommentByLine;
      exports.toggleComment = toggleComment;
      exports.toggleLineComment = toggleLineComment;
      exports.transposeChars = transposeChars;
      exports.undo = undo;
      exports.undoDepth = undoDepth;
      exports.undoSelection = undoSelection;
    }
  });

  // node_modules/crelt/dist/index.cjs
  var require_dist7 = __commonJS({
    "node_modules/crelt/dist/index.cjs"(exports, module) {
      "use strict";
      function crelt() {
        var elt = arguments[0];
        if (typeof elt == "string")
          elt = document.createElement(elt);
        var i = 1, next = arguments[1];
        if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
          for (var name in next)
            if (Object.prototype.hasOwnProperty.call(next, name)) {
              var value = next[name];
              if (typeof value == "string")
                elt.setAttribute(name, value);
              else if (value != null)
                elt[name] = value;
            }
          i++;
        }
        for (; i < arguments.length; i++)
          add(elt, arguments[i]);
        return elt;
      }
      function add(elt, child) {
        if (typeof child == "string") {
          elt.appendChild(document.createTextNode(child));
        } else if (child == null)
          ;
        else if (child.nodeType != null) {
          elt.appendChild(child);
        } else if (Array.isArray(child)) {
          for (var i = 0; i < child.length; i++)
            add(elt, child[i]);
        } else {
          throw new RangeError("Unsupported child node: " + child);
        }
      }
      module.exports = crelt;
    }
  });

  // node_modules/@codemirror/search/dist/index.cjs
  var require_dist8 = __commonJS({
    "node_modules/@codemirror/search/dist/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var view = require_dist2();
      var state = require_dist();
      var elt = require_dist7();
      function _interopDefaultLegacy(e) {
        return e && typeof e === "object" && "default" in e ? e : { "default": e };
      }
      var elt__default = /* @__PURE__ */ _interopDefaultLegacy(elt);
      var basicNormalize = typeof String.prototype.normalize == "function" ? (x) => x.normalize("NFKD") : (x) => x;
      var SearchCursor = class {
        constructor(text, query, from = 0, to = text.length, normalize) {
          this.value = { from: 0, to: 0 };
          this.done = false;
          this.matches = [];
          this.buffer = "";
          this.bufferPos = 0;
          this.iter = text.iterRange(from, to);
          this.bufferStart = from;
          this.normalize = normalize ? (x) => normalize(basicNormalize(x)) : basicNormalize;
          this.query = this.normalize(query);
        }
        peek() {
          if (this.bufferPos == this.buffer.length) {
            this.bufferStart += this.buffer.length;
            this.iter.next();
            if (this.iter.done)
              return -1;
            this.bufferPos = 0;
            this.buffer = this.iter.value;
          }
          return state.codePointAt(this.buffer, this.bufferPos);
        }
        next() {
          while (this.matches.length)
            this.matches.pop();
          return this.nextOverlapping();
        }
        nextOverlapping() {
          for (; ; ) {
            let next = this.peek();
            if (next < 0) {
              this.done = true;
              return this;
            }
            let str = state.fromCodePoint(next), start = this.bufferStart + this.bufferPos;
            this.bufferPos += state.codePointSize(next);
            let norm = this.normalize(str);
            for (let i = 0, pos = start; ; i++) {
              let code = norm.charCodeAt(i);
              let match = this.match(code, pos);
              if (match) {
                this.value = match;
                return this;
              }
              if (i == norm.length - 1)
                break;
              if (pos == start && i < str.length && str.charCodeAt(i) == code)
                pos++;
            }
          }
        }
        match(code, pos) {
          let match = null;
          for (let i = 0; i < this.matches.length; i += 2) {
            let index = this.matches[i], keep = false;
            if (this.query.charCodeAt(index) == code) {
              if (index == this.query.length - 1) {
                match = { from: this.matches[i + 1], to: pos + 1 };
              } else {
                this.matches[i]++;
                keep = true;
              }
            }
            if (!keep) {
              this.matches.splice(i, 2);
              i -= 2;
            }
          }
          if (this.query.charCodeAt(0) == code) {
            if (this.query.length == 1)
              match = { from: pos, to: pos + 1 };
            else
              this.matches.push(1, pos);
          }
          return match;
        }
      };
      if (typeof Symbol != "undefined")
        SearchCursor.prototype[Symbol.iterator] = function() {
          return this;
        };
      var empty = { from: -1, to: -1, match: /.*/.exec("") };
      var baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
      var RegExpCursor = class {
        constructor(text, query, options, from = 0, to = text.length) {
          this.to = to;
          this.curLine = "";
          this.done = false;
          this.value = empty;
          if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
            return new MultilineRegExpCursor(text, query, options, from, to);
          this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
          this.iter = text.iter();
          let startLine = text.lineAt(from);
          this.curLineStart = startLine.from;
          this.matchPos = from;
          this.getLine(this.curLineStart);
        }
        getLine(skip) {
          this.iter.next(skip);
          if (this.iter.lineBreak) {
            this.curLine = "";
          } else {
            this.curLine = this.iter.value;
            if (this.curLineStart + this.curLine.length > this.to)
              this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
            this.iter.next();
          }
        }
        nextLine() {
          this.curLineStart = this.curLineStart + this.curLine.length + 1;
          if (this.curLineStart > this.to)
            this.curLine = "";
          else
            this.getLine(0);
        }
        next() {
          for (let off = this.matchPos - this.curLineStart; ; ) {
            this.re.lastIndex = off;
            let match = this.matchPos <= this.to && this.re.exec(this.curLine);
            if (match) {
              let from = this.curLineStart + match.index, to = from + match[0].length;
              this.matchPos = to + (from == to ? 1 : 0);
              if (from == this.curLine.length)
                this.nextLine();
              if (from < to || from > this.value.to) {
                this.value = { from, to, match };
                return this;
              }
              off = this.matchPos - this.curLineStart;
            } else if (this.curLineStart + this.curLine.length < this.to) {
              this.nextLine();
              off = 0;
            } else {
              this.done = true;
              return this;
            }
          }
        }
      };
      var flattened = /* @__PURE__ */ new WeakMap();
      var FlattenedDoc = class {
        constructor(from, text) {
          this.from = from;
          this.text = text;
        }
        get to() {
          return this.from + this.text.length;
        }
        static get(doc, from, to) {
          let cached = flattened.get(doc);
          if (!cached || cached.from >= to || cached.to <= from) {
            let flat = new FlattenedDoc(from, doc.sliceString(from, to));
            flattened.set(doc, flat);
            return flat;
          }
          if (cached.from == from && cached.to == to)
            return cached;
          let { text, from: cachedFrom } = cached;
          if (cachedFrom > from) {
            text = doc.sliceString(from, cachedFrom) + text;
            cachedFrom = from;
          }
          if (cached.to < to)
            text += doc.sliceString(cached.to, to);
          flattened.set(doc, new FlattenedDoc(cachedFrom, text));
          return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));
        }
      };
      var MultilineRegExpCursor = class {
        constructor(text, query, options, from, to) {
          this.text = text;
          this.to = to;
          this.done = false;
          this.value = empty;
          this.matchPos = from;
          this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
          this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5e3));
        }
        chunkEnd(pos) {
          return pos >= this.to ? this.to : this.text.lineAt(pos).to;
        }
        next() {
          for (; ; ) {
            let off = this.re.lastIndex = this.matchPos - this.flat.from;
            let match = this.re.exec(this.flat.text);
            if (match && !match[0] && match.index == off) {
              this.re.lastIndex = off + 1;
              match = this.re.exec(this.flat.text);
            }
            if (match && this.flat.to < this.to && match.index + match[0].length > this.flat.text.length - 10)
              match = null;
            if (match) {
              let from = this.flat.from + match.index, to = from + match[0].length;
              this.value = { from, to, match };
              this.matchPos = to + (from == to ? 1 : 0);
              return this;
            } else {
              if (this.flat.to == this.to) {
                this.done = true;
                return this;
              }
              this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
            }
          }
        }
      };
      if (typeof Symbol != "undefined") {
        RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
          return this;
        };
      }
      function validRegExp(source) {
        try {
          new RegExp(source, baseFlags);
          return true;
        } catch (_a) {
          return false;
        }
      }
      function createLineDialog(view2) {
        let input = elt__default["default"]("input", { class: "cm-textfield", name: "line" });
        let dom = elt__default["default"]("form", {
          class: "cm-gotoLine",
          onkeydown: (event) => {
            if (event.keyCode == 27) {
              event.preventDefault();
              view2.dispatch({ effects: dialogEffect.of(false) });
              view2.focus();
            } else if (event.keyCode == 13) {
              event.preventDefault();
              go();
            }
          },
          onsubmit: (event) => {
            event.preventDefault();
            go();
          }
        }, elt__default["default"]("label", view2.state.phrase("Go to line"), ": ", input), " ", elt__default["default"]("button", { class: "cm-button", type: "submit" }, view2.state.phrase("go")));
        function go() {
          let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
          if (!match)
            return;
          let { state: state$1 } = view2, startLine = state$1.doc.lineAt(state$1.selection.main.head);
          let [, sign, ln, cl, percent] = match;
          let col = cl ? +cl.slice(1) : 0;
          let line = ln ? +ln : startLine.number;
          if (ln && percent) {
            let pc = line / 100;
            if (sign)
              pc = pc * (sign == "-" ? -1 : 1) + startLine.number / state$1.doc.lines;
            line = Math.round(state$1.doc.lines * pc);
          } else if (ln && sign) {
            line = line * (sign == "-" ? -1 : 1) + startLine.number;
          }
          let docLine = state$1.doc.line(Math.max(1, Math.min(state$1.doc.lines, line)));
          view2.dispatch({
            effects: dialogEffect.of(false),
            selection: state.EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),
            scrollIntoView: true
          });
          view2.focus();
        }
        return { dom };
      }
      var dialogEffect = state.StateEffect.define();
      var dialogField = state.StateField.define({
        create() {
          return true;
        },
        update(value, tr) {
          for (let e of tr.effects)
            if (e.is(dialogEffect))
              value = e.value;
          return value;
        },
        provide: (f) => view.showPanel.from(f, (val) => val ? createLineDialog : null)
      });
      var gotoLine = (view$1) => {
        let panel = view.getPanel(view$1, createLineDialog);
        if (!panel) {
          let effects = [dialogEffect.of(true)];
          if (view$1.state.field(dialogField, false) == null)
            effects.push(state.StateEffect.appendConfig.of([dialogField, baseTheme$1]));
          view$1.dispatch({ effects });
          panel = view.getPanel(view$1, createLineDialog);
        }
        if (panel)
          panel.dom.querySelector("input").focus();
        return true;
      };
      var baseTheme$1 = view.EditorView.baseTheme({
        ".cm-panel.cm-gotoLine": {
          padding: "2px 6px 4px",
          "& label": { fontSize: "80%" }
        }
      });
      var defaultHighlightOptions = {
        highlightWordAroundCursor: false,
        minSelectionLength: 1,
        maxMatches: 100,
        wholeWords: false
      };
      var highlightConfig = state.Facet.define({
        combine(options) {
          return state.combineConfig(options, defaultHighlightOptions, {
            highlightWordAroundCursor: (a, b) => a || b,
            minSelectionLength: Math.min,
            maxMatches: Math.min
          });
        }
      });
      function highlightSelectionMatches(options) {
        let ext = [defaultTheme, matchHighlighter];
        if (options)
          ext.push(highlightConfig.of(options));
        return ext;
      }
      var matchDeco = view.Decoration.mark({ class: "cm-selectionMatch" });
      var mainMatchDeco = view.Decoration.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
      function insideWordBoundaries(check, state$1, from, to) {
        return (from == 0 || check(state$1.sliceDoc(from - 1, from)) != state.CharCategory.Word) && (to == state$1.doc.length || check(state$1.sliceDoc(to, to + 1)) != state.CharCategory.Word);
      }
      function insideWord(check, state$1, from, to) {
        return check(state$1.sliceDoc(from, from + 1)) == state.CharCategory.Word && check(state$1.sliceDoc(to - 1, to)) == state.CharCategory.Word;
      }
      var matchHighlighter = view.ViewPlugin.fromClass(class {
        constructor(view2) {
          this.decorations = this.getDeco(view2);
        }
        update(update) {
          if (update.selectionSet || update.docChanged || update.viewportChanged)
            this.decorations = this.getDeco(update.view);
        }
        getDeco(view$1) {
          let conf = view$1.state.facet(highlightConfig);
          let { state: state2 } = view$1, sel = state2.selection;
          if (sel.ranges.length > 1)
            return view.Decoration.none;
          let range = sel.main, query, check = null;
          if (range.empty) {
            if (!conf.highlightWordAroundCursor)
              return view.Decoration.none;
            let word = state2.wordAt(range.head);
            if (!word)
              return view.Decoration.none;
            check = state2.charCategorizer(range.head);
            query = state2.sliceDoc(word.from, word.to);
          } else {
            let len = range.to - range.from;
            if (len < conf.minSelectionLength || len > 200)
              return view.Decoration.none;
            if (conf.wholeWords) {
              query = state2.sliceDoc(range.from, range.to);
              check = state2.charCategorizer(range.head);
              if (!(insideWordBoundaries(check, state2, range.from, range.to) && insideWord(check, state2, range.from, range.to)))
                return view.Decoration.none;
            } else {
              query = state2.sliceDoc(range.from, range.to).trim();
              if (!query)
                return view.Decoration.none;
            }
          }
          let deco = [];
          for (let part of view$1.visibleRanges) {
            let cursor = new SearchCursor(state2.doc, query, part.from, part.to);
            while (!cursor.next().done) {
              let { from, to } = cursor.value;
              if (!check || insideWordBoundaries(check, state2, from, to)) {
                if (range.empty && from <= range.from && to >= range.to)
                  deco.push(mainMatchDeco.range(from, to));
                else if (from >= range.to || to <= range.from)
                  deco.push(matchDeco.range(from, to));
                if (deco.length > conf.maxMatches)
                  return view.Decoration.none;
              }
            }
          }
          return view.Decoration.set(deco);
        }
      }, {
        decorations: (v) => v.decorations
      });
      var defaultTheme = view.EditorView.baseTheme({
        ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
        ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
      });
      var selectWord = ({ state: state$1, dispatch }) => {
        let { selection } = state$1;
        let newSel = state.EditorSelection.create(selection.ranges.map((range) => state$1.wordAt(range.head) || state.EditorSelection.cursor(range.head)), selection.mainIndex);
        if (newSel.eq(selection))
          return false;
        dispatch(state$1.update({ selection: newSel }));
        return true;
      };
      function findNextOccurrence(state2, query) {
        let { main, ranges } = state2.selection;
        let word = state2.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;
        for (let cycled = false, cursor = new SearchCursor(state2.doc, query, ranges[ranges.length - 1].to); ; ) {
          cursor.next();
          if (cursor.done) {
            if (cycled)
              return null;
            cursor = new SearchCursor(state2.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
            cycled = true;
          } else {
            if (cycled && ranges.some((r) => r.from == cursor.value.from))
              continue;
            if (fullWord) {
              let word2 = state2.wordAt(cursor.value.from);
              if (!word2 || word2.from != cursor.value.from || word2.to != cursor.value.to)
                continue;
            }
            return cursor.value;
          }
        }
      }
      var selectNextOccurrence = ({ state: state$1, dispatch }) => {
        let { ranges } = state$1.selection;
        if (ranges.some((sel) => sel.from === sel.to))
          return selectWord({ state: state$1, dispatch });
        let searchedText = state$1.sliceDoc(ranges[0].from, ranges[0].to);
        if (state$1.selection.ranges.some((r) => state$1.sliceDoc(r.from, r.to) != searchedText))
          return false;
        let range = findNextOccurrence(state$1, searchedText);
        if (!range)
          return false;
        dispatch(state$1.update({
          selection: state$1.selection.addRange(state.EditorSelection.range(range.from, range.to), false),
          effects: view.EditorView.scrollIntoView(range.to)
        }));
        return true;
      };
      var searchConfigFacet = state.Facet.define({
        combine(configs) {
          var _a;
          return {
            top: configs.reduce((val, conf) => val !== null && val !== void 0 ? val : conf.top, void 0) || false,
            caseSensitive: configs.reduce((val, conf) => val !== null && val !== void 0 ? val : conf.caseSensitive, void 0) || false,
            createPanel: ((_a = configs.find((c) => c.createPanel)) === null || _a === void 0 ? void 0 : _a.createPanel) || ((view2) => new SearchPanel(view2))
          };
        }
      });
      function search(config) {
        return config ? [searchConfigFacet.of(config), searchExtensions] : searchExtensions;
      }
      var SearchQuery = class {
        constructor(config) {
          this.search = config.search;
          this.caseSensitive = !!config.caseSensitive;
          this.regexp = !!config.regexp;
          this.replace = config.replace || "";
          this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
          this.unquoted = config.literal ? this.search : this.search.replace(/\\([nrt\\])/g, (_, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "	" : "\\");
        }
        eq(other) {
          return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp;
        }
        create() {
          return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
        }
        getCursor(doc, from = 0, to = doc.length) {
          return this.regexp ? regexpCursor(this, doc, from, to) : stringCursor(this, doc, from, to);
        }
      };
      var QueryType = class {
        constructor(spec) {
          this.spec = spec;
        }
      };
      function stringCursor(spec, doc, from, to) {
        return new SearchCursor(doc, spec.unquoted, from, to, spec.caseSensitive ? void 0 : (x) => x.toLowerCase());
      }
      var StringQuery = class extends QueryType {
        constructor(spec) {
          super(spec);
        }
        nextMatch(doc, curFrom, curTo) {
          let cursor = stringCursor(this.spec, doc, curTo, doc.length).nextOverlapping();
          if (cursor.done)
            cursor = stringCursor(this.spec, doc, 0, curFrom).nextOverlapping();
          return cursor.done ? null : cursor.value;
        }
        prevMatchInRange(doc, from, to) {
          for (let pos = to; ; ) {
            let start = Math.max(from, pos - 1e4 - this.spec.unquoted.length);
            let cursor = stringCursor(this.spec, doc, start, pos), range = null;
            while (!cursor.nextOverlapping().done)
              range = cursor.value;
            if (range)
              return range;
            if (start == from)
              return null;
            pos -= 1e4;
          }
        }
        prevMatch(doc, curFrom, curTo) {
          return this.prevMatchInRange(doc, 0, curFrom) || this.prevMatchInRange(doc, curTo, doc.length);
        }
        getReplacement(_result) {
          return this.spec.replace;
        }
        matchAll(doc, limit) {
          let cursor = stringCursor(this.spec, doc, 0, doc.length), ranges = [];
          while (!cursor.next().done) {
            if (ranges.length >= limit)
              return null;
            ranges.push(cursor.value);
          }
          return ranges;
        }
        highlight(doc, from, to, add) {
          let cursor = stringCursor(this.spec, doc, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, doc.length));
          while (!cursor.next().done)
            add(cursor.value.from, cursor.value.to);
        }
      };
      function regexpCursor(spec, doc, from, to) {
        return new RegExpCursor(doc, spec.search, spec.caseSensitive ? void 0 : { ignoreCase: true }, from, to);
      }
      var RegExpQuery = class extends QueryType {
        nextMatch(doc, curFrom, curTo) {
          let cursor = regexpCursor(this.spec, doc, curTo, doc.length).next();
          if (cursor.done)
            cursor = regexpCursor(this.spec, doc, 0, curFrom).next();
          return cursor.done ? null : cursor.value;
        }
        prevMatchInRange(doc, from, to) {
          for (let size = 1; ; size++) {
            let start = Math.max(from, to - size * 1e4);
            let cursor = regexpCursor(this.spec, doc, start, to), range = null;
            while (!cursor.next().done)
              range = cursor.value;
            if (range && (start == from || range.from > start + 10))
              return range;
            if (start == from)
              return null;
          }
        }
        prevMatch(doc, curFrom, curTo) {
          return this.prevMatchInRange(doc, 0, curFrom) || this.prevMatchInRange(doc, curTo, doc.length);
        }
        getReplacement(result) {
          return this.spec.replace.replace(/\$([$&\d+])/g, (m, i) => i == "$" ? "$" : i == "&" ? result.match[0] : i != "0" && +i < result.match.length ? result.match[i] : m);
        }
        matchAll(doc, limit) {
          let cursor = regexpCursor(this.spec, doc, 0, doc.length), ranges = [];
          while (!cursor.next().done) {
            if (ranges.length >= limit)
              return null;
            ranges.push(cursor.value);
          }
          return ranges;
        }
        highlight(doc, from, to, add) {
          let cursor = regexpCursor(this.spec, doc, Math.max(0, from - 250), Math.min(to + 250, doc.length));
          while (!cursor.next().done)
            add(cursor.value.from, cursor.value.to);
        }
      };
      var setSearchQuery = state.StateEffect.define();
      var togglePanel = state.StateEffect.define();
      var searchState = state.StateField.define({
        create(state2) {
          return new SearchState(defaultQuery(state2).create(), null);
        },
        update(value, tr) {
          for (let effect of tr.effects) {
            if (effect.is(setSearchQuery))
              value = new SearchState(effect.value.create(), value.panel);
            else if (effect.is(togglePanel))
              value = new SearchState(value.query, effect.value ? createSearchPanel : null);
          }
          return value;
        },
        provide: (f) => view.showPanel.from(f, (val) => val.panel)
      });
      function getSearchQuery(state2) {
        let curState = state2.field(searchState, false);
        return curState ? curState.query.spec : defaultQuery(state2);
      }
      var SearchState = class {
        constructor(query, panel) {
          this.query = query;
          this.panel = panel;
        }
      };
      var matchMark = view.Decoration.mark({ class: "cm-searchMatch" });
      var selectedMatchMark = view.Decoration.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
      var searchHighlighter = view.ViewPlugin.fromClass(class {
        constructor(view2) {
          this.view = view2;
          this.decorations = this.highlight(view2.state.field(searchState));
        }
        update(update) {
          let state2 = update.state.field(searchState);
          if (state2 != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)
            this.decorations = this.highlight(state2);
        }
        highlight({ query, panel }) {
          if (!panel || !query.spec.valid)
            return view.Decoration.none;
          let { view: view$1 } = this;
          let builder = new state.RangeSetBuilder();
          for (let i = 0, ranges = view$1.visibleRanges, l = ranges.length; i < l; i++) {
            let { from, to } = ranges[i];
            while (i < l - 1 && to > ranges[i + 1].from - 2 * 250)
              to = ranges[++i].to;
            query.highlight(view$1.state.doc, from, to, (from2, to2) => {
              let selected = view$1.state.selection.ranges.some((r) => r.from == from2 && r.to == to2);
              builder.add(from2, to2, selected ? selectedMatchMark : matchMark);
            });
          }
          return builder.finish();
        }
      }, {
        decorations: (v) => v.decorations
      });
      function searchCommand(f) {
        return (view2) => {
          let state2 = view2.state.field(searchState, false);
          return state2 && state2.query.spec.valid ? f(view2, state2) : openSearchPanel(view2);
        };
      }
      var findNext = searchCommand((view2, { query }) => {
        let { to } = view2.state.selection.main;
        let next = query.nextMatch(view2.state.doc, to, to);
        if (!next)
          return false;
        view2.dispatch({
          selection: { anchor: next.from, head: next.to },
          scrollIntoView: true,
          effects: announceMatch(view2, next),
          userEvent: "select.search"
        });
        return true;
      });
      var findPrevious = searchCommand((view2, { query }) => {
        let { state: state2 } = view2, { from } = state2.selection.main;
        let range = query.prevMatch(state2.doc, from, from);
        if (!range)
          return false;
        view2.dispatch({
          selection: { anchor: range.from, head: range.to },
          scrollIntoView: true,
          effects: announceMatch(view2, range),
          userEvent: "select.search"
        });
        return true;
      });
      var selectMatches = searchCommand((view2, { query }) => {
        let ranges = query.matchAll(view2.state.doc, 1e3);
        if (!ranges || !ranges.length)
          return false;
        view2.dispatch({
          selection: state.EditorSelection.create(ranges.map((r) => state.EditorSelection.range(r.from, r.to))),
          userEvent: "select.search.matches"
        });
        return true;
      });
      var selectSelectionMatches = ({ state: state$1, dispatch }) => {
        let sel = state$1.selection;
        if (sel.ranges.length > 1 || sel.main.empty)
          return false;
        let { from, to } = sel.main;
        let ranges = [], main = 0;
        for (let cur = new SearchCursor(state$1.doc, state$1.sliceDoc(from, to)); !cur.next().done; ) {
          if (ranges.length > 1e3)
            return false;
          if (cur.value.from == from)
            main = ranges.length;
          ranges.push(state.EditorSelection.range(cur.value.from, cur.value.to));
        }
        dispatch(state$1.update({
          selection: state.EditorSelection.create(ranges, main),
          userEvent: "select.search.matches"
        }));
        return true;
      };
      var replaceNext = searchCommand((view$1, { query }) => {
        let { state: state2 } = view$1, { from, to } = state2.selection.main;
        if (state2.readOnly)
          return false;
        let next = query.nextMatch(state2.doc, from, from);
        if (!next)
          return false;
        let changes = [], selection, replacement;
        let announce = [];
        if (next.from == from && next.to == to) {
          replacement = state2.toText(query.getReplacement(next));
          changes.push({ from: next.from, to: next.to, insert: replacement });
          next = query.nextMatch(state2.doc, next.from, next.to);
          announce.push(view.EditorView.announce.of(state2.phrase("replaced match on line $", state2.doc.lineAt(from).number) + "."));
        }
        if (next) {
          let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;
          selection = { anchor: next.from - off, head: next.to - off };
          announce.push(announceMatch(view$1, next));
        }
        view$1.dispatch({
          changes,
          selection,
          scrollIntoView: !!selection,
          effects: announce,
          userEvent: "input.replace"
        });
        return true;
      });
      var replaceAll = searchCommand((view$1, { query }) => {
        if (view$1.state.readOnly)
          return false;
        let changes = query.matchAll(view$1.state.doc, 1e9).map((match) => {
          let { from, to } = match;
          return { from, to, insert: query.getReplacement(match) };
        });
        if (!changes.length)
          return false;
        let announceText = view$1.state.phrase("replaced $ matches", changes.length) + ".";
        view$1.dispatch({
          changes,
          effects: view.EditorView.announce.of(announceText),
          userEvent: "input.replace.all"
        });
        return true;
      });
      function createSearchPanel(view2) {
        return view2.state.facet(searchConfigFacet).createPanel(view2);
      }
      function defaultQuery(state2, fallback) {
        var _a;
        let sel = state2.selection.main;
        let selText = sel.empty || sel.to > sel.from + 100 ? "" : state2.sliceDoc(sel.from, sel.to);
        let caseSensitive = (_a = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _a !== void 0 ? _a : state2.facet(searchConfigFacet).caseSensitive;
        return fallback && !selText ? fallback : new SearchQuery({ search: selText.replace(/\n/g, "\\n"), caseSensitive });
      }
      var openSearchPanel = (view$1) => {
        let state$1 = view$1.state.field(searchState, false);
        if (state$1 && state$1.panel) {
          let panel = view.getPanel(view$1, createSearchPanel);
          if (!panel)
            return false;
          let searchInput = panel.dom.querySelector("[main-field]");
          if (searchInput && searchInput != view$1.root.activeElement) {
            let query = defaultQuery(view$1.state, state$1.query.spec);
            if (query.valid)
              view$1.dispatch({ effects: setSearchQuery.of(query) });
            searchInput.focus();
            searchInput.select();
          }
        } else {
          view$1.dispatch({ effects: [
            togglePanel.of(true),
            state$1 ? setSearchQuery.of(defaultQuery(view$1.state, state$1.query.spec)) : state.StateEffect.appendConfig.of(searchExtensions)
          ] });
        }
        return true;
      };
      var closeSearchPanel = (view$1) => {
        let state2 = view$1.state.field(searchState, false);
        if (!state2 || !state2.panel)
          return false;
        let panel = view.getPanel(view$1, createSearchPanel);
        if (panel && panel.dom.contains(view$1.root.activeElement))
          view$1.focus();
        view$1.dispatch({ effects: togglePanel.of(false) });
        return true;
      };
      var searchKeymap = [
        { key: "Mod-f", run: openSearchPanel, scope: "editor search-panel" },
        { key: "F3", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
        { key: "Mod-g", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
        { key: "Escape", run: closeSearchPanel, scope: "editor search-panel" },
        { key: "Mod-Shift-l", run: selectSelectionMatches },
        { key: "Alt-g", run: gotoLine },
        { key: "Mod-d", run: selectNextOccurrence, preventDefault: true }
      ];
      var SearchPanel = class {
        constructor(view2) {
          this.view = view2;
          let query = this.query = view2.state.field(searchState).query.spec;
          this.commit = this.commit.bind(this);
          this.searchField = elt__default["default"]("input", {
            value: query.search,
            placeholder: phrase(view2, "Find"),
            "aria-label": phrase(view2, "Find"),
            class: "cm-textfield",
            name: "search",
            "main-field": "true",
            onchange: this.commit,
            onkeyup: this.commit
          });
          this.replaceField = elt__default["default"]("input", {
            value: query.replace,
            placeholder: phrase(view2, "Replace"),
            "aria-label": phrase(view2, "Replace"),
            class: "cm-textfield",
            name: "replace",
            onchange: this.commit,
            onkeyup: this.commit
          });
          this.caseField = elt__default["default"]("input", {
            type: "checkbox",
            name: "case",
            checked: query.caseSensitive,
            onchange: this.commit
          });
          this.reField = elt__default["default"]("input", {
            type: "checkbox",
            name: "re",
            checked: query.regexp,
            onchange: this.commit
          });
          function button(name, onclick, content) {
            return elt__default["default"]("button", { class: "cm-button", name, onclick, type: "button" }, content);
          }
          this.dom = elt__default["default"]("div", { onkeydown: (e) => this.keydown(e), class: "cm-search" }, [
            this.searchField,
            button("next", () => findNext(view2), [phrase(view2, "next")]),
            button("prev", () => findPrevious(view2), [phrase(view2, "previous")]),
            button("select", () => selectMatches(view2), [phrase(view2, "all")]),
            elt__default["default"]("label", null, [this.caseField, phrase(view2, "match case")]),
            elt__default["default"]("label", null, [this.reField, phrase(view2, "regexp")]),
            ...view2.state.readOnly ? [] : [
              elt__default["default"]("br"),
              this.replaceField,
              button("replace", () => replaceNext(view2), [phrase(view2, "replace")]),
              button("replaceAll", () => replaceAll(view2), [phrase(view2, "replace all")]),
              elt__default["default"]("button", {
                name: "close",
                onclick: () => closeSearchPanel(view2),
                "aria-label": phrase(view2, "close"),
                type: "button"
              }, ["\xD7"])
            ]
          ]);
        }
        commit() {
          let query = new SearchQuery({
            search: this.searchField.value,
            caseSensitive: this.caseField.checked,
            regexp: this.reField.checked,
            replace: this.replaceField.value
          });
          if (!query.eq(this.query)) {
            this.query = query;
            this.view.dispatch({ effects: setSearchQuery.of(query) });
          }
        }
        keydown(e) {
          if (view.runScopeHandlers(this.view, e, "search-panel")) {
            e.preventDefault();
          } else if (e.keyCode == 13 && e.target == this.searchField) {
            e.preventDefault();
            (e.shiftKey ? findPrevious : findNext)(this.view);
          } else if (e.keyCode == 13 && e.target == this.replaceField) {
            e.preventDefault();
            replaceNext(this.view);
          }
        }
        update(update) {
          for (let tr of update.transactions)
            for (let effect of tr.effects) {
              if (effect.is(setSearchQuery) && !effect.value.eq(this.query))
                this.setQuery(effect.value);
            }
        }
        setQuery(query) {
          this.query = query;
          this.searchField.value = query.search;
          this.replaceField.value = query.replace;
          this.caseField.checked = query.caseSensitive;
          this.reField.checked = query.regexp;
        }
        mount() {
          this.searchField.select();
        }
        get pos() {
          return 80;
        }
        get top() {
          return this.view.state.facet(searchConfigFacet).top;
        }
      };
      function phrase(view2, phrase2) {
        return view2.state.phrase(phrase2);
      }
      var AnnounceMargin = 30;
      var Break = /[\s\.,:;?!]/;
      function announceMatch(view$1, { from, to }) {
        let line = view$1.state.doc.lineAt(from), lineEnd = view$1.state.doc.lineAt(to).to;
        let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);
        let text = view$1.state.sliceDoc(start, end);
        if (start != line.from) {
          for (let i = 0; i < AnnounceMargin; i++)
            if (!Break.test(text[i + 1]) && Break.test(text[i])) {
              text = text.slice(i);
              break;
            }
        }
        if (end != lineEnd) {
          for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)
            if (!Break.test(text[i - 1]) && Break.test(text[i])) {
              text = text.slice(0, i);
              break;
            }
        }
        return view.EditorView.announce.of(`${view$1.state.phrase("current match")}. ${text} ${view$1.state.phrase("on line")} ${line.number}.`);
      }
      var baseTheme = view.EditorView.baseTheme({
        ".cm-panel.cm-search": {
          padding: "2px 6px 4px",
          position: "relative",
          "& [name=close]": {
            position: "absolute",
            top: "0",
            right: "4px",
            backgroundColor: "inherit",
            border: "none",
            font: "inherit",
            padding: 0,
            margin: 0
          },
          "& input, & button, & label": {
            margin: ".2em .6em .2em 0"
          },
          "& input[type=checkbox]": {
            marginRight: ".2em"
          },
          "& label": {
            fontSize: "80%",
            whiteSpace: "pre"
          }
        },
        "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
        "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
        "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
        "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
      });
      var searchExtensions = [
        searchState,
        state.Prec.lowest(searchHighlighter),
        baseTheme
      ];
      exports.RegExpCursor = RegExpCursor;
      exports.SearchCursor = SearchCursor;
      exports.SearchQuery = SearchQuery;
      exports.closeSearchPanel = closeSearchPanel;
      exports.findNext = findNext;
      exports.findPrevious = findPrevious;
      exports.getSearchQuery = getSearchQuery;
      exports.gotoLine = gotoLine;
      exports.highlightSelectionMatches = highlightSelectionMatches;
      exports.openSearchPanel = openSearchPanel;
      exports.replaceAll = replaceAll;
      exports.replaceNext = replaceNext;
      exports.search = search;
      exports.searchKeymap = searchKeymap;
      exports.selectMatches = selectMatches;
      exports.selectNextOccurrence = selectNextOccurrence;
      exports.selectSelectionMatches = selectSelectionMatches;
      exports.setSearchQuery = setSearchQuery;
    }
  });

  // node_modules/@codemirror/autocomplete/dist/index.cjs
  var require_dist9 = __commonJS({
    "node_modules/@codemirror/autocomplete/dist/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var state = require_dist();
      var view = require_dist2();
      var language = require_dist5();
      var CompletionContext = class {
        constructor(state2, pos, explicit) {
          this.state = state2;
          this.pos = pos;
          this.explicit = explicit;
          this.abortListeners = [];
        }
        tokenBefore(types) {
          let token = language.syntaxTree(this.state).resolveInner(this.pos, -1);
          while (token && types.indexOf(token.name) < 0)
            token = token.parent;
          return token ? {
            from: token.from,
            to: this.pos,
            text: this.state.sliceDoc(token.from, this.pos),
            type: token.type
          } : null;
        }
        matchBefore(expr) {
          let line = this.state.doc.lineAt(this.pos);
          let start = Math.max(line.from, this.pos - 250);
          let str = line.text.slice(start - line.from, this.pos - line.from);
          let found = str.search(ensureAnchor(expr, false));
          return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };
        }
        get aborted() {
          return this.abortListeners == null;
        }
        addEventListener(type, listener) {
          if (type == "abort" && this.abortListeners)
            this.abortListeners.push(listener);
        }
      };
      function toSet(chars) {
        let flat = Object.keys(chars).join("");
        let words = /\w/.test(flat);
        if (words)
          flat = flat.replace(/\w/g, "");
        return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
      }
      function prefixMatch(options) {
        let first = /* @__PURE__ */ Object.create(null), rest = /* @__PURE__ */ Object.create(null);
        for (let { label } of options) {
          first[label[0]] = true;
          for (let i = 1; i < label.length; i++)
            rest[label[i]] = true;
        }
        let source = toSet(first) + toSet(rest) + "*$";
        return [new RegExp("^" + source), new RegExp(source)];
      }
      function completeFromList(list) {
        let options = list.map((o) => typeof o == "string" ? { label: o } : o);
        let [validFor, match] = options.every((o) => /^\w+$/.test(o.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options);
        return (context) => {
          let token = context.matchBefore(match);
          return token || context.explicit ? { from: token ? token.from : context.pos, options, validFor } : null;
        };
      }
      function ifIn(nodes, source) {
        return (context) => {
          for (let pos = language.syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent)
            if (nodes.indexOf(pos.name) > -1)
              return source(context);
          return null;
        };
      }
      function ifNotIn(nodes, source) {
        return (context) => {
          for (let pos = language.syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent)
            if (nodes.indexOf(pos.name) > -1)
              return null;
          return source(context);
        };
      }
      var Option = class {
        constructor(completion, source, match) {
          this.completion = completion;
          this.source = source;
          this.match = match;
        }
      };
      function cur(state2) {
        return state2.selection.main.head;
      }
      function ensureAnchor(expr, start) {
        var _a;
        let { source } = expr;
        let addStart = start && source[0] != "^", addEnd = source[source.length - 1] != "$";
        if (!addStart && !addEnd)
          return expr;
        return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : expr.ignoreCase ? "i" : "");
      }
      var pickedCompletion = state.Annotation.define();
      function insertCompletionText(state$1, text, from, to) {
        return Object.assign(Object.assign({}, state$1.changeByRange((range) => {
          if (range == state$1.selection.main)
            return {
              changes: { from, to, insert: text },
              range: state.EditorSelection.cursor(from + text.length)
            };
          let len = to - from;
          if (!range.empty || len && state$1.sliceDoc(range.from - len, range.from) != state$1.sliceDoc(from, to))
            return { range };
          return {
            changes: { from: range.from - len, to: range.from, insert: text },
            range: state.EditorSelection.cursor(range.from - len + text.length)
          };
        })), { userEvent: "input.complete" });
      }
      function applyCompletion(view2, option) {
        const apply = option.completion.apply || option.completion.label;
        let result = option.source;
        if (typeof apply == "string")
          view2.dispatch(insertCompletionText(view2.state, apply, result.from, result.to));
        else
          apply(view2, option.completion, result.from, result.to);
      }
      var SourceCache = /* @__PURE__ */ new WeakMap();
      function asSource(source) {
        if (!Array.isArray(source))
          return source;
        let known = SourceCache.get(source);
        if (!known)
          SourceCache.set(source, known = completeFromList(source));
        return known;
      }
      var FuzzyMatcher = class {
        constructor(pattern) {
          this.pattern = pattern;
          this.chars = [];
          this.folded = [];
          this.any = [];
          this.precise = [];
          this.byWord = [];
          for (let p = 0; p < pattern.length; ) {
            let char = state.codePointAt(pattern, p), size = state.codePointSize(char);
            this.chars.push(char);
            let part = pattern.slice(p, p + size), upper = part.toUpperCase();
            this.folded.push(state.codePointAt(upper == part ? part.toLowerCase() : upper, 0));
            p += size;
          }
          this.astral = pattern.length != this.chars.length;
        }
        match(word) {
          if (this.pattern.length == 0)
            return [0];
          if (word.length < this.pattern.length)
            return null;
          let { chars, folded, any, precise, byWord } = this;
          if (chars.length == 1) {
            let first = state.codePointAt(word, 0);
            return first == chars[0] ? [0, 0, state.codePointSize(first)] : first == folded[0] ? [-200, 0, state.codePointSize(first)] : null;
          }
          let direct = word.indexOf(this.pattern);
          if (direct == 0)
            return [0, 0, this.pattern.length];
          let len = chars.length, anyTo = 0;
          if (direct < 0) {
            for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len; ) {
              let next = state.codePointAt(word, i);
              if (next == chars[anyTo] || next == folded[anyTo])
                any[anyTo++] = i;
              i += state.codePointSize(next);
            }
            if (anyTo < len)
              return null;
          }
          let preciseTo = 0;
          let byWordTo = 0, byWordFolded = false;
          let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
          let hasLower = /[a-z]/.test(word), wordAdjacent = true;
          for (let i = 0, e = Math.min(word.length, 200), prevType = 0; i < e && byWordTo < len; ) {
            let next = state.codePointAt(word, i);
            if (direct < 0) {
              if (preciseTo < len && next == chars[preciseTo])
                precise[preciseTo++] = i;
              if (adjacentTo < len) {
                if (next == chars[adjacentTo] || next == folded[adjacentTo]) {
                  if (adjacentTo == 0)
                    adjacentStart = i;
                  adjacentEnd = i + 1;
                  adjacentTo++;
                } else {
                  adjacentTo = 0;
                }
              }
            }
            let ch, type = next < 255 ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 : next >= 65 && next <= 90 ? 1 : 0 : (ch = state.fromCodePoint(next)) != ch.toLowerCase() ? 1 : ch != ch.toUpperCase() ? 2 : 0;
            if (!i || type == 1 && hasLower || prevType == 0 && type != 0) {
              if (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true))
                byWord[byWordTo++] = i;
              else if (byWord.length)
                wordAdjacent = false;
            }
            prevType = type;
            i += state.codePointSize(next);
          }
          if (byWordTo == len && byWord[0] == 0 && wordAdjacent)
            return this.result(-100 + (byWordFolded ? -200 : 0), byWord, word);
          if (adjacentTo == len && adjacentStart == 0)
            return [-200 - word.length, 0, adjacentEnd];
          if (direct > -1)
            return [-700 - word.length, direct, direct + this.pattern.length];
          if (adjacentTo == len)
            return [-200 + -700 - word.length, adjacentStart, adjacentEnd];
          if (byWordTo == len)
            return this.result(-100 + (byWordFolded ? -200 : 0) + -700 + (wordAdjacent ? 0 : -1100), byWord, word);
          return chars.length == 2 ? null : this.result((any[0] ? -700 : 0) + -200 + -1100, any, word);
        }
        result(score2, positions, word) {
          let result = [score2 - word.length], i = 1;
          for (let pos of positions) {
            let to = pos + (this.astral ? state.codePointSize(state.codePointAt(word, pos)) : 1);
            if (i > 1 && result[i - 1] == pos)
              result[i - 1] = to;
            else {
              result[i++] = pos;
              result[i++] = to;
            }
          }
          return result;
        }
      };
      var completionConfig = state.Facet.define({
        combine(configs) {
          return state.combineConfig(configs, {
            activateOnTyping: true,
            selectOnOpen: true,
            override: null,
            closeOnBlur: true,
            maxRenderedOptions: 100,
            defaultKeymap: true,
            optionClass: () => "",
            aboveCursor: false,
            icons: true,
            addToOptions: [],
            compareCompletions: (a, b) => a.label.localeCompare(b.label)
          }, {
            defaultKeymap: (a, b) => a && b,
            closeOnBlur: (a, b) => a && b,
            icons: (a, b) => a && b,
            optionClass: (a, b) => (c) => joinClass(a(c), b(c)),
            addToOptions: (a, b) => a.concat(b)
          });
        }
      });
      function joinClass(a, b) {
        return a ? b ? a + " " + b : a : b;
      }
      function optionContent(config2) {
        let content = config2.addToOptions.slice();
        if (config2.icons)
          content.push({
            render(completion) {
              let icon = document.createElement("div");
              icon.classList.add("cm-completionIcon");
              if (completion.type)
                icon.classList.add(...completion.type.split(/\s+/g).map((cls) => "cm-completionIcon-" + cls));
              icon.setAttribute("aria-hidden", "true");
              return icon;
            },
            position: 20
          });
        content.push({
          render(completion, _s, match) {
            let labelElt = document.createElement("span");
            labelElt.className = "cm-completionLabel";
            let { label } = completion, off = 0;
            for (let j = 1; j < match.length; ) {
              let from = match[j++], to = match[j++];
              if (from > off)
                labelElt.appendChild(document.createTextNode(label.slice(off, from)));
              let span = labelElt.appendChild(document.createElement("span"));
              span.appendChild(document.createTextNode(label.slice(from, to)));
              span.className = "cm-completionMatchedText";
              off = to;
            }
            if (off < label.length)
              labelElt.appendChild(document.createTextNode(label.slice(off)));
            return labelElt;
          },
          position: 50
        }, {
          render(completion) {
            if (!completion.detail)
              return null;
            let detailElt = document.createElement("span");
            detailElt.className = "cm-completionDetail";
            detailElt.textContent = completion.detail;
            return detailElt;
          },
          position: 80
        });
        return content.sort((a, b) => a.position - b.position).map((a) => a.render);
      }
      function rangeAroundSelected(total, selected, max) {
        if (total <= max)
          return { from: 0, to: total };
        if (selected < 0)
          selected = 0;
        if (selected <= total >> 1) {
          let off2 = Math.floor(selected / max);
          return { from: off2 * max, to: (off2 + 1) * max };
        }
        let off = Math.floor((total - selected) / max);
        return { from: total - (off + 1) * max, to: total - off * max };
      }
      var CompletionTooltip = class {
        constructor(view2, stateField) {
          this.view = view2;
          this.stateField = stateField;
          this.info = null;
          this.placeInfo = {
            read: () => this.measureInfo(),
            write: (pos) => this.positionInfo(pos),
            key: this
          };
          let cState = view2.state.field(stateField);
          let { options, selected } = cState.open;
          let config2 = view2.state.facet(completionConfig);
          this.optionContent = optionContent(config2);
          this.optionClass = config2.optionClass;
          this.range = rangeAroundSelected(options.length, selected, config2.maxRenderedOptions);
          this.dom = document.createElement("div");
          this.dom.className = "cm-tooltip-autocomplete";
          this.dom.addEventListener("mousedown", (e) => {
            for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {
              if (dom.nodeName == "LI" && (match = /-(\d+)$/.exec(dom.id)) && +match[1] < options.length) {
                applyCompletion(view2, options[+match[1]]);
                e.preventDefault();
                return;
              }
            }
          });
          this.list = this.dom.appendChild(this.createListBox(options, cState.id, this.range));
          this.list.addEventListener("scroll", () => {
            if (this.info)
              this.view.requestMeasure(this.placeInfo);
          });
        }
        mount() {
          this.updateSel();
        }
        update(update) {
          if (update.state.field(this.stateField) != update.startState.field(this.stateField))
            this.updateSel();
        }
        positioned() {
          if (this.info)
            this.view.requestMeasure(this.placeInfo);
        }
        updateSel() {
          let cState = this.view.state.field(this.stateField), open2 = cState.open;
          if (open2.selected < this.range.from || open2.selected >= this.range.to) {
            this.range = rangeAroundSelected(open2.options.length, open2.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
            this.list.remove();
            this.list = this.dom.appendChild(this.createListBox(open2.options, cState.id, this.range));
            this.list.addEventListener("scroll", () => {
              if (this.info)
                this.view.requestMeasure(this.placeInfo);
            });
          }
          if (this.updateSelectedOption(open2.selected)) {
            if (this.info) {
              this.info.remove();
              this.info = null;
            }
            let { completion } = open2.options[open2.selected];
            let { info } = completion;
            if (!info)
              return;
            let infoResult = typeof info === "string" ? document.createTextNode(info) : info(completion);
            if (!infoResult)
              return;
            if ("then" in infoResult) {
              infoResult.then((node) => {
                if (node && this.view.state.field(this.stateField, false) == cState)
                  this.addInfoPane(node);
              }).catch((e) => view.logException(this.view.state, e, "completion info"));
            } else {
              this.addInfoPane(infoResult);
            }
          }
        }
        addInfoPane(content) {
          let dom = this.info = document.createElement("div");
          dom.className = "cm-tooltip cm-completionInfo";
          dom.appendChild(content);
          this.dom.appendChild(dom);
          this.view.requestMeasure(this.placeInfo);
        }
        updateSelectedOption(selected) {
          let set = null;
          for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {
            if (i == selected) {
              if (!opt.hasAttribute("aria-selected")) {
                opt.setAttribute("aria-selected", "true");
                set = opt;
              }
            } else {
              if (opt.hasAttribute("aria-selected"))
                opt.removeAttribute("aria-selected");
            }
          }
          if (set)
            scrollIntoView(this.list, set);
          return set;
        }
        measureInfo() {
          let sel = this.dom.querySelector("[aria-selected]");
          if (!sel || !this.info)
            return null;
          let listRect = this.dom.getBoundingClientRect();
          let infoRect = this.info.getBoundingClientRect();
          let selRect = sel.getBoundingClientRect();
          if (selRect.top > Math.min(innerHeight, listRect.bottom) - 10 || selRect.bottom < Math.max(0, listRect.top) + 10)
            return null;
          let top = Math.max(0, Math.min(selRect.top, innerHeight - infoRect.height)) - listRect.top;
          let left = this.view.textDirection == view.Direction.RTL;
          let spaceLeft = listRect.left, spaceRight = innerWidth - listRect.right;
          if (left && spaceLeft < Math.min(infoRect.width, spaceRight))
            left = false;
          else if (!left && spaceRight < Math.min(infoRect.width, spaceLeft))
            left = true;
          return { top, left };
        }
        positionInfo(pos) {
          if (this.info) {
            this.info.style.top = (pos ? pos.top : -1e6) + "px";
            if (pos) {
              this.info.classList.toggle("cm-completionInfo-left", pos.left);
              this.info.classList.toggle("cm-completionInfo-right", !pos.left);
            }
          }
        }
        createListBox(options, id, range) {
          const ul = document.createElement("ul");
          ul.id = id;
          ul.setAttribute("role", "listbox");
          ul.setAttribute("aria-expanded", "true");
          ul.setAttribute("aria-label", this.view.state.phrase("Completions"));
          for (let i = range.from; i < range.to; i++) {
            let { completion, match } = options[i];
            const li = ul.appendChild(document.createElement("li"));
            li.id = id + "-" + i;
            li.setAttribute("role", "option");
            let cls = this.optionClass(completion);
            if (cls)
              li.className = cls;
            for (let source of this.optionContent) {
              let node = source(completion, this.view.state, match);
              if (node)
                li.appendChild(node);
            }
          }
          if (range.from)
            ul.classList.add("cm-completionListIncompleteTop");
          if (range.to < options.length)
            ul.classList.add("cm-completionListIncompleteBottom");
          return ul;
        }
      };
      function completionTooltip(stateField) {
        return (view2) => new CompletionTooltip(view2, stateField);
      }
      function scrollIntoView(container, element) {
        let parent = container.getBoundingClientRect();
        let self2 = element.getBoundingClientRect();
        if (self2.top < parent.top)
          container.scrollTop -= parent.top - self2.top;
        else if (self2.bottom > parent.bottom)
          container.scrollTop += self2.bottom - parent.bottom;
      }
      function score(option) {
        return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);
      }
      function sortOptions(active, state2) {
        let options = [], i = 0;
        for (let a of active)
          if (a.hasResult()) {
            if (a.result.filter === false) {
              let getMatch = a.result.getMatch;
              for (let option of a.result.options) {
                let match = [1e9 - i++];
                if (getMatch)
                  for (let n of getMatch(option))
                    match.push(n);
                options.push(new Option(option, a, match));
              }
            } else {
              let matcher = new FuzzyMatcher(state2.sliceDoc(a.from, a.to)), match;
              for (let option of a.result.options)
                if (match = matcher.match(option.label)) {
                  if (option.boost != null)
                    match[0] += option.boost;
                  options.push(new Option(option, a, match));
                }
            }
          }
        let result = [], prev = null;
        let compare = state2.facet(completionConfig).compareCompletions;
        for (let opt of options.sort((a, b) => b.match[0] - a.match[0] || compare(a.completion, b.completion))) {
          if (!prev || prev.label != opt.completion.label || prev.detail != opt.completion.detail || prev.type != null && opt.completion.type != null && prev.type != opt.completion.type || prev.apply != opt.completion.apply)
            result.push(opt);
          else if (score(opt.completion) > score(prev))
            result[result.length - 1] = opt;
          prev = opt.completion;
        }
        return result;
      }
      var CompletionDialog = class {
        constructor(options, attrs, tooltip, timestamp, selected) {
          this.options = options;
          this.attrs = attrs;
          this.tooltip = tooltip;
          this.timestamp = timestamp;
          this.selected = selected;
        }
        setSelected(selected, id) {
          return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected);
        }
        static build(active, state2, id, prev, conf) {
          let options = sortOptions(active, state2);
          if (!options.length)
            return null;
          let selected = state2.facet(completionConfig).selectOnOpen ? 0 : -1;
          if (prev && prev.selected != selected && prev.selected != -1) {
            let selectedValue = prev.options[prev.selected].completion;
            for (let i = 0; i < options.length; i++)
              if (options[i].completion == selectedValue) {
                selected = i;
                break;
              }
          }
          return new CompletionDialog(options, makeAttrs(id, selected), {
            pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),
            create: completionTooltip(completionState),
            above: conf.aboveCursor
          }, prev ? prev.timestamp : Date.now(), selected);
        }
        map(changes) {
          return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected);
        }
      };
      var CompletionState = class {
        constructor(active, id, open2) {
          this.active = active;
          this.id = id;
          this.open = open2;
        }
        static start() {
          return new CompletionState(none, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
        }
        update(tr) {
          let { state: state2 } = tr, conf = state2.facet(completionConfig);
          let sources = conf.override || state2.languageDataAt("autocomplete", cur(state2)).map(asSource);
          let active = sources.map((source) => {
            let value = this.active.find((s) => s.source == source) || new ActiveSource(source, this.active.some((a) => a.state != 0) ? 1 : 0);
            return value.update(tr, conf);
          });
          if (active.length == this.active.length && active.every((a, i) => a == this.active[i]))
            active = this.active;
          let open2 = tr.selection || active.some((a) => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) || !sameResults(active, this.active) ? CompletionDialog.build(active, state2, this.id, this.open, conf) : this.open && tr.docChanged ? this.open.map(tr.changes) : this.open;
          if (!open2 && active.every((a) => a.state != 1) && active.some((a) => a.hasResult()))
            active = active.map((a) => a.hasResult() ? new ActiveSource(a.source, 0) : a);
          for (let effect of tr.effects)
            if (effect.is(setSelectedEffect))
              open2 = open2 && open2.setSelected(effect.value, this.id);
          return active == this.active && open2 == this.open ? this : new CompletionState(active, this.id, open2);
        }
        get tooltip() {
          return this.open ? this.open.tooltip : null;
        }
        get attrs() {
          return this.open ? this.open.attrs : baseAttrs;
        }
      };
      function sameResults(a, b) {
        if (a == b)
          return true;
        for (let iA = 0, iB = 0; ; ) {
          while (iA < a.length && !a[iA].hasResult)
            iA++;
          while (iB < b.length && !b[iB].hasResult)
            iB++;
          let endA = iA == a.length, endB = iB == b.length;
          if (endA || endB)
            return endA == endB;
          if (a[iA++].result != b[iB++].result)
            return false;
        }
      }
      var baseAttrs = {
        "aria-autocomplete": "list"
      };
      function makeAttrs(id, selected) {
        let result = {
          "aria-autocomplete": "list",
          "aria-haspopup": "listbox",
          "aria-controls": id
        };
        if (selected > -1)
          result["aria-activedescendant"] = id + "-" + selected;
        return result;
      }
      var none = [];
      function getUserEvent(tr) {
        return tr.isUserEvent("input.type") ? "input" : tr.isUserEvent("delete.backward") ? "delete" : null;
      }
      var ActiveSource = class {
        constructor(source, state2, explicitPos = -1) {
          this.source = source;
          this.state = state2;
          this.explicitPos = explicitPos;
        }
        hasResult() {
          return false;
        }
        update(tr, conf) {
          let event = getUserEvent(tr), value = this;
          if (event)
            value = value.handleUserEvent(tr, event, conf);
          else if (tr.docChanged)
            value = value.handleChange(tr);
          else if (tr.selection && value.state != 0)
            value = new ActiveSource(value.source, 0);
          for (let effect of tr.effects) {
            if (effect.is(startCompletionEffect))
              value = new ActiveSource(value.source, 1, effect.value ? cur(tr.state) : -1);
            else if (effect.is(closeCompletionEffect))
              value = new ActiveSource(value.source, 0);
            else if (effect.is(setActiveEffect)) {
              for (let active of effect.value)
                if (active.source == value.source)
                  value = active;
            }
          }
          return value;
        }
        handleUserEvent(tr, type, conf) {
          return type == "delete" || !conf.activateOnTyping ? this.map(tr.changes) : new ActiveSource(this.source, 1);
        }
        handleChange(tr) {
          return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0) : this.map(tr.changes);
        }
        map(changes) {
          return changes.empty || this.explicitPos < 0 ? this : new ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));
        }
      };
      var ActiveResult = class extends ActiveSource {
        constructor(source, explicitPos, result, from, to) {
          super(source, 2, explicitPos);
          this.result = result;
          this.from = from;
          this.to = to;
        }
        hasResult() {
          return true;
        }
        handleUserEvent(tr, type, conf) {
          var _a;
          let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);
          let pos = cur(tr.state);
          if ((this.explicitPos < 0 ? pos <= from : pos < this.from) || pos > to || type == "delete" && cur(tr.startState) == this.from)
            return new ActiveSource(this.source, type == "input" && conf.activateOnTyping ? 1 : 0);
          let explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos), updated;
          if (checkValid(this.result.validFor, tr.state, from, to))
            return new ActiveResult(this.source, explicitPos, this.result, from, to);
          if (this.result.update && (updated = this.result.update(this.result, from, to, new CompletionContext(tr.state, pos, explicitPos >= 0))))
            return new ActiveResult(this.source, explicitPos, updated, updated.from, (_a = updated.to) !== null && _a !== void 0 ? _a : cur(tr.state));
          return new ActiveSource(this.source, 1, explicitPos);
        }
        handleChange(tr) {
          return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, 0) : this.map(tr.changes);
        }
        map(mapping) {
          return mapping.empty ? this : new ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));
        }
      };
      function checkValid(validFor, state2, from, to) {
        if (!validFor)
          return false;
        let text = state2.sliceDoc(from, to);
        return typeof validFor == "function" ? validFor(text, from, to, state2) : ensureAnchor(validFor, true).test(text);
      }
      var startCompletionEffect = state.StateEffect.define();
      var closeCompletionEffect = state.StateEffect.define();
      var setActiveEffect = state.StateEffect.define({
        map(sources, mapping) {
          return sources.map((s) => s.map(mapping));
        }
      });
      var setSelectedEffect = state.StateEffect.define();
      var completionState = state.StateField.define({
        create() {
          return CompletionState.start();
        },
        update(value, tr) {
          return value.update(tr);
        },
        provide: (f) => [
          view.showTooltip.from(f, (val) => val.tooltip),
          view.EditorView.contentAttributes.from(f, (state2) => state2.attrs)
        ]
      });
      var CompletionInteractMargin = 75;
      function moveCompletionSelection(forward, by = "option") {
        return (view$1) => {
          let cState = view$1.state.field(completionState, false);
          if (!cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin)
            return false;
          let step = 1, tooltip;
          if (by == "page" && (tooltip = view.getTooltip(view$1, cState.open.tooltip)))
            step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector("li").offsetHeight) - 1);
          let { length } = cState.open.options;
          let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;
          if (selected < 0)
            selected = by == "page" ? 0 : length - 1;
          else if (selected >= length)
            selected = by == "page" ? length - 1 : 0;
          view$1.dispatch({ effects: setSelectedEffect.of(selected) });
          return true;
        };
      }
      var acceptCompletion = (view2) => {
        let cState = view2.state.field(completionState, false);
        if (view2.state.readOnly || !cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin || cState.open.selected < 0)
          return false;
        applyCompletion(view2, cState.open.options[cState.open.selected]);
        return true;
      };
      var startCompletion = (view2) => {
        let cState = view2.state.field(completionState, false);
        if (!cState)
          return false;
        view2.dispatch({ effects: startCompletionEffect.of(true) });
        return true;
      };
      var closeCompletion = (view2) => {
        let cState = view2.state.field(completionState, false);
        if (!cState || !cState.active.some((a) => a.state != 0))
          return false;
        view2.dispatch({ effects: closeCompletionEffect.of(null) });
        return true;
      };
      var RunningQuery = class {
        constructor(active, context) {
          this.active = active;
          this.context = context;
          this.time = Date.now();
          this.updates = [];
          this.done = void 0;
        }
      };
      var DebounceTime = 50;
      var MaxUpdateCount = 50;
      var MinAbortTime = 1e3;
      var completionPlugin = view.ViewPlugin.fromClass(class {
        constructor(view2) {
          this.view = view2;
          this.debounceUpdate = -1;
          this.running = [];
          this.debounceAccept = -1;
          this.composing = 0;
          for (let active of view2.state.field(completionState).active)
            if (active.state == 1)
              this.startQuery(active);
        }
        update(update) {
          let cState = update.state.field(completionState);
          if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)
            return;
          let doesReset = update.transactions.some((tr) => {
            return (tr.selection || tr.docChanged) && !getUserEvent(tr);
          });
          for (let i = 0; i < this.running.length; i++) {
            let query = this.running[i];
            if (doesReset || query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {
              for (let handler of query.context.abortListeners) {
                try {
                  handler();
                } catch (e) {
                  view.logException(this.view.state, e);
                }
              }
              query.context.abortListeners = null;
              this.running.splice(i--, 1);
            } else {
              query.updates.push(...update.transactions);
            }
          }
          if (this.debounceUpdate > -1)
            clearTimeout(this.debounceUpdate);
          this.debounceUpdate = cState.active.some((a) => a.state == 1 && !this.running.some((q) => q.active.source == a.source)) ? setTimeout(() => this.startUpdate(), DebounceTime) : -1;
          if (this.composing != 0)
            for (let tr of update.transactions) {
              if (getUserEvent(tr) == "input")
                this.composing = 2;
              else if (this.composing == 2 && tr.selection)
                this.composing = 3;
            }
        }
        startUpdate() {
          this.debounceUpdate = -1;
          let { state: state2 } = this.view, cState = state2.field(completionState);
          for (let active of cState.active) {
            if (active.state == 1 && !this.running.some((r) => r.active.source == active.source))
              this.startQuery(active);
          }
        }
        startQuery(active) {
          let { state: state2 } = this.view, pos = cur(state2);
          let context = new CompletionContext(state2, pos, active.explicitPos == pos);
          let pending = new RunningQuery(active, context);
          this.running.push(pending);
          Promise.resolve(active.source(context)).then((result) => {
            if (!pending.context.aborted) {
              pending.done = result || null;
              this.scheduleAccept();
            }
          }, (err) => {
            this.view.dispatch({ effects: closeCompletionEffect.of(null) });
            view.logException(this.view.state, err);
          });
        }
        scheduleAccept() {
          if (this.running.every((q) => q.done !== void 0))
            this.accept();
          else if (this.debounceAccept < 0)
            this.debounceAccept = setTimeout(() => this.accept(), DebounceTime);
        }
        accept() {
          var _a;
          if (this.debounceAccept > -1)
            clearTimeout(this.debounceAccept);
          this.debounceAccept = -1;
          let updated = [];
          let conf = this.view.state.facet(completionConfig);
          for (let i = 0; i < this.running.length; i++) {
            let query = this.running[i];
            if (query.done === void 0)
              continue;
            this.running.splice(i--, 1);
            if (query.done) {
              let active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : cur(query.updates.length ? query.updates[0].startState : this.view.state));
              for (let tr of query.updates)
                active = active.update(tr, conf);
              if (active.hasResult()) {
                updated.push(active);
                continue;
              }
            }
            let current = this.view.state.field(completionState).active.find((a) => a.source == query.active.source);
            if (current && current.state == 1) {
              if (query.done == null) {
                let active = new ActiveSource(query.active.source, 0);
                for (let tr of query.updates)
                  active = active.update(tr, conf);
                if (active.state != 1)
                  updated.push(active);
              } else {
                this.startQuery(current);
              }
            }
          }
          if (updated.length)
            this.view.dispatch({ effects: setActiveEffect.of(updated) });
        }
      }, {
        eventHandlers: {
          blur() {
            let state2 = this.view.state.field(completionState, false);
            if (state2 && state2.tooltip && this.view.state.facet(completionConfig).closeOnBlur)
              this.view.dispatch({ effects: closeCompletionEffect.of(null) });
          },
          compositionstart() {
            this.composing = 1;
          },
          compositionend() {
            if (this.composing == 3) {
              setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20);
            }
            this.composing = 0;
          }
        }
      });
      var baseTheme = view.EditorView.baseTheme({
        ".cm-tooltip.cm-tooltip-autocomplete": {
          "& > ul": {
            fontFamily: "monospace",
            whiteSpace: "nowrap",
            overflow: "hidden auto",
            maxWidth_fallback: "700px",
            maxWidth: "min(700px, 95vw)",
            minWidth: "250px",
            maxHeight: "10em",
            listStyle: "none",
            margin: 0,
            padding: 0,
            "& > li": {
              overflowX: "hidden",
              textOverflow: "ellipsis",
              cursor: "pointer",
              padding: "1px 3px",
              lineHeight: 1.2
            }
          }
        },
        "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
          background: "#17c",
          color: "white"
        },
        "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
          background: "#347",
          color: "white"
        },
        ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
          content: '"\xB7\xB7\xB7"',
          opacity: 0.5,
          display: "block",
          textAlign: "center"
        },
        ".cm-tooltip.cm-completionInfo": {
          position: "absolute",
          padding: "3px 9px",
          width: "max-content",
          maxWidth: "300px"
        },
        ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
        ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
        "&light .cm-snippetField": { backgroundColor: "#00000022" },
        "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
        ".cm-snippetFieldPosition": {
          verticalAlign: "text-top",
          width: 0,
          height: "1.15em",
          margin: "0 -0.7px -.7em",
          borderLeft: "1.4px dotted #888"
        },
        ".cm-completionMatchedText": {
          textDecoration: "underline"
        },
        ".cm-completionDetail": {
          marginLeft: "0.5em",
          fontStyle: "italic"
        },
        ".cm-completionIcon": {
          fontSize: "90%",
          width: ".8em",
          display: "inline-block",
          textAlign: "center",
          paddingRight: ".6em",
          opacity: "0.6"
        },
        ".cm-completionIcon-function, .cm-completionIcon-method": {
          "&:after": { content: "'\u0192'" }
        },
        ".cm-completionIcon-class": {
          "&:after": { content: "'\u25CB'" }
        },
        ".cm-completionIcon-interface": {
          "&:after": { content: "'\u25CC'" }
        },
        ".cm-completionIcon-variable": {
          "&:after": { content: "'\u{1D465}'" }
        },
        ".cm-completionIcon-constant": {
          "&:after": { content: "'\u{1D436}'" }
        },
        ".cm-completionIcon-type": {
          "&:after": { content: "'\u{1D461}'" }
        },
        ".cm-completionIcon-enum": {
          "&:after": { content: "'\u222A'" }
        },
        ".cm-completionIcon-property": {
          "&:after": { content: "'\u25A1'" }
        },
        ".cm-completionIcon-keyword": {
          "&:after": { content: "'\u{1F511}\uFE0E'" }
        },
        ".cm-completionIcon-namespace": {
          "&:after": { content: "'\u25A2'" }
        },
        ".cm-completionIcon-text": {
          "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
        }
      });
      var FieldPos = class {
        constructor(field, line, from, to) {
          this.field = field;
          this.line = line;
          this.from = from;
          this.to = to;
        }
      };
      var FieldRange = class {
        constructor(field, from, to) {
          this.field = field;
          this.from = from;
          this.to = to;
        }
        map(changes) {
          let from = changes.mapPos(this.from, -1, state.MapMode.TrackDel);
          let to = changes.mapPos(this.to, 1, state.MapMode.TrackDel);
          return from == null || to == null ? null : new FieldRange(this.field, from, to);
        }
      };
      var Snippet = class {
        constructor(lines, fieldPositions) {
          this.lines = lines;
          this.fieldPositions = fieldPositions;
        }
        instantiate(state2, pos) {
          let text = [], lineStart = [pos];
          let lineObj = state2.doc.lineAt(pos), baseIndent = /^\s*/.exec(lineObj.text)[0];
          for (let line of this.lines) {
            if (text.length) {
              let indent = baseIndent, tabs = /^\t*/.exec(line)[0].length;
              for (let i = 0; i < tabs; i++)
                indent += state2.facet(language.indentUnit);
              lineStart.push(pos + indent.length - tabs);
              line = indent + line.slice(tabs);
            }
            text.push(line);
            pos += line.length + 1;
          }
          let ranges = this.fieldPositions.map((pos2) => new FieldRange(pos2.field, lineStart[pos2.line] + pos2.from, lineStart[pos2.line] + pos2.to));
          return { text, ranges };
        }
        static parse(template) {
          let fields = [];
          let lines = [], positions = [], m;
          for (let line of template.split(/\r\n?|\n/)) {
            while (m = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(line)) {
              let seq = m[1] ? +m[1] : null, name = m[2] || m[3] || "", found = -1;
              for (let i = 0; i < fields.length; i++) {
                if (seq != null ? fields[i].seq == seq : name ? fields[i].name == name : false)
                  found = i;
              }
              if (found < 0) {
                let i = 0;
                while (i < fields.length && (seq == null || fields[i].seq != null && fields[i].seq < seq))
                  i++;
                fields.splice(i, 0, { seq, name });
                found = i;
                for (let pos of positions)
                  if (pos.field >= found)
                    pos.field++;
              }
              positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));
              line = line.slice(0, m.index) + name + line.slice(m.index + m[0].length);
            }
            for (let esc; esc = /([$#])\\{/.exec(line); ) {
              line = line.slice(0, esc.index) + esc[1] + "{" + line.slice(esc.index + esc[0].length);
              for (let pos of positions)
                if (pos.line == lines.length && pos.from > esc.index) {
                  pos.from--;
                  pos.to--;
                }
            }
            lines.push(line);
          }
          return new Snippet(lines, positions);
        }
      };
      var fieldMarker = view.Decoration.widget({ widget: new class extends view.WidgetType {
        toDOM() {
          let span = document.createElement("span");
          span.className = "cm-snippetFieldPosition";
          return span;
        }
        ignoreEvent() {
          return false;
        }
      }() });
      var fieldRange = view.Decoration.mark({ class: "cm-snippetField" });
      var ActiveSnippet = class {
        constructor(ranges, active) {
          this.ranges = ranges;
          this.active = active;
          this.deco = view.Decoration.set(ranges.map((r) => (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));
        }
        map(changes) {
          let ranges = [];
          for (let r of this.ranges) {
            let mapped = r.map(changes);
            if (!mapped)
              return null;
            ranges.push(mapped);
          }
          return new ActiveSnippet(ranges, this.active);
        }
        selectionInsideField(sel) {
          return sel.ranges.every((range) => this.ranges.some((r) => r.field == this.active && r.from <= range.from && r.to >= range.to));
        }
      };
      var setActive = state.StateEffect.define({
        map(value, changes) {
          return value && value.map(changes);
        }
      });
      var moveToField = state.StateEffect.define();
      var snippetState = state.StateField.define({
        create() {
          return null;
        },
        update(value, tr) {
          for (let effect of tr.effects) {
            if (effect.is(setActive))
              return effect.value;
            if (effect.is(moveToField) && value)
              return new ActiveSnippet(value.ranges, effect.value);
          }
          if (value && tr.docChanged)
            value = value.map(tr.changes);
          if (value && tr.selection && !value.selectionInsideField(tr.selection))
            value = null;
          return value;
        },
        provide: (f) => view.EditorView.decorations.from(f, (val) => val ? val.deco : view.Decoration.none)
      });
      function fieldSelection(ranges, field) {
        return state.EditorSelection.create(ranges.filter((r) => r.field == field).map((r) => state.EditorSelection.range(r.from, r.to)));
      }
      function snippet(template) {
        let snippet2 = Snippet.parse(template);
        return (editor, _completion, from, to) => {
          let { text, ranges } = snippet2.instantiate(editor.state, from);
          let spec = {
            changes: { from, to, insert: state.Text.of(text) },
            scrollIntoView: true
          };
          if (ranges.length)
            spec.selection = fieldSelection(ranges, 0);
          if (ranges.length > 1) {
            let active = new ActiveSnippet(ranges, 0);
            let effects = spec.effects = [setActive.of(active)];
            if (editor.state.field(snippetState, false) === void 0)
              effects.push(state.StateEffect.appendConfig.of([snippetState, addSnippetKeymap, snippetPointerHandler, baseTheme]));
          }
          editor.dispatch(editor.state.update(spec));
        };
      }
      function moveField(dir) {
        return ({ state: state2, dispatch }) => {
          let active = state2.field(snippetState, false);
          if (!active || dir < 0 && active.active == 0)
            return false;
          let next = active.active + dir, last = dir > 0 && !active.ranges.some((r) => r.field == next + dir);
          dispatch(state2.update({
            selection: fieldSelection(active.ranges, next),
            effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next))
          }));
          return true;
        };
      }
      var clearSnippet = ({ state: state2, dispatch }) => {
        let active = state2.field(snippetState, false);
        if (!active)
          return false;
        dispatch(state2.update({ effects: setActive.of(null) }));
        return true;
      };
      var nextSnippetField = moveField(1);
      var prevSnippetField = moveField(-1);
      var defaultSnippetKeymap = [
        { key: "Tab", run: nextSnippetField, shift: prevSnippetField },
        { key: "Escape", run: clearSnippet }
      ];
      var snippetKeymap = state.Facet.define({
        combine(maps) {
          return maps.length ? maps[0] : defaultSnippetKeymap;
        }
      });
      var addSnippetKeymap = state.Prec.highest(view.keymap.compute([snippetKeymap], (state2) => state2.facet(snippetKeymap)));
      function snippetCompletion(template, completion) {
        return Object.assign(Object.assign({}, completion), { apply: snippet(template) });
      }
      var snippetPointerHandler = view.EditorView.domEventHandlers({
        mousedown(event, view2) {
          let active = view2.state.field(snippetState, false), pos;
          if (!active || (pos = view2.posAtCoords({ x: event.clientX, y: event.clientY })) == null)
            return false;
          let match = active.ranges.find((r) => r.from <= pos && r.to >= pos);
          if (!match || match.field == active.active)
            return false;
          view2.dispatch({
            selection: fieldSelection(active.ranges, match.field),
            effects: setActive.of(active.ranges.some((r) => r.field > match.field) ? new ActiveSnippet(active.ranges, match.field) : null)
          });
          return true;
        }
      });
      function wordRE(wordChars) {
        let escaped = wordChars.replace(/[\\[.+*?(){|^$]/g, "\\$&");
        try {
          return new RegExp(`[\\p{Alphabetic}\\p{Number}_${escaped}]+`, "ug");
        } catch (_a) {
          return new RegExp(`[w${escaped}]`, "g");
        }
      }
      function mapRE(re, f) {
        return new RegExp(f(re.source), re.unicode ? "u" : "");
      }
      var wordCaches = /* @__PURE__ */ Object.create(null);
      function wordCache(wordChars) {
        return wordCaches[wordChars] || (wordCaches[wordChars] = /* @__PURE__ */ new WeakMap());
      }
      function storeWords(doc, wordRE2, result, seen, ignoreAt) {
        for (let lines = doc.iterLines(), pos = 0; !lines.next().done; ) {
          let { value } = lines, m;
          wordRE2.lastIndex = 0;
          while (m = wordRE2.exec(value)) {
            if (!seen[m[0]] && pos + m.index != ignoreAt) {
              result.push({ type: "text", label: m[0] });
              seen[m[0]] = true;
              if (result.length >= 2e3)
                return;
            }
          }
          pos += value.length + 1;
        }
      }
      function collectWords(doc, cache, wordRE2, to, ignoreAt) {
        let big = doc.length >= 1e3;
        let cached = big && cache.get(doc);
        if (cached)
          return cached;
        let result = [], seen = /* @__PURE__ */ Object.create(null);
        if (doc.children) {
          let pos = 0;
          for (let ch of doc.children) {
            if (ch.length >= 1e3) {
              for (let c of collectWords(ch, cache, wordRE2, to - pos, ignoreAt - pos)) {
                if (!seen[c.label]) {
                  seen[c.label] = true;
                  result.push(c);
                }
              }
            } else {
              storeWords(ch, wordRE2, result, seen, ignoreAt - pos);
            }
            pos += ch.length + 1;
          }
        } else {
          storeWords(doc, wordRE2, result, seen, ignoreAt);
        }
        if (big && result.length < 2e3)
          cache.set(doc, result);
        return result;
      }
      var completeAnyWord = (context) => {
        let wordChars = context.state.languageDataAt("wordChars", context.pos).join("");
        let re = wordRE(wordChars);
        let token = context.matchBefore(mapRE(re, (s) => s + "$"));
        if (!token && !context.explicit)
          return null;
        let from = token ? token.from : context.pos;
        let options = collectWords(context.state.doc, wordCache(wordChars), re, 5e4, from);
        return { from, options, validFor: mapRE(re, (s) => "^" + s) };
      };
      var defaults = {
        brackets: ["(", "[", "{", "'", '"'],
        before: ")]}:;>"
      };
      var closeBracketEffect = state.StateEffect.define({
        map(value, mapping) {
          let mapped = mapping.mapPos(value, -1, state.MapMode.TrackAfter);
          return mapped == null ? void 0 : mapped;
        }
      });
      var skipBracketEffect = state.StateEffect.define({
        map(value, mapping) {
          return mapping.mapPos(value);
        }
      });
      var closedBracket = new class extends state.RangeValue {
      }();
      closedBracket.startSide = 1;
      closedBracket.endSide = -1;
      var bracketState = state.StateField.define({
        create() {
          return state.RangeSet.empty;
        },
        update(value, tr) {
          if (tr.selection) {
            let lineStart = tr.state.doc.lineAt(tr.selection.main.head).from;
            let prevLineStart = tr.startState.doc.lineAt(tr.startState.selection.main.head).from;
            if (lineStart != tr.changes.mapPos(prevLineStart, -1))
              value = state.RangeSet.empty;
          }
          value = value.map(tr.changes);
          for (let effect of tr.effects) {
            if (effect.is(closeBracketEffect))
              value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });
            else if (effect.is(skipBracketEffect))
              value = value.update({ filter: (from) => from != effect.value });
          }
          return value;
        }
      });
      function closeBrackets() {
        return [inputHandler, bracketState];
      }
      var definedClosing = "()[]{}<>";
      function closing(ch) {
        for (let i = 0; i < definedClosing.length; i += 2)
          if (definedClosing.charCodeAt(i) == ch)
            return definedClosing.charAt(i + 1);
        return state.fromCodePoint(ch < 128 ? ch : ch + 1);
      }
      function config(state2, pos) {
        return state2.languageDataAt("closeBrackets", pos)[0] || defaults;
      }
      var android = typeof navigator == "object" && /Android\b/.test(navigator.userAgent);
      var inputHandler = view.EditorView.inputHandler.of((view2, from, to, insert) => {
        if ((android ? view2.composing : view2.compositionStarted) || view2.state.readOnly)
          return false;
        let sel = view2.state.selection.main;
        if (insert.length > 2 || insert.length == 2 && state.codePointSize(state.codePointAt(insert, 0)) == 1 || from != sel.from || to != sel.to)
          return false;
        let tr = insertBracket(view2.state, insert);
        if (!tr)
          return false;
        view2.dispatch(tr);
        return true;
      });
      var deleteBracketPair = ({ state: state$1, dispatch }) => {
        if (state$1.readOnly)
          return false;
        let conf = config(state$1, state$1.selection.main.head);
        let tokens = conf.brackets || defaults.brackets;
        let dont = null, changes = state$1.changeByRange((range) => {
          if (range.empty) {
            let before = prevChar(state$1.doc, range.head);
            for (let token of tokens) {
              if (token == before && nextChar(state$1.doc, range.head) == closing(state.codePointAt(token, 0)))
                return {
                  changes: { from: range.head - token.length, to: range.head + token.length },
                  range: state.EditorSelection.cursor(range.head - token.length),
                  userEvent: "delete.backward"
                };
            }
          }
          return { range: dont = range };
        });
        if (!dont)
          dispatch(state$1.update(changes, { scrollIntoView: true }));
        return !dont;
      };
      var closeBracketsKeymap = [
        { key: "Backspace", run: deleteBracketPair }
      ];
      function insertBracket(state$1, bracket) {
        let conf = config(state$1, state$1.selection.main.head);
        let tokens = conf.brackets || defaults.brackets;
        for (let tok of tokens) {
          let closed = closing(state.codePointAt(tok, 0));
          if (bracket == tok)
            return closed == tok ? handleSame(state$1, tok, tokens.indexOf(tok + tok + tok) > -1) : handleOpen(state$1, tok, closed, conf.before || defaults.before);
          if (bracket == closed && closedBracketAt(state$1, state$1.selection.main.from))
            return handleClose(state$1, tok, closed);
        }
        return null;
      }
      function closedBracketAt(state2, pos) {
        let found = false;
        state2.field(bracketState).between(0, state2.doc.length, (from) => {
          if (from == pos)
            found = true;
        });
        return found;
      }
      function nextChar(doc, pos) {
        let next = doc.sliceString(pos, pos + 2);
        return next.slice(0, state.codePointSize(state.codePointAt(next, 0)));
      }
      function prevChar(doc, pos) {
        let prev = doc.sliceString(pos - 2, pos);
        return state.codePointSize(state.codePointAt(prev, 0)) == prev.length ? prev : prev.slice(1);
      }
      function handleOpen(state$1, open2, close, closeBefore) {
        let dont = null, changes = state$1.changeByRange((range) => {
          if (!range.empty)
            return {
              changes: [{ insert: open2, from: range.from }, { insert: close, from: range.to }],
              effects: closeBracketEffect.of(range.to + open2.length),
              range: state.EditorSelection.range(range.anchor + open2.length, range.head + open2.length)
            };
          let next = nextChar(state$1.doc, range.head);
          if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1)
            return {
              changes: { insert: open2 + close, from: range.head },
              effects: closeBracketEffect.of(range.head + open2.length),
              range: state.EditorSelection.cursor(range.head + open2.length)
            };
          return { range: dont = range };
        });
        return dont ? null : state$1.update(changes, {
          scrollIntoView: true,
          userEvent: "input.type"
        });
      }
      function handleClose(state$1, _open, close) {
        let dont = null, moved = state$1.selection.ranges.map((range) => {
          if (range.empty && nextChar(state$1.doc, range.head) == close)
            return state.EditorSelection.cursor(range.head + close.length);
          return dont = range;
        });
        return dont ? null : state$1.update({
          selection: state.EditorSelection.create(moved, state$1.selection.mainIndex),
          scrollIntoView: true,
          effects: state$1.selection.ranges.map(({ from }) => skipBracketEffect.of(from))
        });
      }
      function handleSame(state$1, token, allowTriple) {
        let dont = null, changes = state$1.changeByRange((range) => {
          if (!range.empty)
            return {
              changes: [{ insert: token, from: range.from }, { insert: token, from: range.to }],
              effects: closeBracketEffect.of(range.to + token.length),
              range: state.EditorSelection.range(range.anchor + token.length, range.head + token.length)
            };
          let pos = range.head, next = nextChar(state$1.doc, pos);
          if (next == token) {
            if (nodeStart(state$1, pos)) {
              return {
                changes: { insert: token + token, from: pos },
                effects: closeBracketEffect.of(pos + token.length),
                range: state.EditorSelection.cursor(pos + token.length)
              };
            } else if (closedBracketAt(state$1, pos)) {
              let isTriple = allowTriple && state$1.sliceDoc(pos, pos + token.length * 3) == token + token + token;
              return {
                range: state.EditorSelection.cursor(pos + token.length * (isTriple ? 3 : 1)),
                effects: skipBracketEffect.of(pos)
              };
            }
          } else if (allowTriple && state$1.sliceDoc(pos - 2 * token.length, pos) == token + token && nodeStart(state$1, pos - 2 * token.length)) {
            return {
              changes: { insert: token + token + token + token, from: pos },
              effects: closeBracketEffect.of(pos + token.length),
              range: state.EditorSelection.cursor(pos + token.length)
            };
          } else if (state$1.charCategorizer(pos)(next) != state.CharCategory.Word) {
            let prev = state$1.sliceDoc(pos - 1, pos);
            if (prev != token && state$1.charCategorizer(pos)(prev) != state.CharCategory.Word && !probablyInString(state$1, pos, token))
              return {
                changes: { insert: token + token, from: pos },
                effects: closeBracketEffect.of(pos + token.length),
                range: state.EditorSelection.cursor(pos + token.length)
              };
          }
          return { range: dont = range };
        });
        return dont ? null : state$1.update(changes, {
          scrollIntoView: true,
          userEvent: "input.type"
        });
      }
      function nodeStart(state2, pos) {
        let tree = language.syntaxTree(state2).resolveInner(pos + 1);
        return tree.parent && tree.from == pos;
      }
      function probablyInString(state2, pos, quoteToken) {
        let node = language.syntaxTree(state2).resolveInner(pos, -1);
        for (let i = 0; i < 5; i++) {
          if (state2.sliceDoc(node.from, node.from + quoteToken.length) == quoteToken) {
            let first = node.firstChild;
            while (first && first.from == node.from && first.to - first.from > quoteToken.length) {
              if (state2.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken)
                return false;
              first = first.firstChild;
            }
            return true;
          }
          let parent = node.to == pos && node.parent;
          if (!parent)
            break;
          node = parent;
        }
        return false;
      }
      function autocompletion(config2 = {}) {
        return [
          completionState,
          completionConfig.of(config2),
          completionPlugin,
          completionKeymapExt,
          baseTheme
        ];
      }
      var completionKeymap = [
        { key: "Ctrl-Space", run: startCompletion },
        { key: "Escape", run: closeCompletion },
        { key: "ArrowDown", run: moveCompletionSelection(true) },
        { key: "ArrowUp", run: moveCompletionSelection(false) },
        { key: "PageDown", run: moveCompletionSelection(true, "page") },
        { key: "PageUp", run: moveCompletionSelection(false, "page") },
        { key: "Enter", run: acceptCompletion }
      ];
      var completionKeymapExt = state.Prec.highest(view.keymap.computeN([completionConfig], (state2) => state2.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));
      function completionStatus(state2) {
        let cState = state2.field(completionState, false);
        return cState && cState.active.some((a) => a.state == 1) ? "pending" : cState && cState.active.some((a) => a.state != 0) ? "active" : null;
      }
      var completionArrayCache = /* @__PURE__ */ new WeakMap();
      function currentCompletions(state2) {
        var _a;
        let open2 = (_a = state2.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;
        if (!open2)
          return [];
        let completions = completionArrayCache.get(open2.options);
        if (!completions)
          completionArrayCache.set(open2.options, completions = open2.options.map((o) => o.completion));
        return completions;
      }
      function selectedCompletion(state2) {
        var _a;
        let open2 = (_a = state2.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;
        return open2 && open2.selected >= 0 ? open2.options[open2.selected].completion : null;
      }
      function selectedCompletionIndex(state2) {
        var _a;
        let open2 = (_a = state2.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;
        return open2 && open2.selected >= 0 ? open2.selected : null;
      }
      function setSelectedCompletion(index) {
        return setSelectedEffect.of(index);
      }
      exports.CompletionContext = CompletionContext;
      exports.acceptCompletion = acceptCompletion;
      exports.autocompletion = autocompletion;
      exports.clearSnippet = clearSnippet;
      exports.closeBrackets = closeBrackets;
      exports.closeBracketsKeymap = closeBracketsKeymap;
      exports.closeCompletion = closeCompletion;
      exports.completeAnyWord = completeAnyWord;
      exports.completeFromList = completeFromList;
      exports.completionKeymap = completionKeymap;
      exports.completionStatus = completionStatus;
      exports.currentCompletions = currentCompletions;
      exports.deleteBracketPair = deleteBracketPair;
      exports.ifIn = ifIn;
      exports.ifNotIn = ifNotIn;
      exports.insertBracket = insertBracket;
      exports.insertCompletionText = insertCompletionText;
      exports.moveCompletionSelection = moveCompletionSelection;
      exports.nextSnippetField = nextSnippetField;
      exports.pickedCompletion = pickedCompletion;
      exports.prevSnippetField = prevSnippetField;
      exports.selectedCompletion = selectedCompletion;
      exports.selectedCompletionIndex = selectedCompletionIndex;
      exports.setSelectedCompletion = setSelectedCompletion;
      exports.snippet = snippet;
      exports.snippetCompletion = snippetCompletion;
      exports.snippetKeymap = snippetKeymap;
      exports.startCompletion = startCompletion;
    }
  });

  // node_modules/@codemirror/lint/dist/index.cjs
  var require_dist10 = __commonJS({
    "node_modules/@codemirror/lint/dist/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var view = require_dist2();
      var state = require_dist();
      var elt = require_dist7();
      function _interopDefaultLegacy(e) {
        return e && typeof e === "object" && "default" in e ? e : { "default": e };
      }
      var elt__default = /* @__PURE__ */ _interopDefaultLegacy(elt);
      var SelectedDiagnostic = class {
        constructor(from, to, diagnostic) {
          this.from = from;
          this.to = to;
          this.diagnostic = diagnostic;
        }
      };
      var LintState = class {
        constructor(diagnostics, panel, selected) {
          this.diagnostics = diagnostics;
          this.panel = panel;
          this.selected = selected;
        }
        static init(diagnostics, panel, state2) {
          let markedDiagnostics = diagnostics;
          let diagnosticFilter = state2.facet(lintConfig).markerFilter;
          if (diagnosticFilter)
            markedDiagnostics = diagnosticFilter(markedDiagnostics);
          let ranges = view.Decoration.set(markedDiagnostics.map((d) => {
            return d.from == d.to || d.from == d.to - 1 && state2.doc.lineAt(d.from).to == d.from ? view.Decoration.widget({
              widget: new DiagnosticWidget(d),
              diagnostic: d
            }).range(d.from) : view.Decoration.mark({
              attributes: { class: "cm-lintRange cm-lintRange-" + d.severity },
              diagnostic: d
            }).range(d.from, d.to);
          }), true);
          return new LintState(ranges, panel, findDiagnostic(ranges));
        }
      };
      function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
        let found = null;
        diagnostics.between(after, 1e9, (from, to, { spec }) => {
          if (diagnostic && spec.diagnostic != diagnostic)
            return;
          found = new SelectedDiagnostic(from, to, spec.diagnostic);
          return false;
        });
        return found;
      }
      function hideTooltip(tr, tooltip) {
        return !!(tr.effects.some((e) => e.is(setDiagnosticsEffect)) || tr.changes.touchesRange(tooltip.pos));
      }
      function maybeEnableLint(state$1, effects) {
        return state$1.field(lintState, false) ? effects : effects.concat(state.StateEffect.appendConfig.of([
          lintState,
          view.EditorView.decorations.compute([lintState], (state2) => {
            let { selected, panel } = state2.field(lintState);
            return !selected || !panel || selected.from == selected.to ? view.Decoration.none : view.Decoration.set([
              activeMark.range(selected.from, selected.to)
            ]);
          }),
          view.hoverTooltip(lintTooltip, { hideOn: hideTooltip }),
          baseTheme
        ]));
      }
      function setDiagnostics(state2, diagnostics) {
        return {
          effects: maybeEnableLint(state2, [setDiagnosticsEffect.of(diagnostics)])
        };
      }
      var setDiagnosticsEffect = state.StateEffect.define();
      var togglePanel = state.StateEffect.define();
      var movePanelSelection = state.StateEffect.define();
      var lintState = state.StateField.define({
        create() {
          return new LintState(view.Decoration.none, null, null);
        },
        update(value, tr) {
          if (tr.docChanged) {
            let mapped = value.diagnostics.map(tr.changes), selected = null;
            if (value.selected) {
              let selPos = tr.changes.mapPos(value.selected.from, 1);
              selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
            }
            value = new LintState(mapped, value.panel, selected);
          }
          for (let effect of tr.effects) {
            if (effect.is(setDiagnosticsEffect)) {
              value = LintState.init(effect.value, value.panel, tr.state);
            } else if (effect.is(togglePanel)) {
              value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
            } else if (effect.is(movePanelSelection)) {
              value = new LintState(value.diagnostics, value.panel, effect.value);
            }
          }
          return value;
        },
        provide: (f) => [
          view.showPanel.from(f, (val) => val.panel),
          view.EditorView.decorations.from(f, (s) => s.diagnostics)
        ]
      });
      function diagnosticCount(state2) {
        let lint = state2.field(lintState, false);
        return lint ? lint.diagnostics.size : 0;
      }
      var activeMark = view.Decoration.mark({ class: "cm-lintRange cm-lintRange-active" });
      function lintTooltip(view2, pos, side) {
        let { diagnostics } = view2.state.field(lintState);
        let found = [], stackStart = 2e8, stackEnd = 0;
        diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec }) => {
          if (pos >= from && pos <= to && (from == to || (pos > from || side > 0) && (pos < to || side < 0))) {
            found.push(spec.diagnostic);
            stackStart = Math.min(from, stackStart);
            stackEnd = Math.max(to, stackEnd);
          }
        });
        let diagnosticFilter = view2.state.facet(lintConfig).tooltipFilter;
        if (diagnosticFilter)
          found = diagnosticFilter(found);
        if (!found.length)
          return null;
        return {
          pos: stackStart,
          end: stackEnd,
          above: view2.state.doc.lineAt(stackStart).to < stackEnd,
          create() {
            return { dom: diagnosticsTooltip(view2, found) };
          }
        };
      }
      function diagnosticsTooltip(view2, diagnostics) {
        return elt__default["default"]("ul", { class: "cm-tooltip-lint" }, diagnostics.map((d) => renderDiagnostic(view2, d, false)));
      }
      var openLintPanel = (view$1) => {
        let field = view$1.state.field(lintState, false);
        if (!field || !field.panel)
          view$1.dispatch({ effects: maybeEnableLint(view$1.state, [togglePanel.of(true)]) });
        let panel = view.getPanel(view$1, LintPanel.open);
        if (panel)
          panel.dom.querySelector(".cm-panel-lint ul").focus();
        return true;
      };
      var closeLintPanel = (view2) => {
        let field = view2.state.field(lintState, false);
        if (!field || !field.panel)
          return false;
        view2.dispatch({ effects: togglePanel.of(false) });
        return true;
      };
      var nextDiagnostic = (view2) => {
        let field = view2.state.field(lintState, false);
        if (!field)
          return false;
        let sel = view2.state.selection.main, next = field.diagnostics.iter(sel.to + 1);
        if (!next.value) {
          next = field.diagnostics.iter(0);
          if (!next.value || next.from == sel.from && next.to == sel.to)
            return false;
        }
        view2.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });
        return true;
      };
      var lintKeymap = [
        { key: "Mod-Shift-m", run: openLintPanel },
        { key: "F8", run: nextDiagnostic }
      ];
      var lintPlugin = view.ViewPlugin.fromClass(class {
        constructor(view2) {
          this.view = view2;
          this.timeout = -1;
          this.set = true;
          let { delay } = view2.state.facet(lintConfig);
          this.lintTime = Date.now() + delay;
          this.run = this.run.bind(this);
          this.timeout = setTimeout(this.run, delay);
        }
        run() {
          let now = Date.now();
          if (now < this.lintTime - 10) {
            setTimeout(this.run, this.lintTime - now);
          } else {
            this.set = false;
            let { state: state2 } = this.view, { sources } = state2.facet(lintConfig);
            Promise.all(sources.map((source) => Promise.resolve(source(this.view)))).then((annotations) => {
              let all = annotations.reduce((a, b) => a.concat(b));
              if (this.view.state.doc == state2.doc)
                this.view.dispatch(setDiagnostics(this.view.state, all));
            }, (error) => {
              view.logException(this.view.state, error);
            });
          }
        }
        update(update) {
          let config = update.state.facet(lintConfig);
          if (update.docChanged || config != update.startState.facet(lintConfig)) {
            this.lintTime = Date.now() + config.delay;
            if (!this.set) {
              this.set = true;
              this.timeout = setTimeout(this.run, config.delay);
            }
          }
        }
        force() {
          if (this.set) {
            this.lintTime = Date.now();
            this.run();
          }
        }
        destroy() {
          clearTimeout(this.timeout);
        }
      });
      var lintConfig = state.Facet.define({
        combine(input) {
          return Object.assign({ sources: input.map((i) => i.source) }, state.combineConfig(input.map((i) => i.config), {
            delay: 750,
            markerFilter: null,
            tooltipFilter: null
          }));
        },
        enables: lintPlugin
      });
      function linter(source, config = {}) {
        return lintConfig.of({ source, config });
      }
      function forceLinting(view2) {
        let plugin = view2.plugin(lintPlugin);
        if (plugin)
          plugin.force();
      }
      function assignKeys(actions) {
        let assigned = [];
        if (actions)
          actions:
            for (let { name } of actions) {
              for (let i = 0; i < name.length; i++) {
                let ch = name[i];
                if (/[a-zA-Z]/.test(ch) && !assigned.some((c) => c.toLowerCase() == ch.toLowerCase())) {
                  assigned.push(ch);
                  continue actions;
                }
              }
              assigned.push("");
            }
        return assigned;
      }
      function renderDiagnostic(view2, diagnostic, inPanel) {
        var _a;
        let keys = inPanel ? assignKeys(diagnostic.actions) : [];
        return elt__default["default"]("li", { class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity }, elt__default["default"]("span", { class: "cm-diagnosticText" }, diagnostic.renderMessage ? diagnostic.renderMessage() : diagnostic.message), (_a = diagnostic.actions) === null || _a === void 0 ? void 0 : _a.map((action, i) => {
          let click = (e) => {
            e.preventDefault();
            let found = findDiagnostic(view2.state.field(lintState).diagnostics, diagnostic);
            if (found)
              action.apply(view2, found.from, found.to);
          };
          let { name } = action, keyIndex = keys[i] ? name.indexOf(keys[i]) : -1;
          let nameElt = keyIndex < 0 ? name : [
            name.slice(0, keyIndex),
            elt__default["default"]("u", name.slice(keyIndex, keyIndex + 1)),
            name.slice(keyIndex + 1)
          ];
          return elt__default["default"]("button", {
            type: "button",
            class: "cm-diagnosticAction",
            onclick: click,
            onmousedown: click,
            "aria-label": ` Action: ${name}${keyIndex < 0 ? "" : ` (access key "${keys[i]})"`}.`
          }, nameElt);
        }), diagnostic.source && elt__default["default"]("div", { class: "cm-diagnosticSource" }, diagnostic.source));
      }
      var DiagnosticWidget = class extends view.WidgetType {
        constructor(diagnostic) {
          super();
          this.diagnostic = diagnostic;
        }
        eq(other) {
          return other.diagnostic == this.diagnostic;
        }
        toDOM() {
          return elt__default["default"]("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
        }
      };
      var PanelItem = class {
        constructor(view2, diagnostic) {
          this.diagnostic = diagnostic;
          this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16);
          this.dom = renderDiagnostic(view2, diagnostic, true);
          this.dom.id = this.id;
          this.dom.setAttribute("role", "option");
        }
      };
      var LintPanel = class {
        constructor(view2) {
          this.view = view2;
          this.items = [];
          let onkeydown = (event) => {
            if (event.keyCode == 27) {
              closeLintPanel(this.view);
              this.view.focus();
            } else if (event.keyCode == 38 || event.keyCode == 33) {
              this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
            } else if (event.keyCode == 40 || event.keyCode == 34) {
              this.moveSelection((this.selectedIndex + 1) % this.items.length);
            } else if (event.keyCode == 36) {
              this.moveSelection(0);
            } else if (event.keyCode == 35) {
              this.moveSelection(this.items.length - 1);
            } else if (event.keyCode == 13) {
              this.view.focus();
            } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {
              let { diagnostic } = this.items[this.selectedIndex], keys = assignKeys(diagnostic.actions);
              for (let i = 0; i < keys.length; i++)
                if (keys[i].toUpperCase().charCodeAt(0) == event.keyCode) {
                  let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
                  if (found)
                    diagnostic.actions[i].apply(view2, found.from, found.to);
                }
            } else {
              return;
            }
            event.preventDefault();
          };
          let onclick = (event) => {
            for (let i = 0; i < this.items.length; i++) {
              if (this.items[i].dom.contains(event.target))
                this.moveSelection(i);
            }
          };
          this.list = elt__default["default"]("ul", {
            tabIndex: 0,
            role: "listbox",
            "aria-label": this.view.state.phrase("Diagnostics"),
            onkeydown,
            onclick
          });
          this.dom = elt__default["default"]("div", { class: "cm-panel-lint" }, this.list, elt__default["default"]("button", {
            type: "button",
            name: "close",
            "aria-label": this.view.state.phrase("close"),
            onclick: () => closeLintPanel(this.view)
          }, "\xD7"));
          this.update();
        }
        get selectedIndex() {
          let selected = this.view.state.field(lintState).selected;
          if (!selected)
            return -1;
          for (let i = 0; i < this.items.length; i++)
            if (this.items[i].diagnostic == selected.diagnostic)
              return i;
          return -1;
        }
        update() {
          let { diagnostics, selected } = this.view.state.field(lintState);
          let i = 0, needsSync = false, newSelectedItem = null;
          diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {
            let found = -1, item;
            for (let j = i; j < this.items.length; j++)
              if (this.items[j].diagnostic == spec.diagnostic) {
                found = j;
                break;
              }
            if (found < 0) {
              item = new PanelItem(this.view, spec.diagnostic);
              this.items.splice(i, 0, item);
              needsSync = true;
            } else {
              item = this.items[found];
              if (found > i) {
                this.items.splice(i, found - i);
                needsSync = true;
              }
            }
            if (selected && item.diagnostic == selected.diagnostic) {
              if (!item.dom.hasAttribute("aria-selected")) {
                item.dom.setAttribute("aria-selected", "true");
                newSelectedItem = item;
              }
            } else if (item.dom.hasAttribute("aria-selected")) {
              item.dom.removeAttribute("aria-selected");
            }
            i++;
          });
          while (i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
            needsSync = true;
            this.items.pop();
          }
          if (this.items.length == 0) {
            this.items.push(new PanelItem(this.view, {
              from: -1,
              to: -1,
              severity: "info",
              message: this.view.state.phrase("No diagnostics")
            }));
            needsSync = true;
          }
          if (newSelectedItem) {
            this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
            this.view.requestMeasure({
              key: this,
              read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
              write: ({ sel, panel }) => {
                if (sel.top < panel.top)
                  this.list.scrollTop -= panel.top - sel.top;
                else if (sel.bottom > panel.bottom)
                  this.list.scrollTop += sel.bottom - panel.bottom;
              }
            });
          } else if (this.selectedIndex < 0) {
            this.list.removeAttribute("aria-activedescendant");
          }
          if (needsSync)
            this.sync();
        }
        sync() {
          let domPos = this.list.firstChild;
          function rm() {
            let prev = domPos;
            domPos = prev.nextSibling;
            prev.remove();
          }
          for (let item of this.items) {
            if (item.dom.parentNode == this.list) {
              while (domPos != item.dom)
                rm();
              domPos = item.dom.nextSibling;
            } else {
              this.list.insertBefore(item.dom, domPos);
            }
          }
          while (domPos)
            rm();
        }
        moveSelection(selectedIndex) {
          if (this.selectedIndex < 0)
            return;
          let field = this.view.state.field(lintState);
          let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
          if (!selection)
            return;
          this.view.dispatch({
            selection: { anchor: selection.from, head: selection.to },
            scrollIntoView: true,
            effects: movePanelSelection.of(selection)
          });
        }
        static open(view2) {
          return new LintPanel(view2);
        }
      };
      function svg(content, attrs = `viewBox="0 0 40 40"`) {
        return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content)}</svg>')`;
      }
      function underline(color) {
        return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
      }
      var baseTheme = view.EditorView.baseTheme({
        ".cm-diagnostic": {
          padding: "3px 6px 3px 8px",
          marginLeft: "-1px",
          display: "block",
          whiteSpace: "pre-wrap"
        },
        ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
        ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
        ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
        ".cm-diagnosticAction": {
          font: "inherit",
          border: "none",
          padding: "2px 4px",
          backgroundColor: "#444",
          color: "white",
          borderRadius: "3px",
          marginLeft: "8px"
        },
        ".cm-diagnosticSource": {
          fontSize: "70%",
          opacity: 0.7
        },
        ".cm-lintRange": {
          backgroundPosition: "left bottom",
          backgroundRepeat: "repeat-x",
          paddingBottom: "0.7px"
        },
        ".cm-lintRange-error": { backgroundImage: underline("#d11") },
        ".cm-lintRange-warning": { backgroundImage: underline("orange") },
        ".cm-lintRange-info": { backgroundImage: underline("#999") },
        ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
        ".cm-tooltip-lint": {
          padding: 0,
          margin: 0
        },
        ".cm-lintPoint": {
          position: "relative",
          "&:after": {
            content: '""',
            position: "absolute",
            bottom: 0,
            left: "-2px",
            borderLeft: "3px solid transparent",
            borderRight: "3px solid transparent",
            borderBottom: "4px solid #d11"
          }
        },
        ".cm-lintPoint-warning": {
          "&:after": { borderBottomColor: "orange" }
        },
        ".cm-lintPoint-info": {
          "&:after": { borderBottomColor: "#999" }
        },
        ".cm-panel.cm-panel-lint": {
          position: "relative",
          "& ul": {
            maxHeight: "100px",
            overflowY: "auto",
            "& [aria-selected]": {
              backgroundColor: "#ddd",
              "& u": { textDecoration: "underline" }
            },
            "&:focus [aria-selected]": {
              background_fallback: "#bdf",
              backgroundColor: "Highlight",
              color_fallback: "white",
              color: "HighlightText"
            },
            "& u": { textDecoration: "none" },
            padding: 0,
            margin: 0
          },
          "& [name=close]": {
            position: "absolute",
            top: "0",
            right: "2px",
            background: "inherit",
            border: "none",
            font: "inherit",
            padding: 0,
            margin: 0
          }
        }
      });
      var LintGutterMarker = class extends view.GutterMarker {
        constructor(diagnostics) {
          super();
          this.diagnostics = diagnostics;
          this.severity = diagnostics.reduce((max, d) => {
            let s = d.severity;
            return s == "error" || s == "warning" && max == "info" ? s : max;
          }, "info");
        }
        toDOM(view2) {
          let elt2 = document.createElement("div");
          elt2.className = "cm-lint-marker cm-lint-marker-" + this.severity;
          let diagnostics = this.diagnostics;
          let diagnosticsFilter = view2.state.facet(lintGutterConfig).tooltipFilter;
          if (diagnosticsFilter)
            diagnostics = diagnosticsFilter(diagnostics);
          if (diagnostics.length)
            elt2.onmouseover = () => gutterMarkerMouseOver(view2, elt2, diagnostics);
          return elt2;
        }
      };
      function trackHoverOn(view2, marker) {
        let mousemove = (event) => {
          let rect = marker.getBoundingClientRect();
          if (event.clientX > rect.left - 10 && event.clientX < rect.right + 10 && event.clientY > rect.top - 10 && event.clientY < rect.bottom + 10)
            return;
          for (let target = event.target; target; target = target.parentNode) {
            if (target.nodeType == 1 && target.classList.contains("cm-tooltip-lint"))
              return;
          }
          window.removeEventListener("mousemove", mousemove);
          if (view2.state.field(lintGutterTooltip))
            view2.dispatch({ effects: setLintGutterTooltip.of(null) });
        };
        window.addEventListener("mousemove", mousemove);
      }
      function gutterMarkerMouseOver(view2, marker, diagnostics) {
        function hovered() {
          let line = view2.elementAtHeight(marker.getBoundingClientRect().top + 5 - view2.documentTop);
          const linePos = view2.coordsAtPos(line.from);
          if (linePos) {
            view2.dispatch({ effects: setLintGutterTooltip.of({
              pos: line.from,
              above: false,
              create() {
                return {
                  dom: diagnosticsTooltip(view2, diagnostics),
                  getCoords: () => marker.getBoundingClientRect()
                };
              }
            }) });
          }
          marker.onmouseout = marker.onmousemove = null;
          trackHoverOn(view2, marker);
        }
        let { hoverTime } = view2.state.facet(lintGutterConfig);
        let hoverTimeout = setTimeout(hovered, hoverTime);
        marker.onmouseout = () => {
          clearTimeout(hoverTimeout);
          marker.onmouseout = marker.onmousemove = null;
        };
        marker.onmousemove = () => {
          clearTimeout(hoverTimeout);
          hoverTimeout = setTimeout(hovered, hoverTime);
        };
      }
      function markersForDiagnostics(doc, diagnostics) {
        let byLine = /* @__PURE__ */ Object.create(null);
        for (let diagnostic of diagnostics) {
          let line = doc.lineAt(diagnostic.from);
          (byLine[line.from] || (byLine[line.from] = [])).push(diagnostic);
        }
        let markers = [];
        for (let line in byLine) {
          markers.push(new LintGutterMarker(byLine[line]).range(+line));
        }
        return state.RangeSet.of(markers, true);
      }
      var lintGutterExtension = view.gutter({
        class: "cm-gutter-lint",
        markers: (view2) => view2.state.field(lintGutterMarkers)
      });
      var lintGutterMarkers = state.StateField.define({
        create() {
          return state.RangeSet.empty;
        },
        update(markers, tr) {
          markers = markers.map(tr.changes);
          let diagnosticFilter = tr.state.facet(lintGutterConfig).markerFilter;
          for (let effect of tr.effects) {
            if (effect.is(setDiagnosticsEffect)) {
              let diagnostics = effect.value;
              if (diagnosticFilter)
                diagnostics = diagnosticFilter(diagnostics || []);
              markers = markersForDiagnostics(tr.state.doc, diagnostics.slice(0));
            }
          }
          return markers;
        }
      });
      var setLintGutterTooltip = state.StateEffect.define();
      var lintGutterTooltip = state.StateField.define({
        create() {
          return null;
        },
        update(tooltip, tr) {
          if (tooltip && tr.docChanged)
            tooltip = hideTooltip(tr, tooltip) ? null : Object.assign(Object.assign({}, tooltip), { pos: tr.changes.mapPos(tooltip.pos) });
          return tr.effects.reduce((t, e) => e.is(setLintGutterTooltip) ? e.value : t, tooltip);
        },
        provide: (field) => view.showTooltip.from(field)
      });
      var lintGutterTheme = view.EditorView.baseTheme({
        ".cm-gutter-lint": {
          width: "1.4em",
          "& .cm-gutterElement": {
            padding: ".2em"
          }
        },
        ".cm-lint-marker": {
          width: "1em",
          height: "1em"
        },
        ".cm-lint-marker-info": {
          content: svg(`<path fill="#aaf" stroke="#77e" stroke-width="6" stroke-linejoin="round" d="M5 5L35 5L35 35L5 35Z"/>`)
        },
        ".cm-lint-marker-warning": {
          content: svg(`<path fill="#fe8" stroke="#fd7" stroke-width="6" stroke-linejoin="round" d="M20 6L37 35L3 35Z"/>`)
        },
        ".cm-lint-marker-error:before": {
          content: svg(`<circle cx="20" cy="20" r="15" fill="#f87" stroke="#f43" stroke-width="6"/>`)
        }
      });
      var lintGutterConfig = state.Facet.define({
        combine(configs) {
          return state.combineConfig(configs, {
            hoverTime: 300,
            markerFilter: null,
            tooltipFilter: null
          });
        }
      });
      function lintGutter(config = {}) {
        return [lintGutterConfig.of(config), lintGutterMarkers, lintGutterExtension, lintGutterTheme, lintGutterTooltip];
      }
      exports.closeLintPanel = closeLintPanel;
      exports.diagnosticCount = diagnosticCount;
      exports.forceLinting = forceLinting;
      exports.lintGutter = lintGutter;
      exports.lintKeymap = lintKeymap;
      exports.linter = linter;
      exports.nextDiagnostic = nextDiagnostic;
      exports.openLintPanel = openLintPanel;
      exports.setDiagnostics = setDiagnostics;
      exports.setDiagnosticsEffect = setDiagnosticsEffect;
    }
  });

  // node_modules/codemirror/dist/index.cjs
  var require_dist11 = __commonJS({
    "node_modules/codemirror/dist/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var view = require_dist2();
      var state = require_dist();
      var language = require_dist5();
      var commands = require_dist6();
      var search = require_dist8();
      var autocomplete = require_dist9();
      var lint = require_dist10();
      var basicSetup = (() => [
        view.lineNumbers(),
        view.highlightActiveLineGutter(),
        view.highlightSpecialChars(),
        commands.history(),
        language.foldGutter(),
        view.drawSelection(),
        view.dropCursor(),
        state.EditorState.allowMultipleSelections.of(true),
        language.indentOnInput(),
        language.syntaxHighlighting(language.defaultHighlightStyle, { fallback: true }),
        language.bracketMatching(),
        autocomplete.closeBrackets(),
        autocomplete.autocompletion(),
        view.rectangularSelection(),
        view.crosshairCursor(),
        view.highlightActiveLine(),
        search.highlightSelectionMatches(),
        view.keymap.of([
          ...autocomplete.closeBracketsKeymap,
          ...commands.defaultKeymap,
          ...search.searchKeymap,
          ...commands.historyKeymap,
          ...language.foldKeymap,
          ...autocomplete.completionKeymap,
          ...lint.lintKeymap
        ])
      ])();
      var minimalSetup = (() => [
        view.highlightSpecialChars(),
        commands.history(),
        view.drawSelection(),
        language.syntaxHighlighting(language.defaultHighlightStyle, { fallback: true }),
        view.keymap.of([
          ...commands.defaultKeymap,
          ...commands.historyKeymap
        ])
      ])();
      Object.defineProperty(exports, "EditorView", {
        enumerable: true,
        get: function() {
          return view.EditorView;
        }
      });
      exports.basicSetup = basicSetup;
      exports.minimalSetup = minimalSetup;
    }
  });

  // node_modules/file-saver/dist/FileSaver.min.js
  var require_FileSaver_min = __commonJS({
    "node_modules/file-saver/dist/FileSaver.min.js"(exports, module) {
      (function(a, b) {
        if ("function" == typeof define && define.amd)
          define([], b);
        else if ("undefined" != typeof exports)
          b();
        else {
          b(), a.FileSaver = { exports: {} }.exports;
        }
      })(exports, function() {
        "use strict";
        function b(a2, b2) {
          return "undefined" == typeof b2 ? b2 = { autoBom: false } : "object" != typeof b2 && (console.warn("Deprecated: Expected third argument to be a object"), b2 = { autoBom: !b2 }), b2.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a2.type) ? new Blob(["\uFEFF", a2], { type: a2.type }) : a2;
        }
        function c(a2, b2, c2) {
          var d2 = new XMLHttpRequest();
          d2.open("GET", a2), d2.responseType = "blob", d2.onload = function() {
            g(d2.response, b2, c2);
          }, d2.onerror = function() {
            console.error("could not download file");
          }, d2.send();
        }
        function d(a2) {
          var b2 = new XMLHttpRequest();
          b2.open("HEAD", a2, false);
          try {
            b2.send();
          } catch (a3) {
          }
          return 200 <= b2.status && 299 >= b2.status;
        }
        function e(a2) {
          try {
            a2.dispatchEvent(new MouseEvent("click"));
          } catch (c2) {
            var b2 = document.createEvent("MouseEvents");
            b2.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a2.dispatchEvent(b2);
          }
        }
        var f = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof global && global.global === global ? global : void 0, a = f.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g = f.saveAs || ("object" != typeof window || window !== f ? function() {
        } : "download" in HTMLAnchorElement.prototype && !a ? function(b2, g2, h) {
          var i = f.URL || f.webkitURL, j = document.createElement("a");
          g2 = g2 || b2.name || "download", j.download = g2, j.rel = "noopener", "string" == typeof b2 ? (j.href = b2, j.origin === location.origin ? e(j) : d(j.href) ? c(b2, g2, h) : e(j, j.target = "_blank")) : (j.href = i.createObjectURL(b2), setTimeout(function() {
            i.revokeObjectURL(j.href);
          }, 4e4), setTimeout(function() {
            e(j);
          }, 0));
        } : "msSaveOrOpenBlob" in navigator ? function(f2, g2, h) {
          if (g2 = g2 || f2.name || "download", "string" != typeof f2)
            navigator.msSaveOrOpenBlob(b(f2, h), g2);
          else if (d(f2))
            c(f2, g2, h);
          else {
            var i = document.createElement("a");
            i.href = f2, i.target = "_blank", setTimeout(function() {
              e(i);
            });
          }
        } : function(b2, d2, e2, g2) {
          if (g2 = g2 || open("", "_blank"), g2 && (g2.document.title = g2.document.body.innerText = "downloading..."), "string" == typeof b2)
            return c(b2, d2, e2);
          var h = "application/octet-stream" === b2.type, i = /constructor/i.test(f.HTMLElement) || f.safari, j = /CriOS\/[\d]+/.test(navigator.userAgent);
          if ((j || h && i || a) && "undefined" != typeof FileReader) {
            var k = new FileReader();
            k.onloadend = function() {
              var a2 = k.result;
              a2 = j ? a2 : a2.replace(/^data:[^;]*;/, "data:attachment/file;"), g2 ? g2.location.href = a2 : location = a2, g2 = null;
            }, k.readAsDataURL(b2);
          } else {
            var l = f.URL || f.webkitURL, m = l.createObjectURL(b2);
            g2 ? g2.location = m : location.href = m, g2 = null, setTimeout(function() {
              l.revokeObjectURL(m);
            }, 4e4);
          }
        });
        f.saveAs = g.saveAs = g, "undefined" != typeof module && (module.exports = g);
      });
    }
  });

  // node_modules/@popperjs/core/dist/cjs/popper.js
  var require_popper = __commonJS({
    "node_modules/@popperjs/core/dist/cjs/popper.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function getWindow(node) {
        if (node == null) {
          return window;
        }
        if (node.toString() !== "[object Window]") {
          var ownerDocument = node.ownerDocument;
          return ownerDocument ? ownerDocument.defaultView || window : window;
        }
        return node;
      }
      function isElement(node) {
        var OwnElement = getWindow(node).Element;
        return node instanceof OwnElement || node instanceof Element;
      }
      function isHTMLElement(node) {
        var OwnElement = getWindow(node).HTMLElement;
        return node instanceof OwnElement || node instanceof HTMLElement;
      }
      function isShadowRoot(node) {
        if (typeof ShadowRoot === "undefined") {
          return false;
        }
        var OwnElement = getWindow(node).ShadowRoot;
        return node instanceof OwnElement || node instanceof ShadowRoot;
      }
      var max = Math.max;
      var min = Math.min;
      var round = Math.round;
      function getUAString() {
        var uaData = navigator.userAgentData;
        if (uaData != null && uaData.brands) {
          return uaData.brands.map(function(item) {
            return item.brand + "/" + item.version;
          }).join(" ");
        }
        return navigator.userAgent;
      }
      function isLayoutViewport() {
        return !/^((?!chrome|android).)*safari/i.test(getUAString());
      }
      function getBoundingClientRect(element, includeScale, isFixedStrategy) {
        if (includeScale === void 0) {
          includeScale = false;
        }
        if (isFixedStrategy === void 0) {
          isFixedStrategy = false;
        }
        var clientRect = element.getBoundingClientRect();
        var scaleX = 1;
        var scaleY = 1;
        if (includeScale && isHTMLElement(element)) {
          scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
          scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
        }
        var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
        var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
        var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
        var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
        var width = clientRect.width / scaleX;
        var height = clientRect.height / scaleY;
        return {
          width,
          height,
          top: y,
          right: x + width,
          bottom: y + height,
          left: x,
          x,
          y
        };
      }
      function getWindowScroll(node) {
        var win = getWindow(node);
        var scrollLeft = win.pageXOffset;
        var scrollTop = win.pageYOffset;
        return {
          scrollLeft,
          scrollTop
        };
      }
      function getHTMLElementScroll(element) {
        return {
          scrollLeft: element.scrollLeft,
          scrollTop: element.scrollTop
        };
      }
      function getNodeScroll(node) {
        if (node === getWindow(node) || !isHTMLElement(node)) {
          return getWindowScroll(node);
        } else {
          return getHTMLElementScroll(node);
        }
      }
      function getNodeName(element) {
        return element ? (element.nodeName || "").toLowerCase() : null;
      }
      function getDocumentElement(element) {
        return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
      }
      function getWindowScrollBarX(element) {
        return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
      }
      function getComputedStyle2(element) {
        return getWindow(element).getComputedStyle(element);
      }
      function isScrollParent(element) {
        var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
        return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
      }
      function isElementScaled(element) {
        var rect = element.getBoundingClientRect();
        var scaleX = round(rect.width) / element.offsetWidth || 1;
        var scaleY = round(rect.height) / element.offsetHeight || 1;
        return scaleX !== 1 || scaleY !== 1;
      }
      function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
        if (isFixed === void 0) {
          isFixed = false;
        }
        var isOffsetParentAnElement = isHTMLElement(offsetParent);
        var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
        var documentElement = getDocumentElement(offsetParent);
        var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
        var scroll = {
          scrollLeft: 0,
          scrollTop: 0
        };
        var offsets = {
          x: 0,
          y: 0
        };
        if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
          if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
            scroll = getNodeScroll(offsetParent);
          }
          if (isHTMLElement(offsetParent)) {
            offsets = getBoundingClientRect(offsetParent, true);
            offsets.x += offsetParent.clientLeft;
            offsets.y += offsetParent.clientTop;
          } else if (documentElement) {
            offsets.x = getWindowScrollBarX(documentElement);
          }
        }
        return {
          x: rect.left + scroll.scrollLeft - offsets.x,
          y: rect.top + scroll.scrollTop - offsets.y,
          width: rect.width,
          height: rect.height
        };
      }
      function getLayoutRect(element) {
        var clientRect = getBoundingClientRect(element);
        var width = element.offsetWidth;
        var height = element.offsetHeight;
        if (Math.abs(clientRect.width - width) <= 1) {
          width = clientRect.width;
        }
        if (Math.abs(clientRect.height - height) <= 1) {
          height = clientRect.height;
        }
        return {
          x: element.offsetLeft,
          y: element.offsetTop,
          width,
          height
        };
      }
      function getParentNode(element) {
        if (getNodeName(element) === "html") {
          return element;
        }
        return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
      }
      function getScrollParent(node) {
        if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
          return node.ownerDocument.body;
        }
        if (isHTMLElement(node) && isScrollParent(node)) {
          return node;
        }
        return getScrollParent(getParentNode(node));
      }
      function listScrollParents(element, list) {
        var _element$ownerDocumen;
        if (list === void 0) {
          list = [];
        }
        var scrollParent = getScrollParent(element);
        var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
        var win = getWindow(scrollParent);
        var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
        var updatedList = list.concat(target);
        return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
      }
      function isTableElement(element) {
        return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
      }
      function getTrueOffsetParent(element) {
        if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
          return null;
        }
        return element.offsetParent;
      }
      function getContainingBlock(element) {
        var isFirefox = /firefox/i.test(getUAString());
        var isIE = /Trident/i.test(getUAString());
        if (isIE && isHTMLElement(element)) {
          var elementCss = getComputedStyle2(element);
          if (elementCss.position === "fixed") {
            return null;
          }
        }
        var currentNode = getParentNode(element);
        if (isShadowRoot(currentNode)) {
          currentNode = currentNode.host;
        }
        while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
          var css = getComputedStyle2(currentNode);
          if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
            return currentNode;
          } else {
            currentNode = currentNode.parentNode;
          }
        }
        return null;
      }
      function getOffsetParent(element) {
        var window2 = getWindow(element);
        var offsetParent = getTrueOffsetParent(element);
        while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
          offsetParent = getTrueOffsetParent(offsetParent);
        }
        if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
          return window2;
        }
        return offsetParent || getContainingBlock(element) || window2;
      }
      var top = "top";
      var bottom = "bottom";
      var right = "right";
      var left = "left";
      var auto = "auto";
      var basePlacements = [top, bottom, right, left];
      var start = "start";
      var end = "end";
      var clippingParents = "clippingParents";
      var viewport = "viewport";
      var popper = "popper";
      var reference = "reference";
      var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
        return acc.concat([placement + "-" + start, placement + "-" + end]);
      }, []);
      var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
        return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
      }, []);
      var beforeRead = "beforeRead";
      var read = "read";
      var afterRead = "afterRead";
      var beforeMain = "beforeMain";
      var main = "main";
      var afterMain = "afterMain";
      var beforeWrite = "beforeWrite";
      var write = "write";
      var afterWrite = "afterWrite";
      var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
      function order(modifiers) {
        var map = /* @__PURE__ */ new Map();
        var visited = /* @__PURE__ */ new Set();
        var result = [];
        modifiers.forEach(function(modifier) {
          map.set(modifier.name, modifier);
        });
        function sort(modifier) {
          visited.add(modifier.name);
          var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
          requires.forEach(function(dep) {
            if (!visited.has(dep)) {
              var depModifier = map.get(dep);
              if (depModifier) {
                sort(depModifier);
              }
            }
          });
          result.push(modifier);
        }
        modifiers.forEach(function(modifier) {
          if (!visited.has(modifier.name)) {
            sort(modifier);
          }
        });
        return result;
      }
      function orderModifiers(modifiers) {
        var orderedModifiers = order(modifiers);
        return modifierPhases.reduce(function(acc, phase) {
          return acc.concat(orderedModifiers.filter(function(modifier) {
            return modifier.phase === phase;
          }));
        }, []);
      }
      function debounce(fn) {
        var pending;
        return function() {
          if (!pending) {
            pending = new Promise(function(resolve) {
              Promise.resolve().then(function() {
                pending = void 0;
                resolve(fn());
              });
            });
          }
          return pending;
        };
      }
      function format(str) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        return [].concat(args).reduce(function(p, c) {
          return p.replace(/%s/, c);
        }, str);
      }
      var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
      var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
      var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
      function validateModifiers(modifiers) {
        modifiers.forEach(function(modifier) {
          [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index, self2) {
            return self2.indexOf(value) === index;
          }).forEach(function(key) {
            switch (key) {
              case "name":
                if (typeof modifier.name !== "string") {
                  console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
                }
                break;
              case "enabled":
                if (typeof modifier.enabled !== "boolean") {
                  console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
                }
                break;
              case "phase":
                if (modifierPhases.indexOf(modifier.phase) < 0) {
                  console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
                }
                break;
              case "fn":
                if (typeof modifier.fn !== "function") {
                  console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
                }
                break;
              case "effect":
                if (modifier.effect != null && typeof modifier.effect !== "function") {
                  console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
                }
                break;
              case "requires":
                if (modifier.requires != null && !Array.isArray(modifier.requires)) {
                  console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
                }
                break;
              case "requiresIfExists":
                if (!Array.isArray(modifier.requiresIfExists)) {
                  console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
                }
                break;
              case "options":
              case "data":
                break;
              default:
                console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {
                  return '"' + s + '"';
                }).join(", ") + '; but "' + key + '" was provided.');
            }
            modifier.requires && modifier.requires.forEach(function(requirement) {
              if (modifiers.find(function(mod) {
                return mod.name === requirement;
              }) == null) {
                console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
              }
            });
          });
        });
      }
      function uniqueBy(arr, fn) {
        var identifiers = /* @__PURE__ */ new Set();
        return arr.filter(function(item) {
          var identifier = fn(item);
          if (!identifiers.has(identifier)) {
            identifiers.add(identifier);
            return true;
          }
        });
      }
      function getBasePlacement(placement) {
        return placement.split("-")[0];
      }
      function mergeByName(modifiers) {
        var merged = modifiers.reduce(function(merged2, current) {
          var existing = merged2[current.name];
          merged2[current.name] = existing ? Object.assign({}, existing, current, {
            options: Object.assign({}, existing.options, current.options),
            data: Object.assign({}, existing.data, current.data)
          }) : current;
          return merged2;
        }, {});
        return Object.keys(merged).map(function(key) {
          return merged[key];
        });
      }
      function getViewportRect(element, strategy) {
        var win = getWindow(element);
        var html = getDocumentElement(element);
        var visualViewport = win.visualViewport;
        var width = html.clientWidth;
        var height = html.clientHeight;
        var x = 0;
        var y = 0;
        if (visualViewport) {
          width = visualViewport.width;
          height = visualViewport.height;
          var layoutViewport = isLayoutViewport();
          if (layoutViewport || !layoutViewport && strategy === "fixed") {
            x = visualViewport.offsetLeft;
            y = visualViewport.offsetTop;
          }
        }
        return {
          width,
          height,
          x: x + getWindowScrollBarX(element),
          y
        };
      }
      function getDocumentRect(element) {
        var _element$ownerDocumen;
        var html = getDocumentElement(element);
        var winScroll = getWindowScroll(element);
        var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
        var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
        var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
        var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
        var y = -winScroll.scrollTop;
        if (getComputedStyle2(body || html).direction === "rtl") {
          x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
        }
        return {
          width,
          height,
          x,
          y
        };
      }
      function contains(parent, child) {
        var rootNode = child.getRootNode && child.getRootNode();
        if (parent.contains(child)) {
          return true;
        } else if (rootNode && isShadowRoot(rootNode)) {
          var next = child;
          do {
            if (next && parent.isSameNode(next)) {
              return true;
            }
            next = next.parentNode || next.host;
          } while (next);
        }
        return false;
      }
      function rectToClientRect(rect) {
        return Object.assign({}, rect, {
          left: rect.x,
          top: rect.y,
          right: rect.x + rect.width,
          bottom: rect.y + rect.height
        });
      }
      function getInnerBoundingClientRect(element, strategy) {
        var rect = getBoundingClientRect(element, false, strategy === "fixed");
        rect.top = rect.top + element.clientTop;
        rect.left = rect.left + element.clientLeft;
        rect.bottom = rect.top + element.clientHeight;
        rect.right = rect.left + element.clientWidth;
        rect.width = element.clientWidth;
        rect.height = element.clientHeight;
        rect.x = rect.left;
        rect.y = rect.top;
        return rect;
      }
      function getClientRectFromMixedType(element, clippingParent, strategy) {
        return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
      }
      function getClippingParents(element) {
        var clippingParents2 = listScrollParents(getParentNode(element));
        var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0;
        var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
        if (!isElement(clipperElement)) {
          return [];
        }
        return clippingParents2.filter(function(clippingParent) {
          return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
        });
      }
      function getClippingRect(element, boundary, rootBoundary, strategy) {
        var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
        var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
        var firstClippingParent = clippingParents2[0];
        var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
          var rect = getClientRectFromMixedType(element, clippingParent, strategy);
          accRect.top = max(rect.top, accRect.top);
          accRect.right = min(rect.right, accRect.right);
          accRect.bottom = min(rect.bottom, accRect.bottom);
          accRect.left = max(rect.left, accRect.left);
          return accRect;
        }, getClientRectFromMixedType(element, firstClippingParent, strategy));
        clippingRect.width = clippingRect.right - clippingRect.left;
        clippingRect.height = clippingRect.bottom - clippingRect.top;
        clippingRect.x = clippingRect.left;
        clippingRect.y = clippingRect.top;
        return clippingRect;
      }
      function getVariation(placement) {
        return placement.split("-")[1];
      }
      function getMainAxisFromPlacement(placement) {
        return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
      }
      function computeOffsets(_ref) {
        var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
        var basePlacement = placement ? getBasePlacement(placement) : null;
        var variation = placement ? getVariation(placement) : null;
        var commonX = reference2.x + reference2.width / 2 - element.width / 2;
        var commonY = reference2.y + reference2.height / 2 - element.height / 2;
        var offsets;
        switch (basePlacement) {
          case top:
            offsets = {
              x: commonX,
              y: reference2.y - element.height
            };
            break;
          case bottom:
            offsets = {
              x: commonX,
              y: reference2.y + reference2.height
            };
            break;
          case right:
            offsets = {
              x: reference2.x + reference2.width,
              y: commonY
            };
            break;
          case left:
            offsets = {
              x: reference2.x - element.width,
              y: commonY
            };
            break;
          default:
            offsets = {
              x: reference2.x,
              y: reference2.y
            };
        }
        var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
        if (mainAxis != null) {
          var len = mainAxis === "y" ? "height" : "width";
          switch (variation) {
            case start:
              offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
              break;
            case end:
              offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
              break;
          }
        }
        return offsets;
      }
      function getFreshSideObject() {
        return {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        };
      }
      function mergePaddingObject(paddingObject) {
        return Object.assign({}, getFreshSideObject(), paddingObject);
      }
      function expandToHashMap(value, keys) {
        return keys.reduce(function(hashMap, key) {
          hashMap[key] = value;
          return hashMap;
        }, {});
      }
      function detectOverflow(state, options) {
        if (options === void 0) {
          options = {};
        }
        var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
        var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
        var altContext = elementContext === popper ? reference : popper;
        var popperRect = state.rects.popper;
        var element = state.elements[altBoundary ? altContext : elementContext];
        var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
        var referenceClientRect = getBoundingClientRect(state.elements.reference);
        var popperOffsets2 = computeOffsets({
          reference: referenceClientRect,
          element: popperRect,
          strategy: "absolute",
          placement
        });
        var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
        var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
        var overflowOffsets = {
          top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
          bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
          left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
          right: elementClientRect.right - clippingClientRect.right + paddingObject.right
        };
        var offsetData = state.modifiersData.offset;
        if (elementContext === popper && offsetData) {
          var offset2 = offsetData[placement];
          Object.keys(overflowOffsets).forEach(function(key) {
            var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
            var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
            overflowOffsets[key] += offset2[axis] * multiply;
          });
        }
        return overflowOffsets;
      }
      var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
      var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
      var DEFAULT_OPTIONS = {
        placement: "bottom",
        modifiers: [],
        strategy: "absolute"
      };
      function areValidElements() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return !args.some(function(element) {
          return !(element && typeof element.getBoundingClientRect === "function");
        });
      }
      function popperGenerator(generatorOptions) {
        if (generatorOptions === void 0) {
          generatorOptions = {};
        }
        var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
        return function createPopper2(reference2, popper2, options) {
          if (options === void 0) {
            options = defaultOptions;
          }
          var state = {
            placement: "bottom",
            orderedModifiers: [],
            options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
            modifiersData: {},
            elements: {
              reference: reference2,
              popper: popper2
            },
            attributes: {},
            styles: {}
          };
          var effectCleanupFns = [];
          var isDestroyed = false;
          var instance = {
            state,
            setOptions: function setOptions(setOptionsAction) {
              var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
              cleanupModifierEffects();
              state.options = Object.assign({}, defaultOptions, state.options, options2);
              state.scrollParents = {
                reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
                popper: listScrollParents(popper2)
              };
              var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
              state.orderedModifiers = orderedModifiers.filter(function(m) {
                return m.enabled;
              });
              if (true) {
                var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
                  var name = _ref.name;
                  return name;
                });
                validateModifiers(modifiers);
                if (getBasePlacement(state.options.placement) === auto) {
                  var flipModifier = state.orderedModifiers.find(function(_ref2) {
                    var name = _ref2.name;
                    return name === "flip";
                  });
                  if (!flipModifier) {
                    console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
                  }
                }
                var _getComputedStyle = getComputedStyle2(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
                if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
                  return parseFloat(margin);
                })) {
                  console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
                }
              }
              runModifierEffects();
              return instance.update();
            },
            forceUpdate: function forceUpdate() {
              if (isDestroyed) {
                return;
              }
              var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
              if (!areValidElements(reference3, popper3)) {
                if (true) {
                  console.error(INVALID_ELEMENT_ERROR);
                }
                return;
              }
              state.rects = {
                reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
                popper: getLayoutRect(popper3)
              };
              state.reset = false;
              state.placement = state.options.placement;
              state.orderedModifiers.forEach(function(modifier) {
                return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
              });
              var __debug_loops__ = 0;
              for (var index = 0; index < state.orderedModifiers.length; index++) {
                if (true) {
                  __debug_loops__ += 1;
                  if (__debug_loops__ > 100) {
                    console.error(INFINITE_LOOP_ERROR);
                    break;
                  }
                }
                if (state.reset === true) {
                  state.reset = false;
                  index = -1;
                  continue;
                }
                var _state$orderedModifie = state.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
                if (typeof fn === "function") {
                  state = fn({
                    state,
                    options: _options,
                    name,
                    instance
                  }) || state;
                }
              }
            },
            update: debounce(function() {
              return new Promise(function(resolve) {
                instance.forceUpdate();
                resolve(state);
              });
            }),
            destroy: function destroy() {
              cleanupModifierEffects();
              isDestroyed = true;
            }
          };
          if (!areValidElements(reference2, popper2)) {
            if (true) {
              console.error(INVALID_ELEMENT_ERROR);
            }
            return instance;
          }
          instance.setOptions(options).then(function(state2) {
            if (!isDestroyed && options.onFirstUpdate) {
              options.onFirstUpdate(state2);
            }
          });
          function runModifierEffects() {
            state.orderedModifiers.forEach(function(_ref3) {
              var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect2 = _ref3.effect;
              if (typeof effect2 === "function") {
                var cleanupFn = effect2({
                  state,
                  name,
                  instance,
                  options: options2
                });
                var noopFn = function noopFn2() {
                };
                effectCleanupFns.push(cleanupFn || noopFn);
              }
            });
          }
          function cleanupModifierEffects() {
            effectCleanupFns.forEach(function(fn) {
              return fn();
            });
            effectCleanupFns = [];
          }
          return instance;
        };
      }
      var passive = {
        passive: true
      };
      function effect$2(_ref) {
        var state = _ref.state, instance = _ref.instance, options = _ref.options;
        var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
        var window2 = getWindow(state.elements.popper);
        var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
        if (scroll) {
          scrollParents.forEach(function(scrollParent) {
            scrollParent.addEventListener("scroll", instance.update, passive);
          });
        }
        if (resize) {
          window2.addEventListener("resize", instance.update, passive);
        }
        return function() {
          if (scroll) {
            scrollParents.forEach(function(scrollParent) {
              scrollParent.removeEventListener("scroll", instance.update, passive);
            });
          }
          if (resize) {
            window2.removeEventListener("resize", instance.update, passive);
          }
        };
      }
      var eventListeners = {
        name: "eventListeners",
        enabled: true,
        phase: "write",
        fn: function fn() {
        },
        effect: effect$2,
        data: {}
      };
      function popperOffsets(_ref) {
        var state = _ref.state, name = _ref.name;
        state.modifiersData[name] = computeOffsets({
          reference: state.rects.reference,
          element: state.rects.popper,
          strategy: "absolute",
          placement: state.placement
        });
      }
      var popperOffsets$1 = {
        name: "popperOffsets",
        enabled: true,
        phase: "read",
        fn: popperOffsets,
        data: {}
      };
      var unsetSides = {
        top: "auto",
        right: "auto",
        bottom: "auto",
        left: "auto"
      };
      function roundOffsetsByDPR(_ref) {
        var x = _ref.x, y = _ref.y;
        var win = window;
        var dpr = win.devicePixelRatio || 1;
        return {
          x: round(x * dpr) / dpr || 0,
          y: round(y * dpr) / dpr || 0
        };
      }
      function mapToStyles(_ref2) {
        var _Object$assign2;
        var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
        var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
        var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
          x,
          y
        }) : {
          x,
          y
        };
        x = _ref3.x;
        y = _ref3.y;
        var hasX = offsets.hasOwnProperty("x");
        var hasY = offsets.hasOwnProperty("y");
        var sideX = left;
        var sideY = top;
        var win = window;
        if (adaptive) {
          var offsetParent = getOffsetParent(popper2);
          var heightProp = "clientHeight";
          var widthProp = "clientWidth";
          if (offsetParent === getWindow(popper2)) {
            offsetParent = getDocumentElement(popper2);
            if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
              heightProp = "scrollHeight";
              widthProp = "scrollWidth";
            }
          }
          offsetParent = offsetParent;
          if (placement === top || (placement === left || placement === right) && variation === end) {
            sideY = bottom;
            var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
            y -= offsetY - popperRect.height;
            y *= gpuAcceleration ? 1 : -1;
          }
          if (placement === left || (placement === top || placement === bottom) && variation === end) {
            sideX = right;
            var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
            x -= offsetX - popperRect.width;
            x *= gpuAcceleration ? 1 : -1;
          }
        }
        var commonStyles = Object.assign({
          position
        }, adaptive && unsetSides);
        var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
          x,
          y
        }) : {
          x,
          y
        };
        x = _ref4.x;
        y = _ref4.y;
        if (gpuAcceleration) {
          var _Object$assign;
          return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
        }
        return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
      }
      function computeStyles(_ref5) {
        var state = _ref5.state, options = _ref5.options;
        var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
        if (true) {
          var transitionProperty = getComputedStyle2(state.elements.popper).transitionProperty || "";
          if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
            return transitionProperty.indexOf(property) >= 0;
          })) {
            console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
          }
        }
        var commonStyles = {
          placement: getBasePlacement(state.placement),
          variation: getVariation(state.placement),
          popper: state.elements.popper,
          popperRect: state.rects.popper,
          gpuAcceleration,
          isFixed: state.options.strategy === "fixed"
        };
        if (state.modifiersData.popperOffsets != null) {
          state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
            offsets: state.modifiersData.popperOffsets,
            position: state.options.strategy,
            adaptive,
            roundOffsets
          })));
        }
        if (state.modifiersData.arrow != null) {
          state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
            offsets: state.modifiersData.arrow,
            position: "absolute",
            adaptive: false,
            roundOffsets
          })));
        }
        state.attributes.popper = Object.assign({}, state.attributes.popper, {
          "data-popper-placement": state.placement
        });
      }
      var computeStyles$1 = {
        name: "computeStyles",
        enabled: true,
        phase: "beforeWrite",
        fn: computeStyles,
        data: {}
      };
      function applyStyles(_ref) {
        var state = _ref.state;
        Object.keys(state.elements).forEach(function(name) {
          var style = state.styles[name] || {};
          var attributes = state.attributes[name] || {};
          var element = state.elements[name];
          if (!isHTMLElement(element) || !getNodeName(element)) {
            return;
          }
          Object.assign(element.style, style);
          Object.keys(attributes).forEach(function(name2) {
            var value = attributes[name2];
            if (value === false) {
              element.removeAttribute(name2);
            } else {
              element.setAttribute(name2, value === true ? "" : value);
            }
          });
        });
      }
      function effect$1(_ref2) {
        var state = _ref2.state;
        var initialStyles = {
          popper: {
            position: state.options.strategy,
            left: "0",
            top: "0",
            margin: "0"
          },
          arrow: {
            position: "absolute"
          },
          reference: {}
        };
        Object.assign(state.elements.popper.style, initialStyles.popper);
        state.styles = initialStyles;
        if (state.elements.arrow) {
          Object.assign(state.elements.arrow.style, initialStyles.arrow);
        }
        return function() {
          Object.keys(state.elements).forEach(function(name) {
            var element = state.elements[name];
            var attributes = state.attributes[name] || {};
            var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
            var style = styleProperties.reduce(function(style2, property) {
              style2[property] = "";
              return style2;
            }, {});
            if (!isHTMLElement(element) || !getNodeName(element)) {
              return;
            }
            Object.assign(element.style, style);
            Object.keys(attributes).forEach(function(attribute) {
              element.removeAttribute(attribute);
            });
          });
        };
      }
      var applyStyles$1 = {
        name: "applyStyles",
        enabled: true,
        phase: "write",
        fn: applyStyles,
        effect: effect$1,
        requires: ["computeStyles"]
      };
      function distanceAndSkiddingToXY(placement, rects, offset2) {
        var basePlacement = getBasePlacement(placement);
        var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
        var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
          placement
        })) : offset2, skidding = _ref[0], distance = _ref[1];
        skidding = skidding || 0;
        distance = (distance || 0) * invertDistance;
        return [left, right].indexOf(basePlacement) >= 0 ? {
          x: distance,
          y: skidding
        } : {
          x: skidding,
          y: distance
        };
      }
      function offset(_ref2) {
        var state = _ref2.state, options = _ref2.options, name = _ref2.name;
        var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
        var data = placements.reduce(function(acc, placement) {
          acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
          return acc;
        }, {});
        var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
        if (state.modifiersData.popperOffsets != null) {
          state.modifiersData.popperOffsets.x += x;
          state.modifiersData.popperOffsets.y += y;
        }
        state.modifiersData[name] = data;
      }
      var offset$1 = {
        name: "offset",
        enabled: true,
        phase: "main",
        requires: ["popperOffsets"],
        fn: offset
      };
      var hash$1 = {
        left: "right",
        right: "left",
        bottom: "top",
        top: "bottom"
      };
      function getOppositePlacement(placement) {
        return placement.replace(/left|right|bottom|top/g, function(matched) {
          return hash$1[matched];
        });
      }
      var hash = {
        start: "end",
        end: "start"
      };
      function getOppositeVariationPlacement(placement) {
        return placement.replace(/start|end/g, function(matched) {
          return hash[matched];
        });
      }
      function computeAutoPlacement(state, options) {
        if (options === void 0) {
          options = {};
        }
        var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
        var variation = getVariation(placement);
        var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
          return getVariation(placement2) === variation;
        }) : basePlacements;
        var allowedPlacements = placements$1.filter(function(placement2) {
          return allowedAutoPlacements.indexOf(placement2) >= 0;
        });
        if (allowedPlacements.length === 0) {
          allowedPlacements = placements$1;
          if (true) {
            console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
          }
        }
        var overflows = allowedPlacements.reduce(function(acc, placement2) {
          acc[placement2] = detectOverflow(state, {
            placement: placement2,
            boundary,
            rootBoundary,
            padding
          })[getBasePlacement(placement2)];
          return acc;
        }, {});
        return Object.keys(overflows).sort(function(a, b) {
          return overflows[a] - overflows[b];
        });
      }
      function getExpandedFallbackPlacements(placement) {
        if (getBasePlacement(placement) === auto) {
          return [];
        }
        var oppositePlacement = getOppositePlacement(placement);
        return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
      }
      function flip(_ref) {
        var state = _ref.state, options = _ref.options, name = _ref.name;
        if (state.modifiersData[name]._skip) {
          return;
        }
        var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
        var preferredPlacement = state.options.placement;
        var basePlacement = getBasePlacement(preferredPlacement);
        var isBasePlacement = basePlacement === preferredPlacement;
        var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
        var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
          return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
            placement: placement2,
            boundary,
            rootBoundary,
            padding,
            flipVariations,
            allowedAutoPlacements
          }) : placement2);
        }, []);
        var referenceRect = state.rects.reference;
        var popperRect = state.rects.popper;
        var checksMap = /* @__PURE__ */ new Map();
        var makeFallbackChecks = true;
        var firstFittingPlacement = placements2[0];
        for (var i = 0; i < placements2.length; i++) {
          var placement = placements2[i];
          var _basePlacement = getBasePlacement(placement);
          var isStartVariation = getVariation(placement) === start;
          var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
          var len = isVertical ? "width" : "height";
          var overflow = detectOverflow(state, {
            placement,
            boundary,
            rootBoundary,
            altBoundary,
            padding
          });
          var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
          if (referenceRect[len] > popperRect[len]) {
            mainVariationSide = getOppositePlacement(mainVariationSide);
          }
          var altVariationSide = getOppositePlacement(mainVariationSide);
          var checks = [];
          if (checkMainAxis) {
            checks.push(overflow[_basePlacement] <= 0);
          }
          if (checkAltAxis) {
            checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
          }
          if (checks.every(function(check) {
            return check;
          })) {
            firstFittingPlacement = placement;
            makeFallbackChecks = false;
            break;
          }
          checksMap.set(placement, checks);
        }
        if (makeFallbackChecks) {
          var numberOfChecks = flipVariations ? 3 : 1;
          var _loop = function _loop2(_i2) {
            var fittingPlacement = placements2.find(function(placement2) {
              var checks2 = checksMap.get(placement2);
              if (checks2) {
                return checks2.slice(0, _i2).every(function(check) {
                  return check;
                });
              }
            });
            if (fittingPlacement) {
              firstFittingPlacement = fittingPlacement;
              return "break";
            }
          };
          for (var _i = numberOfChecks; _i > 0; _i--) {
            var _ret = _loop(_i);
            if (_ret === "break")
              break;
          }
        }
        if (state.placement !== firstFittingPlacement) {
          state.modifiersData[name]._skip = true;
          state.placement = firstFittingPlacement;
          state.reset = true;
        }
      }
      var flip$1 = {
        name: "flip",
        enabled: true,
        phase: "main",
        fn: flip,
        requiresIfExists: ["offset"],
        data: {
          _skip: false
        }
      };
      function getAltAxis(axis) {
        return axis === "x" ? "y" : "x";
      }
      function within(min$1, value, max$1) {
        return max(min$1, min(value, max$1));
      }
      function withinMaxClamp(min2, value, max2) {
        var v = within(min2, value, max2);
        return v > max2 ? max2 : v;
      }
      function preventOverflow(_ref) {
        var state = _ref.state, options = _ref.options, name = _ref.name;
        var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
        var overflow = detectOverflow(state, {
          boundary,
          rootBoundary,
          padding,
          altBoundary
        });
        var basePlacement = getBasePlacement(state.placement);
        var variation = getVariation(state.placement);
        var isBasePlacement = !variation;
        var mainAxis = getMainAxisFromPlacement(basePlacement);
        var altAxis = getAltAxis(mainAxis);
        var popperOffsets2 = state.modifiersData.popperOffsets;
        var referenceRect = state.rects.reference;
        var popperRect = state.rects.popper;
        var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
          placement: state.placement
        })) : tetherOffset;
        var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
          mainAxis: tetherOffsetValue,
          altAxis: tetherOffsetValue
        } : Object.assign({
          mainAxis: 0,
          altAxis: 0
        }, tetherOffsetValue);
        var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
        var data = {
          x: 0,
          y: 0
        };
        if (!popperOffsets2) {
          return;
        }
        if (checkMainAxis) {
          var _offsetModifierState$;
          var mainSide = mainAxis === "y" ? top : left;
          var altSide = mainAxis === "y" ? bottom : right;
          var len = mainAxis === "y" ? "height" : "width";
          var offset2 = popperOffsets2[mainAxis];
          var min$1 = offset2 + overflow[mainSide];
          var max$1 = offset2 - overflow[altSide];
          var additive = tether ? -popperRect[len] / 2 : 0;
          var minLen = variation === start ? referenceRect[len] : popperRect[len];
          var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
          var arrowElement = state.elements.arrow;
          var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
            width: 0,
            height: 0
          };
          var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
          var arrowPaddingMin = arrowPaddingObject[mainSide];
          var arrowPaddingMax = arrowPaddingObject[altSide];
          var arrowLen = within(0, referenceRect[len], arrowRect[len]);
          var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
          var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
          var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
          var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
          var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
          var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
          var tetherMax = offset2 + maxOffset - offsetModifierValue;
          var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);
          popperOffsets2[mainAxis] = preventedOffset;
          data[mainAxis] = preventedOffset - offset2;
        }
        if (checkAltAxis) {
          var _offsetModifierState$2;
          var _mainSide = mainAxis === "x" ? top : left;
          var _altSide = mainAxis === "x" ? bottom : right;
          var _offset = popperOffsets2[altAxis];
          var _len = altAxis === "y" ? "height" : "width";
          var _min = _offset + overflow[_mainSide];
          var _max = _offset - overflow[_altSide];
          var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
          var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
          var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
          var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
          var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
          popperOffsets2[altAxis] = _preventedOffset;
          data[altAxis] = _preventedOffset - _offset;
        }
        state.modifiersData[name] = data;
      }
      var preventOverflow$1 = {
        name: "preventOverflow",
        enabled: true,
        phase: "main",
        fn: preventOverflow,
        requiresIfExists: ["offset"]
      };
      var toPaddingObject = function toPaddingObject2(padding, state) {
        padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
          placement: state.placement
        })) : padding;
        return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
      };
      function arrow(_ref) {
        var _state$modifiersData$;
        var state = _ref.state, name = _ref.name, options = _ref.options;
        var arrowElement = state.elements.arrow;
        var popperOffsets2 = state.modifiersData.popperOffsets;
        var basePlacement = getBasePlacement(state.placement);
        var axis = getMainAxisFromPlacement(basePlacement);
        var isVertical = [left, right].indexOf(basePlacement) >= 0;
        var len = isVertical ? "height" : "width";
        if (!arrowElement || !popperOffsets2) {
          return;
        }
        var paddingObject = toPaddingObject(options.padding, state);
        var arrowRect = getLayoutRect(arrowElement);
        var minProp = axis === "y" ? top : left;
        var maxProp = axis === "y" ? bottom : right;
        var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
        var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
        var arrowOffsetParent = getOffsetParent(arrowElement);
        var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
        var centerToReference = endDiff / 2 - startDiff / 2;
        var min2 = paddingObject[minProp];
        var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
        var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
        var offset2 = within(min2, center, max2);
        var axisProp = axis;
        state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
      }
      function effect(_ref2) {
        var state = _ref2.state, options = _ref2.options;
        var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
        if (arrowElement == null) {
          return;
        }
        if (typeof arrowElement === "string") {
          arrowElement = state.elements.popper.querySelector(arrowElement);
          if (!arrowElement) {
            return;
          }
        }
        if (true) {
          if (!isHTMLElement(arrowElement)) {
            console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
          }
        }
        if (!contains(state.elements.popper, arrowElement)) {
          if (true) {
            console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
          }
          return;
        }
        state.elements.arrow = arrowElement;
      }
      var arrow$1 = {
        name: "arrow",
        enabled: true,
        phase: "main",
        fn: arrow,
        effect,
        requires: ["popperOffsets"],
        requiresIfExists: ["preventOverflow"]
      };
      function getSideOffsets(overflow, rect, preventedOffsets) {
        if (preventedOffsets === void 0) {
          preventedOffsets = {
            x: 0,
            y: 0
          };
        }
        return {
          top: overflow.top - rect.height - preventedOffsets.y,
          right: overflow.right - rect.width + preventedOffsets.x,
          bottom: overflow.bottom - rect.height + preventedOffsets.y,
          left: overflow.left - rect.width - preventedOffsets.x
        };
      }
      function isAnySideFullyClipped(overflow) {
        return [top, right, bottom, left].some(function(side) {
          return overflow[side] >= 0;
        });
      }
      function hide(_ref) {
        var state = _ref.state, name = _ref.name;
        var referenceRect = state.rects.reference;
        var popperRect = state.rects.popper;
        var preventedOffsets = state.modifiersData.preventOverflow;
        var referenceOverflow = detectOverflow(state, {
          elementContext: "reference"
        });
        var popperAltOverflow = detectOverflow(state, {
          altBoundary: true
        });
        var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
        var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
        var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
        var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
        state.modifiersData[name] = {
          referenceClippingOffsets,
          popperEscapeOffsets,
          isReferenceHidden,
          hasPopperEscaped
        };
        state.attributes.popper = Object.assign({}, state.attributes.popper, {
          "data-popper-reference-hidden": isReferenceHidden,
          "data-popper-escaped": hasPopperEscaped
        });
      }
      var hide$1 = {
        name: "hide",
        enabled: true,
        phase: "main",
        requiresIfExists: ["preventOverflow"],
        fn: hide
      };
      var defaultModifiers$1 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];
      var createPopper$1 = /* @__PURE__ */ popperGenerator({
        defaultModifiers: defaultModifiers$1
      });
      var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
      var createPopper = /* @__PURE__ */ popperGenerator({
        defaultModifiers
      });
      exports.applyStyles = applyStyles$1;
      exports.arrow = arrow$1;
      exports.computeStyles = computeStyles$1;
      exports.createPopper = createPopper;
      exports.createPopperLite = createPopper$1;
      exports.defaultModifiers = defaultModifiers;
      exports.detectOverflow = detectOverflow;
      exports.eventListeners = eventListeners;
      exports.flip = flip$1;
      exports.hide = hide$1;
      exports.offset = offset$1;
      exports.popperGenerator = popperGenerator;
      exports.popperOffsets = popperOffsets$1;
      exports.preventOverflow = preventOverflow$1;
    }
  });

  // node_modules/bootstrap/dist/js/bootstrap.js
  var require_bootstrap = __commonJS({
    "node_modules/bootstrap/dist/js/bootstrap.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory(require_popper()) : typeof define === "function" && define.amd ? define(["@popperjs/core"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.bootstrap = factory(global2.Popper));
      })(exports, function(Popper) {
        "use strict";
        function _interopNamespace(e) {
          if (e && e.__esModule)
            return e;
          const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
          if (e) {
            for (const k in e) {
              if (k !== "default") {
                const d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                  enumerable: true,
                  get: () => e[k]
                });
              }
            }
          }
          n.default = e;
          return Object.freeze(n);
        }
        const Popper__namespace = /* @__PURE__ */ _interopNamespace(Popper);
        const MAX_UID = 1e6;
        const MILLISECONDS_MULTIPLIER = 1e3;
        const TRANSITION_END = "transitionend";
        const toType = (object) => {
          if (object === null || object === void 0) {
            return `${object}`;
          }
          return Object.prototype.toString.call(object).match(/\s([a-z]+)/i)[1].toLowerCase();
        };
        const getUID = (prefix) => {
          do {
            prefix += Math.floor(Math.random() * MAX_UID);
          } while (document.getElementById(prefix));
          return prefix;
        };
        const getSelector = (element) => {
          let selector = element.getAttribute("data-bs-target");
          if (!selector || selector === "#") {
            let hrefAttribute = element.getAttribute("href");
            if (!hrefAttribute || !hrefAttribute.includes("#") && !hrefAttribute.startsWith(".")) {
              return null;
            }
            if (hrefAttribute.includes("#") && !hrefAttribute.startsWith("#")) {
              hrefAttribute = `#${hrefAttribute.split("#")[1]}`;
            }
            selector = hrefAttribute && hrefAttribute !== "#" ? hrefAttribute.trim() : null;
          }
          return selector;
        };
        const getSelectorFromElement = (element) => {
          const selector = getSelector(element);
          if (selector) {
            return document.querySelector(selector) ? selector : null;
          }
          return null;
        };
        const getElementFromSelector = (element) => {
          const selector = getSelector(element);
          return selector ? document.querySelector(selector) : null;
        };
        const getTransitionDurationFromElement = (element) => {
          if (!element) {
            return 0;
          }
          let {
            transitionDuration,
            transitionDelay
          } = window.getComputedStyle(element);
          const floatTransitionDuration = Number.parseFloat(transitionDuration);
          const floatTransitionDelay = Number.parseFloat(transitionDelay);
          if (!floatTransitionDuration && !floatTransitionDelay) {
            return 0;
          }
          transitionDuration = transitionDuration.split(",")[0];
          transitionDelay = transitionDelay.split(",")[0];
          return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
        };
        const triggerTransitionEnd = (element) => {
          element.dispatchEvent(new Event(TRANSITION_END));
        };
        const isElement = (object) => {
          if (!object || typeof object !== "object") {
            return false;
          }
          if (typeof object.jquery !== "undefined") {
            object = object[0];
          }
          return typeof object.nodeType !== "undefined";
        };
        const getElement = (object) => {
          if (isElement(object)) {
            return object.jquery ? object[0] : object;
          }
          if (typeof object === "string" && object.length > 0) {
            return document.querySelector(object);
          }
          return null;
        };
        const isVisible = (element) => {
          if (!isElement(element) || element.getClientRects().length === 0) {
            return false;
          }
          const elementIsVisible = getComputedStyle(element).getPropertyValue("visibility") === "visible";
          const closedDetails = element.closest("details:not([open])");
          if (!closedDetails) {
            return elementIsVisible;
          }
          if (closedDetails !== element) {
            const summary = element.closest("summary");
            if (summary && summary.parentNode !== closedDetails) {
              return false;
            }
            if (summary === null) {
              return false;
            }
          }
          return elementIsVisible;
        };
        const isDisabled = (element) => {
          if (!element || element.nodeType !== Node.ELEMENT_NODE) {
            return true;
          }
          if (element.classList.contains("disabled")) {
            return true;
          }
          if (typeof element.disabled !== "undefined") {
            return element.disabled;
          }
          return element.hasAttribute("disabled") && element.getAttribute("disabled") !== "false";
        };
        const findShadowRoot = (element) => {
          if (!document.documentElement.attachShadow) {
            return null;
          }
          if (typeof element.getRootNode === "function") {
            const root = element.getRootNode();
            return root instanceof ShadowRoot ? root : null;
          }
          if (element instanceof ShadowRoot) {
            return element;
          }
          if (!element.parentNode) {
            return null;
          }
          return findShadowRoot(element.parentNode);
        };
        const noop = () => {
        };
        const reflow = (element) => {
          element.offsetHeight;
        };
        const getjQuery = () => {
          if (window.jQuery && !document.body.hasAttribute("data-bs-no-jquery")) {
            return window.jQuery;
          }
          return null;
        };
        const DOMContentLoadedCallbacks = [];
        const onDOMContentLoaded = (callback) => {
          if (document.readyState === "loading") {
            if (!DOMContentLoadedCallbacks.length) {
              document.addEventListener("DOMContentLoaded", () => {
                for (const callback2 of DOMContentLoadedCallbacks) {
                  callback2();
                }
              });
            }
            DOMContentLoadedCallbacks.push(callback);
          } else {
            callback();
          }
        };
        const isRTL = () => document.documentElement.dir === "rtl";
        const defineJQueryPlugin = (plugin) => {
          onDOMContentLoaded(() => {
            const $2 = getjQuery();
            if ($2) {
              const name = plugin.NAME;
              const JQUERY_NO_CONFLICT = $2.fn[name];
              $2.fn[name] = plugin.jQueryInterface;
              $2.fn[name].Constructor = plugin;
              $2.fn[name].noConflict = () => {
                $2.fn[name] = JQUERY_NO_CONFLICT;
                return plugin.jQueryInterface;
              };
            }
          });
        };
        const execute = (callback) => {
          if (typeof callback === "function") {
            callback();
          }
        };
        const executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {
          if (!waitForTransition) {
            execute(callback);
            return;
          }
          const durationPadding = 5;
          const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
          let called = false;
          const handler = ({
            target
          }) => {
            if (target !== transitionElement) {
              return;
            }
            called = true;
            transitionElement.removeEventListener(TRANSITION_END, handler);
            execute(callback);
          };
          transitionElement.addEventListener(TRANSITION_END, handler);
          setTimeout(() => {
            if (!called) {
              triggerTransitionEnd(transitionElement);
            }
          }, emulatedDuration);
        };
        const getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {
          const listLength = list.length;
          let index = list.indexOf(activeElement);
          if (index === -1) {
            return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];
          }
          index += shouldGetNext ? 1 : -1;
          if (isCycleAllowed) {
            index = (index + listLength) % listLength;
          }
          return list[Math.max(0, Math.min(index, listLength - 1))];
        };
        const namespaceRegex = /[^.]*(?=\..*)\.|.*/;
        const stripNameRegex = /\..*/;
        const stripUidRegex = /::\d+$/;
        const eventRegistry = {};
        let uidEvent = 1;
        const customEvents = {
          mouseenter: "mouseover",
          mouseleave: "mouseout"
        };
        const nativeEvents = /* @__PURE__ */ new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
        function makeEventUid(element, uid) {
          return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;
        }
        function getElementEvents(element) {
          const uid = makeEventUid(element);
          element.uidEvent = uid;
          eventRegistry[uid] = eventRegistry[uid] || {};
          return eventRegistry[uid];
        }
        function bootstrapHandler(element, fn) {
          return function handler(event) {
            hydrateObj(event, {
              delegateTarget: element
            });
            if (handler.oneOff) {
              EventHandler.off(element, event.type, fn);
            }
            return fn.apply(element, [event]);
          };
        }
        function bootstrapDelegationHandler(element, selector, fn) {
          return function handler(event) {
            const domElements = element.querySelectorAll(selector);
            for (let {
              target
            } = event; target && target !== this; target = target.parentNode) {
              for (const domElement of domElements) {
                if (domElement !== target) {
                  continue;
                }
                hydrateObj(event, {
                  delegateTarget: target
                });
                if (handler.oneOff) {
                  EventHandler.off(element, event.type, selector, fn);
                }
                return fn.apply(target, [event]);
              }
            }
          };
        }
        function findHandler(events, callable, delegationSelector = null) {
          return Object.values(events).find((event) => event.callable === callable && event.delegationSelector === delegationSelector);
        }
        function normalizeParameters(originalTypeEvent, handler, delegationFunction) {
          const isDelegated = typeof handler === "string";
          const callable = isDelegated ? delegationFunction : handler || delegationFunction;
          let typeEvent = getTypeEvent(originalTypeEvent);
          if (!nativeEvents.has(typeEvent)) {
            typeEvent = originalTypeEvent;
          }
          return [isDelegated, callable, typeEvent];
        }
        function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {
          if (typeof originalTypeEvent !== "string" || !element) {
            return;
          }
          let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
          if (originalTypeEvent in customEvents) {
            const wrapFunction = (fn2) => {
              return function(event) {
                if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
                  return fn2.call(this, event);
                }
              };
            };
            callable = wrapFunction(callable);
          }
          const events = getElementEvents(element);
          const handlers = events[typeEvent] || (events[typeEvent] = {});
          const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);
          if (previousFunction) {
            previousFunction.oneOff = previousFunction.oneOff && oneOff;
            return;
          }
          const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ""));
          const fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);
          fn.delegationSelector = isDelegated ? handler : null;
          fn.callable = callable;
          fn.oneOff = oneOff;
          fn.uidEvent = uid;
          handlers[uid] = fn;
          element.addEventListener(typeEvent, fn, isDelegated);
        }
        function removeHandler(element, events, typeEvent, handler, delegationSelector) {
          const fn = findHandler(events[typeEvent], handler, delegationSelector);
          if (!fn) {
            return;
          }
          element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));
          delete events[typeEvent][fn.uidEvent];
        }
        function removeNamespacedHandlers(element, events, typeEvent, namespace) {
          const storeElementEvent = events[typeEvent] || {};
          for (const handlerKey of Object.keys(storeElementEvent)) {
            if (handlerKey.includes(namespace)) {
              const event = storeElementEvent[handlerKey];
              removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
            }
          }
        }
        function getTypeEvent(event) {
          event = event.replace(stripNameRegex, "");
          return customEvents[event] || event;
        }
        const EventHandler = {
          on(element, event, handler, delegationFunction) {
            addHandler(element, event, handler, delegationFunction, false);
          },
          one(element, event, handler, delegationFunction) {
            addHandler(element, event, handler, delegationFunction, true);
          },
          off(element, originalTypeEvent, handler, delegationFunction) {
            if (typeof originalTypeEvent !== "string" || !element) {
              return;
            }
            const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
            const inNamespace = typeEvent !== originalTypeEvent;
            const events = getElementEvents(element);
            const storeElementEvent = events[typeEvent] || {};
            const isNamespace = originalTypeEvent.startsWith(".");
            if (typeof callable !== "undefined") {
              if (!Object.keys(storeElementEvent).length) {
                return;
              }
              removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);
              return;
            }
            if (isNamespace) {
              for (const elementEvent of Object.keys(events)) {
                removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
              }
            }
            for (const keyHandlers of Object.keys(storeElementEvent)) {
              const handlerKey = keyHandlers.replace(stripUidRegex, "");
              if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
                const event = storeElementEvent[keyHandlers];
                removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
              }
            }
          },
          trigger(element, event, args) {
            if (typeof event !== "string" || !element) {
              return null;
            }
            const $2 = getjQuery();
            const typeEvent = getTypeEvent(event);
            const inNamespace = event !== typeEvent;
            let jQueryEvent = null;
            let bubbles = true;
            let nativeDispatch = true;
            let defaultPrevented = false;
            if (inNamespace && $2) {
              jQueryEvent = $2.Event(event, args);
              $2(element).trigger(jQueryEvent);
              bubbles = !jQueryEvent.isPropagationStopped();
              nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
              defaultPrevented = jQueryEvent.isDefaultPrevented();
            }
            let evt = new Event(event, {
              bubbles,
              cancelable: true
            });
            evt = hydrateObj(evt, args);
            if (defaultPrevented) {
              evt.preventDefault();
            }
            if (nativeDispatch) {
              element.dispatchEvent(evt);
            }
            if (evt.defaultPrevented && jQueryEvent) {
              jQueryEvent.preventDefault();
            }
            return evt;
          }
        };
        function hydrateObj(obj, meta) {
          for (const [key, value] of Object.entries(meta || {})) {
            try {
              obj[key] = value;
            } catch (_unused) {
              Object.defineProperty(obj, key, {
                configurable: true,
                get() {
                  return value;
                }
              });
            }
          }
          return obj;
        }
        const elementMap = /* @__PURE__ */ new Map();
        const Data = {
          set(element, key, instance) {
            if (!elementMap.has(element)) {
              elementMap.set(element, /* @__PURE__ */ new Map());
            }
            const instanceMap = elementMap.get(element);
            if (!instanceMap.has(key) && instanceMap.size !== 0) {
              console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
              return;
            }
            instanceMap.set(key, instance);
          },
          get(element, key) {
            if (elementMap.has(element)) {
              return elementMap.get(element).get(key) || null;
            }
            return null;
          },
          remove(element, key) {
            if (!elementMap.has(element)) {
              return;
            }
            const instanceMap = elementMap.get(element);
            instanceMap.delete(key);
            if (instanceMap.size === 0) {
              elementMap.delete(element);
            }
          }
        };
        function normalizeData(value) {
          if (value === "true") {
            return true;
          }
          if (value === "false") {
            return false;
          }
          if (value === Number(value).toString()) {
            return Number(value);
          }
          if (value === "" || value === "null") {
            return null;
          }
          if (typeof value !== "string") {
            return value;
          }
          try {
            return JSON.parse(decodeURIComponent(value));
          } catch (_unused) {
            return value;
          }
        }
        function normalizeDataKey(key) {
          return key.replace(/[A-Z]/g, (chr) => `-${chr.toLowerCase()}`);
        }
        const Manipulator = {
          setDataAttribute(element, key, value) {
            element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
          },
          removeDataAttribute(element, key) {
            element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
          },
          getDataAttributes(element) {
            if (!element) {
              return {};
            }
            const attributes = {};
            const bsKeys = Object.keys(element.dataset).filter((key) => key.startsWith("bs") && !key.startsWith("bsConfig"));
            for (const key of bsKeys) {
              let pureKey = key.replace(/^bs/, "");
              pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
              attributes[pureKey] = normalizeData(element.dataset[key]);
            }
            return attributes;
          },
          getDataAttribute(element, key) {
            return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
          }
        };
        class Config {
          static get Default() {
            return {};
          }
          static get DefaultType() {
            return {};
          }
          static get NAME() {
            throw new Error('You have to implement the static method "NAME", for each component!');
          }
          _getConfig(config) {
            config = this._mergeConfigObj(config);
            config = this._configAfterMerge(config);
            this._typeCheckConfig(config);
            return config;
          }
          _configAfterMerge(config) {
            return config;
          }
          _mergeConfigObj(config, element) {
            const jsonConfig = isElement(element) ? Manipulator.getDataAttribute(element, "config") : {};
            return {
              ...this.constructor.Default,
              ...typeof jsonConfig === "object" ? jsonConfig : {},
              ...isElement(element) ? Manipulator.getDataAttributes(element) : {},
              ...typeof config === "object" ? config : {}
            };
          }
          _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {
            for (const property of Object.keys(configTypes)) {
              const expectedTypes = configTypes[property];
              const value = config[property];
              const valueType = isElement(value) ? "element" : toType(value);
              if (!new RegExp(expectedTypes).test(valueType)) {
                throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
              }
            }
          }
        }
        const VERSION = "5.2.0";
        class BaseComponent extends Config {
          constructor(element, config) {
            super();
            element = getElement(element);
            if (!element) {
              return;
            }
            this._element = element;
            this._config = this._getConfig(config);
            Data.set(this._element, this.constructor.DATA_KEY, this);
          }
          dispose() {
            Data.remove(this._element, this.constructor.DATA_KEY);
            EventHandler.off(this._element, this.constructor.EVENT_KEY);
            for (const propertyName of Object.getOwnPropertyNames(this)) {
              this[propertyName] = null;
            }
          }
          _queueCallback(callback, element, isAnimated = true) {
            executeAfterTransition(callback, element, isAnimated);
          }
          _getConfig(config) {
            config = this._mergeConfigObj(config, this._element);
            config = this._configAfterMerge(config);
            this._typeCheckConfig(config);
            return config;
          }
          static getInstance(element) {
            return Data.get(getElement(element), this.DATA_KEY);
          }
          static getOrCreateInstance(element, config = {}) {
            return this.getInstance(element) || new this(element, typeof config === "object" ? config : null);
          }
          static get VERSION() {
            return VERSION;
          }
          static get DATA_KEY() {
            return `bs.${this.NAME}`;
          }
          static get EVENT_KEY() {
            return `.${this.DATA_KEY}`;
          }
          static eventName(name) {
            return `${name}${this.EVENT_KEY}`;
          }
        }
        const enableDismissTrigger = (component, method = "hide") => {
          const clickEvent = `click.dismiss${component.EVENT_KEY}`;
          const name = component.NAME;
          EventHandler.on(document, clickEvent, `[data-bs-dismiss="${name}"]`, function(event) {
            if (["A", "AREA"].includes(this.tagName)) {
              event.preventDefault();
            }
            if (isDisabled(this)) {
              return;
            }
            const target = getElementFromSelector(this) || this.closest(`.${name}`);
            const instance = component.getOrCreateInstance(target);
            instance[method]();
          });
        };
        const NAME$f = "alert";
        const DATA_KEY$a = "bs.alert";
        const EVENT_KEY$b = `.${DATA_KEY$a}`;
        const EVENT_CLOSE = `close${EVENT_KEY$b}`;
        const EVENT_CLOSED = `closed${EVENT_KEY$b}`;
        const CLASS_NAME_FADE$5 = "fade";
        const CLASS_NAME_SHOW$8 = "show";
        class Alert extends BaseComponent {
          static get NAME() {
            return NAME$f;
          }
          close() {
            const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);
            if (closeEvent.defaultPrevented) {
              return;
            }
            this._element.classList.remove(CLASS_NAME_SHOW$8);
            const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);
            this._queueCallback(() => this._destroyElement(), this._element, isAnimated);
          }
          _destroyElement() {
            this._element.remove();
            EventHandler.trigger(this._element, EVENT_CLOSED);
            this.dispose();
          }
          static jQueryInterface(config) {
            return this.each(function() {
              const data = Alert.getOrCreateInstance(this);
              if (typeof config !== "string") {
                return;
              }
              if (data[config] === void 0 || config.startsWith("_") || config === "constructor") {
                throw new TypeError(`No method named "${config}"`);
              }
              data[config](this);
            });
          }
        }
        enableDismissTrigger(Alert, "close");
        defineJQueryPlugin(Alert);
        const NAME$e = "button";
        const DATA_KEY$9 = "bs.button";
        const EVENT_KEY$a = `.${DATA_KEY$9}`;
        const DATA_API_KEY$6 = ".data-api";
        const CLASS_NAME_ACTIVE$3 = "active";
        const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]';
        const EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;
        class Button extends BaseComponent {
          static get NAME() {
            return NAME$e;
          }
          toggle() {
            this._element.setAttribute("aria-pressed", this._element.classList.toggle(CLASS_NAME_ACTIVE$3));
          }
          static jQueryInterface(config) {
            return this.each(function() {
              const data = Button.getOrCreateInstance(this);
              if (config === "toggle") {
                data[config]();
              }
            });
          }
        }
        EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, (event) => {
          event.preventDefault();
          const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
          const data = Button.getOrCreateInstance(button);
          data.toggle();
        });
        defineJQueryPlugin(Button);
        const SelectorEngine = {
          find(selector, element = document.documentElement) {
            return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
          },
          findOne(selector, element = document.documentElement) {
            return Element.prototype.querySelector.call(element, selector);
          },
          children(element, selector) {
            return [].concat(...element.children).filter((child) => child.matches(selector));
          },
          parents(element, selector) {
            const parents = [];
            let ancestor = element.parentNode.closest(selector);
            while (ancestor) {
              parents.push(ancestor);
              ancestor = ancestor.parentNode.closest(selector);
            }
            return parents;
          },
          prev(element, selector) {
            let previous = element.previousElementSibling;
            while (previous) {
              if (previous.matches(selector)) {
                return [previous];
              }
              previous = previous.previousElementSibling;
            }
            return [];
          },
          next(element, selector) {
            let next = element.nextElementSibling;
            while (next) {
              if (next.matches(selector)) {
                return [next];
              }
              next = next.nextElementSibling;
            }
            return [];
          },
          focusableChildren(element) {
            const focusables = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((selector) => `${selector}:not([tabindex^="-"])`).join(",");
            return this.find(focusables, element).filter((el) => !isDisabled(el) && isVisible(el));
          }
        };
        const NAME$d = "swipe";
        const EVENT_KEY$9 = ".bs.swipe";
        const EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;
        const EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;
        const EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;
        const EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;
        const EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;
        const POINTER_TYPE_TOUCH = "touch";
        const POINTER_TYPE_PEN = "pen";
        const CLASS_NAME_POINTER_EVENT = "pointer-event";
        const SWIPE_THRESHOLD = 40;
        const Default$c = {
          endCallback: null,
          leftCallback: null,
          rightCallback: null
        };
        const DefaultType$c = {
          endCallback: "(function|null)",
          leftCallback: "(function|null)",
          rightCallback: "(function|null)"
        };
        class Swipe extends Config {
          constructor(element, config) {
            super();
            this._element = element;
            if (!element || !Swipe.isSupported()) {
              return;
            }
            this._config = this._getConfig(config);
            this._deltaX = 0;
            this._supportPointerEvents = Boolean(window.PointerEvent);
            this._initEvents();
          }
          static get Default() {
            return Default$c;
          }
          static get DefaultType() {
            return DefaultType$c;
          }
          static get NAME() {
            return NAME$d;
          }
          dispose() {
            EventHandler.off(this._element, EVENT_KEY$9);
          }
          _start(event) {
            if (!this._supportPointerEvents) {
              this._deltaX = event.touches[0].clientX;
              return;
            }
            if (this._eventIsPointerPenTouch(event)) {
              this._deltaX = event.clientX;
            }
          }
          _end(event) {
            if (this._eventIsPointerPenTouch(event)) {
              this._deltaX = event.clientX - this._deltaX;
            }
            this._handleSwipe();
            execute(this._config.endCallback);
          }
          _move(event) {
            this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;
          }
          _handleSwipe() {
            const absDeltaX = Math.abs(this._deltaX);
            if (absDeltaX <= SWIPE_THRESHOLD) {
              return;
            }
            const direction = absDeltaX / this._deltaX;
            this._deltaX = 0;
            if (!direction) {
              return;
            }
            execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);
          }
          _initEvents() {
            if (this._supportPointerEvents) {
              EventHandler.on(this._element, EVENT_POINTERDOWN, (event) => this._start(event));
              EventHandler.on(this._element, EVENT_POINTERUP, (event) => this._end(event));
              this._element.classList.add(CLASS_NAME_POINTER_EVENT);
            } else {
              EventHandler.on(this._element, EVENT_TOUCHSTART, (event) => this._start(event));
              EventHandler.on(this._element, EVENT_TOUCHMOVE, (event) => this._move(event));
              EventHandler.on(this._element, EVENT_TOUCHEND, (event) => this._end(event));
            }
          }
          _eventIsPointerPenTouch(event) {
            return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
          }
          static isSupported() {
            return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
          }
        }
        const NAME$c = "carousel";
        const DATA_KEY$8 = "bs.carousel";
        const EVENT_KEY$8 = `.${DATA_KEY$8}`;
        const DATA_API_KEY$5 = ".data-api";
        const ARROW_LEFT_KEY$1 = "ArrowLeft";
        const ARROW_RIGHT_KEY$1 = "ArrowRight";
        const TOUCHEVENT_COMPAT_WAIT = 500;
        const ORDER_NEXT = "next";
        const ORDER_PREV = "prev";
        const DIRECTION_LEFT = "left";
        const DIRECTION_RIGHT = "right";
        const EVENT_SLIDE = `slide${EVENT_KEY$8}`;
        const EVENT_SLID = `slid${EVENT_KEY$8}`;
        const EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;
        const EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;
        const EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;
        const EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;
        const EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;
        const EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;
        const CLASS_NAME_CAROUSEL = "carousel";
        const CLASS_NAME_ACTIVE$2 = "active";
        const CLASS_NAME_SLIDE = "slide";
        const CLASS_NAME_END = "carousel-item-end";
        const CLASS_NAME_START = "carousel-item-start";
        const CLASS_NAME_NEXT = "carousel-item-next";
        const CLASS_NAME_PREV = "carousel-item-prev";
        const SELECTOR_ACTIVE = ".active";
        const SELECTOR_ITEM = ".carousel-item";
        const SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;
        const SELECTOR_ITEM_IMG = ".carousel-item img";
        const SELECTOR_INDICATORS = ".carousel-indicators";
        const SELECTOR_DATA_SLIDE = "[data-bs-slide], [data-bs-slide-to]";
        const SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
        const KEY_TO_DIRECTION = {
          [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,
          [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT
        };
        const Default$b = {
          interval: 5e3,
          keyboard: true,
          pause: "hover",
          ride: false,
          touch: true,
          wrap: true
        };
        const DefaultType$b = {
          interval: "(number|boolean)",
          keyboard: "boolean",
          pause: "(string|boolean)",
          ride: "(boolean|string)",
          touch: "boolean",
          wrap: "boolean"
        };
        class Carousel extends BaseComponent {
          constructor(element, config) {
            super(element, config);
            this._interval = null;
            this._activeElement = null;
            this._isSliding = false;
            this.touchTimeout = null;
            this._swipeHelper = null;
            this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);
            this._addEventListeners();
            if (this._config.ride === CLASS_NAME_CAROUSEL) {
              this.cycle();
            }
          }
          static get Default() {
            return Default$b;
          }
          static get DefaultType() {
            return DefaultType$b;
          }
          static get NAME() {
            return NAME$c;
          }
          next() {
            this._slide(ORDER_NEXT);
          }
          nextWhenVisible() {
            if (!document.hidden && isVisible(this._element)) {
              this.next();
            }
          }
          prev() {
            this._slide(ORDER_PREV);
          }
          pause() {
            if (this._isSliding) {
              triggerTransitionEnd(this._element);
            }
            this._clearInterval();
          }
          cycle() {
            this._clearInterval();
            this._updateInterval();
            this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
          }
          _maybeEnableCycle() {
            if (!this._config.ride) {
              return;
            }
            if (this._isSliding) {
              EventHandler.one(this._element, EVENT_SLID, () => this.cycle());
              return;
            }
            this.cycle();
          }
          to(index) {
            const items = this._getItems();
            if (index > items.length - 1 || index < 0) {
              return;
            }
            if (this._isSliding) {
              EventHandler.one(this._element, EVENT_SLID, () => this.to(index));
              return;
            }
            const activeIndex = this._getItemIndex(this._getActive());
            if (activeIndex === index) {
              return;
            }
            const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;
            this._slide(order, items[index]);
          }
          dispose() {
            if (this._swipeHelper) {
              this._swipeHelper.dispose();
            }
            super.dispose();
          }
          _configAfterMerge(config) {
            config.defaultInterval = config.interval;
            return config;
          }
          _addEventListeners() {
            if (this._config.keyboard) {
              EventHandler.on(this._element, EVENT_KEYDOWN$1, (event) => this._keydown(event));
            }
            if (this._config.pause === "hover") {
              EventHandler.on(this._element, EVENT_MOUSEENTER$1, () => this.pause());
              EventHandler.on(this._element, EVENT_MOUSELEAVE$1, () => this._maybeEnableCycle());
            }
            if (this._config.touch && Swipe.isSupported()) {
              this._addTouchEventListeners();
            }
          }
          _addTouchEventListeners() {
            for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)) {
              EventHandler.on(img, EVENT_DRAG_START, (event) => event.preventDefault());
            }
            const endCallBack = () => {
              if (this._config.pause !== "hover") {
                return;
              }
              this.pause();
              if (this.touchTimeout) {
                clearTimeout(this.touchTimeout);
              }
              this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);
            };
            const swipeConfig = {
              leftCallback: () => this._slide(this._directionToOrder(DIRECTION_LEFT)),
              rightCallback: () => this._slide(this._directionToOrder(DIRECTION_RIGHT)),
              endCallback: endCallBack
            };
            this._swipeHelper = new Swipe(this._element, swipeConfig);
          }
          _keydown(event) {
            if (/input|textarea/i.test(event.target.tagName)) {
              return;
            }
            const direction = KEY_TO_DIRECTION[event.key];
            if (direction) {
              event.preventDefault();
              this._slide(this._directionToOrder(direction));
            }
          }
          _getItemIndex(element) {
            return this._getItems().indexOf(element);
          }
          _setActiveIndicatorElement(index) {
            if (!this._indicatorsElement) {
              return;
            }
            const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);
            activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
            activeIndicator.removeAttribute("aria-current");
            const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to="${index}"]`, this._indicatorsElement);
            if (newActiveIndicator) {
              newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);
              newActiveIndicator.setAttribute("aria-current", "true");
            }
          }
          _updateInterval() {
            const element = this._activeElement || this._getActive();
            if (!element) {
              return;
            }
            const elementInterval = Number.parseInt(element.getAttribute("data-bs-interval"), 10);
            this._config.interval = elementInterval || this._config.defaultInterval;
          }
          _slide(order, element = null) {
            if (this._isSliding) {
              return;
            }
            const activeElement = this._getActive();
            const isNext = order === ORDER_NEXT;
            const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);
            if (nextElement === activeElement) {
              return;
            }
            const nextElementIndex = this._getItemIndex(nextElement);
            const triggerEvent = (eventName) => {
              return EventHandler.trigger(this._element, eventName, {
                relatedTarget: nextElement,
                direction: this._orderToDirection(order),
                from: this._getItemIndex(activeElement),
                to: nextElementIndex
              });
            };
            const slideEvent = triggerEvent(EVENT_SLIDE);
            if (slideEvent.defaultPrevented) {
              return;
            }
            if (!activeElement || !nextElement) {
              return;
            }
            const isCycling = Boolean(this._interval);
            this.pause();
            this._isSliding = true;
            this._setActiveIndicatorElement(nextElementIndex);
            this._activeElement = nextElement;
            const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
            const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;
            nextElement.classList.add(orderClassName);
            reflow(nextElement);
            activeElement.classList.add(directionalClassName);
            nextElement.classList.add(directionalClassName);
            const completeCallBack = () => {
              nextElement.classList.remove(directionalClassName, orderClassName);
              nextElement.classList.add(CLASS_NAME_ACTIVE$2);
              activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
              this._isSliding = false;
              triggerEvent(EVENT_SLID);
            };
            this._queueCallback(completeCallBack, activeElement, this._isAnimated());
            if (isCycling) {
              this.cycle();
            }
          }
          _isAnimated() {
            return this._element.classList.contains(CLASS_NAME_SLIDE);
          }
          _getActive() {
            return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
          }
          _getItems() {
            return SelectorEngine.find(SELECTOR_ITEM, this._element);
          }
          _clearInterval() {
            if (this._interval) {
              clearInterval(this._interval);
              this._interval = null;
            }
          }
          _directionToOrder(direction) {
            if (isRTL()) {
              return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
            }
            return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
          }
          _orderToDirection(order) {
            if (isRTL()) {
              return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
            }
            return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
          }
          static jQueryInterface(config) {
            return this.each(function() {
              const data = Carousel.getOrCreateInstance(this, config);
              if (typeof config === "number") {
                data.to(config);
                return;
              }
              if (typeof config === "string") {
                if (data[config] === void 0 || config.startsWith("_") || config === "constructor") {
                  throw new TypeError(`No method named "${config}"`);
                }
                data[config]();
              }
            });
          }
        }
        EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function(event) {
          const target = getElementFromSelector(this);
          if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {
            return;
          }
          event.preventDefault();
          const carousel = Carousel.getOrCreateInstance(target);
          const slideIndex = this.getAttribute("data-bs-slide-to");
          if (slideIndex) {
            carousel.to(slideIndex);
            carousel._maybeEnableCycle();
            return;
          }
          if (Manipulator.getDataAttribute(this, "slide") === "next") {
            carousel.next();
            carousel._maybeEnableCycle();
            return;
          }
          carousel.prev();
          carousel._maybeEnableCycle();
        });
        EventHandler.on(window, EVENT_LOAD_DATA_API$3, () => {
          const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);
          for (const carousel of carousels) {
            Carousel.getOrCreateInstance(carousel);
          }
        });
        defineJQueryPlugin(Carousel);
        const NAME$b = "collapse";
        const DATA_KEY$7 = "bs.collapse";
        const EVENT_KEY$7 = `.${DATA_KEY$7}`;
        const DATA_API_KEY$4 = ".data-api";
        const EVENT_SHOW$6 = `show${EVENT_KEY$7}`;
        const EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;
        const EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;
        const EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;
        const EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;
        const CLASS_NAME_SHOW$7 = "show";
        const CLASS_NAME_COLLAPSE = "collapse";
        const CLASS_NAME_COLLAPSING = "collapsing";
        const CLASS_NAME_COLLAPSED = "collapsed";
        const CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;
        const CLASS_NAME_HORIZONTAL = "collapse-horizontal";
        const WIDTH = "width";
        const HEIGHT = "height";
        const SELECTOR_ACTIVES = ".collapse.show, .collapse.collapsing";
        const SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]';
        const Default$a = {
          parent: null,
          toggle: true
        };
        const DefaultType$a = {
          parent: "(null|element)",
          toggle: "boolean"
        };
        class Collapse extends BaseComponent {
          constructor(element, config) {
            super(element, config);
            this._isTransitioning = false;
            this._triggerArray = [];
            const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);
            for (const elem of toggleList) {
              const selector = getSelectorFromElement(elem);
              const filterElement = SelectorEngine.find(selector).filter((foundElement) => foundElement === this._element);
              if (selector !== null && filterElement.length) {
                this._triggerArray.push(elem);
              }
            }
            this._initializeChildren();
            if (!this._config.parent) {
              this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
            }
            if (this._config.toggle) {
              this.toggle();
            }
          }
          static get Default() {
            return Default$a;
          }
          static get DefaultType() {
            return DefaultType$a;
          }
          static get NAME() {
            return NAME$b;
          }
          toggle() {
            if (this._isShown()) {
              this.hide();
            } else {
              this.show();
            }
          }
          show() {
            if (this._isTransitioning || this._isShown()) {
              return;
            }
            let activeChildren = [];
            if (this._config.parent) {
              activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter((element) => element !== this._element).map((element) => Collapse.getOrCreateInstance(element, {
                toggle: false
              }));
            }
            if (activeChildren.length && activeChildren[0]._isTransitioning) {
              return;
            }
            const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);
            if (startEvent.defaultPrevented) {
              return;
            }
            for (const activeInstance of activeChildren) {
              activeInstance.hide();
            }
            const dimension = this._getDimension();
            this._element.classList.remove(CLASS_NAME_COLLAPSE);
            this._element.classList.add(CLASS_NAME_COLLAPSING);
            this._element.style[dimension] = 0;
            this._addAriaAndCollapsedClass(this._triggerArray, true);
            this._isTransitioning = true;
            const complete = () => {
              this._isTransitioning = false;
              this._element.classList.remove(CLASS_NAME_COLLAPSING);
              this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
              this._element.style[dimension] = "";
              EventHandler.trigger(this._element, EVENT_SHOWN$6);
            };
            const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
            const scrollSize = `scroll${capitalizedDimension}`;
            this._queueCallback(complete, this._element, true);
            this._element.style[dimension] = `${this._element[scrollSize]}px`;
          }
          hide() {
            if (this._isTransitioning || !this._isShown()) {
              return;
            }
            const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);
            if (startEvent.defaultPrevented) {
              return;
            }
            const dimension = this._getDimension();
            this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
            reflow(this._element);
            this._element.classList.add(CLASS_NAME_COLLAPSING);
            this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
            for (const trigger of this._triggerArray) {
              const element = getElementFromSelector(trigger);
              if (element && !this._isShown(element)) {
                this._addAriaAndCollapsedClass([trigger], false);
              }
            }
            this._isTransitioning = true;
            const complete = () => {
              this._isTransitioning = false;
              this._element.classList.remove(CLASS_NAME_COLLAPSING);
              this._element.classList.add(CLASS_NAME_COLLAPSE);
              EventHandler.trigger(this._element, EVENT_HIDDEN$6);
            };
            this._element.style[dimension] = "";
            this._queueCallback(complete, this._element, true);
          }
          _isShown(element = this._element) {
            return element.classList.contains(CLASS_NAME_SHOW$7);
          }
          _configAfterMerge(config) {
            config.toggle = Boolean(config.toggle);
            config.parent = getElement(config.parent);
            return config;
          }
          _getDimension() {
            return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
          }
          _initializeChildren() {
            if (!this._config.parent) {
              return;
            }
            const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);
            for (const element of children) {
              const selected = getElementFromSelector(element);
              if (selected) {
                this._addAriaAndCollapsedClass([element], this._isShown(selected));
              }
            }
          }
          _getFirstLevelChildren(selector) {
            const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
            return SelectorEngine.find(selector, this._config.parent).filter((element) => !children.includes(element));
          }
          _addAriaAndCollapsedClass(triggerArray, isOpen) {
            if (!triggerArray.length) {
              return;
            }
            for (const element of triggerArray) {
              element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);
              element.setAttribute("aria-expanded", isOpen);
            }
          }
          static jQueryInterface(config) {
            const _config = {};
            if (typeof config === "string" && /show|hide/.test(config)) {
              _config.toggle = false;
            }
            return this.each(function() {
              const data = Collapse.getOrCreateInstance(this, _config);
              if (typeof config === "string") {
                if (typeof data[config] === "undefined") {
                  throw new TypeError(`No method named "${config}"`);
                }
                data[config]();
              }
            });
          }
        }
        EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function(event) {
          if (event.target.tagName === "A" || event.delegateTarget && event.delegateTarget.tagName === "A") {
            event.preventDefault();
          }
          const selector = getSelectorFromElement(this);
          const selectorElements = SelectorEngine.find(selector);
          for (const element of selectorElements) {
            Collapse.getOrCreateInstance(element, {
              toggle: false
            }).toggle();
          }
        });
        defineJQueryPlugin(Collapse);
        const NAME$a = "dropdown";
        const DATA_KEY$6 = "bs.dropdown";
        const EVENT_KEY$6 = `.${DATA_KEY$6}`;
        const DATA_API_KEY$3 = ".data-api";
        const ESCAPE_KEY$2 = "Escape";
        const TAB_KEY$1 = "Tab";
        const ARROW_UP_KEY$1 = "ArrowUp";
        const ARROW_DOWN_KEY$1 = "ArrowDown";
        const RIGHT_MOUSE_BUTTON = 2;
        const EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;
        const EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;
        const EVENT_SHOW$5 = `show${EVENT_KEY$6}`;
        const EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;
        const EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;
        const EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;
        const EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;
        const CLASS_NAME_SHOW$6 = "show";
        const CLASS_NAME_DROPUP = "dropup";
        const CLASS_NAME_DROPEND = "dropend";
        const CLASS_NAME_DROPSTART = "dropstart";
        const CLASS_NAME_DROPUP_CENTER = "dropup-center";
        const CLASS_NAME_DROPDOWN_CENTER = "dropdown-center";
        const SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)';
        const SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;
        const SELECTOR_MENU = ".dropdown-menu";
        const SELECTOR_NAVBAR = ".navbar";
        const SELECTOR_NAVBAR_NAV = ".navbar-nav";
        const SELECTOR_VISIBLE_ITEMS = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)";
        const PLACEMENT_TOP = isRTL() ? "top-end" : "top-start";
        const PLACEMENT_TOPEND = isRTL() ? "top-start" : "top-end";
        const PLACEMENT_BOTTOM = isRTL() ? "bottom-end" : "bottom-start";
        const PLACEMENT_BOTTOMEND = isRTL() ? "bottom-start" : "bottom-end";
        const PLACEMENT_RIGHT = isRTL() ? "left-start" : "right-start";
        const PLACEMENT_LEFT = isRTL() ? "right-start" : "left-start";
        const PLACEMENT_TOPCENTER = "top";
        const PLACEMENT_BOTTOMCENTER = "bottom";
        const Default$9 = {
          autoClose: true,
          boundary: "clippingParents",
          display: "dynamic",
          offset: [0, 2],
          popperConfig: null,
          reference: "toggle"
        };
        const DefaultType$9 = {
          autoClose: "(boolean|string)",
          boundary: "(string|element)",
          display: "string",
          offset: "(array|string|function)",
          popperConfig: "(null|object|function)",
          reference: "(string|element|object)"
        };
        class Dropdown extends BaseComponent {
          constructor(element, config) {
            super(element, config);
            this._popper = null;
            this._parent = this._element.parentNode;
            this._menu = SelectorEngine.findOne(SELECTOR_MENU, this._parent);
            this._inNavbar = this._detectNavbar();
          }
          static get Default() {
            return Default$9;
          }
          static get DefaultType() {
            return DefaultType$9;
          }
          static get NAME() {
            return NAME$a;
          }
          toggle() {
            return this._isShown() ? this.hide() : this.show();
          }
          show() {
            if (isDisabled(this._element) || this._isShown()) {
              return;
            }
            const relatedTarget = {
              relatedTarget: this._element
            };
            const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);
            if (showEvent.defaultPrevented) {
              return;
            }
            this._createPopper();
            if ("ontouchstart" in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {
              for (const element of [].concat(...document.body.children)) {
                EventHandler.on(element, "mouseover", noop);
              }
            }
            this._element.focus();
            this._element.setAttribute("aria-expanded", true);
            this._menu.classList.add(CLASS_NAME_SHOW$6);
            this._element.classList.add(CLASS_NAME_SHOW$6);
            EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);
          }
          hide() {
            if (isDisabled(this._element) || !this._isShown()) {
              return;
            }
            const relatedTarget = {
              relatedTarget: this._element
            };
            this._completeHide(relatedTarget);
          }
          dispose() {
            if (this._popper) {
              this._popper.destroy();
            }
            super.dispose();
          }
          update() {
            this._inNavbar = this._detectNavbar();
            if (this._popper) {
              this._popper.update();
            }
          }
          _completeHide(relatedTarget) {
            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);
            if (hideEvent.defaultPrevented) {
              return;
            }
            if ("ontouchstart" in document.documentElement) {
              for (const element of [].concat(...document.body.children)) {
                EventHandler.off(element, "mouseover", noop);
              }
            }
            if (this._popper) {
              this._popper.destroy();
            }
            this._menu.classList.remove(CLASS_NAME_SHOW$6);
            this._element.classList.remove(CLASS_NAME_SHOW$6);
            this._element.setAttribute("aria-expanded", "false");
            Manipulator.removeDataAttribute(this._menu, "popper");
            EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);
          }
          _getConfig(config) {
            config = super._getConfig(config);
            if (typeof config.reference === "object" && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== "function") {
              throw new TypeError(`${NAME$a.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
            }
            return config;
          }
          _createPopper() {
            if (typeof Popper__namespace === "undefined") {
              throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
            }
            let referenceElement = this._element;
            if (this._config.reference === "parent") {
              referenceElement = this._parent;
            } else if (isElement(this._config.reference)) {
              referenceElement = getElement(this._config.reference);
            } else if (typeof this._config.reference === "object") {
              referenceElement = this._config.reference;
            }
            const popperConfig = this._getPopperConfig();
            this._popper = Popper__namespace.createPopper(referenceElement, this._menu, popperConfig);
          }
          _isShown() {
            return this._menu.classList.contains(CLASS_NAME_SHOW$6);
          }
          _getPlacement() {
            const parentDropdown = this._parent;
            if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
              return PLACEMENT_RIGHT;
            }
            if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
              return PLACEMENT_LEFT;
            }
            if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {
              return PLACEMENT_TOPCENTER;
            }
            if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {
              return PLACEMENT_BOTTOMCENTER;
            }
            const isEnd = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end";
            if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
              return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
            }
            return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
          }
          _detectNavbar() {
            return this._element.closest(SELECTOR_NAVBAR) !== null;
          }
          _getOffset() {
            const {
              offset
            } = this._config;
            if (typeof offset === "string") {
              return offset.split(",").map((value) => Number.parseInt(value, 10));
            }
            if (typeof offset === "function") {
              return (popperData) => offset(popperData, this._element);
            }
            return offset;
          }
          _getPopperConfig() {
            const defaultBsPopperConfig = {
              placement: this._getPlacement(),
              modifiers: [{
                name: "preventOverflow",
                options: {
                  boundary: this._config.boundary
                }
              }, {
                name: "offset",
                options: {
                  offset: this._getOffset()
                }
              }]
            };
            if (this._inNavbar || this._config.display === "static") {
              Manipulator.setDataAttribute(this._menu, "popper", "static");
              defaultBsPopperConfig.modifiers = [{
                name: "applyStyles",
                enabled: false
              }];
            }
            return {
              ...defaultBsPopperConfig,
              ...typeof this._config.popperConfig === "function" ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig
            };
          }
          _selectMenuItem({
            key,
            target
          }) {
            const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter((element) => isVisible(element));
            if (!items.length) {
              return;
            }
            getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();
          }
          static jQueryInterface(config) {
            return this.each(function() {
              const data = Dropdown.getOrCreateInstance(this, config);
              if (typeof config !== "string") {
                return;
              }
              if (typeof data[config] === "undefined") {
                throw new TypeError(`No method named "${config}"`);
              }
              data[config]();
            });
          }
          static clearMenus(event) {
            if (event.button === RIGHT_MOUSE_BUTTON || event.type === "keyup" && event.key !== TAB_KEY$1) {
              return;
            }
            const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);
            for (const toggle of openToggles) {
              const context = Dropdown.getInstance(toggle);
              if (!context || context._config.autoClose === false) {
                continue;
              }
              const composedPath = event.composedPath();
              const isMenuTarget = composedPath.includes(context._menu);
              if (composedPath.includes(context._element) || context._config.autoClose === "inside" && !isMenuTarget || context._config.autoClose === "outside" && isMenuTarget) {
                continue;
              }
              if (context._menu.contains(event.target) && (event.type === "keyup" && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {
                continue;
              }
              const relatedTarget = {
                relatedTarget: context._element
              };
              if (event.type === "click") {
                relatedTarget.clickEvent = event;
              }
              context._completeHide(relatedTarget);
            }
          }
          static dataApiKeydownHandler(event) {
            const isInput = /input|textarea/i.test(event.target.tagName);
            const isEscapeEvent = event.key === ESCAPE_KEY$2;
            const isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(event.key);
            if (!isUpOrDownEvent && !isEscapeEvent) {
              return;
            }
            if (isInput && !isEscapeEvent) {
              return;
            }
            event.preventDefault();
            const getToggleButton = SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);
            const instance = Dropdown.getOrCreateInstance(getToggleButton);
            if (isUpOrDownEvent) {
              event.stopPropagation();
              instance.show();
              instance._selectMenuItem(event);
              return;
            }
            if (instance._isShown()) {
              event.stopPropagation();
              instance.hide();
              getToggleButton.focus();
            }
          }
        }
        EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
        EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
        EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
        EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
        EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function(event) {
          event.preventDefault();
          Dropdown.getOrCreateInstance(this).toggle();
        });
        defineJQueryPlugin(Dropdown);
        const SELECTOR_FIXED_CONTENT = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top";
        const SELECTOR_STICKY_CONTENT = ".sticky-top";
        const PROPERTY_PADDING = "padding-right";
        const PROPERTY_MARGIN = "margin-right";
        class ScrollBarHelper {
          constructor() {
            this._element = document.body;
          }
          getWidth() {
            const documentWidth = document.documentElement.clientWidth;
            return Math.abs(window.innerWidth - documentWidth);
          }
          hide() {
            const width = this.getWidth();
            this._disableOverFlow();
            this._setElementAttributes(this._element, PROPERTY_PADDING, (calculatedValue) => calculatedValue + width);
            this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, (calculatedValue) => calculatedValue + width);
            this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, (calculatedValue) => calculatedValue - width);
          }
          reset() {
            this._resetElementAttributes(this._element, "overflow");
            this._resetElementAttributes(this._element, PROPERTY_PADDING);
            this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);
            this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);
          }
          isOverflowing() {
            return this.getWidth() > 0;
          }
          _disableOverFlow() {
            this._saveInitialAttribute(this._element, "overflow");
            this._element.style.overflow = "hidden";
          }
          _setElementAttributes(selector, styleProperty, callback) {
            const scrollbarWidth = this.getWidth();
            const manipulationCallBack = (element) => {
              if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
                return;
              }
              this._saveInitialAttribute(element, styleProperty);
              const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);
              element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);
            };
            this._applyManipulationCallback(selector, manipulationCallBack);
          }
          _saveInitialAttribute(element, styleProperty) {
            const actualValue = element.style.getPropertyValue(styleProperty);
            if (actualValue) {
              Manipulator.setDataAttribute(element, styleProperty, actualValue);
            }
          }
          _resetElementAttributes(selector, styleProperty) {
            const manipulationCallBack = (element) => {
              const value = Manipulator.getDataAttribute(element, styleProperty);
              if (value === null) {
                element.style.removeProperty(styleProperty);
                return;
              }
              Manipulator.removeDataAttribute(element, styleProperty);
              element.style.setProperty(styleProperty, value);
            };
            this._applyManipulationCallback(selector, manipulationCallBack);
          }
          _applyManipulationCallback(selector, callBack) {
            if (isElement(selector)) {
              callBack(selector);
              return;
            }
            for (const sel of SelectorEngine.find(selector, this._element)) {
              callBack(sel);
            }
          }
        }
        const NAME$9 = "backdrop";
        const CLASS_NAME_FADE$4 = "fade";
        const CLASS_NAME_SHOW$5 = "show";
        const EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;
        const Default$8 = {
          className: "modal-backdrop",
          clickCallback: null,
          isAnimated: false,
          isVisible: true,
          rootElement: "body"
        };
        const DefaultType$8 = {
          className: "string",
          clickCallback: "(function|null)",
          isAnimated: "boolean",
          isVisible: "boolean",
          rootElement: "(element|string)"
        };
        class Backdrop extends Config {
          constructor(config) {
            super();
            this._config = this._getConfig(config);
            this._isAppended = false;
            this._element = null;
          }
          static get Default() {
            return Default$8;
          }
          static get DefaultType() {
            return DefaultType$8;
          }
          static get NAME() {
            return NAME$9;
          }
          show(callback) {
            if (!this._config.isVisible) {
              execute(callback);
              return;
            }
            this._append();
            const element = this._getElement();
            if (this._config.isAnimated) {
              reflow(element);
            }
            element.classList.add(CLASS_NAME_SHOW$5);
            this._emulateAnimation(() => {
              execute(callback);
            });
          }
          hide(callback) {
            if (!this._config.isVisible) {
              execute(callback);
              return;
            }
            this._getElement().classList.remove(CLASS_NAME_SHOW$5);
            this._emulateAnimation(() => {
              this.dispose();
              execute(callback);
            });
          }
          dispose() {
            if (!this._isAppended) {
              return;
            }
            EventHandler.off(this._element, EVENT_MOUSEDOWN);
            this._element.remove();
            this._isAppended = false;
          }
          _getElement() {
            if (!this._element) {
              const backdrop = document.createElement("div");
              backdrop.className = this._config.className;
              if (this._config.isAnimated) {
                backdrop.classList.add(CLASS_NAME_FADE$4);
              }
              this._element = backdrop;
            }
            return this._element;
          }
          _configAfterMerge(config) {
            config.rootElement = getElement(config.rootElement);
            return config;
          }
          _append() {
            if (this._isAppended) {
              return;
            }
            const element = this._getElement();
            this._config.rootElement.append(element);
            EventHandler.on(element, EVENT_MOUSEDOWN, () => {
              execute(this._config.clickCallback);
            });
            this._isAppended = true;
          }
          _emulateAnimation(callback) {
            executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
          }
        }
        const NAME$8 = "focustrap";
        const DATA_KEY$5 = "bs.focustrap";
        const EVENT_KEY$5 = `.${DATA_KEY$5}`;
        const EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;
        const EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;
        const TAB_KEY = "Tab";
        const TAB_NAV_FORWARD = "forward";
        const TAB_NAV_BACKWARD = "backward";
        const Default$7 = {
          autofocus: true,
          trapElement: null
        };
        const DefaultType$7 = {
          autofocus: "boolean",
          trapElement: "element"
        };
        class FocusTrap extends Config {
          constructor(config) {
            super();
            this._config = this._getConfig(config);
            this._isActive = false;
            this._lastTabNavDirection = null;
          }
          static get Default() {
            return Default$7;
          }
          static get DefaultType() {
            return DefaultType$7;
          }
          static get NAME() {
            return NAME$8;
          }
          activate() {
            if (this._isActive) {
              return;
            }
            if (this._config.autofocus) {
              this._config.trapElement.focus();
            }
            EventHandler.off(document, EVENT_KEY$5);
            EventHandler.on(document, EVENT_FOCUSIN$2, (event) => this._handleFocusin(event));
            EventHandler.on(document, EVENT_KEYDOWN_TAB, (event) => this._handleKeydown(event));
            this._isActive = true;
          }
          deactivate() {
            if (!this._isActive) {
              return;
            }
            this._isActive = false;
            EventHandler.off(document, EVENT_KEY$5);
          }
          _handleFocusin(event) {
            const {
              trapElement
            } = this._config;
            if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {
              return;
            }
            const elements = SelectorEngine.focusableChildren(trapElement);
            if (elements.length === 0) {
              trapElement.focus();
            } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
              elements[elements.length - 1].focus();
            } else {
              elements[0].focus();
            }
          }
          _handleKeydown(event) {
            if (event.key !== TAB_KEY) {
              return;
            }
            this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
          }
        }
        const NAME$7 = "modal";
        const DATA_KEY$4 = "bs.modal";
        const EVENT_KEY$4 = `.${DATA_KEY$4}`;
        const DATA_API_KEY$2 = ".data-api";
        const ESCAPE_KEY$1 = "Escape";
        const EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;
        const EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;
        const EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;
        const EVENT_SHOW$4 = `show${EVENT_KEY$4}`;
        const EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;
        const EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;
        const EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;
        const EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;
        const EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;
        const CLASS_NAME_OPEN = "modal-open";
        const CLASS_NAME_FADE$3 = "fade";
        const CLASS_NAME_SHOW$4 = "show";
        const CLASS_NAME_STATIC = "modal-static";
        const OPEN_SELECTOR$1 = ".modal.show";
        const SELECTOR_DIALOG = ".modal-dialog";
        const SELECTOR_MODAL_BODY = ".modal-body";
        const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
        const Default$6 = {
          backdrop: true,
          focus: true,
          keyboard: true
        };
        const DefaultType$6 = {
          backdrop: "(boolean|string)",
          focus: "boolean",
          keyboard: "boolean"
        };
        class Modal extends BaseComponent {
          constructor(element, config) {
            super(element, config);
            this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
            this._backdrop = this._initializeBackDrop();
            this._focustrap = this._initializeFocusTrap();
            this._isShown = false;
            this._isTransitioning = false;
            this._scrollBar = new ScrollBarHelper();
            this._addEventListeners();
          }
          static get Default() {
            return Default$6;
          }
          static get DefaultType() {
            return DefaultType$6;
          }
          static get NAME() {
            return NAME$7;
          }
          toggle(relatedTarget) {
            return this._isShown ? this.hide() : this.show(relatedTarget);
          }
          show(relatedTarget) {
            if (this._isShown || this._isTransitioning) {
              return;
            }
            const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {
              relatedTarget
            });
            if (showEvent.defaultPrevented) {
              return;
            }
            this._isShown = true;
            this._isTransitioning = true;
            this._scrollBar.hide();
            document.body.classList.add(CLASS_NAME_OPEN);
            this._adjustDialog();
            this._backdrop.show(() => this._showElement(relatedTarget));
          }
          hide() {
            if (!this._isShown || this._isTransitioning) {
              return;
            }
            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);
            if (hideEvent.defaultPrevented) {
              return;
            }
            this._isShown = false;
            this._isTransitioning = true;
            this._focustrap.deactivate();
            this._element.classList.remove(CLASS_NAME_SHOW$4);
            this._queueCallback(() => this._hideModal(), this._element, this._isAnimated());
          }
          dispose() {
            for (const htmlElement of [window, this._dialog]) {
              EventHandler.off(htmlElement, EVENT_KEY$4);
            }
            this._backdrop.dispose();
            this._focustrap.deactivate();
            super.dispose();
          }
          handleUpdate() {
            this._adjustDialog();
          }
          _initializeBackDrop() {
            return new Backdrop({
              isVisible: Boolean(this._config.backdrop),
              isAnimated: this._isAnimated()
            });
          }
          _initializeFocusTrap() {
            return new FocusTrap({
              trapElement: this._element
            });
          }
          _showElement(relatedTarget) {
            if (!document.body.contains(this._element)) {
              document.body.append(this._element);
            }
            this._element.style.display = "block";
            this._element.removeAttribute("aria-hidden");
            this._element.setAttribute("aria-modal", true);
            this._element.setAttribute("role", "dialog");
            this._element.scrollTop = 0;
            const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);
            if (modalBody) {
              modalBody.scrollTop = 0;
            }
            reflow(this._element);
            this._element.classList.add(CLASS_NAME_SHOW$4);
            const transitionComplete = () => {
              if (this._config.focus) {
                this._focustrap.activate();
              }
              this._isTransitioning = false;
              EventHandler.trigger(this._element, EVENT_SHOWN$4, {
                relatedTarget
              });
            };
            this._queueCallback(transitionComplete, this._dialog, this._isAnimated());
          }
          _addEventListeners() {
            EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, (event) => {
              if (event.key !== ESCAPE_KEY$1) {
                return;
              }
              if (this._config.keyboard) {
                event.preventDefault();
                this.hide();
                return;
              }
              this._triggerBackdropTransition();
            });
            EventHandler.on(window, EVENT_RESIZE$1, () => {
              if (this._isShown && !this._isTransitioning) {
                this._adjustDialog();
              }
            });
            EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, (event) => {
              if (event.target !== event.currentTarget) {
                return;
              }
              if (this._config.backdrop === "static") {
                this._triggerBackdropTransition();
                return;
              }
              if (this._config.backdrop) {
                this.hide();
              }
            });
          }
          _hideModal() {
            this._element.style.display = "none";
            this._element.setAttribute("aria-hidden", true);
            this._element.removeAttribute("aria-modal");
            this._element.removeAttribute("role");
            this._isTransitioning = false;
            this._backdrop.hide(() => {
              document.body.classList.remove(CLASS_NAME_OPEN);
              this._resetAdjustments();
              this._scrollBar.reset();
              EventHandler.trigger(this._element, EVENT_HIDDEN$4);
            });
          }
          _isAnimated() {
            return this._element.classList.contains(CLASS_NAME_FADE$3);
          }
          _triggerBackdropTransition() {
            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);
            if (hideEvent.defaultPrevented) {
              return;
            }
            const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
            const initialOverflowY = this._element.style.overflowY;
            if (initialOverflowY === "hidden" || this._element.classList.contains(CLASS_NAME_STATIC)) {
              return;
            }
            if (!isModalOverflowing) {
              this._element.style.overflowY = "hidden";
            }
            this._element.classList.add(CLASS_NAME_STATIC);
            this._queueCallback(() => {
              this._element.classList.remove(CLASS_NAME_STATIC);
              this._queueCallback(() => {
                this._element.style.overflowY = initialOverflowY;
              }, this._dialog);
            }, this._dialog);
            this._element.focus();
          }
          _adjustDialog() {
            const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
            const scrollbarWidth = this._scrollBar.getWidth();
            const isBodyOverflowing = scrollbarWidth > 0;
            if (isBodyOverflowing && !isModalOverflowing) {
              const property = isRTL() ? "paddingLeft" : "paddingRight";
              this._element.style[property] = `${scrollbarWidth}px`;
            }
            if (!isBodyOverflowing && isModalOverflowing) {
              const property = isRTL() ? "paddingRight" : "paddingLeft";
              this._element.style[property] = `${scrollbarWidth}px`;
            }
          }
          _resetAdjustments() {
            this._element.style.paddingLeft = "";
            this._element.style.paddingRight = "";
          }
          static jQueryInterface(config, relatedTarget) {
            return this.each(function() {
              const data = Modal.getOrCreateInstance(this, config);
              if (typeof config !== "string") {
                return;
              }
              if (typeof data[config] === "undefined") {
                throw new TypeError(`No method named "${config}"`);
              }
              data[config](relatedTarget);
            });
          }
        }
        EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function(event) {
          const target = getElementFromSelector(this);
          if (["A", "AREA"].includes(this.tagName)) {
            event.preventDefault();
          }
          EventHandler.one(target, EVENT_SHOW$4, (showEvent) => {
            if (showEvent.defaultPrevented) {
              return;
            }
            EventHandler.one(target, EVENT_HIDDEN$4, () => {
              if (isVisible(this)) {
                this.focus();
              }
            });
          });
          const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);
          if (alreadyOpen) {
            Modal.getInstance(alreadyOpen).hide();
          }
          const data = Modal.getOrCreateInstance(target);
          data.toggle(this);
        });
        enableDismissTrigger(Modal);
        defineJQueryPlugin(Modal);
        const NAME$6 = "offcanvas";
        const DATA_KEY$3 = "bs.offcanvas";
        const EVENT_KEY$3 = `.${DATA_KEY$3}`;
        const DATA_API_KEY$1 = ".data-api";
        const EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;
        const ESCAPE_KEY = "Escape";
        const CLASS_NAME_SHOW$3 = "show";
        const CLASS_NAME_SHOWING$1 = "showing";
        const CLASS_NAME_HIDING = "hiding";
        const CLASS_NAME_BACKDROP = "offcanvas-backdrop";
        const OPEN_SELECTOR = ".offcanvas.show";
        const EVENT_SHOW$3 = `show${EVENT_KEY$3}`;
        const EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;
        const EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;
        const EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;
        const EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;
        const EVENT_RESIZE = `resize${EVENT_KEY$3}`;
        const EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;
        const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;
        const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
        const Default$5 = {
          backdrop: true,
          keyboard: true,
          scroll: false
        };
        const DefaultType$5 = {
          backdrop: "(boolean|string)",
          keyboard: "boolean",
          scroll: "boolean"
        };
        class Offcanvas extends BaseComponent {
          constructor(element, config) {
            super(element, config);
            this._isShown = false;
            this._backdrop = this._initializeBackDrop();
            this._focustrap = this._initializeFocusTrap();
            this._addEventListeners();
          }
          static get Default() {
            return Default$5;
          }
          static get DefaultType() {
            return DefaultType$5;
          }
          static get NAME() {
            return NAME$6;
          }
          toggle(relatedTarget) {
            return this._isShown ? this.hide() : this.show(relatedTarget);
          }
          show(relatedTarget) {
            if (this._isShown) {
              return;
            }
            const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
              relatedTarget
            });
            if (showEvent.defaultPrevented) {
              return;
            }
            this._isShown = true;
            this._backdrop.show();
            if (!this._config.scroll) {
              new ScrollBarHelper().hide();
            }
            this._element.setAttribute("aria-modal", true);
            this._element.setAttribute("role", "dialog");
            this._element.classList.add(CLASS_NAME_SHOWING$1);
            const completeCallBack = () => {
              if (!this._config.scroll || this._config.backdrop) {
                this._focustrap.activate();
              }
              this._element.classList.add(CLASS_NAME_SHOW$3);
              this._element.classList.remove(CLASS_NAME_SHOWING$1);
              EventHandler.trigger(this._element, EVENT_SHOWN$3, {
                relatedTarget
              });
            };
            this._queueCallback(completeCallBack, this._element, true);
          }
          hide() {
            if (!this._isShown) {
              return;
            }
            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);
            if (hideEvent.defaultPrevented) {
              return;
            }
            this._focustrap.deactivate();
            this._element.blur();
            this._isShown = false;
            this._element.classList.add(CLASS_NAME_HIDING);
            this._backdrop.hide();
            const completeCallback = () => {
              this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);
              this._element.removeAttribute("aria-modal");
              this._element.removeAttribute("role");
              if (!this._config.scroll) {
                new ScrollBarHelper().reset();
              }
              EventHandler.trigger(this._element, EVENT_HIDDEN$3);
            };
            this._queueCallback(completeCallback, this._element, true);
          }
          dispose() {
            this._backdrop.dispose();
            this._focustrap.deactivate();
            super.dispose();
          }
          _initializeBackDrop() {
            const clickCallback = () => {
              if (this._config.backdrop === "static") {
                EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
                return;
              }
              this.hide();
            };
            const isVisible2 = Boolean(this._config.backdrop);
            return new Backdrop({
              className: CLASS_NAME_BACKDROP,
              isVisible: isVisible2,
              isAnimated: true,
              rootElement: this._element.parentNode,
              clickCallback: isVisible2 ? clickCallback : null
            });
          }
          _initializeFocusTrap() {
            return new FocusTrap({
              trapElement: this._element
            });
          }
          _addEventListeners() {
            EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, (event) => {
              if (event.key !== ESCAPE_KEY) {
                return;
              }
              if (!this._config.keyboard) {
                EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
                return;
              }
              this.hide();
            });
          }
          static jQueryInterface(config) {
            return this.each(function() {
              const data = Offcanvas.getOrCreateInstance(this, config);
              if (typeof config !== "string") {
                return;
              }
              if (data[config] === void 0 || config.startsWith("_") || config === "constructor") {
                throw new TypeError(`No method named "${config}"`);
              }
              data[config](this);
            });
          }
        }
        EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function(event) {
          const target = getElementFromSelector(this);
          if (["A", "AREA"].includes(this.tagName)) {
            event.preventDefault();
          }
          if (isDisabled(this)) {
            return;
          }
          EventHandler.one(target, EVENT_HIDDEN$3, () => {
            if (isVisible(this)) {
              this.focus();
            }
          });
          const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);
          if (alreadyOpen && alreadyOpen !== target) {
            Offcanvas.getInstance(alreadyOpen).hide();
          }
          const data = Offcanvas.getOrCreateInstance(target);
          data.toggle(this);
        });
        EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {
          for (const selector of SelectorEngine.find(OPEN_SELECTOR)) {
            Offcanvas.getOrCreateInstance(selector).show();
          }
        });
        EventHandler.on(window, EVENT_RESIZE, () => {
          for (const element of SelectorEngine.find("[aria-modal][class*=show][class*=offcanvas-]")) {
            if (getComputedStyle(element).position !== "fixed") {
              Offcanvas.getOrCreateInstance(element).hide();
            }
          }
        });
        enableDismissTrigger(Offcanvas);
        defineJQueryPlugin(Offcanvas);
        const uriAttributes = /* @__PURE__ */ new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]);
        const ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
        const SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;
        const DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;
        const allowedAttribute = (attribute, allowedAttributeList) => {
          const attributeName = attribute.nodeName.toLowerCase();
          if (allowedAttributeList.includes(attributeName)) {
            if (uriAttributes.has(attributeName)) {
              return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue) || DATA_URL_PATTERN.test(attribute.nodeValue));
            }
            return true;
          }
          return allowedAttributeList.filter((attributeRegex) => attributeRegex instanceof RegExp).some((regex) => regex.test(attributeName));
        };
        const DefaultAllowlist = {
          "*": ["class", "dir", "id", "lang", "role", ARIA_ATTRIBUTE_PATTERN],
          a: ["target", "href", "title", "rel"],
          area: [],
          b: [],
          br: [],
          col: [],
          code: [],
          div: [],
          em: [],
          hr: [],
          h1: [],
          h2: [],
          h3: [],
          h4: [],
          h5: [],
          h6: [],
          i: [],
          img: ["src", "srcset", "alt", "title", "width", "height"],
          li: [],
          ol: [],
          p: [],
          pre: [],
          s: [],
          small: [],
          span: [],
          sub: [],
          sup: [],
          strong: [],
          u: [],
          ul: []
        };
        function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {
          if (!unsafeHtml.length) {
            return unsafeHtml;
          }
          if (sanitizeFunction && typeof sanitizeFunction === "function") {
            return sanitizeFunction(unsafeHtml);
          }
          const domParser = new window.DOMParser();
          const createdDocument = domParser.parseFromString(unsafeHtml, "text/html");
          const elements = [].concat(...createdDocument.body.querySelectorAll("*"));
          for (const element of elements) {
            const elementName = element.nodeName.toLowerCase();
            if (!Object.keys(allowList).includes(elementName)) {
              element.remove();
              continue;
            }
            const attributeList = [].concat(...element.attributes);
            const allowedAttributes = [].concat(allowList["*"] || [], allowList[elementName] || []);
            for (const attribute of attributeList) {
              if (!allowedAttribute(attribute, allowedAttributes)) {
                element.removeAttribute(attribute.nodeName);
              }
            }
          }
          return createdDocument.body.innerHTML;
        }
        const NAME$5 = "TemplateFactory";
        const Default$4 = {
          allowList: DefaultAllowlist,
          content: {},
          extraClass: "",
          html: false,
          sanitize: true,
          sanitizeFn: null,
          template: "<div></div>"
        };
        const DefaultType$4 = {
          allowList: "object",
          content: "object",
          extraClass: "(string|function)",
          html: "boolean",
          sanitize: "boolean",
          sanitizeFn: "(null|function)",
          template: "string"
        };
        const DefaultContentType = {
          entry: "(string|element|function|null)",
          selector: "(string|element)"
        };
        class TemplateFactory extends Config {
          constructor(config) {
            super();
            this._config = this._getConfig(config);
          }
          static get Default() {
            return Default$4;
          }
          static get DefaultType() {
            return DefaultType$4;
          }
          static get NAME() {
            return NAME$5;
          }
          getContent() {
            return Object.values(this._config.content).map((config) => this._resolvePossibleFunction(config)).filter(Boolean);
          }
          hasContent() {
            return this.getContent().length > 0;
          }
          changeContent(content) {
            this._checkContent(content);
            this._config.content = {
              ...this._config.content,
              ...content
            };
            return this;
          }
          toHtml() {
            const templateWrapper = document.createElement("div");
            templateWrapper.innerHTML = this._maybeSanitize(this._config.template);
            for (const [selector, text] of Object.entries(this._config.content)) {
              this._setContent(templateWrapper, text, selector);
            }
            const template = templateWrapper.children[0];
            const extraClass = this._resolvePossibleFunction(this._config.extraClass);
            if (extraClass) {
              template.classList.add(...extraClass.split(" "));
            }
            return template;
          }
          _typeCheckConfig(config) {
            super._typeCheckConfig(config);
            this._checkContent(config.content);
          }
          _checkContent(arg) {
            for (const [selector, content] of Object.entries(arg)) {
              super._typeCheckConfig({
                selector,
                entry: content
              }, DefaultContentType);
            }
          }
          _setContent(template, content, selector) {
            const templateElement = SelectorEngine.findOne(selector, template);
            if (!templateElement) {
              return;
            }
            content = this._resolvePossibleFunction(content);
            if (!content) {
              templateElement.remove();
              return;
            }
            if (isElement(content)) {
              this._putElementInTemplate(getElement(content), templateElement);
              return;
            }
            if (this._config.html) {
              templateElement.innerHTML = this._maybeSanitize(content);
              return;
            }
            templateElement.textContent = content;
          }
          _maybeSanitize(arg) {
            return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;
          }
          _resolvePossibleFunction(arg) {
            return typeof arg === "function" ? arg(this) : arg;
          }
          _putElementInTemplate(element, templateElement) {
            if (this._config.html) {
              templateElement.innerHTML = "";
              templateElement.append(element);
              return;
            }
            templateElement.textContent = element.textContent;
          }
        }
        const NAME$4 = "tooltip";
        const DISALLOWED_ATTRIBUTES = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]);
        const CLASS_NAME_FADE$2 = "fade";
        const CLASS_NAME_MODAL = "modal";
        const CLASS_NAME_SHOW$2 = "show";
        const SELECTOR_TOOLTIP_INNER = ".tooltip-inner";
        const SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;
        const EVENT_MODAL_HIDE = "hide.bs.modal";
        const TRIGGER_HOVER = "hover";
        const TRIGGER_FOCUS = "focus";
        const TRIGGER_CLICK = "click";
        const TRIGGER_MANUAL = "manual";
        const EVENT_HIDE$2 = "hide";
        const EVENT_HIDDEN$2 = "hidden";
        const EVENT_SHOW$2 = "show";
        const EVENT_SHOWN$2 = "shown";
        const EVENT_INSERTED = "inserted";
        const EVENT_CLICK$1 = "click";
        const EVENT_FOCUSIN$1 = "focusin";
        const EVENT_FOCUSOUT$1 = "focusout";
        const EVENT_MOUSEENTER = "mouseenter";
        const EVENT_MOUSELEAVE = "mouseleave";
        const AttachmentMap = {
          AUTO: "auto",
          TOP: "top",
          RIGHT: isRTL() ? "left" : "right",
          BOTTOM: "bottom",
          LEFT: isRTL() ? "right" : "left"
        };
        const Default$3 = {
          allowList: DefaultAllowlist,
          animation: true,
          boundary: "clippingParents",
          container: false,
          customClass: "",
          delay: 0,
          fallbackPlacements: ["top", "right", "bottom", "left"],
          html: false,
          offset: [0, 0],
          placement: "top",
          popperConfig: null,
          sanitize: true,
          sanitizeFn: null,
          selector: false,
          template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
          title: "",
          trigger: "hover focus"
        };
        const DefaultType$3 = {
          allowList: "object",
          animation: "boolean",
          boundary: "(string|element)",
          container: "(string|element|boolean)",
          customClass: "(string|function)",
          delay: "(number|object)",
          fallbackPlacements: "array",
          html: "boolean",
          offset: "(array|string|function)",
          placement: "(string|function)",
          popperConfig: "(null|object|function)",
          sanitize: "boolean",
          sanitizeFn: "(null|function)",
          selector: "(string|boolean)",
          template: "string",
          title: "(string|element|function)",
          trigger: "string"
        };
        class Tooltip extends BaseComponent {
          constructor(element, config) {
            if (typeof Popper__namespace === "undefined") {
              throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
            }
            super(element, config);
            this._isEnabled = true;
            this._timeout = 0;
            this._isHovered = false;
            this._activeTrigger = {};
            this._popper = null;
            this._templateFactory = null;
            this._newContent = null;
            this.tip = null;
            this._setListeners();
          }
          static get Default() {
            return Default$3;
          }
          static get DefaultType() {
            return DefaultType$3;
          }
          static get NAME() {
            return NAME$4;
          }
          enable() {
            this._isEnabled = true;
          }
          disable() {
            this._isEnabled = false;
          }
          toggleEnabled() {
            this._isEnabled = !this._isEnabled;
          }
          toggle(event) {
            if (!this._isEnabled) {
              return;
            }
            if (event) {
              const context = this._initializeOnDelegatedTarget(event);
              context._activeTrigger.click = !context._activeTrigger.click;
              if (context._isWithActiveTrigger()) {
                context._enter();
              } else {
                context._leave();
              }
              return;
            }
            if (this._isShown()) {
              this._leave();
              return;
            }
            this._enter();
          }
          dispose() {
            clearTimeout(this._timeout);
            EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
            if (this.tip) {
              this.tip.remove();
            }
            this._disposePopper();
            super.dispose();
          }
          show() {
            if (this._element.style.display === "none") {
              throw new Error("Please use show on visible elements");
            }
            if (!(this._isWithContent() && this._isEnabled)) {
              return;
            }
            const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));
            const shadowRoot = findShadowRoot(this._element);
            const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);
            if (showEvent.defaultPrevented || !isInTheDom) {
              return;
            }
            if (this.tip) {
              this.tip.remove();
              this.tip = null;
            }
            const tip = this._getTipElement();
            this._element.setAttribute("aria-describedby", tip.getAttribute("id"));
            const {
              container
            } = this._config;
            if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
              container.append(tip);
              EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));
            }
            if (this._popper) {
              this._popper.update();
            } else {
              this._popper = this._createPopper(tip);
            }
            tip.classList.add(CLASS_NAME_SHOW$2);
            if ("ontouchstart" in document.documentElement) {
              for (const element of [].concat(...document.body.children)) {
                EventHandler.on(element, "mouseover", noop);
              }
            }
            const complete = () => {
              const previousHoverState = this._isHovered;
              this._isHovered = false;
              EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));
              if (previousHoverState) {
                this._leave();
              }
            };
            this._queueCallback(complete, this.tip, this._isAnimated());
          }
          hide() {
            if (!this._isShown()) {
              return;
            }
            const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));
            if (hideEvent.defaultPrevented) {
              return;
            }
            const tip = this._getTipElement();
            tip.classList.remove(CLASS_NAME_SHOW$2);
            if ("ontouchstart" in document.documentElement) {
              for (const element of [].concat(...document.body.children)) {
                EventHandler.off(element, "mouseover", noop);
              }
            }
            this._activeTrigger[TRIGGER_CLICK] = false;
            this._activeTrigger[TRIGGER_FOCUS] = false;
            this._activeTrigger[TRIGGER_HOVER] = false;
            this._isHovered = false;
            const complete = () => {
              if (this._isWithActiveTrigger()) {
                return;
              }
              if (!this._isHovered) {
                tip.remove();
              }
              this._element.removeAttribute("aria-describedby");
              EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));
              this._disposePopper();
            };
            this._queueCallback(complete, this.tip, this._isAnimated());
          }
          update() {
            if (this._popper) {
              this._popper.update();
            }
          }
          _isWithContent() {
            return Boolean(this._getTitle());
          }
          _getTipElement() {
            if (!this.tip) {
              this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());
            }
            return this.tip;
          }
          _createTipElement(content) {
            const tip = this._getTemplateFactory(content).toHtml();
            if (!tip) {
              return null;
            }
            tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);
            tip.classList.add(`bs-${this.constructor.NAME}-auto`);
            const tipId = getUID(this.constructor.NAME).toString();
            tip.setAttribute("id", tipId);
            if (this._isAnimated()) {
              tip.classList.add(CLASS_NAME_FADE$2);
            }
            return tip;
          }
          setContent(content) {
            this._newContent = content;
            if (this._isShown()) {
              this._disposePopper();
              this.show();
            }
          }
          _getTemplateFactory(content) {
            if (this._templateFactory) {
              this._templateFactory.changeContent(content);
            } else {
              this._templateFactory = new TemplateFactory({
                ...this._config,
                content,
                extraClass: this._resolvePossibleFunction(this._config.customClass)
              });
            }
            return this._templateFactory;
          }
          _getContentForTemplate() {
            return {
              [SELECTOR_TOOLTIP_INNER]: this._getTitle()
            };
          }
          _getTitle() {
            return this._resolvePossibleFunction(this._config.title) || this._config.originalTitle;
          }
          _initializeOnDelegatedTarget(event) {
            return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
          }
          _isAnimated() {
            return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);
          }
          _isShown() {
            return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);
          }
          _createPopper(tip) {
            const placement = typeof this._config.placement === "function" ? this._config.placement.call(this, tip, this._element) : this._config.placement;
            const attachment = AttachmentMap[placement.toUpperCase()];
            return Popper__namespace.createPopper(this._element, tip, this._getPopperConfig(attachment));
          }
          _getOffset() {
            const {
              offset
            } = this._config;
            if (typeof offset === "string") {
              return offset.split(",").map((value) => Number.parseInt(value, 10));
            }
            if (typeof offset === "function") {
              return (popperData) => offset(popperData, this._element);
            }
            return offset;
          }
          _resolvePossibleFunction(arg) {
            return typeof arg === "function" ? arg.call(this._element) : arg;
          }
          _getPopperConfig(attachment) {
            const defaultBsPopperConfig = {
              placement: attachment,
              modifiers: [{
                name: "flip",
                options: {
                  fallbackPlacements: this._config.fallbackPlacements
                }
              }, {
                name: "offset",
                options: {
                  offset: this._getOffset()
                }
              }, {
                name: "preventOverflow",
                options: {
                  boundary: this._config.boundary
                }
              }, {
                name: "arrow",
                options: {
                  element: `.${this.constructor.NAME}-arrow`
                }
              }, {
                name: "preSetPlacement",
                enabled: true,
                phase: "beforeMain",
                fn: (data) => {
                  this._getTipElement().setAttribute("data-popper-placement", data.state.placement);
                }
              }]
            };
            return {
              ...defaultBsPopperConfig,
              ...typeof this._config.popperConfig === "function" ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig
            };
          }
          _setListeners() {
            const triggers = this._config.trigger.split(" ");
            for (const trigger of triggers) {
              if (trigger === "click") {
                EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, (event) => this.toggle(event));
              } else if (trigger !== TRIGGER_MANUAL) {
                const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);
                const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);
                EventHandler.on(this._element, eventIn, this._config.selector, (event) => {
                  const context = this._initializeOnDelegatedTarget(event);
                  context._activeTrigger[event.type === "focusin" ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
                  context._enter();
                });
                EventHandler.on(this._element, eventOut, this._config.selector, (event) => {
                  const context = this._initializeOnDelegatedTarget(event);
                  context._activeTrigger[event.type === "focusout" ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
                  context._leave();
                });
              }
            }
            this._hideModalHandler = () => {
              if (this._element) {
                this.hide();
              }
            };
            EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
            if (this._config.selector) {
              this._config = {
                ...this._config,
                trigger: "manual",
                selector: ""
              };
            } else {
              this._fixTitle();
            }
          }
          _fixTitle() {
            const title = this._config.originalTitle;
            if (!title) {
              return;
            }
            if (!this._element.getAttribute("aria-label") && !this._element.textContent.trim()) {
              this._element.setAttribute("aria-label", title);
            }
            this._element.removeAttribute("title");
          }
          _enter() {
            if (this._isShown() || this._isHovered) {
              this._isHovered = true;
              return;
            }
            this._isHovered = true;
            this._setTimeout(() => {
              if (this._isHovered) {
                this.show();
              }
            }, this._config.delay.show);
          }
          _leave() {
            if (this._isWithActiveTrigger()) {
              return;
            }
            this._isHovered = false;
            this._setTimeout(() => {
              if (!this._isHovered) {
                this.hide();
              }
            }, this._config.delay.hide);
          }
          _setTimeout(handler, timeout) {
            clearTimeout(this._timeout);
            this._timeout = setTimeout(handler, timeout);
          }
          _isWithActiveTrigger() {
            return Object.values(this._activeTrigger).includes(true);
          }
          _getConfig(config) {
            const dataAttributes = Manipulator.getDataAttributes(this._element);
            for (const dataAttribute of Object.keys(dataAttributes)) {
              if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {
                delete dataAttributes[dataAttribute];
              }
            }
            config = {
              ...dataAttributes,
              ...typeof config === "object" && config ? config : {}
            };
            config = this._mergeConfigObj(config);
            config = this._configAfterMerge(config);
            this._typeCheckConfig(config);
            return config;
          }
          _configAfterMerge(config) {
            config.container = config.container === false ? document.body : getElement(config.container);
            if (typeof config.delay === "number") {
              config.delay = {
                show: config.delay,
                hide: config.delay
              };
            }
            config.originalTitle = this._element.getAttribute("title") || "";
            if (typeof config.title === "number") {
              config.title = config.title.toString();
            }
            if (typeof config.content === "number") {
              config.content = config.content.toString();
            }
            return config;
          }
          _getDelegateConfig() {
            const config = {};
            for (const key in this._config) {
              if (this.constructor.Default[key] !== this._config[key]) {
                config[key] = this._config[key];
              }
            }
            return config;
          }
          _disposePopper() {
            if (this._popper) {
              this._popper.destroy();
              this._popper = null;
            }
          }
          static jQueryInterface(config) {
            return this.each(function() {
              const data = Tooltip.getOrCreateInstance(this, config);
              if (typeof config !== "string") {
                return;
              }
              if (typeof data[config] === "undefined") {
                throw new TypeError(`No method named "${config}"`);
              }
              data[config]();
            });
          }
        }
        defineJQueryPlugin(Tooltip);
        const NAME$3 = "popover";
        const SELECTOR_TITLE = ".popover-header";
        const SELECTOR_CONTENT = ".popover-body";
        const Default$2 = {
          ...Tooltip.Default,
          content: "",
          offset: [0, 8],
          placement: "right",
          template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
          trigger: "click"
        };
        const DefaultType$2 = {
          ...Tooltip.DefaultType,
          content: "(null|string|element|function)"
        };
        class Popover extends Tooltip {
          static get Default() {
            return Default$2;
          }
          static get DefaultType() {
            return DefaultType$2;
          }
          static get NAME() {
            return NAME$3;
          }
          _isWithContent() {
            return this._getTitle() || this._getContent();
          }
          _getContentForTemplate() {
            return {
              [SELECTOR_TITLE]: this._getTitle(),
              [SELECTOR_CONTENT]: this._getContent()
            };
          }
          _getContent() {
            return this._resolvePossibleFunction(this._config.content);
          }
          static jQueryInterface(config) {
            return this.each(function() {
              const data = Popover.getOrCreateInstance(this, config);
              if (typeof config !== "string") {
                return;
              }
              if (typeof data[config] === "undefined") {
                throw new TypeError(`No method named "${config}"`);
              }
              data[config]();
            });
          }
        }
        defineJQueryPlugin(Popover);
        const NAME$2 = "scrollspy";
        const DATA_KEY$2 = "bs.scrollspy";
        const EVENT_KEY$2 = `.${DATA_KEY$2}`;
        const DATA_API_KEY = ".data-api";
        const EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;
        const EVENT_CLICK = `click${EVENT_KEY$2}`;
        const EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;
        const CLASS_NAME_DROPDOWN_ITEM = "dropdown-item";
        const CLASS_NAME_ACTIVE$1 = "active";
        const SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
        const SELECTOR_TARGET_LINKS = "[href]";
        const SELECTOR_NAV_LIST_GROUP = ".nav, .list-group";
        const SELECTOR_NAV_LINKS = ".nav-link";
        const SELECTOR_NAV_ITEMS = ".nav-item";
        const SELECTOR_LIST_ITEMS = ".list-group-item";
        const SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;
        const SELECTOR_DROPDOWN = ".dropdown";
        const SELECTOR_DROPDOWN_TOGGLE$1 = ".dropdown-toggle";
        const Default$1 = {
          offset: null,
          rootMargin: "0px 0px -25%",
          smoothScroll: false,
          target: null
        };
        const DefaultType$1 = {
          offset: "(number|null)",
          rootMargin: "string",
          smoothScroll: "boolean",
          target: "element"
        };
        class ScrollSpy extends BaseComponent {
          constructor(element, config) {
            super(element, config);
            this._targetLinks = /* @__PURE__ */ new Map();
            this._observableSections = /* @__PURE__ */ new Map();
            this._rootElement = getComputedStyle(this._element).overflowY === "visible" ? null : this._element;
            this._activeTarget = null;
            this._observer = null;
            this._previousScrollData = {
              visibleEntryTop: 0,
              parentScrollTop: 0
            };
            this.refresh();
          }
          static get Default() {
            return Default$1;
          }
          static get DefaultType() {
            return DefaultType$1;
          }
          static get NAME() {
            return NAME$2;
          }
          refresh() {
            this._initializeTargetsAndObservables();
            this._maybeEnableSmoothScroll();
            if (this._observer) {
              this._observer.disconnect();
            } else {
              this._observer = this._getNewObserver();
            }
            for (const section of this._observableSections.values()) {
              this._observer.observe(section);
            }
          }
          dispose() {
            this._observer.disconnect();
            super.dispose();
          }
          _configAfterMerge(config) {
            config.target = getElement(config.target) || document.body;
            return config;
          }
          _maybeEnableSmoothScroll() {
            if (!this._config.smoothScroll) {
              return;
            }
            EventHandler.off(this._config.target, EVENT_CLICK);
            EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, (event) => {
              const observableSection = this._observableSections.get(event.target.hash);
              if (observableSection) {
                event.preventDefault();
                const root = this._rootElement || window;
                const height = observableSection.offsetTop - this._element.offsetTop;
                if (root.scrollTo) {
                  root.scrollTo({
                    top: height,
                    behavior: "smooth"
                  });
                  return;
                }
                root.scrollTop = height;
              }
            });
          }
          _getNewObserver() {
            const options = {
              root: this._rootElement,
              threshold: [0.1, 0.5, 1],
              rootMargin: this._getRootMargin()
            };
            return new IntersectionObserver((entries) => this._observerCallback(entries), options);
          }
          _observerCallback(entries) {
            const targetElement = (entry) => this._targetLinks.get(`#${entry.target.id}`);
            const activate = (entry) => {
              this._previousScrollData.visibleEntryTop = entry.target.offsetTop;
              this._process(targetElement(entry));
            };
            const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;
            const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;
            this._previousScrollData.parentScrollTop = parentScrollTop;
            for (const entry of entries) {
              if (!entry.isIntersecting) {
                this._activeTarget = null;
                this._clearActiveClass(targetElement(entry));
                continue;
              }
              const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;
              if (userScrollsDown && entryIsLowerThanPrevious) {
                activate(entry);
                if (!parentScrollTop) {
                  return;
                }
                continue;
              }
              if (!userScrollsDown && !entryIsLowerThanPrevious) {
                activate(entry);
              }
            }
          }
          _getRootMargin() {
            return this._config.offset ? `${this._config.offset}px 0px -30%` : this._config.rootMargin;
          }
          _initializeTargetsAndObservables() {
            this._targetLinks = /* @__PURE__ */ new Map();
            this._observableSections = /* @__PURE__ */ new Map();
            const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);
            for (const anchor of targetLinks) {
              if (!anchor.hash || isDisabled(anchor)) {
                continue;
              }
              const observableSection = SelectorEngine.findOne(anchor.hash, this._element);
              if (isVisible(observableSection)) {
                this._targetLinks.set(anchor.hash, anchor);
                this._observableSections.set(anchor.hash, observableSection);
              }
            }
          }
          _process(target) {
            if (this._activeTarget === target) {
              return;
            }
            this._clearActiveClass(this._config.target);
            this._activeTarget = target;
            target.classList.add(CLASS_NAME_ACTIVE$1);
            this._activateParents(target);
            EventHandler.trigger(this._element, EVENT_ACTIVATE, {
              relatedTarget: target
            });
          }
          _activateParents(target) {
            if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
              SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);
              return;
            }
            for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)) {
              for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)) {
                item.classList.add(CLASS_NAME_ACTIVE$1);
              }
            }
          }
          _clearActiveClass(parent) {
            parent.classList.remove(CLASS_NAME_ACTIVE$1);
            const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);
            for (const node of activeNodes) {
              node.classList.remove(CLASS_NAME_ACTIVE$1);
            }
          }
          static jQueryInterface(config) {
            return this.each(function() {
              const data = ScrollSpy.getOrCreateInstance(this, config);
              if (typeof config !== "string") {
                return;
              }
              if (data[config] === void 0 || config.startsWith("_") || config === "constructor") {
                throw new TypeError(`No method named "${config}"`);
              }
              data[config]();
            });
          }
        }
        EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {
          for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)) {
            ScrollSpy.getOrCreateInstance(spy);
          }
        });
        defineJQueryPlugin(ScrollSpy);
        const NAME$1 = "tab";
        const DATA_KEY$1 = "bs.tab";
        const EVENT_KEY$1 = `.${DATA_KEY$1}`;
        const EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;
        const EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;
        const EVENT_SHOW$1 = `show${EVENT_KEY$1}`;
        const EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;
        const EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;
        const EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;
        const EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;
        const ARROW_LEFT_KEY = "ArrowLeft";
        const ARROW_RIGHT_KEY = "ArrowRight";
        const ARROW_UP_KEY = "ArrowUp";
        const ARROW_DOWN_KEY = "ArrowDown";
        const CLASS_NAME_ACTIVE = "active";
        const CLASS_NAME_FADE$1 = "fade";
        const CLASS_NAME_SHOW$1 = "show";
        const CLASS_DROPDOWN = "dropdown";
        const SELECTOR_DROPDOWN_TOGGLE = ".dropdown-toggle";
        const SELECTOR_DROPDOWN_MENU = ".dropdown-menu";
        const SELECTOR_DROPDOWN_ITEM = ".dropdown-item";
        const NOT_SELECTOR_DROPDOWN_TOGGLE = ":not(.dropdown-toggle)";
        const SELECTOR_TAB_PANEL = '.list-group, .nav, [role="tablist"]';
        const SELECTOR_OUTER = ".nav-item, .list-group-item";
        const SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role="tab"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;
        const SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]';
        const SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;
        const SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle="tab"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="pill"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="list"]`;
        class Tab extends BaseComponent {
          constructor(element) {
            super(element);
            this._parent = this._element.closest(SELECTOR_TAB_PANEL);
            if (!this._parent) {
              return;
            }
            this._setInitialAttributes(this._parent, this._getChildren());
            EventHandler.on(this._element, EVENT_KEYDOWN, (event) => this._keydown(event));
          }
          static get NAME() {
            return NAME$1;
          }
          show() {
            const innerElem = this._element;
            if (this._elemIsActive(innerElem)) {
              return;
            }
            const active = this._getActiveElem();
            const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {
              relatedTarget: innerElem
            }) : null;
            const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {
              relatedTarget: active
            });
            if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {
              return;
            }
            this._deactivate(active, innerElem);
            this._activate(innerElem, active);
          }
          _activate(element, relatedElem) {
            if (!element) {
              return;
            }
            element.classList.add(CLASS_NAME_ACTIVE);
            this._activate(getElementFromSelector(element));
            const complete = () => {
              if (element.getAttribute("role") !== "tab") {
                element.classList.add(CLASS_NAME_SHOW$1);
                return;
              }
              element.focus();
              element.removeAttribute("tabindex");
              element.setAttribute("aria-selected", true);
              this._toggleDropDown(element, true);
              EventHandler.trigger(element, EVENT_SHOWN$1, {
                relatedTarget: relatedElem
              });
            };
            this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
          }
          _deactivate(element, relatedElem) {
            if (!element) {
              return;
            }
            element.classList.remove(CLASS_NAME_ACTIVE);
            element.blur();
            this._deactivate(getElementFromSelector(element));
            const complete = () => {
              if (element.getAttribute("role") !== "tab") {
                element.classList.remove(CLASS_NAME_SHOW$1);
                return;
              }
              element.setAttribute("aria-selected", false);
              element.setAttribute("tabindex", "-1");
              this._toggleDropDown(element, false);
              EventHandler.trigger(element, EVENT_HIDDEN$1, {
                relatedTarget: relatedElem
              });
            };
            this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
          }
          _keydown(event) {
            if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY].includes(event.key)) {
              return;
            }
            event.stopPropagation();
            event.preventDefault();
            const isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);
            const nextActiveElement = getNextActiveElement(this._getChildren().filter((element) => !isDisabled(element)), event.target, isNext, true);
            if (nextActiveElement) {
              Tab.getOrCreateInstance(nextActiveElement).show();
            }
          }
          _getChildren() {
            return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);
          }
          _getActiveElem() {
            return this._getChildren().find((child) => this._elemIsActive(child)) || null;
          }
          _setInitialAttributes(parent, children) {
            this._setAttributeIfNotExists(parent, "role", "tablist");
            for (const child of children) {
              this._setInitialAttributesOnChild(child);
            }
          }
          _setInitialAttributesOnChild(child) {
            child = this._getInnerElement(child);
            const isActive = this._elemIsActive(child);
            const outerElem = this._getOuterElement(child);
            child.setAttribute("aria-selected", isActive);
            if (outerElem !== child) {
              this._setAttributeIfNotExists(outerElem, "role", "presentation");
            }
            if (!isActive) {
              child.setAttribute("tabindex", "-1");
            }
            this._setAttributeIfNotExists(child, "role", "tab");
            this._setInitialAttributesOnTargetPanel(child);
          }
          _setInitialAttributesOnTargetPanel(child) {
            const target = getElementFromSelector(child);
            if (!target) {
              return;
            }
            this._setAttributeIfNotExists(target, "role", "tabpanel");
            if (child.id) {
              this._setAttributeIfNotExists(target, "aria-labelledby", `#${child.id}`);
            }
          }
          _toggleDropDown(element, open2) {
            const outerElem = this._getOuterElement(element);
            if (!outerElem.classList.contains(CLASS_DROPDOWN)) {
              return;
            }
            const toggle = (selector, className) => {
              const element2 = SelectorEngine.findOne(selector, outerElem);
              if (element2) {
                element2.classList.toggle(className, open2);
              }
            };
            toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);
            toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);
            toggle(SELECTOR_DROPDOWN_ITEM, CLASS_NAME_ACTIVE);
            outerElem.setAttribute("aria-expanded", open2);
          }
          _setAttributeIfNotExists(element, attribute, value) {
            if (!element.hasAttribute(attribute)) {
              element.setAttribute(attribute, value);
            }
          }
          _elemIsActive(elem) {
            return elem.classList.contains(CLASS_NAME_ACTIVE);
          }
          _getInnerElement(elem) {
            return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);
          }
          _getOuterElement(elem) {
            return elem.closest(SELECTOR_OUTER) || elem;
          }
          static jQueryInterface(config) {
            return this.each(function() {
              const data = Tab.getOrCreateInstance(this);
              if (typeof config !== "string") {
                return;
              }
              if (data[config] === void 0 || config.startsWith("_") || config === "constructor") {
                throw new TypeError(`No method named "${config}"`);
              }
              data[config]();
            });
          }
        }
        EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function(event) {
          if (["A", "AREA"].includes(this.tagName)) {
            event.preventDefault();
          }
          if (isDisabled(this)) {
            return;
          }
          Tab.getOrCreateInstance(this).show();
        });
        EventHandler.on(window, EVENT_LOAD_DATA_API, () => {
          for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)) {
            Tab.getOrCreateInstance(element);
          }
        });
        defineJQueryPlugin(Tab);
        const NAME = "toast";
        const DATA_KEY = "bs.toast";
        const EVENT_KEY = `.${DATA_KEY}`;
        const EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;
        const EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;
        const EVENT_FOCUSIN = `focusin${EVENT_KEY}`;
        const EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;
        const EVENT_HIDE = `hide${EVENT_KEY}`;
        const EVENT_HIDDEN = `hidden${EVENT_KEY}`;
        const EVENT_SHOW = `show${EVENT_KEY}`;
        const EVENT_SHOWN = `shown${EVENT_KEY}`;
        const CLASS_NAME_FADE = "fade";
        const CLASS_NAME_HIDE = "hide";
        const CLASS_NAME_SHOW = "show";
        const CLASS_NAME_SHOWING = "showing";
        const DefaultType = {
          animation: "boolean",
          autohide: "boolean",
          delay: "number"
        };
        const Default = {
          animation: true,
          autohide: true,
          delay: 5e3
        };
        class Toast extends BaseComponent {
          constructor(element, config) {
            super(element, config);
            this._timeout = null;
            this._hasMouseInteraction = false;
            this._hasKeyboardInteraction = false;
            this._setListeners();
          }
          static get Default() {
            return Default;
          }
          static get DefaultType() {
            return DefaultType;
          }
          static get NAME() {
            return NAME;
          }
          show() {
            const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);
            if (showEvent.defaultPrevented) {
              return;
            }
            this._clearTimeout();
            if (this._config.animation) {
              this._element.classList.add(CLASS_NAME_FADE);
            }
            const complete = () => {
              this._element.classList.remove(CLASS_NAME_SHOWING);
              EventHandler.trigger(this._element, EVENT_SHOWN);
              this._maybeScheduleHide();
            };
            this._element.classList.remove(CLASS_NAME_HIDE);
            reflow(this._element);
            this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);
            this._queueCallback(complete, this._element, this._config.animation);
          }
          hide() {
            if (!this.isShown()) {
              return;
            }
            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);
            if (hideEvent.defaultPrevented) {
              return;
            }
            const complete = () => {
              this._element.classList.add(CLASS_NAME_HIDE);
              this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);
              EventHandler.trigger(this._element, EVENT_HIDDEN);
            };
            this._element.classList.add(CLASS_NAME_SHOWING);
            this._queueCallback(complete, this._element, this._config.animation);
          }
          dispose() {
            this._clearTimeout();
            if (this.isShown()) {
              this._element.classList.remove(CLASS_NAME_SHOW);
            }
            super.dispose();
          }
          isShown() {
            return this._element.classList.contains(CLASS_NAME_SHOW);
          }
          _maybeScheduleHide() {
            if (!this._config.autohide) {
              return;
            }
            if (this._hasMouseInteraction || this._hasKeyboardInteraction) {
              return;
            }
            this._timeout = setTimeout(() => {
              this.hide();
            }, this._config.delay);
          }
          _onInteraction(event, isInteracting) {
            switch (event.type) {
              case "mouseover":
              case "mouseout":
                this._hasMouseInteraction = isInteracting;
                break;
              case "focusin":
              case "focusout":
                this._hasKeyboardInteraction = isInteracting;
                break;
            }
            if (isInteracting) {
              this._clearTimeout();
              return;
            }
            const nextElement = event.relatedTarget;
            if (this._element === nextElement || this._element.contains(nextElement)) {
              return;
            }
            this._maybeScheduleHide();
          }
          _setListeners() {
            EventHandler.on(this._element, EVENT_MOUSEOVER, (event) => this._onInteraction(event, true));
            EventHandler.on(this._element, EVENT_MOUSEOUT, (event) => this._onInteraction(event, false));
            EventHandler.on(this._element, EVENT_FOCUSIN, (event) => this._onInteraction(event, true));
            EventHandler.on(this._element, EVENT_FOCUSOUT, (event) => this._onInteraction(event, false));
          }
          _clearTimeout() {
            clearTimeout(this._timeout);
            this._timeout = null;
          }
          static jQueryInterface(config) {
            return this.each(function() {
              const data = Toast.getOrCreateInstance(this, config);
              if (typeof config === "string") {
                if (typeof data[config] === "undefined") {
                  throw new TypeError(`No method named "${config}"`);
                }
                data[config](this);
              }
            });
          }
        }
        enableDismissTrigger(Toast);
        defineJQueryPlugin(Toast);
        const index_umd = {
          Alert,
          Button,
          Carousel,
          Collapse,
          Dropdown,
          Modal,
          Offcanvas,
          Popover,
          ScrollSpy,
          Tab,
          Toast,
          Tooltip
        };
        return index_umd;
      });
    }
  });

  // node_modules/bootstrap-table/dist/bootstrap-table.min.js
  var require_bootstrap_table_min = __commonJS({
    "node_modules/bootstrap-table/dist/bootstrap-table.min.js"(exports, module) {
      !function(t, e) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = e(require_jquery()) : "function" == typeof define && define.amd ? define(["jquery"], e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).BootstrapTable = e(t.jQuery);
      }(exports, function(t) {
        "use strict";
        function e(t2) {
          return t2 && "object" == typeof t2 && "default" in t2 ? t2 : { default: t2 };
        }
        var i = e(t);
        function n(t2) {
          return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
            return typeof t3;
          } : function(t3) {
            return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
          }, n(t2);
        }
        function o(t2, e2) {
          if (!(t2 instanceof e2))
            throw new TypeError("Cannot call a class as a function");
        }
        function a(t2, e2) {
          for (var i2 = 0; i2 < e2.length; i2++) {
            var n2 = e2[i2];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
          }
        }
        function r(t2, e2, i2) {
          return e2 && a(t2.prototype, e2), i2 && a(t2, i2), Object.defineProperty(t2, "prototype", { writable: false }), t2;
        }
        function s(t2, e2) {
          return function(t3) {
            if (Array.isArray(t3))
              return t3;
          }(t2) || function(t3, e3) {
            var i2 = null == t3 ? null : "undefined" != typeof Symbol && t3[Symbol.iterator] || t3["@@iterator"];
            if (null == i2)
              return;
            var n2, o2, a2 = [], r2 = true, s2 = false;
            try {
              for (i2 = i2.call(t3); !(r2 = (n2 = i2.next()).done) && (a2.push(n2.value), !e3 || a2.length !== e3); r2 = true)
                ;
            } catch (t4) {
              s2 = true, o2 = t4;
            } finally {
              try {
                r2 || null == i2.return || i2.return();
              } finally {
                if (s2)
                  throw o2;
              }
            }
            return a2;
          }(t2, e2) || c(t2, e2) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function l(t2) {
          return function(t3) {
            if (Array.isArray(t3))
              return h(t3);
          }(t2) || function(t3) {
            if ("undefined" != typeof Symbol && null != t3[Symbol.iterator] || null != t3["@@iterator"])
              return Array.from(t3);
          }(t2) || c(t2) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function c(t2, e2) {
          if (t2) {
            if ("string" == typeof t2)
              return h(t2, e2);
            var i2 = Object.prototype.toString.call(t2).slice(8, -1);
            return "Object" === i2 && t2.constructor && (i2 = t2.constructor.name), "Map" === i2 || "Set" === i2 ? Array.from(t2) : "Arguments" === i2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i2) ? h(t2, e2) : void 0;
          }
        }
        function h(t2, e2) {
          (null == e2 || e2 > t2.length) && (e2 = t2.length);
          for (var i2 = 0, n2 = new Array(e2); i2 < e2; i2++)
            n2[i2] = t2[i2];
          return n2;
        }
        function u(t2, e2) {
          var i2 = "undefined" != typeof Symbol && t2[Symbol.iterator] || t2["@@iterator"];
          if (!i2) {
            if (Array.isArray(t2) || (i2 = c(t2)) || e2 && t2 && "number" == typeof t2.length) {
              i2 && (t2 = i2);
              var n2 = 0, o2 = function() {
              };
              return { s: o2, n: function() {
                return n2 >= t2.length ? { done: true } : { done: false, value: t2[n2++] };
              }, e: function(t3) {
                throw t3;
              }, f: o2 };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var a2, r2 = true, s2 = false;
          return { s: function() {
            i2 = i2.call(t2);
          }, n: function() {
            var t3 = i2.next();
            return r2 = t3.done, t3;
          }, e: function(t3) {
            s2 = true, a2 = t3;
          }, f: function() {
            try {
              r2 || null == i2.return || i2.return();
            } finally {
              if (s2)
                throw a2;
            }
          } };
        }
        var d = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, f = function(t2) {
          return t2 && t2.Math == Math && t2;
        }, p = f("object" == typeof globalThis && globalThis) || f("object" == typeof window && window) || f("object" == typeof self && self) || f("object" == typeof d && d) || function() {
          return this;
        }() || Function("return this")(), g = {}, v = function(t2) {
          try {
            return !!t2();
          } catch (t3) {
            return true;
          }
        }, b = !v(function() {
          return 7 != Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1];
        }), m = !v(function() {
          var t2 = function() {
          }.bind();
          return "function" != typeof t2 || t2.hasOwnProperty("prototype");
        }), y = m, w = Function.prototype.call, S = y ? w.bind(w) : function() {
          return w.apply(w, arguments);
        }, x = {}, k = {}.propertyIsEnumerable, O = Object.getOwnPropertyDescriptor, C = O && !k.call({ 1: 2 }, 1);
        x.f = C ? function(t2) {
          var e2 = O(this, t2);
          return !!e2 && e2.enumerable;
        } : k;
        var T, P, I = function(t2, e2) {
          return { enumerable: !(1 & t2), configurable: !(2 & t2), writable: !(4 & t2), value: e2 };
        }, A = m, $2 = Function.prototype, R = $2.bind, E = $2.call, j = A && R.bind(E, E), F = A ? function(t2) {
          return t2 && j(t2);
        } : function(t2) {
          return t2 && function() {
            return E.apply(t2, arguments);
          };
        }, _ = F, N = _({}.toString), D = _("".slice), V = function(t2) {
          return D(N(t2), 8, -1);
        }, B = F, L3 = v, H = V, M = p.Object, U = B("".split), z = L3(function() {
          return !M("z").propertyIsEnumerable(0);
        }) ? function(t2) {
          return "String" == H(t2) ? U(t2, "") : M(t2);
        } : M, q = p.TypeError, W = function(t2) {
          if (null == t2)
            throw q("Can't call method on " + t2);
          return t2;
        }, G = z, K = W, Y = function(t2) {
          return G(K(t2));
        }, J = function(t2) {
          return "function" == typeof t2;
        }, X = J, Q = function(t2) {
          return "object" == typeof t2 ? null !== t2 : X(t2);
        }, Z = p, tt = J, et = function(t2) {
          return tt(t2) ? t2 : void 0;
        }, it = function(t2, e2) {
          return arguments.length < 2 ? et(Z[t2]) : Z[t2] && Z[t2][e2];
        }, nt = F({}.isPrototypeOf), ot = it("navigator", "userAgent") || "", at = p, rt = ot, st = at.process, lt = at.Deno, ct = st && st.versions || lt && lt.version, ht = ct && ct.v8;
        ht && (P = (T = ht.split("."))[0] > 0 && T[0] < 4 ? 1 : +(T[0] + T[1])), !P && rt && (!(T = rt.match(/Edge\/(\d+)/)) || T[1] >= 74) && (T = rt.match(/Chrome\/(\d+)/)) && (P = +T[1]);
        var ut = P, dt = ut, ft = v, pt = !!Object.getOwnPropertySymbols && !ft(function() {
          var t2 = Symbol();
          return !String(t2) || !(Object(t2) instanceof Symbol) || !Symbol.sham && dt && dt < 41;
        }), gt = pt && !Symbol.sham && "symbol" == typeof Symbol.iterator, vt = it, bt = J, mt = nt, yt = gt, wt = p.Object, St = yt ? function(t2) {
          return "symbol" == typeof t2;
        } : function(t2) {
          var e2 = vt("Symbol");
          return bt(e2) && mt(e2.prototype, wt(t2));
        }, xt = p.String, kt = function(t2) {
          try {
            return xt(t2);
          } catch (t3) {
            return "Object";
          }
        }, Ot = J, Ct = kt, Tt = p.TypeError, Pt = function(t2) {
          if (Ot(t2))
            return t2;
          throw Tt(Ct(t2) + " is not a function");
        }, It = Pt, At = function(t2, e2) {
          var i2 = t2[e2];
          return null == i2 ? void 0 : It(i2);
        }, $t = S, Rt = J, Et = Q, jt = p.TypeError, Ft = { exports: {} }, _t = p, Nt = Object.defineProperty, Dt = function(t2, e2) {
          try {
            Nt(_t, t2, { value: e2, configurable: true, writable: true });
          } catch (i2) {
            _t[t2] = e2;
          }
          return e2;
        }, Vt = Dt, Bt = "__core-js_shared__", Lt = p[Bt] || Vt(Bt, {}), Ht = Lt;
        (Ft.exports = function(t2, e2) {
          return Ht[t2] || (Ht[t2] = void 0 !== e2 ? e2 : {});
        })("versions", []).push({ version: "3.22.5", mode: "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.22.5/LICENSE", source: "https://github.com/zloirock/core-js" });
        var Mt = W, Ut = p.Object, zt = function(t2) {
          return Ut(Mt(t2));
        }, qt = zt, Wt = F({}.hasOwnProperty), Gt = Object.hasOwn || function(t2, e2) {
          return Wt(qt(t2), e2);
        }, Kt = F, Yt = 0, Jt = Math.random(), Xt = Kt(1 .toString), Qt = function(t2) {
          return "Symbol(" + (void 0 === t2 ? "" : t2) + ")_" + Xt(++Yt + Jt, 36);
        }, Zt = p, te = Ft.exports, ee = Gt, ie = Qt, ne = pt, oe = gt, ae = te("wks"), re = Zt.Symbol, se = re && re.for, le = oe ? re : re && re.withoutSetter || ie, ce = function(t2) {
          if (!ee(ae, t2) || !ne && "string" != typeof ae[t2]) {
            var e2 = "Symbol." + t2;
            ne && ee(re, t2) ? ae[t2] = re[t2] : ae[t2] = oe && se ? se(e2) : le(e2);
          }
          return ae[t2];
        }, he = S, ue = Q, de = St, fe = At, pe = function(t2, e2) {
          var i2, n2;
          if ("string" === e2 && Rt(i2 = t2.toString) && !Et(n2 = $t(i2, t2)))
            return n2;
          if (Rt(i2 = t2.valueOf) && !Et(n2 = $t(i2, t2)))
            return n2;
          if ("string" !== e2 && Rt(i2 = t2.toString) && !Et(n2 = $t(i2, t2)))
            return n2;
          throw jt("Can't convert object to primitive value");
        }, ge = ce, ve = p.TypeError, be = ge("toPrimitive"), me = function(t2, e2) {
          if (!ue(t2) || de(t2))
            return t2;
          var i2, n2 = fe(t2, be);
          if (n2) {
            if (void 0 === e2 && (e2 = "default"), i2 = he(n2, t2, e2), !ue(i2) || de(i2))
              return i2;
            throw ve("Can't convert object to primitive value");
          }
          return void 0 === e2 && (e2 = "number"), pe(t2, e2);
        }, ye = me, we = St, Se = function(t2) {
          var e2 = ye(t2, "string");
          return we(e2) ? e2 : e2 + "";
        }, xe = Q, ke = p.document, Oe = xe(ke) && xe(ke.createElement), Ce = function(t2) {
          return Oe ? ke.createElement(t2) : {};
        }, Te = Ce, Pe = !b && !v(function() {
          return 7 != Object.defineProperty(Te("div"), "a", { get: function() {
            return 7;
          } }).a;
        }), Ie = b, Ae = S, $e = x, Re = I, Ee = Y, je = Se, Fe = Gt, _e = Pe, Ne = Object.getOwnPropertyDescriptor;
        g.f = Ie ? Ne : function(t2, e2) {
          if (t2 = Ee(t2), e2 = je(e2), _e)
            try {
              return Ne(t2, e2);
            } catch (t3) {
            }
          if (Fe(t2, e2))
            return Re(!Ae($e.f, t2, e2), t2[e2]);
        };
        var De = {}, Ve = b && v(function() {
          return 42 != Object.defineProperty(function() {
          }, "prototype", { value: 42, writable: false }).prototype;
        }), Be = p, Le = Q, He = Be.String, Me = Be.TypeError, Ue = function(t2) {
          if (Le(t2))
            return t2;
          throw Me(He(t2) + " is not an object");
        }, ze = b, qe = Pe, We = Ve, Ge = Ue, Ke = Se, Ye = p.TypeError, Je = Object.defineProperty, Xe = Object.getOwnPropertyDescriptor, Qe = "enumerable", Ze = "configurable", ti = "writable";
        De.f = ze ? We ? function(t2, e2, i2) {
          if (Ge(t2), e2 = Ke(e2), Ge(i2), "function" == typeof t2 && "prototype" === e2 && "value" in i2 && ti in i2 && !i2.writable) {
            var n2 = Xe(t2, e2);
            n2 && n2.writable && (t2[e2] = i2.value, i2 = { configurable: Ze in i2 ? i2.configurable : n2.configurable, enumerable: Qe in i2 ? i2.enumerable : n2.enumerable, writable: false });
          }
          return Je(t2, e2, i2);
        } : Je : function(t2, e2, i2) {
          if (Ge(t2), e2 = Ke(e2), Ge(i2), qe)
            try {
              return Je(t2, e2, i2);
            } catch (t3) {
            }
          if ("get" in i2 || "set" in i2)
            throw Ye("Accessors not supported");
          return "value" in i2 && (t2[e2] = i2.value), t2;
        };
        var ei = De, ii = I, ni = b ? function(t2, e2, i2) {
          return ei.f(t2, e2, ii(1, i2));
        } : function(t2, e2, i2) {
          return t2[e2] = i2, t2;
        }, oi = { exports: {} }, ai = b, ri = Gt, si = Function.prototype, li = ai && Object.getOwnPropertyDescriptor, ci = ri(si, "name"), hi = { EXISTS: ci, PROPER: ci && "something" === function() {
        }.name, CONFIGURABLE: ci && (!ai || ai && li(si, "name").configurable) }, ui = J, di = Lt, fi = F(Function.toString);
        ui(di.inspectSource) || (di.inspectSource = function(t2) {
          return fi(t2);
        });
        var pi, gi, vi, bi = di.inspectSource, mi = J, yi = bi, wi = p.WeakMap, Si = mi(wi) && /native code/.test(yi(wi)), xi = Ft.exports, ki = Qt, Oi = xi("keys"), Ci = function(t2) {
          return Oi[t2] || (Oi[t2] = ki(t2));
        }, Ti = {}, Pi = Si, Ii = p, Ai = F, $i = Q, Ri = ni, Ei = Gt, ji = Lt, Fi = Ci, _i = Ti, Ni = "Object already initialized", Di = Ii.TypeError, Vi = Ii.WeakMap;
        if (Pi || ji.state) {
          var Bi = ji.state || (ji.state = new Vi()), Li = Ai(Bi.get), Hi = Ai(Bi.has), Mi = Ai(Bi.set);
          pi = function(t2, e2) {
            if (Hi(Bi, t2))
              throw new Di(Ni);
            return e2.facade = t2, Mi(Bi, t2, e2), e2;
          }, gi = function(t2) {
            return Li(Bi, t2) || {};
          }, vi = function(t2) {
            return Hi(Bi, t2);
          };
        } else {
          var Ui = Fi("state");
          _i[Ui] = true, pi = function(t2, e2) {
            if (Ei(t2, Ui))
              throw new Di(Ni);
            return e2.facade = t2, Ri(t2, Ui, e2), e2;
          }, gi = function(t2) {
            return Ei(t2, Ui) ? t2[Ui] : {};
          }, vi = function(t2) {
            return Ei(t2, Ui);
          };
        }
        var zi = { set: pi, get: gi, has: vi, enforce: function(t2) {
          return vi(t2) ? gi(t2) : pi(t2, {});
        }, getterFor: function(t2) {
          return function(e2) {
            var i2;
            if (!$i(e2) || (i2 = gi(e2)).type !== t2)
              throw Di("Incompatible receiver, " + t2 + " required");
            return i2;
          };
        } }, qi = v, Wi = J, Gi = Gt, Ki = b, Yi = hi.CONFIGURABLE, Ji = bi, Xi = zi.enforce, Qi = zi.get, Zi = Object.defineProperty, tn = Ki && !qi(function() {
          return 8 !== Zi(function() {
          }, "length", { value: 8 }).length;
        }), en = String(String).split("String"), nn = oi.exports = function(t2, e2, i2) {
          if ("Symbol(" === String(e2).slice(0, 7) && (e2 = "[" + String(e2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), i2 && i2.getter && (e2 = "get " + e2), i2 && i2.setter && (e2 = "set " + e2), (!Gi(t2, "name") || Yi && t2.name !== e2) && Zi(t2, "name", { value: e2, configurable: true }), tn && i2 && Gi(i2, "arity") && t2.length !== i2.arity && Zi(t2, "length", { value: i2.arity }), i2 && Gi(i2, "constructor") && i2.constructor) {
            if (Ki)
              try {
                Zi(t2, "prototype", { writable: false });
              } catch (t3) {
              }
          } else
            t2.prototype = void 0;
          var n2 = Xi(t2);
          return Gi(n2, "source") || (n2.source = en.join("string" == typeof e2 ? e2 : "")), t2;
        };
        Function.prototype.toString = nn(function() {
          return Wi(this) && Qi(this).source || Ji(this);
        }, "toString");
        var on = p, an = J, rn = ni, sn = oi.exports, ln = Dt, cn = function(t2, e2, i2, n2) {
          var o2 = !!n2 && !!n2.unsafe, a2 = !!n2 && !!n2.enumerable, r2 = !!n2 && !!n2.noTargetGet, s2 = n2 && void 0 !== n2.name ? n2.name : e2;
          return an(i2) && sn(i2, s2, n2), t2 === on ? (a2 ? t2[e2] = i2 : ln(e2, i2), t2) : (o2 ? !r2 && t2[e2] && (a2 = true) : delete t2[e2], a2 ? t2[e2] = i2 : rn(t2, e2, i2), t2);
        }, hn = {}, un = Math.ceil, dn = Math.floor, fn = function(t2) {
          var e2 = +t2;
          return e2 != e2 || 0 === e2 ? 0 : (e2 > 0 ? dn : un)(e2);
        }, pn = fn, gn = Math.max, vn = Math.min, bn = function(t2, e2) {
          var i2 = pn(t2);
          return i2 < 0 ? gn(i2 + e2, 0) : vn(i2, e2);
        }, mn = fn, yn = Math.min, wn = function(t2) {
          return t2 > 0 ? yn(mn(t2), 9007199254740991) : 0;
        }, Sn = wn, xn = function(t2) {
          return Sn(t2.length);
        }, kn = Y, On = bn, Cn = xn, Tn = function(t2) {
          return function(e2, i2, n2) {
            var o2, a2 = kn(e2), r2 = Cn(a2), s2 = On(n2, r2);
            if (t2 && i2 != i2) {
              for (; r2 > s2; )
                if ((o2 = a2[s2++]) != o2)
                  return true;
            } else
              for (; r2 > s2; s2++)
                if ((t2 || s2 in a2) && a2[s2] === i2)
                  return t2 || s2 || 0;
            return !t2 && -1;
          };
        }, Pn = { includes: Tn(true), indexOf: Tn(false) }, In = Gt, An = Y, $n = Pn.indexOf, Rn = Ti, En = F([].push), jn = function(t2, e2) {
          var i2, n2 = An(t2), o2 = 0, a2 = [];
          for (i2 in n2)
            !In(Rn, i2) && In(n2, i2) && En(a2, i2);
          for (; e2.length > o2; )
            In(n2, i2 = e2[o2++]) && (~$n(a2, i2) || En(a2, i2));
          return a2;
        }, Fn = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], _n = jn, Nn = Fn.concat("length", "prototype");
        hn.f = Object.getOwnPropertyNames || function(t2) {
          return _n(t2, Nn);
        };
        var Dn = {};
        Dn.f = Object.getOwnPropertySymbols;
        var Vn = it, Bn = hn, Ln = Dn, Hn = Ue, Mn = F([].concat), Un = Vn("Reflect", "ownKeys") || function(t2) {
          var e2 = Bn.f(Hn(t2)), i2 = Ln.f;
          return i2 ? Mn(e2, i2(t2)) : e2;
        }, zn = Gt, qn = Un, Wn = g, Gn = De, Kn = v, Yn = J, Jn = /#|\.prototype\./, Xn = function(t2, e2) {
          var i2 = Zn[Qn(t2)];
          return i2 == eo || i2 != to && (Yn(e2) ? Kn(e2) : !!e2);
        }, Qn = Xn.normalize = function(t2) {
          return String(t2).replace(Jn, ".").toLowerCase();
        }, Zn = Xn.data = {}, to = Xn.NATIVE = "N", eo = Xn.POLYFILL = "P", io = Xn, no = p, oo = g.f, ao = ni, ro = cn, so = Dt, lo = function(t2, e2, i2) {
          for (var n2 = qn(e2), o2 = Gn.f, a2 = Wn.f, r2 = 0; r2 < n2.length; r2++) {
            var s2 = n2[r2];
            zn(t2, s2) || i2 && zn(i2, s2) || o2(t2, s2, a2(e2, s2));
          }
        }, co = io, ho = function(t2, e2) {
          var i2, n2, o2, a2, r2, s2 = t2.target, l2 = t2.global, c2 = t2.stat;
          if (i2 = l2 ? no : c2 ? no[s2] || so(s2, {}) : (no[s2] || {}).prototype)
            for (n2 in e2) {
              if (a2 = e2[n2], o2 = t2.noTargetGet ? (r2 = oo(i2, n2)) && r2.value : i2[n2], !co(l2 ? n2 : s2 + (c2 ? "." : "#") + n2, t2.forced) && void 0 !== o2) {
                if (typeof a2 == typeof o2)
                  continue;
                lo(a2, o2);
              }
              (t2.sham || o2 && o2.sham) && ao(a2, "sham", true), ro(i2, n2, a2, t2);
            }
        }, uo = jn, fo = Fn, po = Object.keys || function(t2) {
          return uo(t2, fo);
        }, go = b, vo = F, bo = S, mo = v, yo = po, wo = Dn, So = x, xo = zt, ko = z, Oo = Object.assign, Co = Object.defineProperty, To = vo([].concat), Po = !Oo || mo(function() {
          if (go && 1 !== Oo({ b: 1 }, Oo(Co({}, "a", { enumerable: true, get: function() {
            Co(this, "b", { value: 3, enumerable: false });
          } }), { b: 2 })).b)
            return true;
          var t2 = {}, e2 = {}, i2 = Symbol(), n2 = "abcdefghijklmnopqrst";
          return t2[i2] = 7, n2.split("").forEach(function(t3) {
            e2[t3] = t3;
          }), 7 != Oo({}, t2)[i2] || yo(Oo({}, e2)).join("") != n2;
        }) ? function(t2, e2) {
          for (var i2 = xo(t2), n2 = arguments.length, o2 = 1, a2 = wo.f, r2 = So.f; n2 > o2; )
            for (var s2, l2 = ko(arguments[o2++]), c2 = a2 ? To(yo(l2), a2(l2)) : yo(l2), h2 = c2.length, u2 = 0; h2 > u2; )
              s2 = c2[u2++], go && !bo(r2, l2, s2) || (i2[s2] = l2[s2]);
          return i2;
        } : Oo, Io = Po;
        ho({ target: "Object", stat: true, arity: 2, forced: Object.assign !== Io }, { assign: Io });
        var Ao = {};
        Ao[ce("toStringTag")] = "z";
        var $o = "[object z]" === String(Ao), Ro = p, Eo = $o, jo = J, Fo = V, _o = ce("toStringTag"), No = Ro.Object, Do = "Arguments" == Fo(function() {
          return arguments;
        }()), Vo = Eo ? Fo : function(t2) {
          var e2, i2, n2;
          return void 0 === t2 ? "Undefined" : null === t2 ? "Null" : "string" == typeof (i2 = function(t3, e3) {
            try {
              return t3[e3];
            } catch (t4) {
            }
          }(e2 = No(t2), _o)) ? i2 : Do ? Fo(e2) : "Object" == (n2 = Fo(e2)) && jo(e2.callee) ? "Arguments" : n2;
        }, Bo = Vo, Lo = p.String, Ho = function(t2) {
          if ("Symbol" === Bo(t2))
            throw TypeError("Cannot convert a Symbol value to a string");
          return Lo(t2);
        }, Mo = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF", Uo = W, zo = Ho, qo = F("".replace), Wo = "[	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]", Go = RegExp("^" + Wo + Wo + "*"), Ko = RegExp(Wo + Wo + "*$"), Yo = function(t2) {
          return function(e2) {
            var i2 = zo(Uo(e2));
            return 1 & t2 && (i2 = qo(i2, Go, "")), 2 & t2 && (i2 = qo(i2, Ko, "")), i2;
          };
        }, Jo = { start: Yo(1), end: Yo(2), trim: Yo(3) }, Xo = hi.PROPER, Qo = v, Zo = Mo, ta = Jo.trim;
        ho({ target: "String", proto: true, forced: function(t2) {
          return Qo(function() {
            return !!Zo[t2]() || "\u200B\x85\u180E" !== "\u200B\x85\u180E"[t2]() || Xo && Zo[t2].name !== t2;
          });
        }("trim") }, { trim: function() {
          return ta(this);
        } });
        var ea = v, ia = function(t2, e2) {
          var i2 = [][t2];
          return !!i2 && ea(function() {
            i2.call(null, e2 || function() {
              return 1;
            }, 1);
          });
        }, na = ho, oa = z, aa = Y, ra = ia, sa = F([].join), la = oa != Object, ca = ra("join", ",");
        na({ target: "Array", proto: true, forced: la || !ca }, { join: function(t2) {
          return sa(aa(this), void 0 === t2 ? "," : t2);
        } });
        var ha = Ue, ua = function() {
          var t2 = ha(this), e2 = "";
          return t2.hasIndices && (e2 += "d"), t2.global && (e2 += "g"), t2.ignoreCase && (e2 += "i"), t2.multiline && (e2 += "m"), t2.dotAll && (e2 += "s"), t2.unicode && (e2 += "u"), t2.sticky && (e2 += "y"), e2;
        }, da = v, fa = p.RegExp, pa = da(function() {
          var t2 = fa("a", "y");
          return t2.lastIndex = 2, null != t2.exec("abcd");
        }), ga = pa || da(function() {
          return !fa("a", "y").sticky;
        }), va = { BROKEN_CARET: pa || da(function() {
          var t2 = fa("^r", "gy");
          return t2.lastIndex = 2, null != t2.exec("str");
        }), MISSED_STICKY: ga, UNSUPPORTED_Y: pa }, ba = {}, ma = b, ya = Ve, wa = De, Sa = Ue, xa = Y, ka = po;
        ba.f = ma && !ya ? Object.defineProperties : function(t2, e2) {
          Sa(t2);
          for (var i2, n2 = xa(e2), o2 = ka(e2), a2 = o2.length, r2 = 0; a2 > r2; )
            wa.f(t2, i2 = o2[r2++], n2[i2]);
          return t2;
        };
        var Oa, Ca = it("document", "documentElement"), Ta = Ue, Pa = ba, Ia = Fn, Aa = Ti, $a = Ca, Ra = Ce, Ea = Ci("IE_PROTO"), ja = function() {
        }, Fa = function(t2) {
          return "<script>" + t2 + "<\/script>";
        }, _a = function(t2) {
          t2.write(Fa("")), t2.close();
          var e2 = t2.parentWindow.Object;
          return t2 = null, e2;
        }, Na = function() {
          try {
            Oa = new ActiveXObject("htmlfile");
          } catch (t3) {
          }
          var t2, e2;
          Na = "undefined" != typeof document ? document.domain && Oa ? _a(Oa) : ((e2 = Ra("iframe")).style.display = "none", $a.appendChild(e2), e2.src = String("javascript:"), (t2 = e2.contentWindow.document).open(), t2.write(Fa("document.F=Object")), t2.close(), t2.F) : _a(Oa);
          for (var i2 = Ia.length; i2--; )
            delete Na.prototype[Ia[i2]];
          return Na();
        };
        Aa[Ea] = true;
        var Da = Object.create || function(t2, e2) {
          var i2;
          return null !== t2 ? (ja.prototype = Ta(t2), i2 = new ja(), ja.prototype = null, i2[Ea] = t2) : i2 = Na(), void 0 === e2 ? i2 : Pa.f(i2, e2);
        }, Va = v, Ba = p.RegExp, La = Va(function() {
          var t2 = Ba(".", "s");
          return !(t2.dotAll && t2.exec("\n") && "s" === t2.flags);
        }), Ha = v, Ma = p.RegExp, Ua = Ha(function() {
          var t2 = Ma("(?<a>b)", "g");
          return "b" !== t2.exec("b").groups.a || "bc" !== "b".replace(t2, "$<a>c");
        }), za = S, qa = F, Wa = Ho, Ga = ua, Ka = va, Ya = Ft.exports, Ja = Da, Xa = zi.get, Qa = La, Za = Ua, tr = Ya("native-string-replace", String.prototype.replace), er = RegExp.prototype.exec, ir = er, nr = qa("".charAt), or = qa("".indexOf), ar = qa("".replace), rr = qa("".slice), sr = function() {
          var t2 = /a/, e2 = /b*/g;
          return za(er, t2, "a"), za(er, e2, "a"), 0 !== t2.lastIndex || 0 !== e2.lastIndex;
        }(), lr = Ka.BROKEN_CARET, cr = void 0 !== /()??/.exec("")[1];
        (sr || cr || lr || Qa || Za) && (ir = function(t2) {
          var e2, i2, n2, o2, a2, r2, s2, l2 = this, c2 = Xa(l2), h2 = Wa(t2), u2 = c2.raw;
          if (u2)
            return u2.lastIndex = l2.lastIndex, e2 = za(ir, u2, h2), l2.lastIndex = u2.lastIndex, e2;
          var d2 = c2.groups, f2 = lr && l2.sticky, p2 = za(Ga, l2), g2 = l2.source, v2 = 0, b2 = h2;
          if (f2 && (p2 = ar(p2, "y", ""), -1 === or(p2, "g") && (p2 += "g"), b2 = rr(h2, l2.lastIndex), l2.lastIndex > 0 && (!l2.multiline || l2.multiline && "\n" !== nr(h2, l2.lastIndex - 1)) && (g2 = "(?: " + g2 + ")", b2 = " " + b2, v2++), i2 = new RegExp("^(?:" + g2 + ")", p2)), cr && (i2 = new RegExp("^" + g2 + "$(?!\\s)", p2)), sr && (n2 = l2.lastIndex), o2 = za(er, f2 ? i2 : l2, b2), f2 ? o2 ? (o2.input = rr(o2.input, v2), o2[0] = rr(o2[0], v2), o2.index = l2.lastIndex, l2.lastIndex += o2[0].length) : l2.lastIndex = 0 : sr && o2 && (l2.lastIndex = l2.global ? o2.index + o2[0].length : n2), cr && o2 && o2.length > 1 && za(tr, o2[0], i2, function() {
            for (a2 = 1; a2 < arguments.length - 2; a2++)
              void 0 === arguments[a2] && (o2[a2] = void 0);
          }), o2 && d2)
            for (o2.groups = r2 = Ja(null), a2 = 0; a2 < d2.length; a2++)
              r2[(s2 = d2[a2])[0]] = o2[s2[1]];
          return o2;
        });
        var hr = ir;
        ho({ target: "RegExp", proto: true, forced: /./.exec !== hr }, { exec: hr });
        var ur = m, dr = Function.prototype, fr = dr.apply, pr = dr.call, gr = "object" == typeof Reflect && Reflect.apply || (ur ? pr.bind(fr) : function() {
          return pr.apply(fr, arguments);
        }), vr = F, br = cn, mr = hr, yr = v, wr = ce, Sr = ni, xr = wr("species"), kr = RegExp.prototype, Or = function(t2, e2, i2, n2) {
          var o2 = wr(t2), a2 = !yr(function() {
            var e3 = {};
            return e3[o2] = function() {
              return 7;
            }, 7 != ""[t2](e3);
          }), r2 = a2 && !yr(function() {
            var e3 = false, i3 = /a/;
            return "split" === t2 && ((i3 = {}).constructor = {}, i3.constructor[xr] = function() {
              return i3;
            }, i3.flags = "", i3[o2] = /./[o2]), i3.exec = function() {
              return e3 = true, null;
            }, i3[o2](""), !e3;
          });
          if (!a2 || !r2 || i2) {
            var s2 = vr(/./[o2]), l2 = e2(o2, ""[t2], function(t3, e3, i3, n3, o3) {
              var r3 = vr(t3), l3 = e3.exec;
              return l3 === mr || l3 === kr.exec ? a2 && !o3 ? { done: true, value: s2(e3, i3, n3) } : { done: true, value: r3(i3, e3, n3) } : { done: false };
            });
            br(String.prototype, t2, l2[0]), br(kr, o2, l2[1]);
          }
          n2 && Sr(kr[o2], "sham", true);
        }, Cr = Q, Tr = V, Pr = ce("match"), Ir = function(t2) {
          var e2;
          return Cr(t2) && (void 0 !== (e2 = t2[Pr]) ? !!e2 : "RegExp" == Tr(t2));
        }, Ar = F, $r = v, Rr = J, Er = Vo, jr = bi, Fr = function() {
        }, _r = [], Nr = it("Reflect", "construct"), Dr = /^\s*(?:class|function)\b/, Vr = Ar(Dr.exec), Br = !Dr.exec(Fr), Lr = function(t2) {
          if (!Rr(t2))
            return false;
          try {
            return Nr(Fr, _r, t2), true;
          } catch (t3) {
            return false;
          }
        }, Hr = function(t2) {
          if (!Rr(t2))
            return false;
          switch (Er(t2)) {
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
              return false;
          }
          try {
            return Br || !!Vr(Dr, jr(t2));
          } catch (t3) {
            return true;
          }
        };
        Hr.sham = true;
        var Mr = !Nr || $r(function() {
          var t2;
          return Lr(Lr.call) || !Lr(Object) || !Lr(function() {
            t2 = true;
          }) || t2;
        }) ? Hr : Lr, Ur = Mr, zr = kt, qr = p.TypeError, Wr = Ue, Gr = function(t2) {
          if (Ur(t2))
            return t2;
          throw qr(zr(t2) + " is not a constructor");
        }, Kr = ce("species"), Yr = F, Jr = fn, Xr = Ho, Qr = W, Zr = Yr("".charAt), ts = Yr("".charCodeAt), es = Yr("".slice), is = function(t2) {
          return function(e2, i2) {
            var n2, o2, a2 = Xr(Qr(e2)), r2 = Jr(i2), s2 = a2.length;
            return r2 < 0 || r2 >= s2 ? t2 ? "" : void 0 : (n2 = ts(a2, r2)) < 55296 || n2 > 56319 || r2 + 1 === s2 || (o2 = ts(a2, r2 + 1)) < 56320 || o2 > 57343 ? t2 ? Zr(a2, r2) : n2 : t2 ? es(a2, r2, r2 + 2) : o2 - 56320 + (n2 - 55296 << 10) + 65536;
          };
        }, ns = { codeAt: is(false), charAt: is(true) }.charAt, os = function(t2, e2, i2) {
          return e2 + (i2 ? ns(t2, e2).length : 1);
        }, as = Se, rs = De, ss = I, ls = function(t2, e2, i2) {
          var n2 = as(e2);
          n2 in t2 ? rs.f(t2, n2, ss(0, i2)) : t2[n2] = i2;
        }, cs = bn, hs = xn, us = ls, ds = p.Array, fs = Math.max, ps = function(t2, e2, i2) {
          for (var n2 = hs(t2), o2 = cs(e2, n2), a2 = cs(void 0 === i2 ? n2 : i2, n2), r2 = ds(fs(a2 - o2, 0)), s2 = 0; o2 < a2; o2++, s2++)
            us(r2, s2, t2[o2]);
          return r2.length = s2, r2;
        }, gs = S, vs = Ue, bs = J, ms = V, ys = hr, ws = p.TypeError, Ss = function(t2, e2) {
          var i2 = t2.exec;
          if (bs(i2)) {
            var n2 = gs(i2, t2, e2);
            return null !== n2 && vs(n2), n2;
          }
          if ("RegExp" === ms(t2))
            return gs(ys, t2, e2);
          throw ws("RegExp#exec called on incompatible receiver");
        }, xs = gr, ks = S, Os = F, Cs = Or, Ts = Ir, Ps = Ue, Is = W, As = function(t2, e2) {
          var i2, n2 = Wr(t2).constructor;
          return void 0 === n2 || null == (i2 = Wr(n2)[Kr]) ? e2 : Gr(i2);
        }, $s = os, Rs = wn, Es = Ho, js = At, Fs = ps, _s = Ss, Ns = hr, Ds = v, Vs = va.UNSUPPORTED_Y, Bs = 4294967295, Ls = Math.min, Hs = [].push, Ms = Os(/./.exec), Us = Os(Hs), zs = Os("".slice), qs = !Ds(function() {
          var t2 = /(?:)/, e2 = t2.exec;
          t2.exec = function() {
            return e2.apply(this, arguments);
          };
          var i2 = "ab".split(t2);
          return 2 !== i2.length || "a" !== i2[0] || "b" !== i2[1];
        });
        Cs("split", function(t2, e2, i2) {
          var n2;
          return n2 = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(t3, i3) {
            var n3 = Es(Is(this)), o2 = void 0 === i3 ? Bs : i3 >>> 0;
            if (0 === o2)
              return [];
            if (void 0 === t3)
              return [n3];
            if (!Ts(t3))
              return ks(e2, n3, t3, o2);
            for (var a2, r2, s2, l2 = [], c2 = (t3.ignoreCase ? "i" : "") + (t3.multiline ? "m" : "") + (t3.unicode ? "u" : "") + (t3.sticky ? "y" : ""), h2 = 0, u2 = new RegExp(t3.source, c2 + "g"); (a2 = ks(Ns, u2, n3)) && !((r2 = u2.lastIndex) > h2 && (Us(l2, zs(n3, h2, a2.index)), a2.length > 1 && a2.index < n3.length && xs(Hs, l2, Fs(a2, 1)), s2 = a2[0].length, h2 = r2, l2.length >= o2)); )
              u2.lastIndex === a2.index && u2.lastIndex++;
            return h2 === n3.length ? !s2 && Ms(u2, "") || Us(l2, "") : Us(l2, zs(n3, h2)), l2.length > o2 ? Fs(l2, 0, o2) : l2;
          } : "0".split(void 0, 0).length ? function(t3, i3) {
            return void 0 === t3 && 0 === i3 ? [] : ks(e2, this, t3, i3);
          } : e2, [function(e3, i3) {
            var o2 = Is(this), a2 = null == e3 ? void 0 : js(e3, t2);
            return a2 ? ks(a2, e3, o2, i3) : ks(n2, Es(o2), e3, i3);
          }, function(t3, o2) {
            var a2 = Ps(this), r2 = Es(t3), s2 = i2(n2, a2, r2, o2, n2 !== e2);
            if (s2.done)
              return s2.value;
            var l2 = As(a2, RegExp), c2 = a2.unicode, h2 = (a2.ignoreCase ? "i" : "") + (a2.multiline ? "m" : "") + (a2.unicode ? "u" : "") + (Vs ? "g" : "y"), u2 = new l2(Vs ? "^(?:" + a2.source + ")" : a2, h2), d2 = void 0 === o2 ? Bs : o2 >>> 0;
            if (0 === d2)
              return [];
            if (0 === r2.length)
              return null === _s(u2, r2) ? [r2] : [];
            for (var f2 = 0, p2 = 0, g2 = []; p2 < r2.length; ) {
              u2.lastIndex = Vs ? 0 : p2;
              var v2, b2 = _s(u2, Vs ? zs(r2, p2) : r2);
              if (null === b2 || (v2 = Ls(Rs(u2.lastIndex + (Vs ? p2 : 0)), r2.length)) === f2)
                p2 = $s(r2, p2, c2);
              else {
                if (Us(g2, zs(r2, f2, p2)), g2.length === d2)
                  return g2;
                for (var m2 = 1; m2 <= b2.length - 1; m2++)
                  if (Us(g2, b2[m2]), g2.length === d2)
                    return g2;
                p2 = f2 = v2;
              }
            }
            return Us(g2, zs(r2, f2)), g2;
          }];
        }, !qs, Vs);
        var Ws = b, Gs = F, Ks = po, Ys = Y, Js = Gs(x.f), Xs = Gs([].push), Qs = function(t2) {
          return function(e2) {
            for (var i2, n2 = Ys(e2), o2 = Ks(n2), a2 = o2.length, r2 = 0, s2 = []; a2 > r2; )
              i2 = o2[r2++], Ws && !Js(n2, i2) || Xs(s2, t2 ? [i2, n2[i2]] : n2[i2]);
            return s2;
          };
        }, Zs = { entries: Qs(true), values: Qs(false) }.entries;
        ho({ target: "Object", stat: true }, { entries: function(t2) {
          return Zs(t2);
        } });
        var tl = Da, el = De, il = ce("unscopables"), nl = Array.prototype;
        null == nl[il] && el.f(nl, il, { configurable: true, value: tl(null) });
        var ol = function(t2) {
          nl[il][t2] = true;
        }, al = Pn.includes, rl = ol;
        ho({ target: "Array", proto: true, forced: v(function() {
          return !Array(1).includes();
        }) }, { includes: function(t2) {
          return al(this, t2, arguments.length > 1 ? arguments[1] : void 0);
        } }), rl("includes");
        var sl = V, ll = Array.isArray || function(t2) {
          return "Array" == sl(t2);
        }, cl = p, hl = ll, ul = Mr, dl = Q, fl = ce("species"), pl = cl.Array, gl = function(t2) {
          var e2;
          return hl(t2) && (e2 = t2.constructor, (ul(e2) && (e2 === pl || hl(e2.prototype)) || dl(e2) && null === (e2 = e2[fl])) && (e2 = void 0)), void 0 === e2 ? pl : e2;
        }, vl = function(t2, e2) {
          return new (gl(t2))(0 === e2 ? 0 : e2);
        }, bl = v, ml = ut, yl = ce("species"), wl = function(t2) {
          return ml >= 51 || !bl(function() {
            var e2 = [];
            return (e2.constructor = {})[yl] = function() {
              return { foo: 1 };
            }, 1 !== e2[t2](Boolean).foo;
          });
        }, Sl = ho, xl = p, kl = v, Ol = ll, Cl = Q, Tl = zt, Pl = xn, Il = ls, Al = vl, $l = wl, Rl = ut, El = ce("isConcatSpreadable"), jl = 9007199254740991, Fl = "Maximum allowed index exceeded", _l = xl.TypeError, Nl = Rl >= 51 || !kl(function() {
          var t2 = [];
          return t2[El] = false, t2.concat()[0] !== t2;
        }), Dl = $l("concat"), Vl = function(t2) {
          if (!Cl(t2))
            return false;
          var e2 = t2[El];
          return void 0 !== e2 ? !!e2 : Ol(t2);
        };
        Sl({ target: "Array", proto: true, arity: 1, forced: !Nl || !Dl }, { concat: function(t2) {
          var e2, i2, n2, o2, a2, r2 = Tl(this), s2 = Al(r2, 0), l2 = 0;
          for (e2 = -1, n2 = arguments.length; e2 < n2; e2++)
            if (Vl(a2 = -1 === e2 ? r2 : arguments[e2])) {
              if (l2 + (o2 = Pl(a2)) > jl)
                throw _l(Fl);
              for (i2 = 0; i2 < o2; i2++, l2++)
                i2 in a2 && Il(s2, l2, a2[i2]);
            } else {
              if (l2 >= jl)
                throw _l(Fl);
              Il(s2, l2++, a2);
            }
          return s2.length = l2, s2;
        } });
        var Bl = Pt, Ll = m, Hl = F(F.bind), Ml = function(t2, e2) {
          return Bl(t2), void 0 === e2 ? t2 : Ll ? Hl(t2, e2) : function() {
            return t2.apply(e2, arguments);
          };
        }, Ul = z, zl = zt, ql = xn, Wl = vl, Gl = F([].push), Kl = function(t2) {
          var e2 = 1 == t2, i2 = 2 == t2, n2 = 3 == t2, o2 = 4 == t2, a2 = 6 == t2, r2 = 7 == t2, s2 = 5 == t2 || a2;
          return function(l2, c2, h2, u2) {
            for (var d2, f2, p2 = zl(l2), g2 = Ul(p2), v2 = Ml(c2, h2), b2 = ql(g2), m2 = 0, y2 = u2 || Wl, w2 = e2 ? y2(l2, b2) : i2 || r2 ? y2(l2, 0) : void 0; b2 > m2; m2++)
              if ((s2 || m2 in g2) && (f2 = v2(d2 = g2[m2], m2, p2), t2))
                if (e2)
                  w2[m2] = f2;
                else if (f2)
                  switch (t2) {
                    case 3:
                      return true;
                    case 5:
                      return d2;
                    case 6:
                      return m2;
                    case 2:
                      Gl(w2, d2);
                  }
                else
                  switch (t2) {
                    case 4:
                      return false;
                    case 7:
                      Gl(w2, d2);
                  }
            return a2 ? -1 : n2 || o2 ? o2 : w2;
          };
        }, Yl = { forEach: Kl(0), map: Kl(1), filter: Kl(2), some: Kl(3), every: Kl(4), find: Kl(5), findIndex: Kl(6), filterReject: Kl(7) }, Jl = ho, Xl = Yl.find, Ql = ol, Zl = "find", tc = true;
        Zl in [] && Array(1).find(function() {
          tc = false;
        }), Jl({ target: "Array", proto: true, forced: tc }, { find: function(t2) {
          return Xl(this, t2, arguments.length > 1 ? arguments[1] : void 0);
        } }), Ql(Zl);
        var ec = Vo, ic = $o ? {}.toString : function() {
          return "[object " + ec(this) + "]";
        };
        $o || cn(Object.prototype, "toString", ic, { unsafe: true });
        var nc = Ir, oc = p.TypeError, ac = function(t2) {
          if (nc(t2))
            throw oc("The method doesn't accept regular expressions");
          return t2;
        }, rc = ce("match"), sc = function(t2) {
          var e2 = /./;
          try {
            "/./"[t2](e2);
          } catch (i2) {
            try {
              return e2[rc] = false, "/./"[t2](e2);
            } catch (t3) {
            }
          }
          return false;
        }, lc = ho, cc = ac, hc = W, uc = Ho, dc = sc, fc = F("".indexOf);
        lc({ target: "String", proto: true, forced: !dc("includes") }, { includes: function(t2) {
          return !!~fc(uc(hc(this)), uc(cc(t2)), arguments.length > 1 ? arguments[1] : void 0);
        } });
        var pc = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, gc = Ce("span").classList, vc = gc && gc.constructor && gc.constructor.prototype, bc = vc === Object.prototype ? void 0 : vc, mc = Yl.forEach, yc = ia("forEach") ? [].forEach : function(t2) {
          return mc(this, t2, arguments.length > 1 ? arguments[1] : void 0);
        }, wc = p, Sc = pc, xc = bc, kc = yc, Oc = ni, Cc = function(t2) {
          if (t2 && t2.forEach !== kc)
            try {
              Oc(t2, "forEach", kc);
            } catch (e2) {
              t2.forEach = kc;
            }
        };
        for (var Tc in Sc)
          Sc[Tc] && Cc(wc[Tc] && wc[Tc].prototype);
        Cc(xc);
        var Pc = p, Ic = v, Ac = Ho, $c = Jo.trim, Rc = F("".charAt), Ec = Pc.parseFloat, jc = Pc.Symbol, Fc = jc && jc.iterator, _c = 1 / Ec("	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF-0") != -1 / 0 || Fc && !Ic(function() {
          Ec(Object(Fc));
        }) ? function(t2) {
          var e2 = $c(Ac(t2)), i2 = Ec(e2);
          return 0 === i2 && "-" == Rc(e2, 0) ? -0 : i2;
        } : Ec;
        ho({ global: true, forced: parseFloat != _c }, { parseFloat: _c });
        var Nc = ho, Dc = Pn.indexOf, Vc = ia, Bc = F([].indexOf), Lc = !!Bc && 1 / Bc([1], 1, -0) < 0, Hc = Vc("indexOf");
        Nc({ target: "Array", proto: true, forced: Lc || !Hc }, { indexOf: function(t2) {
          var e2 = arguments.length > 1 ? arguments[1] : void 0;
          return Lc ? Bc(this, t2, e2) || 0 : Dc(this, t2, e2);
        } });
        var Mc = ps, Uc = Math.floor, zc = function(t2, e2) {
          var i2 = t2.length, n2 = Uc(i2 / 2);
          return i2 < 8 ? qc(t2, e2) : Wc(t2, zc(Mc(t2, 0, n2), e2), zc(Mc(t2, n2), e2), e2);
        }, qc = function(t2, e2) {
          for (var i2, n2, o2 = t2.length, a2 = 1; a2 < o2; ) {
            for (n2 = a2, i2 = t2[a2]; n2 && e2(t2[n2 - 1], i2) > 0; )
              t2[n2] = t2[--n2];
            n2 !== a2++ && (t2[n2] = i2);
          }
          return t2;
        }, Wc = function(t2, e2, i2, n2) {
          for (var o2 = e2.length, a2 = i2.length, r2 = 0, s2 = 0; r2 < o2 || s2 < a2; )
            t2[r2 + s2] = r2 < o2 && s2 < a2 ? n2(e2[r2], i2[s2]) <= 0 ? e2[r2++] : i2[s2++] : r2 < o2 ? e2[r2++] : i2[s2++];
          return t2;
        }, Gc = zc, Kc = ot.match(/firefox\/(\d+)/i), Yc = !!Kc && +Kc[1], Jc = /MSIE|Trident/.test(ot), Xc = ot.match(/AppleWebKit\/(\d+)\./), Qc = !!Xc && +Xc[1], Zc = ho, th = F, eh = Pt, ih = zt, nh = xn, oh = Ho, ah = v, rh = Gc, sh = ia, lh = Yc, ch = Jc, hh = ut, uh = Qc, dh = [], fh = th(dh.sort), ph = th(dh.push), gh = ah(function() {
          dh.sort(void 0);
        }), vh = ah(function() {
          dh.sort(null);
        }), bh = sh("sort"), mh = !ah(function() {
          if (hh)
            return hh < 70;
          if (!(lh && lh > 3)) {
            if (ch)
              return true;
            if (uh)
              return uh < 603;
            var t2, e2, i2, n2, o2 = "";
            for (t2 = 65; t2 < 76; t2++) {
              switch (e2 = String.fromCharCode(t2), t2) {
                case 66:
                case 69:
                case 70:
                case 72:
                  i2 = 3;
                  break;
                case 68:
                case 71:
                  i2 = 4;
                  break;
                default:
                  i2 = 2;
              }
              for (n2 = 0; n2 < 47; n2++)
                dh.push({ k: e2 + n2, v: i2 });
            }
            for (dh.sort(function(t3, e3) {
              return e3.v - t3.v;
            }), n2 = 0; n2 < dh.length; n2++)
              e2 = dh[n2].k.charAt(0), o2.charAt(o2.length - 1) !== e2 && (o2 += e2);
            return "DGBEFHACIJK" !== o2;
          }
        });
        Zc({ target: "Array", proto: true, forced: gh || !vh || !bh || !mh }, { sort: function(t2) {
          void 0 !== t2 && eh(t2);
          var e2 = ih(this);
          if (mh)
            return void 0 === t2 ? fh(e2) : fh(e2, t2);
          var i2, n2, o2 = [], a2 = nh(e2);
          for (n2 = 0; n2 < a2; n2++)
            n2 in e2 && ph(o2, e2[n2]);
          for (rh(o2, function(t3) {
            return function(e3, i3) {
              return void 0 === i3 ? -1 : void 0 === e3 ? 1 : void 0 !== t3 ? +t3(e3, i3) || 0 : oh(e3) > oh(i3) ? 1 : -1;
            };
          }(t2)), i2 = o2.length, n2 = 0; n2 < i2; )
            e2[n2] = o2[n2++];
          for (; n2 < a2; )
            delete e2[n2++];
          return e2;
        } });
        var yh = F, wh = zt, Sh = Math.floor, xh = yh("".charAt), kh = yh("".replace), Oh = yh("".slice), Ch = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, Th = /\$([$&'`]|\d{1,2})/g, Ph = gr, Ih = S, Ah = F, $h = Or, Rh = v, Eh = Ue, jh = J, Fh = fn, _h = wn, Nh = Ho, Dh = W, Vh = os, Bh = At, Lh = function(t2, e2, i2, n2, o2, a2) {
          var r2 = i2 + t2.length, s2 = n2.length, l2 = Th;
          return void 0 !== o2 && (o2 = wh(o2), l2 = Ch), kh(a2, l2, function(a3, l3) {
            var c2;
            switch (xh(l3, 0)) {
              case "$":
                return "$";
              case "&":
                return t2;
              case "`":
                return Oh(e2, 0, i2);
              case "'":
                return Oh(e2, r2);
              case "<":
                c2 = o2[Oh(l3, 1, -1)];
                break;
              default:
                var h2 = +l3;
                if (0 === h2)
                  return a3;
                if (h2 > s2) {
                  var u2 = Sh(h2 / 10);
                  return 0 === u2 ? a3 : u2 <= s2 ? void 0 === n2[u2 - 1] ? xh(l3, 1) : n2[u2 - 1] + xh(l3, 1) : a3;
                }
                c2 = n2[h2 - 1];
            }
            return void 0 === c2 ? "" : c2;
          });
        }, Hh = Ss, Mh = ce("replace"), Uh = Math.max, zh = Math.min, qh = Ah([].concat), Wh = Ah([].push), Gh = Ah("".indexOf), Kh = Ah("".slice), Yh = "$0" === "a".replace(/./, "$0"), Jh = !!/./[Mh] && "" === /./[Mh]("a", "$0");
        $h("replace", function(t2, e2, i2) {
          var n2 = Jh ? "$" : "$0";
          return [function(t3, i3) {
            var n3 = Dh(this), o2 = null == t3 ? void 0 : Bh(t3, Mh);
            return o2 ? Ih(o2, t3, n3, i3) : Ih(e2, Nh(n3), t3, i3);
          }, function(t3, o2) {
            var a2 = Eh(this), r2 = Nh(t3);
            if ("string" == typeof o2 && -1 === Gh(o2, n2) && -1 === Gh(o2, "$<")) {
              var s2 = i2(e2, a2, r2, o2);
              if (s2.done)
                return s2.value;
            }
            var l2 = jh(o2);
            l2 || (o2 = Nh(o2));
            var c2 = a2.global;
            if (c2) {
              var h2 = a2.unicode;
              a2.lastIndex = 0;
            }
            for (var u2 = []; ; ) {
              var d2 = Hh(a2, r2);
              if (null === d2)
                break;
              if (Wh(u2, d2), !c2)
                break;
              "" === Nh(d2[0]) && (a2.lastIndex = Vh(r2, _h(a2.lastIndex), h2));
            }
            for (var f2, p2 = "", g2 = 0, v2 = 0; v2 < u2.length; v2++) {
              for (var b2 = Nh((d2 = u2[v2])[0]), m2 = Uh(zh(Fh(d2.index), r2.length), 0), y2 = [], w2 = 1; w2 < d2.length; w2++)
                Wh(y2, void 0 === (f2 = d2[w2]) ? f2 : String(f2));
              var S2 = d2.groups;
              if (l2) {
                var x2 = qh([b2], y2, m2, r2);
                void 0 !== S2 && Wh(x2, S2);
                var k2 = Nh(Ph(o2, void 0, x2));
              } else
                k2 = Lh(b2, r2, m2, y2, S2, o2);
              m2 >= g2 && (p2 += Kh(r2, g2, m2) + k2, g2 = m2 + b2.length);
            }
            return p2 + Kh(r2, g2);
          }];
        }, !!Rh(function() {
          var t2 = /./;
          return t2.exec = function() {
            var t3 = [];
            return t3.groups = { a: "7" }, t3;
          }, "7" !== "".replace(t2, "$<a>");
        }) || !Yh || Jh);
        var Xh = Yl.filter;
        ho({ target: "Array", proto: true, forced: !wl("filter") }, { filter: function(t2) {
          return Xh(this, t2, arguments.length > 1 ? arguments[1] : void 0);
        } });
        var Qh = Object.is || function(t2, e2) {
          return t2 === e2 ? 0 !== t2 || 1 / t2 == 1 / e2 : t2 != t2 && e2 != e2;
        }, Zh = S, tu = Ue, eu = W, iu = Qh, nu = Ho, ou = At, au = Ss;
        Or("search", function(t2, e2, i2) {
          return [function(e3) {
            var i3 = eu(this), n2 = null == e3 ? void 0 : ou(e3, t2);
            return n2 ? Zh(n2, e3, i3) : new RegExp(e3)[t2](nu(i3));
          }, function(t3) {
            var n2 = tu(this), o2 = nu(t3), a2 = i2(e2, n2, o2);
            if (a2.done)
              return a2.value;
            var r2 = n2.lastIndex;
            iu(r2, 0) || (n2.lastIndex = 0);
            var s2 = au(n2, o2);
            return iu(n2.lastIndex, r2) || (n2.lastIndex = r2), null === s2 ? -1 : s2.index;
          }];
        });
        var ru = p, su = v, lu = F, cu = Ho, hu = Jo.trim, uu = Mo, du = ru.parseInt, fu = ru.Symbol, pu = fu && fu.iterator, gu = /^[+-]?0x/i, vu = lu(gu.exec), bu = 8 !== du(uu + "08") || 22 !== du(uu + "0x16") || pu && !su(function() {
          du(Object(pu));
        }) ? function(t2, e2) {
          var i2 = hu(cu(t2));
          return du(i2, e2 >>> 0 || (vu(gu, i2) ? 16 : 10));
        } : du;
        ho({ global: true, forced: parseInt != bu }, { parseInt: bu });
        var mu = Yl.map;
        ho({ target: "Array", proto: true, forced: !wl("map") }, { map: function(t2) {
          return mu(this, t2, arguments.length > 1 ? arguments[1] : void 0);
        } });
        var yu = ho, wu = Yl.findIndex, Su = ol, xu = "findIndex", ku = true;
        xu in [] && Array(1).findIndex(function() {
          ku = false;
        }), yu({ target: "Array", proto: true, forced: ku }, { findIndex: function(t2) {
          return wu(this, t2, arguments.length > 1 ? arguments[1] : void 0);
        } }), Su(xu);
        var Ou = p, Cu = J, Tu = Ou.String, Pu = Ou.TypeError, Iu = F, Au = Ue, $u = function(t2) {
          if ("object" == typeof t2 || Cu(t2))
            return t2;
          throw Pu("Can't set " + Tu(t2) + " as a prototype");
        }, Ru = Object.setPrototypeOf || ("__proto__" in {} ? function() {
          var t2, e2 = false, i2 = {};
          try {
            (t2 = Iu(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(i2, []), e2 = i2 instanceof Array;
          } catch (t3) {
          }
          return function(i3, n2) {
            return Au(i3), $u(n2), e2 ? t2(i3, n2) : i3.__proto__ = n2, i3;
          };
        }() : void 0), Eu = J, ju = Q, Fu = Ru, _u = function(t2, e2, i2) {
          var n2, o2;
          return Fu && Eu(n2 = e2.constructor) && n2 !== i2 && ju(o2 = n2.prototype) && o2 !== i2.prototype && Fu(t2, o2), t2;
        }, Nu = S, Du = Gt, Vu = nt, Bu = ua, Lu = RegExp.prototype, Hu = function(t2) {
          var e2 = t2.flags;
          return void 0 !== e2 || "flags" in Lu || Du(t2, "flags") || !Vu(Lu, t2) ? e2 : Nu(Bu, t2);
        }, Mu = De.f, Uu = it, zu = De, qu = b, Wu = ce("species"), Gu = b, Ku = p, Yu = F, Ju = io, Xu = _u, Qu = ni, Zu = hn.f, td = nt, ed = Ir, id = Ho, nd = Hu, od = va, ad = function(t2, e2, i2) {
          i2 in t2 || Mu(t2, i2, { configurable: true, get: function() {
            return e2[i2];
          }, set: function(t3) {
            e2[i2] = t3;
          } });
        }, rd = cn, sd = v, ld = Gt, cd = zi.enforce, hd = function(t2) {
          var e2 = Uu(t2), i2 = zu.f;
          qu && e2 && !e2[Wu] && i2(e2, Wu, { configurable: true, get: function() {
            return this;
          } });
        }, ud = La, dd = Ua, fd = ce("match"), pd = Ku.RegExp, gd = pd.prototype, vd = Ku.SyntaxError, bd = Yu(gd.exec), md = Yu("".charAt), yd = Yu("".replace), wd = Yu("".indexOf), Sd = Yu("".slice), xd = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/, kd = /a/g, Od = /a/g, Cd = new pd(kd) !== kd, Td = od.MISSED_STICKY, Pd = od.UNSUPPORTED_Y, Id = Gu && (!Cd || Td || ud || dd || sd(function() {
          return Od[fd] = false, pd(kd) != kd || pd(Od) == Od || "/a/i" != pd(kd, "i");
        }));
        if (Ju("RegExp", Id)) {
          for (var Ad = function(t2, e2) {
            var i2, n2, o2, a2, r2, s2, l2 = td(gd, this), c2 = ed(t2), h2 = void 0 === e2, u2 = [], d2 = t2;
            if (!l2 && c2 && h2 && t2.constructor === Ad)
              return t2;
            if ((c2 || td(gd, t2)) && (t2 = t2.source, h2 && (e2 = nd(d2))), t2 = void 0 === t2 ? "" : id(t2), e2 = void 0 === e2 ? "" : id(e2), d2 = t2, ud && "dotAll" in kd && (n2 = !!e2 && wd(e2, "s") > -1) && (e2 = yd(e2, /s/g, "")), i2 = e2, Td && "sticky" in kd && (o2 = !!e2 && wd(e2, "y") > -1) && Pd && (e2 = yd(e2, /y/g, "")), dd && (a2 = function(t3) {
              for (var e3, i3 = t3.length, n3 = 0, o3 = "", a3 = [], r3 = {}, s3 = false, l3 = false, c3 = 0, h3 = ""; n3 <= i3; n3++) {
                if ("\\" === (e3 = md(t3, n3)))
                  e3 += md(t3, ++n3);
                else if ("]" === e3)
                  s3 = false;
                else if (!s3)
                  switch (true) {
                    case "[" === e3:
                      s3 = true;
                      break;
                    case "(" === e3:
                      bd(xd, Sd(t3, n3 + 1)) && (n3 += 2, l3 = true), o3 += e3, c3++;
                      continue;
                    case (">" === e3 && l3):
                      if ("" === h3 || ld(r3, h3))
                        throw new vd("Invalid capture group name");
                      r3[h3] = true, a3[a3.length] = [h3, c3], l3 = false, h3 = "";
                      continue;
                  }
                l3 ? h3 += e3 : o3 += e3;
              }
              return [o3, a3];
            }(t2), t2 = a2[0], u2 = a2[1]), r2 = Xu(pd(t2, e2), l2 ? this : gd, Ad), (n2 || o2 || u2.length) && (s2 = cd(r2), n2 && (s2.dotAll = true, s2.raw = Ad(function(t3) {
              for (var e3, i3 = t3.length, n3 = 0, o3 = "", a3 = false; n3 <= i3; n3++)
                "\\" !== (e3 = md(t3, n3)) ? a3 || "." !== e3 ? ("[" === e3 ? a3 = true : "]" === e3 && (a3 = false), o3 += e3) : o3 += "[\\s\\S]" : o3 += e3 + md(t3, ++n3);
              return o3;
            }(t2), i2)), o2 && (s2.sticky = true), u2.length && (s2.groups = u2)), t2 !== d2)
              try {
                Qu(r2, "source", "" === d2 ? "(?:)" : d2);
              } catch (t3) {
              }
            return r2;
          }, $d = Zu(pd), Rd = 0; $d.length > Rd; )
            ad(Ad, pd, $d[Rd++]);
          gd.constructor = Ad, Ad.prototype = gd, rd(Ku, "RegExp", Ad, { constructor: true });
        }
        hd("RegExp");
        var Ed = hi.PROPER, jd = cn, Fd = Ue, _d = Ho, Nd = v, Dd = Hu, Vd = "toString", Bd = RegExp.prototype.toString, Ld = Nd(function() {
          return "/a/b" != Bd.call({ source: "a", flags: "b" });
        }), Hd = Ed && Bd.name != Vd;
        (Ld || Hd) && jd(RegExp.prototype, Vd, function() {
          var t2 = Fd(this);
          return "/" + _d(t2.source) + "/" + _d(Dd(t2));
        }, { unsafe: true });
        var Md = F([].slice), Ud = ho, zd = p, qd = ll, Wd = Mr, Gd = Q, Kd = bn, Yd = xn, Jd = Y, Xd = ls, Qd = ce, Zd = Md, tf = wl("slice"), ef = Qd("species"), nf = zd.Array, of = Math.max;
        Ud({ target: "Array", proto: true, forced: !tf }, { slice: function(t2, e2) {
          var i2, n2, o2, a2 = Jd(this), r2 = Yd(a2), s2 = Kd(t2, r2), l2 = Kd(void 0 === e2 ? r2 : e2, r2);
          if (qd(a2) && (i2 = a2.constructor, (Wd(i2) && (i2 === nf || qd(i2.prototype)) || Gd(i2) && null === (i2 = i2[ef])) && (i2 = void 0), i2 === nf || void 0 === i2))
            return Zd(a2, s2, l2);
          for (n2 = new (void 0 === i2 ? nf : i2)(of(l2 - s2, 0)), o2 = 0; s2 < l2; s2++, o2++)
            s2 in a2 && Xd(n2, o2, a2[s2]);
          return n2.length = o2, n2;
        } });
        var af, rf, sf, lf = {}, cf = !v(function() {
          function t2() {
          }
          return t2.prototype.constructor = null, Object.getPrototypeOf(new t2()) !== t2.prototype;
        }), hf = p, uf = Gt, df = J, ff = zt, pf = cf, gf = Ci("IE_PROTO"), vf = hf.Object, bf = vf.prototype, mf = pf ? vf.getPrototypeOf : function(t2) {
          var e2 = ff(t2);
          if (uf(e2, gf))
            return e2[gf];
          var i2 = e2.constructor;
          return df(i2) && e2 instanceof i2 ? i2.prototype : e2 instanceof vf ? bf : null;
        }, yf = v, wf = J, Sf = mf, xf = cn, kf = ce("iterator"), Of = false;
        [].keys && ("next" in (sf = [].keys()) ? (rf = Sf(Sf(sf))) !== Object.prototype && (af = rf) : Of = true);
        var Cf = null == af || yf(function() {
          var t2 = {};
          return af[kf].call(t2) !== t2;
        });
        Cf && (af = {}), wf(af[kf]) || xf(af, kf, function() {
          return this;
        });
        var Tf = { IteratorPrototype: af, BUGGY_SAFARI_ITERATORS: Of }, Pf = De.f, If = Gt, Af = ce("toStringTag"), $f = function(t2, e2, i2) {
          t2 && !i2 && (t2 = t2.prototype), t2 && !If(t2, Af) && Pf(t2, Af, { configurable: true, value: e2 });
        }, Rf = Tf.IteratorPrototype, Ef = Da, jf = I, Ff = $f, _f = lf, Nf = function() {
          return this;
        }, Df = ho, Vf = S, Bf = J, Lf = function(t2, e2, i2, n2) {
          var o2 = e2 + " Iterator";
          return t2.prototype = Ef(Rf, { next: jf(+!n2, i2) }), Ff(t2, o2, false), _f[o2] = Nf, t2;
        }, Hf = mf, Mf = Ru, Uf = $f, zf = ni, qf = cn, Wf = lf, Gf = hi.PROPER, Kf = hi.CONFIGURABLE, Yf = Tf.IteratorPrototype, Jf = Tf.BUGGY_SAFARI_ITERATORS, Xf = ce("iterator"), Qf = "keys", Zf = "values", tp = "entries", ep = function() {
          return this;
        }, ip = Y, np = ol, op = lf, ap = zi, rp = De.f, sp = function(t2, e2, i2, n2, o2, a2, r2) {
          Lf(i2, e2, n2);
          var s2, l2, c2, h2 = function(t3) {
            if (t3 === o2 && g2)
              return g2;
            if (!Jf && t3 in f2)
              return f2[t3];
            switch (t3) {
              case Qf:
              case Zf:
              case tp:
                return function() {
                  return new i2(this, t3);
                };
            }
            return function() {
              return new i2(this);
            };
          }, u2 = e2 + " Iterator", d2 = false, f2 = t2.prototype, p2 = f2[Xf] || f2["@@iterator"] || o2 && f2[o2], g2 = !Jf && p2 || h2(o2), v2 = "Array" == e2 && f2.entries || p2;
          if (v2 && (s2 = Hf(v2.call(new t2()))) !== Object.prototype && s2.next && (Hf(s2) !== Yf && (Mf ? Mf(s2, Yf) : Bf(s2[Xf]) || qf(s2, Xf, ep)), Uf(s2, u2, true)), Gf && o2 == Zf && p2 && p2.name !== Zf && (Kf ? zf(f2, "name", Zf) : (d2 = true, g2 = function() {
            return Vf(p2, this);
          })), o2)
            if (l2 = { values: h2(Zf), keys: a2 ? g2 : h2(Qf), entries: h2(tp) }, r2)
              for (c2 in l2)
                (Jf || d2 || !(c2 in f2)) && qf(f2, c2, l2[c2]);
            else
              Df({ target: e2, proto: true, forced: Jf || d2 }, l2);
          return f2[Xf] !== g2 && qf(f2, Xf, g2, { name: o2 }), Wf[e2] = g2, l2;
        }, lp = b, cp = "Array Iterator", hp = ap.set, up = ap.getterFor(cp), dp = sp(Array, "Array", function(t2, e2) {
          hp(this, { type: cp, target: ip(t2), index: 0, kind: e2 });
        }, function() {
          var t2 = up(this), e2 = t2.target, i2 = t2.kind, n2 = t2.index++;
          return !e2 || n2 >= e2.length ? (t2.target = void 0, { value: void 0, done: true }) : "keys" == i2 ? { value: n2, done: false } : "values" == i2 ? { value: e2[n2], done: false } : { value: [n2, e2[n2]], done: false };
        }, "values"), fp = op.Arguments = op.Array;
        if (np("keys"), np("values"), np("entries"), lp && "values" !== fp.name)
          try {
            rp(fp, "name", { value: "values" });
          } catch (t2) {
          }
        var pp = p, gp = pc, vp = bc, bp = dp, mp = ni, yp = ce, wp = yp("iterator"), Sp = yp("toStringTag"), xp = bp.values, kp = function(t2, e2) {
          if (t2) {
            if (t2[wp] !== xp)
              try {
                mp(t2, wp, xp);
              } catch (e3) {
                t2[wp] = xp;
              }
            if (t2[Sp] || mp(t2, Sp, e2), gp[e2]) {
              for (var i2 in bp)
                if (t2[i2] !== bp[i2])
                  try {
                    mp(t2, i2, bp[i2]);
                  } catch (e3) {
                    t2[i2] = bp[i2];
                  }
            }
          }
        };
        for (var Op in gp)
          kp(pp[Op] && pp[Op].prototype, Op);
        kp(vp, "DOMTokenList");
        var Cp = ho, Tp = p, Pp = bn, Ip = fn, Ap = xn, $p = zt, Rp = vl, Ep = ls, jp = wl("splice"), Fp = Tp.TypeError, _p = Math.max, Np = Math.min, Dp = 9007199254740991, Vp = "Maximum allowed length exceeded";
        Cp({ target: "Array", proto: true, forced: !jp }, { splice: function(t2, e2) {
          var i2, n2, o2, a2, r2, s2, l2 = $p(this), c2 = Ap(l2), h2 = Pp(t2, c2), u2 = arguments.length;
          if (0 === u2 ? i2 = n2 = 0 : 1 === u2 ? (i2 = 0, n2 = c2 - h2) : (i2 = u2 - 2, n2 = Np(_p(Ip(e2), 0), c2 - h2)), c2 + i2 - n2 > Dp)
            throw Fp(Vp);
          for (o2 = Rp(l2, n2), a2 = 0; a2 < n2; a2++)
            (r2 = h2 + a2) in l2 && Ep(o2, a2, l2[r2]);
          if (o2.length = n2, i2 < n2) {
            for (a2 = h2; a2 < c2 - n2; a2++)
              s2 = a2 + i2, (r2 = a2 + n2) in l2 ? l2[s2] = l2[r2] : delete l2[s2];
            for (a2 = c2; a2 > c2 - n2 + i2; a2--)
              delete l2[a2 - 1];
          } else if (i2 > n2)
            for (a2 = c2 - n2; a2 > h2; a2--)
              s2 = a2 + i2 - 1, (r2 = a2 + n2 - 1) in l2 ? l2[s2] = l2[r2] : delete l2[s2];
          for (a2 = 0; a2 < i2; a2++)
            l2[a2 + h2] = arguments[a2 + 2];
          return l2.length = c2 - n2 + i2, o2;
        } });
        var Bp = F(1 .valueOf), Lp = b, Hp = p, Mp = F, Up = io, zp = cn, qp = Gt, Wp = _u, Gp = nt, Kp = St, Yp = me, Jp = v, Xp = hn.f, Qp = g.f, Zp = De.f, tg = Bp, eg = Jo.trim, ig = "Number", ng = Hp.Number, og = ng.prototype, ag = Hp.TypeError, rg = Mp("".slice), sg = Mp("".charCodeAt), lg = function(t2) {
          var e2 = Yp(t2, "number");
          return "bigint" == typeof e2 ? e2 : cg(e2);
        }, cg = function(t2) {
          var e2, i2, n2, o2, a2, r2, s2, l2, c2 = Yp(t2, "number");
          if (Kp(c2))
            throw ag("Cannot convert a Symbol value to a number");
          if ("string" == typeof c2 && c2.length > 2) {
            if (c2 = eg(c2), 43 === (e2 = sg(c2, 0)) || 45 === e2) {
              if (88 === (i2 = sg(c2, 2)) || 120 === i2)
                return NaN;
            } else if (48 === e2) {
              switch (sg(c2, 1)) {
                case 66:
                case 98:
                  n2 = 2, o2 = 49;
                  break;
                case 79:
                case 111:
                  n2 = 8, o2 = 55;
                  break;
                default:
                  return +c2;
              }
              for (r2 = (a2 = rg(c2, 2)).length, s2 = 0; s2 < r2; s2++)
                if ((l2 = sg(a2, s2)) < 48 || l2 > o2)
                  return NaN;
              return parseInt(a2, n2);
            }
          }
          return +c2;
        };
        if (Up(ig, !ng(" 0o1") || !ng("0b1") || ng("+0x1"))) {
          for (var hg, ug = function(t2) {
            var e2 = arguments.length < 1 ? 0 : ng(lg(t2)), i2 = this;
            return Gp(og, i2) && Jp(function() {
              tg(i2);
            }) ? Wp(Object(e2), i2, ug) : e2;
          }, dg = Lp ? Xp(ng) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","), fg = 0; dg.length > fg; fg++)
            qp(ng, hg = dg[fg]) && !qp(ug, hg) && Zp(ug, hg, Qp(ng, hg));
          ug.prototype = og, og.constructor = ug, zp(Hp, ig, ug, { constructor: true });
        }
        var pg = ho, gg = ll, vg = F([].reverse), bg = [1, 2];
        pg({ target: "Array", proto: true, forced: String(bg) === String(bg.reverse()) }, { reverse: function() {
          return gg(this) && (this.length = this.length), vg(this);
        } });
        var mg = zt, yg = po;
        ho({ target: "Object", stat: true, forced: v(function() {
          yg(1);
        }) }, { keys: function(t2) {
          return yg(mg(t2));
        } });
        var wg = S, Sg = Ue, xg = wn, kg = Ho, Og = W, Cg = At, Tg = os, Pg = Ss;
        Or("match", function(t2, e2, i2) {
          return [function(e3) {
            var i3 = Og(this), n2 = null == e3 ? void 0 : Cg(e3, t2);
            return n2 ? wg(n2, e3, i3) : new RegExp(e3)[t2](kg(i3));
          }, function(t3) {
            var n2 = Sg(this), o2 = kg(t3), a2 = i2(e2, n2, o2);
            if (a2.done)
              return a2.value;
            if (!n2.global)
              return Pg(n2, o2);
            var r2 = n2.unicode;
            n2.lastIndex = 0;
            for (var s2, l2 = [], c2 = 0; null !== (s2 = Pg(n2, o2)); ) {
              var h2 = kg(s2[0]);
              l2[c2] = h2, "" === h2 && (n2.lastIndex = Tg(o2, xg(n2.lastIndex), r2)), c2++;
            }
            return 0 === c2 ? null : l2;
          }];
        });
        var Ig, Ag = ho, $g = F, Rg = g.f, Eg = wn, jg = Ho, Fg = ac, _g = W, Ng = sc, Dg = $g("".startsWith), Vg = $g("".slice), Bg = Math.min, Lg = Ng("startsWith");
        Ag({ target: "String", proto: true, forced: !!(Lg || (Ig = Rg(String.prototype, "startsWith"), !Ig || Ig.writable)) && !Lg }, { startsWith: function(t2) {
          var e2 = jg(_g(this));
          Fg(t2);
          var i2 = Eg(Bg(arguments.length > 1 ? arguments[1] : void 0, e2.length)), n2 = jg(t2);
          return Dg ? Dg(e2, n2, i2) : Vg(e2, i2, i2 + n2.length) === n2;
        } });
        var Hg = ho, Mg = F, Ug = g.f, zg = wn, qg = Ho, Wg = ac, Gg = W, Kg = sc, Yg = Mg("".endsWith), Jg = Mg("".slice), Xg = Math.min, Qg = Kg("endsWith"), Zg = !Qg && !!function() {
          var t2 = Ug(String.prototype, "endsWith");
          return t2 && !t2.writable;
        }();
        Hg({ target: "String", proto: true, forced: !Zg && !Qg }, { endsWith: function(t2) {
          var e2 = qg(Gg(this));
          Wg(t2);
          var i2 = arguments.length > 1 ? arguments[1] : void 0, n2 = e2.length, o2 = void 0 === i2 ? n2 : Xg(zg(i2), n2), a2 = qg(t2);
          return Yg ? Yg(e2, a2, o2) : Jg(e2, o2 - a2.length, o2) === a2;
        } });
        var tv = { getBootstrapVersion: function() {
          var t2 = 5;
          try {
            var e2 = i.default.fn.dropdown.Constructor.VERSION;
            void 0 !== e2 && (t2 = parseInt(e2, 10));
          } catch (t3) {
          }
          try {
            var n2 = bootstrap.Tooltip.VERSION;
            void 0 !== n2 && (t2 = parseInt(n2, 10));
          } catch (t3) {
          }
          return t2;
        }, getIconsPrefix: function(t2) {
          return { bootstrap3: "glyphicon", bootstrap4: "fa", bootstrap5: "bi", "bootstrap-table": "icon", bulma: "fa", foundation: "fa", materialize: "material-icons", semantic: "fa" }[t2] || "fa";
        }, getIcons: function(t2) {
          return { glyphicon: { paginationSwitchDown: "glyphicon-collapse-down icon-chevron-down", paginationSwitchUp: "glyphicon-collapse-up icon-chevron-up", refresh: "glyphicon-refresh icon-refresh", toggleOff: "glyphicon-list-alt icon-list-alt", toggleOn: "glyphicon-list-alt icon-list-alt", columns: "glyphicon-th icon-th", detailOpen: "glyphicon-plus icon-plus", detailClose: "glyphicon-minus icon-minus", fullscreen: "glyphicon-fullscreen", search: "glyphicon-search", clearSearch: "glyphicon-trash" }, fa: { paginationSwitchDown: "fa-caret-square-down", paginationSwitchUp: "fa-caret-square-up", refresh: "fa-sync", toggleOff: "fa-toggle-off", toggleOn: "fa-toggle-on", columns: "fa-th-list", detailOpen: "fa-plus", detailClose: "fa-minus", fullscreen: "fa-arrows-alt", search: "fa-search", clearSearch: "fa-trash" }, bi: { paginationSwitchDown: "bi-caret-down-square", paginationSwitchUp: "bi-caret-up-square", refresh: "bi-arrow-clockwise", toggleOff: "bi-toggle-off", toggleOn: "bi-toggle-on", columns: "bi-list-ul", detailOpen: "bi-plus", detailClose: "bi-dash", fullscreen: "bi-arrows-move", search: "bi-search", clearSearch: "bi-trash" }, icon: { paginationSwitchDown: "icon-arrow-up-circle", paginationSwitchUp: "icon-arrow-down-circle", refresh: "icon-refresh-cw", toggleOff: "icon-toggle-right", toggleOn: "icon-toggle-right", columns: "icon-list", detailOpen: "icon-plus", detailClose: "icon-minus", fullscreen: "icon-maximize", search: "icon-search", clearSearch: "icon-trash-2" }, "material-icons": { paginationSwitchDown: "grid_on", paginationSwitchUp: "grid_off", refresh: "refresh", toggleOff: "tablet", toggleOn: "tablet_android", columns: "view_list", detailOpen: "add", detailClose: "remove", fullscreen: "fullscreen", sort: "sort", search: "search", clearSearch: "delete" } }[t2];
        }, getSearchInput: function(t2) {
          return "string" == typeof t2.options.searchSelector ? i.default(t2.options.searchSelector) : t2.$toolbar.find(".search input");
        }, sprintf: function(t2) {
          for (var e2 = arguments.length, i2 = new Array(e2 > 1 ? e2 - 1 : 0), n2 = 1; n2 < e2; n2++)
            i2[n2 - 1] = arguments[n2];
          var o2 = true, a2 = 0, r2 = t2.replace(/%s/g, function() {
            var t3 = i2[a2++];
            return void 0 === t3 ? (o2 = false, "") : t3;
          });
          return o2 ? r2 : "";
        }, isObject: function(t2) {
          return t2 instanceof Object && !Array.isArray(t2);
        }, isEmptyObject: function() {
          var t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          return 0 === Object.entries(t2).length && t2.constructor === Object;
        }, isNumeric: function(t2) {
          return !isNaN(parseFloat(t2)) && isFinite(t2);
        }, getFieldTitle: function(t2, e2) {
          var i2, n2 = u(t2);
          try {
            for (n2.s(); !(i2 = n2.n()).done; ) {
              var o2 = i2.value;
              if (o2.field === e2)
                return o2.title;
            }
          } catch (t3) {
            n2.e(t3);
          } finally {
            n2.f();
          }
          return "";
        }, setFieldIndex: function(t2) {
          var e2, i2 = 0, n2 = [], o2 = u(t2[0]);
          try {
            for (o2.s(); !(e2 = o2.n()).done; ) {
              i2 += e2.value.colspan || 1;
            }
          } catch (t3) {
            o2.e(t3);
          } finally {
            o2.f();
          }
          for (var a2 = 0; a2 < t2.length; a2++) {
            n2[a2] = [];
            for (var r2 = 0; r2 < i2; r2++)
              n2[a2][r2] = false;
          }
          for (var s2 = 0; s2 < t2.length; s2++) {
            var l2, c2 = u(t2[s2]);
            try {
              for (c2.s(); !(l2 = c2.n()).done; ) {
                var h2 = l2.value, d2 = h2.rowspan || 1, f2 = h2.colspan || 1, p2 = n2[s2].indexOf(false);
                h2.colspanIndex = p2, 1 === f2 ? (h2.fieldIndex = p2, void 0 === h2.field && (h2.field = p2)) : h2.colspanGroup = h2.colspan;
                for (var g2 = 0; g2 < d2; g2++)
                  for (var v2 = 0; v2 < f2; v2++)
                    n2[s2 + g2][p2 + v2] = true;
              }
            } catch (t3) {
              c2.e(t3);
            } finally {
              c2.f();
            }
          }
        }, normalizeAccent: function(t2) {
          return "string" != typeof t2 ? t2 : t2.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
        }, updateFieldGroup: function(t2, e2) {
          var i2, n2, o2 = (i2 = []).concat.apply(i2, l(t2)), a2 = u(t2);
          try {
            for (a2.s(); !(n2 = a2.n()).done; ) {
              var r2, s2 = u(n2.value);
              try {
                for (s2.s(); !(r2 = s2.n()).done; ) {
                  var c2 = r2.value;
                  if (c2.colspanGroup > 1) {
                    for (var h2 = 0, d2 = function(t3) {
                      o2.find(function(e3) {
                        return e3.fieldIndex === t3;
                      }).visible && h2++;
                    }, f2 = c2.colspanIndex; f2 < c2.colspanIndex + c2.colspanGroup; f2++)
                      d2(f2);
                    c2.colspan = h2, c2.visible = h2 > 0;
                  }
                }
              } catch (t3) {
                s2.e(t3);
              } finally {
                s2.f();
              }
            }
          } catch (t3) {
            a2.e(t3);
          } finally {
            a2.f();
          }
          if (!(t2.length < 2)) {
            var p2, g2 = u(e2);
            try {
              var v2 = function() {
                var t3 = p2.value, e3 = o2.filter(function(e4) {
                  return e4.fieldIndex === t3.fieldIndex;
                });
                if (e3.length > 1) {
                  var i3, n3 = u(e3);
                  try {
                    for (n3.s(); !(i3 = n3.n()).done; ) {
                      i3.value.visible = t3.visible;
                    }
                  } catch (t4) {
                    n3.e(t4);
                  } finally {
                    n3.f();
                  }
                }
              };
              for (g2.s(); !(p2 = g2.n()).done; )
                v2();
            } catch (t3) {
              g2.e(t3);
            } finally {
              g2.f();
            }
          }
        }, getScrollBarWidth: function() {
          if (void 0 === this.cachedWidth) {
            var t2 = i.default("<div/>").addClass("fixed-table-scroll-inner"), e2 = i.default("<div/>").addClass("fixed-table-scroll-outer");
            e2.append(t2), i.default("body").append(e2);
            var n2 = t2[0].offsetWidth;
            e2.css("overflow", "scroll");
            var o2 = t2[0].offsetWidth;
            n2 === o2 && (o2 = e2[0].clientWidth), e2.remove(), this.cachedWidth = n2 - o2;
          }
          return this.cachedWidth;
        }, calculateObjectValue: function(t2, e2, i2, o2) {
          var a2 = e2;
          if ("string" == typeof e2) {
            var r2 = e2.split(".");
            if (r2.length > 1) {
              a2 = window;
              var s2, c2 = u(r2);
              try {
                for (c2.s(); !(s2 = c2.n()).done; ) {
                  a2 = a2[s2.value];
                }
              } catch (t3) {
                c2.e(t3);
              } finally {
                c2.f();
              }
            } else
              a2 = window[e2];
          }
          return null !== a2 && "object" === n(a2) ? a2 : "function" == typeof a2 ? a2.apply(t2, i2 || []) : !a2 && "string" == typeof e2 && i2 && this.sprintf.apply(this, [e2].concat(l(i2))) ? this.sprintf.apply(this, [e2].concat(l(i2))) : o2;
        }, compareObjects: function(t2, e2, i2) {
          var n2 = Object.keys(t2), o2 = Object.keys(e2);
          if (i2 && n2.length !== o2.length)
            return false;
          for (var a2 = 0, r2 = n2; a2 < r2.length; a2++) {
            var s2 = r2[a2];
            if (o2.includes(s2) && t2[s2] !== e2[s2])
              return false;
          }
          return true;
        }, regexCompare: function(t2, e2) {
          try {
            var i2 = e2.match(/^\/(.*?)\/([gim]*)$/);
            if (-1 !== t2.toString().search(i2 ? new RegExp(i2[1], i2[2]) : new RegExp(e2, "gim")))
              return true;
          } catch (t3) {
            return false;
          }
        }, escapeHTML: function(t2) {
          return t2 ? t2.toString().replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;") : t2;
        }, unescapeHTML: function(t2) {
          return "string" == typeof t2 && t2 ? t2.toString().replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'") : t2;
        }, removeHTML: function(t2) {
          return t2 ? t2.toString().replace(/(<([^>]+)>)/gi, "").replace(/&[#A-Za-z0-9]+;/gi, "").trim() : t2;
        }, getRealDataAttr: function(t2) {
          for (var e2 = 0, i2 = Object.entries(t2); e2 < i2.length; e2++) {
            var n2 = s(i2[e2], 2), o2 = n2[0], a2 = n2[1], r2 = o2.split(/(?=[A-Z])/).join("-").toLowerCase();
            r2 !== o2 && (t2[r2] = a2, delete t2[o2]);
          }
          return t2;
        }, getItemField: function(t2, e2, i2) {
          var n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : void 0, o2 = t2;
          if (void 0 !== n2 && (i2 = n2), "string" != typeof e2 || t2.hasOwnProperty(e2))
            return i2 ? this.escapeHTML(t2[e2]) : t2[e2];
          var a2, r2 = e2.split("."), s2 = u(r2);
          try {
            for (s2.s(); !(a2 = s2.n()).done; ) {
              var l2 = a2.value;
              o2 = o2 && o2[l2];
            }
          } catch (t3) {
            s2.e(t3);
          } finally {
            s2.f();
          }
          return i2 ? this.escapeHTML(o2) : o2;
        }, isIEBrowser: function() {
          return navigator.userAgent.includes("MSIE ") || /Trident.*rv:11\./.test(navigator.userAgent);
        }, findIndex: function(t2, e2) {
          var i2, n2 = u(t2);
          try {
            for (n2.s(); !(i2 = n2.n()).done; ) {
              var o2 = i2.value;
              if (JSON.stringify(o2) === JSON.stringify(e2))
                return t2.indexOf(o2);
            }
          } catch (t3) {
            n2.e(t3);
          } finally {
            n2.f();
          }
          return -1;
        }, trToData: function(t2, e2) {
          var n2 = this, o2 = [], a2 = [];
          return e2.each(function(e3, r2) {
            var s2 = i.default(r2), l2 = {};
            l2._id = s2.attr("id"), l2._class = s2.attr("class"), l2._data = n2.getRealDataAttr(s2.data()), l2._style = s2.attr("style"), s2.find(">td,>th").each(function(o3, r3) {
              for (var s3 = i.default(r3), c2 = +s3.attr("colspan") || 1, h2 = +s3.attr("rowspan") || 1, u2 = o3; a2[e3] && a2[e3][u2]; u2++)
                ;
              for (var d2 = u2; d2 < u2 + c2; d2++)
                for (var f2 = e3; f2 < e3 + h2; f2++)
                  a2[f2] || (a2[f2] = []), a2[f2][d2] = true;
              var p2 = t2[u2].field;
              l2[p2] = s3.html().trim(), l2["_".concat(p2, "_id")] = s3.attr("id"), l2["_".concat(p2, "_class")] = s3.attr("class"), l2["_".concat(p2, "_rowspan")] = s3.attr("rowspan"), l2["_".concat(p2, "_colspan")] = s3.attr("colspan"), l2["_".concat(p2, "_title")] = s3.attr("title"), l2["_".concat(p2, "_data")] = n2.getRealDataAttr(s3.data()), l2["_".concat(p2, "_style")] = s3.attr("style");
            }), o2.push(l2);
          }), o2;
        }, sort: function(t2, e2, i2, n2, o2, a2) {
          return null == t2 && (t2 = ""), null == e2 && (e2 = ""), n2 && t2 === e2 && (t2 = o2, e2 = a2), this.isNumeric(t2) && this.isNumeric(e2) ? (t2 = parseFloat(t2)) < (e2 = parseFloat(e2)) ? -1 * i2 : t2 > e2 ? i2 : 0 : t2 === e2 ? 0 : ("string" != typeof t2 && (t2 = t2.toString()), -1 === t2.localeCompare(e2) ? -1 * i2 : i2);
        }, getEventName: function(t2) {
          var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
          return e2 = e2 || "".concat(+new Date()).concat(~~(1e6 * Math.random())), "".concat(t2, "-").concat(e2);
        }, hasDetailViewIcon: function(t2) {
          return t2.detailView && t2.detailViewIcon && !t2.cardView;
        }, getDetailViewIndexOffset: function(t2) {
          return this.hasDetailViewIcon(t2) && "right" !== t2.detailViewAlign ? 1 : 0;
        }, checkAutoMergeCells: function(t2) {
          var e2, i2 = u(t2);
          try {
            for (i2.s(); !(e2 = i2.n()).done; )
              for (var n2 = e2.value, o2 = 0, a2 = Object.keys(n2); o2 < a2.length; o2++) {
                var r2 = a2[o2];
                if (r2.startsWith("_") && (r2.endsWith("_rowspan") || r2.endsWith("_colspan")))
                  return true;
              }
          } catch (t3) {
            i2.e(t3);
          } finally {
            i2.f();
          }
          return false;
        }, deepCopy: function(t2) {
          return void 0 === t2 ? t2 : i.default.extend(true, Array.isArray(t2) ? [] : {}, t2);
        }, debounce: function(t2, e2, i2) {
          var n2;
          return function() {
            var o2 = this, a2 = arguments, r2 = function() {
              n2 = null, i2 || t2.apply(o2, a2);
            }, s2 = i2 && !n2;
            clearTimeout(n2), n2 = setTimeout(r2, e2), s2 && t2.apply(o2, a2);
          };
        } }, ev = tv.getBootstrapVersion(), iv = { 3: { classes: { buttonsPrefix: "btn", buttons: "default", buttonsGroup: "btn-group", buttonsDropdown: "btn-group", pull: "pull", inputGroup: "input-group", inputPrefix: "input-", input: "form-control", select: "form-control", paginationDropdown: "btn-group dropdown", dropup: "dropup", dropdownActive: "active", paginationActive: "active", buttonActive: "active" }, html: { toolbarDropdown: ['<ul class="dropdown-menu" role="menu">', "</ul>"], toolbarDropdownItem: '<li class="dropdown-item-marker" role="menuitem"><label>%s</label></li>', toolbarDropdownSeparator: '<li class="divider"></li>', pageDropdown: ['<ul class="dropdown-menu" role="menu">', "</ul>"], pageDropdownItem: '<li role="menuitem" class="%s"><a href="#">%s</a></li>', dropdownCaret: '<span class="caret"></span>', pagination: ['<ul class="pagination%s">', "</ul>"], paginationItem: '<li class="page-item%s"><a class="page-link" aria-label="%s" href="javascript:void(0)">%s</a></li>', icon: '<i class="%s %s"></i>', inputGroup: '<div class="input-group">%s<span class="input-group-btn">%s</span></div>', searchInput: '<input class="%s%s" type="text" placeholder="%s">', searchButton: '<button class="%s" type="button" name="search" title="%s">%s %s</button>', searchClearButton: '<button class="%s" type="button" name="clearSearch" title="%s">%s %s</button>' } }, 4: { classes: { buttonsPrefix: "btn", buttons: "secondary", buttonsGroup: "btn-group", buttonsDropdown: "btn-group", pull: "float", inputGroup: "btn-group", inputPrefix: "form-control-", input: "form-control", select: "form-control", paginationDropdown: "btn-group dropdown", dropup: "dropup", dropdownActive: "active", paginationActive: "active", buttonActive: "active" }, html: { toolbarDropdown: ['<div class="dropdown-menu dropdown-menu-right">', "</div>"], toolbarDropdownItem: '<label class="dropdown-item dropdown-item-marker">%s</label>', pageDropdown: ['<div class="dropdown-menu">', "</div>"], pageDropdownItem: '<a class="dropdown-item %s" href="#">%s</a>', toolbarDropdownSeparator: '<div class="dropdown-divider"></div>', dropdownCaret: '<span class="caret"></span>', pagination: ['<ul class="pagination%s">', "</ul>"], paginationItem: '<li class="page-item%s"><a class="page-link" aria-label="%s" href="javascript:void(0)">%s</a></li>', icon: '<i class="%s %s"></i>', inputGroup: '<div class="input-group">%s<div class="input-group-append">%s</div></div>', searchInput: '<input class="%s%s" type="text" placeholder="%s">', searchButton: '<button class="%s" type="button" name="search" title="%s">%s %s</button>', searchClearButton: '<button class="%s" type="button" name="clearSearch" title="%s">%s %s</button>' } }, 5: { classes: { buttonsPrefix: "btn", buttons: "secondary", buttonsGroup: "btn-group", buttonsDropdown: "btn-group", pull: "float", inputGroup: "btn-group", inputPrefix: "form-control-", input: "form-control", select: "form-select", paginationDropdown: "btn-group dropdown", dropup: "dropup", dropdownActive: "active", paginationActive: "active", buttonActive: "active" }, html: { dataToggle: "data-bs-toggle", toolbarDropdown: ['<div class="dropdown-menu dropdown-menu-right">', "</div>"], toolbarDropdownItem: '<label class="dropdown-item dropdown-item-marker">%s</label>', pageDropdown: ['<div class="dropdown-menu">', "</div>"], pageDropdownItem: '<a class="dropdown-item %s" href="#">%s</a>', toolbarDropdownSeparator: '<div class="dropdown-divider"></div>', dropdownCaret: '<span class="caret"></span>', pagination: ['<ul class="pagination%s">', "</ul>"], paginationItem: '<li class="page-item%s"><a class="page-link" aria-label="%s" href="javascript:void(0)">%s</a></li>', icon: '<i class="%s %s"></i>', inputGroup: '<div class="input-group">%s%s</div>', searchInput: '<input class="%s%s" type="text" placeholder="%s">', searchButton: '<button class="%s" type="button" name="search" title="%s">%s %s</button>', searchClearButton: '<button class="%s" type="button" name="clearSearch" title="%s">%s %s</button>' } } }[ev], nv = { height: void 0, classes: "table table-bordered table-hover", buttons: {}, theadClasses: "", headerStyle: function(t2) {
          return {};
        }, rowStyle: function(t2, e2) {
          return {};
        }, rowAttributes: function(t2, e2) {
          return {};
        }, undefinedText: "-", locale: void 0, virtualScroll: false, virtualScrollItemHeight: void 0, sortable: true, sortClass: void 0, silentSort: true, sortName: void 0, sortOrder: void 0, sortReset: false, sortStable: false, rememberOrder: false, serverSort: true, customSort: void 0, columns: [[]], data: [], url: void 0, method: "get", cache: true, contentType: "application/json", dataType: "json", ajax: void 0, ajaxOptions: {}, queryParams: function(t2) {
          return t2;
        }, queryParamsType: "limit", responseHandler: function(t2) {
          return t2;
        }, totalField: "total", totalNotFilteredField: "totalNotFiltered", dataField: "rows", footerField: "footer", pagination: false, paginationParts: ["pageInfo", "pageSize", "pageList"], showExtendedPagination: false, paginationLoop: true, sidePagination: "client", totalRows: 0, totalNotFiltered: 0, pageNumber: 1, pageSize: 10, pageList: [10, 25, 50, 100], paginationHAlign: "right", paginationVAlign: "bottom", paginationDetailHAlign: "left", paginationPreText: "&lsaquo;", paginationNextText: "&rsaquo;", paginationSuccessivelySize: 5, paginationPagesBySide: 1, paginationUseIntermediate: false, search: false, searchHighlight: false, searchOnEnterKey: false, strictSearch: false, regexSearch: false, searchSelector: false, visibleSearch: false, showButtonIcons: true, showButtonText: false, showSearchButton: false, showSearchClearButton: false, trimOnSearch: true, searchAlign: "right", searchTimeOut: 500, searchText: "", customSearch: void 0, showHeader: true, showFooter: false, footerStyle: function(t2) {
          return {};
        }, searchAccentNeutralise: false, showColumns: false, showColumnsToggleAll: false, showColumnsSearch: false, minimumCountColumns: 1, showPaginationSwitch: false, showRefresh: false, showToggle: false, showFullscreen: false, smartDisplay: true, escape: false, filterOptions: { filterAlgorithm: "and" }, idField: void 0, selectItemName: "btSelectItem", clickToSelect: false, ignoreClickToSelectOn: function(t2) {
          var e2 = t2.tagName;
          return ["A", "BUTTON"].includes(e2);
        }, singleSelect: false, checkboxHeader: true, maintainMetaData: false, multipleSelectRow: false, uniqueId: void 0, cardView: false, detailView: false, detailViewIcon: true, detailViewByClick: false, detailViewAlign: "left", detailFormatter: function(t2, e2) {
          return "";
        }, detailFilter: function(t2, e2) {
          return true;
        }, toolbar: void 0, toolbarAlign: "left", buttonsToolbar: void 0, buttonsAlign: "right", buttonsOrder: ["paginationSwitch", "refresh", "toggle", "fullscreen", "columns"], buttonsPrefix: iv.classes.buttonsPrefix, buttonsClass: iv.classes.buttons, iconsPrefix: void 0, icons: {}, iconSize: void 0, loadingFontSize: "auto", loadingTemplate: function(t2) {
          return '<span class="loading-wrap">\n      <span class="loading-text">'.concat(t2, '</span>\n      <span class="animation-wrap"><span class="animation-dot"></span></span>\n      </span>\n    ');
        }, onAll: function(t2, e2) {
          return false;
        }, onClickCell: function(t2, e2, i2, n2) {
          return false;
        }, onDblClickCell: function(t2, e2, i2, n2) {
          return false;
        }, onClickRow: function(t2, e2) {
          return false;
        }, onDblClickRow: function(t2, e2) {
          return false;
        }, onSort: function(t2, e2) {
          return false;
        }, onCheck: function(t2) {
          return false;
        }, onUncheck: function(t2) {
          return false;
        }, onCheckAll: function(t2) {
          return false;
        }, onUncheckAll: function(t2) {
          return false;
        }, onCheckSome: function(t2) {
          return false;
        }, onUncheckSome: function(t2) {
          return false;
        }, onLoadSuccess: function(t2) {
          return false;
        }, onLoadError: function(t2) {
          return false;
        }, onColumnSwitch: function(t2, e2) {
          return false;
        }, onColumnSwitchAll: function(t2) {
          return false;
        }, onPageChange: function(t2, e2) {
          return false;
        }, onSearch: function(t2) {
          return false;
        }, onToggle: function(t2) {
          return false;
        }, onPreBody: function(t2) {
          return false;
        }, onPostBody: function() {
          return false;
        }, onPostHeader: function() {
          return false;
        }, onPostFooter: function() {
          return false;
        }, onExpandRow: function(t2, e2, i2) {
          return false;
        }, onCollapseRow: function(t2, e2) {
          return false;
        }, onRefreshOptions: function(t2) {
          return false;
        }, onRefresh: function(t2) {
          return false;
        }, onResetView: function() {
          return false;
        }, onScrollBody: function() {
          return false;
        }, onTogglePagination: function(t2) {
          return false;
        }, onVirtualScroll: function(t2, e2) {
          return false;
        } }, ov = { formatLoadingMessage: function() {
          return "Loading, please wait";
        }, formatRecordsPerPage: function(t2) {
          return "".concat(t2, " rows per page");
        }, formatShowingRows: function(t2, e2, i2, n2) {
          return void 0 !== n2 && n2 > 0 && n2 > i2 ? "Showing ".concat(t2, " to ").concat(e2, " of ").concat(i2, " rows (filtered from ").concat(n2, " total rows)") : "Showing ".concat(t2, " to ").concat(e2, " of ").concat(i2, " rows");
        }, formatSRPaginationPreText: function() {
          return "previous page";
        }, formatSRPaginationPageText: function(t2) {
          return "to page ".concat(t2);
        }, formatSRPaginationNextText: function() {
          return "next page";
        }, formatDetailPagination: function(t2) {
          return "Showing ".concat(t2, " rows");
        }, formatSearch: function() {
          return "Search";
        }, formatClearSearch: function() {
          return "Clear Search";
        }, formatNoMatches: function() {
          return "No matching records found";
        }, formatPaginationSwitch: function() {
          return "Hide/Show pagination";
        }, formatPaginationSwitchDown: function() {
          return "Show pagination";
        }, formatPaginationSwitchUp: function() {
          return "Hide pagination";
        }, formatRefresh: function() {
          return "Refresh";
        }, formatToggle: function() {
          return "Toggle";
        }, formatToggleOn: function() {
          return "Show card view";
        }, formatToggleOff: function() {
          return "Hide card view";
        }, formatColumns: function() {
          return "Columns";
        }, formatColumnsToggleAll: function() {
          return "Toggle all";
        }, formatFullscreen: function() {
          return "Fullscreen";
        }, formatAllRows: function() {
          return "All";
        } }, av = { field: void 0, title: void 0, titleTooltip: void 0, class: void 0, width: void 0, widthUnit: "px", rowspan: void 0, colspan: void 0, align: void 0, halign: void 0, falign: void 0, valign: void 0, cellStyle: void 0, radio: false, checkbox: false, checkboxEnabled: true, clickToSelect: true, showSelectTitle: false, sortable: false, sortName: void 0, order: "asc", sorter: void 0, visible: true, switchable: true, cardVisible: true, searchable: true, formatter: void 0, footerFormatter: void 0, detailFormatter: void 0, searchFormatter: true, searchHighlightFormatter: false, escape: void 0, events: void 0 };
        Object.assign(nv, ov);
        var rv = { VERSION: "1.20.2", THEME: "bootstrap".concat(ev), CONSTANTS: iv, DEFAULTS: nv, COLUMN_DEFAULTS: av, METHODS: ["getOptions", "refreshOptions", "getData", "getSelections", "load", "append", "prepend", "remove", "removeAll", "insertRow", "updateRow", "getRowByUniqueId", "updateByUniqueId", "removeByUniqueId", "updateCell", "updateCellByUniqueId", "showRow", "hideRow", "getHiddenRows", "showColumn", "hideColumn", "getVisibleColumns", "getHiddenColumns", "showAllColumns", "hideAllColumns", "mergeCells", "checkAll", "uncheckAll", "checkInvert", "check", "uncheck", "checkBy", "uncheckBy", "refresh", "destroy", "resetView", "showLoading", "hideLoading", "togglePagination", "toggleFullscreen", "toggleView", "resetSearch", "filterBy", "scrollTo", "getScrollPosition", "selectPage", "prevPage", "nextPage", "toggleDetailView", "expandRow", "collapseRow", "expandRowByUniqueId", "collapseRowByUniqueId", "expandAllRows", "collapseAllRows", "updateColumnTitle", "updateFormatText"], EVENTS: { "all.bs.table": "onAll", "click-row.bs.table": "onClickRow", "dbl-click-row.bs.table": "onDblClickRow", "click-cell.bs.table": "onClickCell", "dbl-click-cell.bs.table": "onDblClickCell", "sort.bs.table": "onSort", "check.bs.table": "onCheck", "uncheck.bs.table": "onUncheck", "check-all.bs.table": "onCheckAll", "uncheck-all.bs.table": "onUncheckAll", "check-some.bs.table": "onCheckSome", "uncheck-some.bs.table": "onUncheckSome", "load-success.bs.table": "onLoadSuccess", "load-error.bs.table": "onLoadError", "column-switch.bs.table": "onColumnSwitch", "column-switch-all.bs.table": "onColumnSwitchAll", "page-change.bs.table": "onPageChange", "search.bs.table": "onSearch", "toggle.bs.table": "onToggle", "pre-body.bs.table": "onPreBody", "post-body.bs.table": "onPostBody", "post-header.bs.table": "onPostHeader", "post-footer.bs.table": "onPostFooter", "expand-row.bs.table": "onExpandRow", "collapse-row.bs.table": "onCollapseRow", "refresh-options.bs.table": "onRefreshOptions", "reset-view.bs.table": "onResetView", "refresh.bs.table": "onRefresh", "scroll-body.bs.table": "onScrollBody", "toggle-pagination.bs.table": "onTogglePagination", "virtual-scroll.bs.table": "onVirtualScroll" }, LOCALES: { en: ov, "en-US": ov } }, sv = function() {
          function t2(e2) {
            var i2 = this;
            o(this, t2), this.rows = e2.rows, this.scrollEl = e2.scrollEl, this.contentEl = e2.contentEl, this.callback = e2.callback, this.itemHeight = e2.itemHeight, this.cache = {}, this.scrollTop = this.scrollEl.scrollTop, this.initDOM(this.rows, e2.fixedScroll), this.scrollEl.scrollTop = this.scrollTop, this.lastCluster = 0;
            var n2 = function() {
              i2.lastCluster !== (i2.lastCluster = i2.getNum()) && (i2.initDOM(i2.rows), i2.callback(i2.startIndex, i2.endIndex));
            };
            this.scrollEl.addEventListener("scroll", n2, false), this.destroy = function() {
              i2.contentEl.innerHtml = "", i2.scrollEl.removeEventListener("scroll", n2, false);
            };
          }
          return r(t2, [{ key: "initDOM", value: function(t3, e2) {
            void 0 === this.clusterHeight && (this.cache.scrollTop = this.scrollEl.scrollTop, this.cache.data = this.contentEl.innerHTML = t3[0] + t3[0] + t3[0], this.getRowsHeight(t3));
            var i2 = this.initData(t3, this.getNum(e2)), n2 = i2.rows.join(""), o2 = this.checkChanges("data", n2), a2 = this.checkChanges("top", i2.topOffset), r2 = this.checkChanges("bottom", i2.bottomOffset), s2 = [];
            o2 && a2 ? (i2.topOffset && s2.push(this.getExtra("top", i2.topOffset)), s2.push(n2), i2.bottomOffset && s2.push(this.getExtra("bottom", i2.bottomOffset)), this.startIndex = i2.start, this.endIndex = i2.end, this.contentEl.innerHTML = s2.join(""), e2 && (this.contentEl.scrollTop = this.cache.scrollTop)) : r2 && (this.contentEl.lastChild.style.height = "".concat(i2.bottomOffset, "px"));
          } }, { key: "getRowsHeight", value: function() {
            if (void 0 === this.itemHeight) {
              var t3 = this.contentEl.children, e2 = t3[Math.floor(t3.length / 2)];
              this.itemHeight = e2.offsetHeight;
            }
            this.blockHeight = 50 * this.itemHeight, this.clusterRows = 200, this.clusterHeight = 4 * this.blockHeight;
          } }, { key: "getNum", value: function(t3) {
            return this.scrollTop = t3 ? this.cache.scrollTop : this.scrollEl.scrollTop, Math.floor(this.scrollTop / (this.clusterHeight - this.blockHeight)) || 0;
          } }, { key: "initData", value: function(t3, e2) {
            if (t3.length < 50)
              return { topOffset: 0, bottomOffset: 0, rowsAbove: 0, rows: t3 };
            var i2 = Math.max((this.clusterRows - 50) * e2, 0), n2 = i2 + this.clusterRows, o2 = Math.max(i2 * this.itemHeight, 0), a2 = Math.max((t3.length - n2) * this.itemHeight, 0), r2 = [], s2 = i2;
            o2 < 1 && s2++;
            for (var l2 = i2; l2 < n2; l2++)
              t3[l2] && r2.push(t3[l2]);
            return { start: i2, end: n2, topOffset: o2, bottomOffset: a2, rowsAbove: s2, rows: r2 };
          } }, { key: "checkChanges", value: function(t3, e2) {
            var i2 = e2 !== this.cache[t3];
            return this.cache[t3] = e2, i2;
          } }, { key: "getExtra", value: function(t3, e2) {
            var i2 = document.createElement("tr");
            return i2.className = "virtual-scroll-".concat(t3), e2 && (i2.style.height = "".concat(e2, "px")), i2.outerHTML;
          } }]), t2;
        }(), lv = function() {
          function t2(e2, n2) {
            o(this, t2), this.options = n2, this.$el = i.default(e2), this.$el_ = this.$el.clone(), this.timeoutId_ = 0, this.timeoutFooter_ = 0;
          }
          return r(t2, [{ key: "init", value: function() {
            this.initConstants(), this.initLocale(), this.initContainer(), this.initTable(), this.initHeader(), this.initData(), this.initHiddenRows(), this.initToolbar(), this.initPagination(), this.initBody(), this.initSearchText(), this.initServer();
          } }, { key: "initConstants", value: function() {
            var t3 = this.options;
            this.constants = rv.CONSTANTS, this.constants.theme = i.default.fn.bootstrapTable.theme, this.constants.dataToggle = this.constants.html.dataToggle || "data-toggle";
            var e2 = tv.getIconsPrefix(i.default.fn.bootstrapTable.theme), o2 = tv.getIcons(e2);
            "string" == typeof t3.icons && (t3.icons = tv.calculateObjectValue(null, t3.icons)), t3.iconsPrefix = t3.iconsPrefix || i.default.fn.bootstrapTable.defaults.iconsPrefix || e2, t3.icons = Object.assign(o2, i.default.fn.bootstrapTable.defaults.icons, t3.icons);
            var a2 = t3.buttonsPrefix ? "".concat(t3.buttonsPrefix, "-") : "";
            this.constants.buttonsClass = [t3.buttonsPrefix, a2 + t3.buttonsClass, tv.sprintf("".concat(a2, "%s"), t3.iconSize)].join(" ").trim(), this.buttons = tv.calculateObjectValue(this, t3.buttons, [], {}), "object" !== n(this.buttons) && (this.buttons = {});
          } }, { key: "initLocale", value: function() {
            if (this.options.locale) {
              var e2 = i.default.fn.bootstrapTable.locales, n2 = this.options.locale.split(/-|_/);
              n2[0] = n2[0].toLowerCase(), n2[1] && (n2[1] = n2[1].toUpperCase());
              var o2 = {};
              e2[this.options.locale] ? o2 = e2[this.options.locale] : e2[n2.join("-")] ? o2 = e2[n2.join("-")] : e2[n2[0]] && (o2 = e2[n2[0]]);
              for (var a2 = 0, r2 = Object.entries(o2); a2 < r2.length; a2++) {
                var l2 = s(r2[a2], 2), c2 = l2[0], h2 = l2[1];
                this.options[c2] === t2.DEFAULTS[c2] && (this.options[c2] = h2);
              }
            }
          } }, { key: "initContainer", value: function() {
            var t3 = ["top", "both"].includes(this.options.paginationVAlign) ? '<div class="fixed-table-pagination clearfix"></div>' : "", e2 = ["bottom", "both"].includes(this.options.paginationVAlign) ? '<div class="fixed-table-pagination"></div>' : "", n2 = tv.calculateObjectValue(this.options, this.options.loadingTemplate, [this.options.formatLoadingMessage()]);
            this.$container = i.default('\n      <div class="bootstrap-table '.concat(this.constants.theme, '">\n      <div class="fixed-table-toolbar"></div>\n      ').concat(t3, '\n      <div class="fixed-table-container">\n      <div class="fixed-table-header"><table></table></div>\n      <div class="fixed-table-body">\n      <div class="fixed-table-loading">\n      ').concat(n2, '\n      </div>\n      </div>\n      <div class="fixed-table-footer"></div>\n      </div>\n      ').concat(e2, "\n      </div>\n    ")), this.$container.insertAfter(this.$el), this.$tableContainer = this.$container.find(".fixed-table-container"), this.$tableHeader = this.$container.find(".fixed-table-header"), this.$tableBody = this.$container.find(".fixed-table-body"), this.$tableLoading = this.$container.find(".fixed-table-loading"), this.$tableFooter = this.$el.find("tfoot"), this.options.buttonsToolbar ? this.$toolbar = i.default("body").find(this.options.buttonsToolbar) : this.$toolbar = this.$container.find(".fixed-table-toolbar"), this.$pagination = this.$container.find(".fixed-table-pagination"), this.$tableBody.append(this.$el), this.$container.after('<div class="clearfix"></div>'), this.$el.addClass(this.options.classes), this.$tableLoading.addClass(this.options.classes), this.options.height && (this.$tableContainer.addClass("fixed-height"), this.options.showFooter && this.$tableContainer.addClass("has-footer"), this.options.classes.split(" ").includes("table-bordered") && (this.$tableBody.append('<div class="fixed-table-border"></div>'), this.$tableBorder = this.$tableBody.find(".fixed-table-border"), this.$tableLoading.addClass("fixed-table-border")), this.$tableFooter = this.$container.find(".fixed-table-footer"));
          } }, { key: "initTable", value: function() {
            var e2 = this, n2 = [];
            if (this.$header = this.$el.find(">thead"), this.$header.length ? this.options.theadClasses && this.$header.addClass(this.options.theadClasses) : this.$header = i.default('<thead class="'.concat(this.options.theadClasses, '"></thead>')).appendTo(this.$el), this._headerTrClasses = [], this._headerTrStyles = [], this.$header.find("tr").each(function(t3, o3) {
              var a2 = i.default(o3), r2 = [];
              a2.find("th").each(function(t4, e3) {
                var n3 = i.default(e3);
                void 0 !== n3.data("field") && n3.data("field", "".concat(n3.data("field"))), r2.push(i.default.extend({}, { title: n3.html(), class: n3.attr("class"), titleTooltip: n3.attr("title"), rowspan: n3.attr("rowspan") ? +n3.attr("rowspan") : void 0, colspan: n3.attr("colspan") ? +n3.attr("colspan") : void 0 }, n3.data()));
              }), n2.push(r2), a2.attr("class") && e2._headerTrClasses.push(a2.attr("class")), a2.attr("style") && e2._headerTrStyles.push(a2.attr("style"));
            }), Array.isArray(this.options.columns[0]) || (this.options.columns = [this.options.columns]), this.options.columns = i.default.extend(true, [], n2, this.options.columns), this.columns = [], this.fieldsColumnsIndex = [], tv.setFieldIndex(this.options.columns), this.options.columns.forEach(function(n3, o3) {
              n3.forEach(function(n4, a2) {
                var r2 = i.default.extend({}, t2.COLUMN_DEFAULTS, n4);
                void 0 !== r2.fieldIndex && (e2.columns[r2.fieldIndex] = r2, e2.fieldsColumnsIndex[r2.field] = r2.fieldIndex), e2.options.columns[o3][a2] = r2;
              });
            }), !this.options.data.length) {
              var o2 = tv.trToData(this.columns, this.$el.find(">tbody>tr"));
              o2.length && (this.options.data = o2, this.fromHtml = true);
            }
            this.options.pagination && "server" !== this.options.sidePagination || (this.footerData = tv.trToData(this.columns, this.$el.find(">tfoot>tr"))), this.footerData && this.$el.find("tfoot").html("<tr></tr>"), !this.options.showFooter || this.options.cardView ? this.$tableFooter.hide() : this.$tableFooter.show();
          } }, { key: "initHeader", value: function() {
            var t3 = this, e2 = {}, n2 = [];
            this.header = { fields: [], styles: [], classes: [], formatters: [], detailFormatters: [], events: [], sorters: [], sortNames: [], cellStyles: [], searchables: [] }, tv.updateFieldGroup(this.options.columns, this.columns), this.options.columns.forEach(function(i2, o3) {
              var a2 = [];
              a2.push("<tr".concat(tv.sprintf(' class="%s"', t3._headerTrClasses[o3]), " ").concat(tv.sprintf(' style="%s"', t3._headerTrStyles[o3]), ">"));
              var r2 = "";
              if (0 === o3 && tv.hasDetailViewIcon(t3.options)) {
                var l2 = t3.options.columns.length > 1 ? ' rowspan="'.concat(t3.options.columns.length, '"') : "";
                r2 = '<th class="detail"'.concat(l2, '>\n          <div class="fht-cell"></div>\n          </th>');
              }
              r2 && "right" !== t3.options.detailViewAlign && a2.push(r2), i2.forEach(function(i3, n3) {
                var r3 = tv.sprintf(' class="%s"', i3.class), l3 = i3.widthUnit, c2 = parseFloat(i3.width), h2 = tv.sprintf("text-align: %s; ", i3.halign ? i3.halign : i3.align), u2 = tv.sprintf("text-align: %s; ", i3.align), d2 = tv.sprintf("vertical-align: %s; ", i3.valign);
                if (d2 += tv.sprintf("width: %s; ", !i3.checkbox && !i3.radio || c2 ? c2 ? c2 + l3 : void 0 : i3.showSelectTitle ? void 0 : "36px"), void 0 !== i3.fieldIndex || i3.visible) {
                  var f2 = tv.calculateObjectValue(null, t3.options.headerStyle, [i3]), p2 = [], g2 = "";
                  if (f2 && f2.css)
                    for (var v2 = 0, b2 = Object.entries(f2.css); v2 < b2.length; v2++) {
                      var m2 = s(b2[v2], 2), y2 = m2[0], w2 = m2[1];
                      p2.push("".concat(y2, ": ").concat(w2));
                    }
                  if (f2 && f2.classes && (g2 = tv.sprintf(' class="%s"', i3.class ? [i3.class, f2.classes].join(" ") : f2.classes)), void 0 !== i3.fieldIndex) {
                    if (t3.header.fields[i3.fieldIndex] = i3.field, t3.header.styles[i3.fieldIndex] = u2 + d2, t3.header.classes[i3.fieldIndex] = r3, t3.header.formatters[i3.fieldIndex] = i3.formatter, t3.header.detailFormatters[i3.fieldIndex] = i3.detailFormatter, t3.header.events[i3.fieldIndex] = i3.events, t3.header.sorters[i3.fieldIndex] = i3.sorter, t3.header.sortNames[i3.fieldIndex] = i3.sortName, t3.header.cellStyles[i3.fieldIndex] = i3.cellStyle, t3.header.searchables[i3.fieldIndex] = i3.searchable, !i3.visible)
                      return;
                    if (t3.options.cardView && !i3.cardVisible)
                      return;
                    e2[i3.field] = i3;
                  }
                  a2.push("<th".concat(tv.sprintf(' title="%s"', i3.titleTooltip)), i3.checkbox || i3.radio ? tv.sprintf(' class="bs-checkbox %s"', i3.class || "") : g2 || r3, tv.sprintf(' style="%s"', h2 + d2 + p2.join("; ")), tv.sprintf(' rowspan="%s"', i3.rowspan), tv.sprintf(' colspan="%s"', i3.colspan), tv.sprintf(' data-field="%s"', i3.field), 0 === n3 && o3 > 0 ? " data-not-first-th" : "", ">"), a2.push(tv.sprintf('<div class="th-inner %s">', t3.options.sortable && i3.sortable ? "sortable both" : ""));
                  var S2 = t3.options.escape ? tv.escapeHTML(i3.title) : i3.title, x2 = S2;
                  i3.checkbox && (S2 = "", !t3.options.singleSelect && t3.options.checkboxHeader && (S2 = '<label><input name="btSelectAll" type="checkbox" /><span></span></label>'), t3.header.stateField = i3.field), i3.radio && (S2 = "", t3.header.stateField = i3.field), !S2 && i3.showSelectTitle && (S2 += x2), a2.push(S2), a2.push("</div>"), a2.push('<div class="fht-cell"></div>'), a2.push("</div>"), a2.push("</th>");
                }
              }), r2 && "right" === t3.options.detailViewAlign && a2.push(r2), a2.push("</tr>"), a2.length > 3 && n2.push(a2.join(""));
            }), this.$header.html(n2.join("")), this.$header.find("th[data-field]").each(function(t4, n3) {
              i.default(n3).data(e2[i.default(n3).data("field")]);
            }), this.$container.off("click", ".th-inner").on("click", ".th-inner", function(e3) {
              var n3 = i.default(e3.currentTarget);
              if (t3.options.detailView && !n3.parent().hasClass("bs-checkbox") && n3.closest(".bootstrap-table")[0] !== t3.$container[0])
                return false;
              t3.options.sortable && n3.parent().data().sortable && t3.onSort(e3);
            });
            var o2 = tv.getEventName("resize.bootstrap-table", this.$el.attr("id"));
            i.default(window).off(o2), !this.options.showHeader || this.options.cardView ? (this.$header.hide(), this.$tableHeader.hide(), this.$tableLoading.css("top", 0)) : (this.$header.show(), this.$tableHeader.show(), this.$tableLoading.css("top", this.$header.outerHeight() + 1), this.getCaret(), i.default(window).on(o2, function() {
              return t3.resetView();
            })), this.$selectAll = this.$header.find('[name="btSelectAll"]'), this.$selectAll.off("click").on("click", function(e3) {
              e3.stopPropagation();
              var n3 = i.default(e3.currentTarget).prop("checked");
              t3[n3 ? "checkAll" : "uncheckAll"](), t3.updateSelected();
            });
          } }, { key: "initData", value: function(t3, e2) {
            "append" === e2 ? this.options.data = this.options.data.concat(t3) : "prepend" === e2 ? this.options.data = [].concat(t3).concat(this.options.data) : (t3 = t3 || tv.deepCopy(this.options.data), this.options.data = Array.isArray(t3) ? t3 : t3[this.options.dataField]), this.data = l(this.options.data), this.options.sortReset && (this.unsortedData = l(this.data)), "server" !== this.options.sidePagination && this.initSort();
          } }, { key: "initSort", value: function() {
            var t3 = this, e2 = this.options.sortName, i2 = "desc" === this.options.sortOrder ? -1 : 1, n2 = this.header.fields.indexOf(this.options.sortName), o2 = 0;
            -1 !== n2 ? (this.options.sortStable && this.data.forEach(function(t4, e3) {
              t4.hasOwnProperty("_position") || (t4._position = e3);
            }), this.options.customSort ? tv.calculateObjectValue(this.options, this.options.customSort, [this.options.sortName, this.options.sortOrder, this.data]) : this.data.sort(function(o3, a2) {
              t3.header.sortNames[n2] && (e2 = t3.header.sortNames[n2]);
              var r2 = tv.getItemField(o3, e2, t3.options.escape), s2 = tv.getItemField(a2, e2, t3.options.escape), l2 = tv.calculateObjectValue(t3.header, t3.header.sorters[n2], [r2, s2, o3, a2]);
              return void 0 !== l2 ? t3.options.sortStable && 0 === l2 ? i2 * (o3._position - a2._position) : i2 * l2 : tv.sort(r2, s2, i2, t3.options.sortStable, o3._position, a2._position);
            }), void 0 !== this.options.sortClass && (clearTimeout(o2), o2 = setTimeout(function() {
              t3.$el.removeClass(t3.options.sortClass);
              var e3 = t3.$header.find('[data-field="'.concat(t3.options.sortName, '"]')).index();
              t3.$el.find("tr td:nth-child(".concat(e3 + 1, ")")).addClass(t3.options.sortClass);
            }, 250))) : this.options.sortReset && (this.data = l(this.unsortedData));
          } }, { key: "onSort", value: function(t3) {
            var e2 = t3.type, n2 = t3.currentTarget, o2 = "keypress" === e2 ? i.default(n2) : i.default(n2).parent(), a2 = this.$header.find("th").eq(o2.index());
            if (this.$header.add(this.$header_).find("span.order").remove(), this.options.sortName === o2.data("field")) {
              var r2 = this.options.sortOrder;
              void 0 === r2 ? this.options.sortOrder = "asc" : "asc" === r2 ? this.options.sortOrder = "desc" : "desc" === this.options.sortOrder && (this.options.sortOrder = this.options.sortReset ? void 0 : "asc"), void 0 === this.options.sortOrder && (this.options.sortName = void 0);
            } else
              this.options.sortName = o2.data("field"), this.options.rememberOrder ? this.options.sortOrder = "asc" === o2.data("order") ? "desc" : "asc" : this.options.sortOrder = this.columns[this.fieldsColumnsIndex[o2.data("field")]].sortOrder || this.columns[this.fieldsColumnsIndex[o2.data("field")]].order;
            if (this.trigger("sort", this.options.sortName, this.options.sortOrder), o2.add(a2).data("order", this.options.sortOrder), this.getCaret(), "server" === this.options.sidePagination && this.options.serverSort)
              return this.options.pageNumber = 1, void this.initServer(this.options.silentSort);
            this.initSort(), this.initBody();
          } }, { key: "initToolbar", value: function() {
            var t3, e2 = this, o2 = this.options, a2 = [], r2 = 0, l2 = 0;
            this.$toolbar.find(".bs-bars").children().length && i.default("body").append(i.default(o2.toolbar)), this.$toolbar.html(""), "string" != typeof o2.toolbar && "object" !== n(o2.toolbar) || i.default(tv.sprintf('<div class="bs-bars %s-%s"></div>', this.constants.classes.pull, o2.toolbarAlign)).appendTo(this.$toolbar).append(i.default(o2.toolbar)), a2 = ['<div class="'.concat(["columns", "columns-".concat(o2.buttonsAlign), this.constants.classes.buttonsGroup, "".concat(this.constants.classes.pull, "-").concat(o2.buttonsAlign)].join(" "), '">')], "string" == typeof o2.buttonsOrder && (o2.buttonsOrder = o2.buttonsOrder.replace(/\[|\]| |'/g, "").split(",")), this.buttons = Object.assign(this.buttons, { paginationSwitch: { text: o2.pagination ? o2.formatPaginationSwitchUp() : o2.formatPaginationSwitchDown(), icon: o2.pagination ? o2.icons.paginationSwitchDown : o2.icons.paginationSwitchUp, render: false, event: this.togglePagination, attributes: { "aria-label": o2.formatPaginationSwitch(), title: o2.formatPaginationSwitch() } }, refresh: { text: o2.formatRefresh(), icon: o2.icons.refresh, render: false, event: this.refresh, attributes: { "aria-label": o2.formatRefresh(), title: o2.formatRefresh() } }, toggle: { text: o2.formatToggle(), icon: o2.icons.toggleOff, render: false, event: this.toggleView, attributes: { "aria-label": o2.formatToggleOn(), title: o2.formatToggleOn() } }, fullscreen: { text: o2.formatFullscreen(), icon: o2.icons.fullscreen, render: false, event: this.toggleFullscreen, attributes: { "aria-label": o2.formatFullscreen(), title: o2.formatFullscreen() } }, columns: { render: false, html: function() {
              var t4 = [];
              if (t4.push('<div class="keep-open '.concat(e2.constants.classes.buttonsDropdown, '" title="').concat(o2.formatColumns(), '">\n            <button class="').concat(e2.constants.buttonsClass, ' dropdown-toggle" type="button" ').concat(e2.constants.dataToggle, '="dropdown"\n            aria-label="Columns" title="').concat(o2.formatColumns(), '">\n            ').concat(o2.showButtonIcons ? tv.sprintf(e2.constants.html.icon, o2.iconsPrefix, o2.icons.columns) : "", "\n            ").concat(o2.showButtonText ? o2.formatColumns() : "", "\n            ").concat(e2.constants.html.dropdownCaret, "\n            </button>\n            ").concat(e2.constants.html.toolbarDropdown[0])), o2.showColumnsSearch && (t4.push(tv.sprintf(e2.constants.html.toolbarDropdownItem, tv.sprintf('<input type="text" class="%s" name="columnsSearch" placeholder="%s" autocomplete="off">', e2.constants.classes.input, o2.formatSearch()))), t4.push(e2.constants.html.toolbarDropdownSeparator)), o2.showColumnsToggleAll) {
                var i2 = e2.getVisibleColumns().length === e2.columns.filter(function(t5) {
                  return !e2.isSelectionColumn(t5);
                }).length;
                t4.push(tv.sprintf(e2.constants.html.toolbarDropdownItem, tv.sprintf('<input type="checkbox" class="toggle-all" %s> <span>%s</span>', i2 ? 'checked="checked"' : "", o2.formatColumnsToggleAll()))), t4.push(e2.constants.html.toolbarDropdownSeparator);
              }
              var n2 = 0;
              return e2.columns.forEach(function(t5) {
                t5.visible && n2++;
              }), e2.columns.forEach(function(i3, a3) {
                if (!e2.isSelectionColumn(i3) && (!o2.cardView || i3.cardVisible)) {
                  var r3 = i3.visible ? ' checked="checked"' : "", s2 = n2 <= o2.minimumCountColumns && r3 ? ' disabled="disabled"' : "";
                  i3.switchable && (t4.push(tv.sprintf(e2.constants.html.toolbarDropdownItem, tv.sprintf('<input type="checkbox" data-field="%s" value="%s"%s%s> <span>%s</span>', i3.field, a3, r3, s2, i3.title))), l2++);
                }
              }), t4.push(e2.constants.html.toolbarDropdown[1], "</div>"), t4.join("");
            } } });
            for (var c2 = {}, h2 = 0, d2 = Object.entries(this.buttons); h2 < d2.length; h2++) {
              var f2 = s(d2[h2], 2), p2 = f2[0], g2 = f2[1], v2 = void 0;
              if (g2.hasOwnProperty("html"))
                "function" == typeof g2.html ? v2 = g2.html() : "string" == typeof g2.html && (v2 = g2.html);
              else {
                if (v2 = '<button class="'.concat(this.constants.buttonsClass, '" type="button" name="').concat(p2, '"'), g2.hasOwnProperty("attributes"))
                  for (var b2 = 0, m2 = Object.entries(g2.attributes); b2 < m2.length; b2++) {
                    var y2 = s(m2[b2], 2), w2 = y2[0], S2 = y2[1];
                    v2 += " ".concat(w2, '="').concat(S2, '"');
                  }
                v2 += ">", o2.showButtonIcons && g2.hasOwnProperty("icon") && (v2 += "".concat(tv.sprintf(this.constants.html.icon, o2.iconsPrefix, g2.icon), " ")), o2.showButtonText && g2.hasOwnProperty("text") && (v2 += g2.text), v2 += "</button>";
              }
              c2[p2] = v2;
              var x2 = "show".concat(p2.charAt(0).toUpperCase()).concat(p2.substring(1)), k2 = o2[x2];
              !(!g2.hasOwnProperty("render") || g2.hasOwnProperty("render") && g2.render) || void 0 !== k2 && true !== k2 || (o2[x2] = true), o2.buttonsOrder.includes(p2) || o2.buttonsOrder.push(p2);
            }
            var O2, C2 = u(o2.buttonsOrder);
            try {
              for (C2.s(); !(O2 = C2.n()).done; ) {
                var T2 = O2.value;
                o2["show".concat(T2.charAt(0).toUpperCase()).concat(T2.substring(1))] && a2.push(c2[T2]);
              }
            } catch (t4) {
              C2.e(t4);
            } finally {
              C2.f();
            }
            a2.push("</div>"), (this.showToolbar || a2.length > 2) && this.$toolbar.append(a2.join(""));
            for (var P2 = 0, I2 = Object.entries(this.buttons); P2 < I2.length; P2++) {
              var A2 = s(I2[P2], 2), $3 = A2[0], R2 = A2[1];
              if (R2.hasOwnProperty("event")) {
                if ("function" == typeof R2.event || "string" == typeof R2.event) {
                  if ("continue" === function() {
                    var t4 = "string" == typeof R2.event ? window[R2.event] : R2.event;
                    return e2.$toolbar.find('button[name="'.concat($3, '"]')).off("click").on("click", function() {
                      return t4.call(e2);
                    }), "continue";
                  }())
                    continue;
                }
                for (var E2 = function() {
                  var t4 = s(F2[j2], 2), i2 = t4[0], n2 = t4[1], o3 = "string" == typeof n2 ? window[n2] : n2;
                  e2.$toolbar.find('button[name="'.concat($3, '"]')).off(i2).on(i2, function() {
                    return o3.call(e2);
                  });
                }, j2 = 0, F2 = Object.entries(R2.event); j2 < F2.length; j2++)
                  E2();
              }
            }
            if (o2.showColumns) {
              var _2 = (t3 = this.$toolbar.find(".keep-open")).find('input[type="checkbox"]:not(".toggle-all")'), N2 = t3.find('input[type="checkbox"].toggle-all');
              if (l2 <= o2.minimumCountColumns && t3.find("input").prop("disabled", true), t3.find("li, label").off("click").on("click", function(t4) {
                t4.stopImmediatePropagation();
              }), _2.off("click").on("click", function(t4) {
                var n2 = t4.currentTarget, o3 = i.default(n2);
                e2._toggleColumn(o3.val(), o3.prop("checked"), false), e2.trigger("column-switch", o3.data("field"), o3.prop("checked")), N2.prop("checked", _2.filter(":checked").length === e2.columns.filter(function(t5) {
                  return !e2.isSelectionColumn(t5);
                }).length);
              }), N2.off("click").on("click", function(t4) {
                var n2 = t4.currentTarget;
                e2._toggleAllColumns(i.default(n2).prop("checked")), e2.trigger("column-switch-all", i.default(n2).prop("checked"));
              }), o2.showColumnsSearch) {
                var D2 = t3.find('[name="columnsSearch"]'), V2 = t3.find(".dropdown-item-marker");
                D2.on("keyup paste change", function(t4) {
                  var e3 = t4.currentTarget, n2 = i.default(e3).val().toLowerCase();
                  V2.show(), _2.each(function(t5, e4) {
                    var o3 = i.default(e4).parents(".dropdown-item-marker");
                    o3.text().toLowerCase().includes(n2) || o3.hide();
                  });
                });
              }
            }
            var B2 = function(t4) {
              var i2 = "keyup drop blur mouseup";
              t4.off(i2).on(i2, function(t5) {
                o2.searchOnEnterKey && 13 !== t5.keyCode || [37, 38, 39, 40].includes(t5.keyCode) || (clearTimeout(r2), r2 = setTimeout(function() {
                  e2.onSearch({ currentTarget: t5.currentTarget });
                }, o2.searchTimeOut));
              });
            };
            if ((o2.search || this.showSearchClearButton) && "string" != typeof o2.searchSelector) {
              a2 = [];
              var L4 = tv.sprintf(this.constants.html.searchButton, this.constants.buttonsClass, o2.formatSearch(), o2.showButtonIcons ? tv.sprintf(this.constants.html.icon, o2.iconsPrefix, o2.icons.search) : "", o2.showButtonText ? o2.formatSearch() : ""), H2 = tv.sprintf(this.constants.html.searchClearButton, this.constants.buttonsClass, o2.formatClearSearch(), o2.showButtonIcons ? tv.sprintf(this.constants.html.icon, o2.iconsPrefix, o2.icons.clearSearch) : "", o2.showButtonText ? o2.formatClearSearch() : ""), M2 = '<input class="'.concat(this.constants.classes.input, "\n        ").concat(tv.sprintf(" %s%s", this.constants.classes.inputPrefix, o2.iconSize), '\n        search-input" type="search" placeholder="').concat(o2.formatSearch(), '" autocomplete="off">'), U2 = M2;
              if (o2.showSearchButton || o2.showSearchClearButton) {
                var z2 = (o2.showSearchButton ? L4 : "") + (o2.showSearchClearButton ? H2 : "");
                U2 = o2.search ? tv.sprintf(this.constants.html.inputGroup, M2, z2) : z2;
              }
              a2.push(tv.sprintf('\n        <div class="'.concat(this.constants.classes.pull, "-").concat(o2.searchAlign, " search ").concat(this.constants.classes.inputGroup, '">\n          %s\n        </div>\n      '), U2)), this.$toolbar.append(a2.join(""));
              var q2 = tv.getSearchInput(this);
              o2.showSearchButton ? (this.$toolbar.find(".search button[name=search]").off("click").on("click", function() {
                clearTimeout(r2), r2 = setTimeout(function() {
                  e2.onSearch({ currentTarget: q2 });
                }, o2.searchTimeOut);
              }), o2.searchOnEnterKey && B2(q2)) : B2(q2), o2.showSearchClearButton && this.$toolbar.find(".search button[name=clearSearch]").click(function() {
                e2.resetSearch();
              });
            } else if ("string" == typeof o2.searchSelector) {
              B2(tv.getSearchInput(this));
            }
          } }, { key: "onSearch", value: function() {
            var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e2 = t3.currentTarget, n2 = t3.firedByInitSearchText, o2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            if (void 0 !== e2 && i.default(e2).length && o2) {
              var a2 = i.default(e2).val().trim();
              if (this.options.trimOnSearch && i.default(e2).val() !== a2 && i.default(e2).val(a2), this.searchText === a2)
                return;
              var r2 = tv.getSearchInput(this), s2 = e2 instanceof jQuery ? e2 : i.default(e2);
              (s2.is(r2) || s2.hasClass("search-input")) && (this.searchText = a2, this.options.searchText = a2);
            }
            n2 || this.options.cookie || (this.options.pageNumber = 1), this.initSearch(), n2 ? "client" === this.options.sidePagination && this.updatePagination() : this.updatePagination(), this.trigger("search", this.searchText);
          } }, { key: "initSearch", value: function() {
            var t3 = this;
            if (this.filterOptions = this.filterOptions || this.options.filterOptions, "server" !== this.options.sidePagination) {
              if (this.options.customSearch)
                return this.data = tv.calculateObjectValue(this.options, this.options.customSearch, [this.options.data, this.searchText, this.filterColumns]), void (this.options.sortReset && (this.unsortedData = l(this.data)));
              var e2 = this.searchText && (this.fromHtml ? tv.escapeHTML(this.searchText) : this.searchText), i2 = e2 ? e2.toLowerCase() : "", n2 = tv.isEmptyObject(this.filterColumns) ? null : this.filterColumns;
              this.options.searchAccentNeutralise && (i2 = tv.normalizeAccent(i2)), "function" == typeof this.filterOptions.filterAlgorithm ? this.data = this.options.data.filter(function(e3) {
                return t3.filterOptions.filterAlgorithm.apply(null, [e3, n2]);
              }) : "string" == typeof this.filterOptions.filterAlgorithm && (this.data = n2 ? this.options.data.filter(function(e3) {
                var i3 = t3.filterOptions.filterAlgorithm;
                if ("and" === i3) {
                  for (var o3 in n2)
                    if (Array.isArray(n2[o3]) && !n2[o3].includes(e3[o3]) || !Array.isArray(n2[o3]) && e3[o3] !== n2[o3])
                      return false;
                } else if ("or" === i3) {
                  var a2 = false;
                  for (var r2 in n2)
                    (Array.isArray(n2[r2]) && n2[r2].includes(e3[r2]) || !Array.isArray(n2[r2]) && e3[r2] === n2[r2]) && (a2 = true);
                  return a2;
                }
                return true;
              }) : l(this.options.data));
              var o2 = this.getVisibleFields();
              this.data = i2 ? this.data.filter(function(n3, a2) {
                for (var r2 = 0; r2 < t3.header.fields.length; r2++)
                  if (t3.header.searchables[r2] && (!t3.options.visibleSearch || -1 !== o2.indexOf(t3.header.fields[r2]))) {
                    var s2 = tv.isNumeric(t3.header.fields[r2]) ? parseInt(t3.header.fields[r2], 10) : t3.header.fields[r2], l2 = t3.columns[t3.fieldsColumnsIndex[s2]], c2 = void 0;
                    if ("string" == typeof s2) {
                      c2 = n3;
                      for (var h2 = s2.split("."), u2 = 0; u2 < h2.length; u2++)
                        null !== c2[h2[u2]] && (c2 = c2[h2[u2]]);
                    } else
                      c2 = n3[s2];
                    if (t3.options.searchAccentNeutralise && (c2 = tv.normalizeAccent(c2)), l2 && l2.searchFormatter && (c2 = tv.calculateObjectValue(l2, t3.header.formatters[r2], [c2, n3, a2, l2.field], c2)), "string" == typeof c2 || "number" == typeof c2) {
                      if (t3.options.strictSearch && "".concat(c2).toLowerCase() === i2 || t3.options.regexSearch && tv.regexCompare(c2, e2))
                        return true;
                      var d2 = /(?:(<=|=>|=<|>=|>|<)(?:\s+)?(-?\d+)?|(-?\d+)?(\s+)?(<=|=>|=<|>=|>|<))/gm.exec(t3.searchText), f2 = false;
                      if (d2) {
                        var p2 = d2[1] || "".concat(d2[5], "l"), g2 = d2[2] || d2[3], v2 = parseInt(c2, 10), b2 = parseInt(g2, 10);
                        switch (p2) {
                          case ">":
                          case "<l":
                            f2 = v2 > b2;
                            break;
                          case "<":
                          case ">l":
                            f2 = v2 < b2;
                            break;
                          case "<=":
                          case "=<":
                          case ">=l":
                          case "=>l":
                            f2 = v2 <= b2;
                            break;
                          case ">=":
                          case "=>":
                          case "<=l":
                          case "=<l":
                            f2 = v2 >= b2;
                        }
                      }
                      if (f2 || "".concat(c2).toLowerCase().includes(i2))
                        return true;
                    }
                  }
                return false;
              }) : this.data, this.options.sortReset && (this.unsortedData = l(this.data)), this.initSort();
            }
          } }, { key: "initPagination", value: function() {
            var t3 = this, e2 = this.options;
            if (e2.pagination) {
              this.$pagination.show();
              var i2, n2, o2, a2, r2, s2, l2, c2 = [], h2 = false, u2 = this.getData({ includeHiddenRows: false }), d2 = e2.pageList;
              if ("string" == typeof d2 && (d2 = d2.replace(/\[|\]| /g, "").toLowerCase().split(",")), d2 = d2.map(function(t4) {
                return "string" == typeof t4 ? t4.toLowerCase() === e2.formatAllRows().toLowerCase() || ["all", "unlimited"].includes(t4.toLowerCase()) ? e2.formatAllRows() : +t4 : t4;
              }), this.paginationParts = e2.paginationParts, "string" == typeof this.paginationParts && (this.paginationParts = this.paginationParts.replace(/\[|\]| |'/g, "").split(",")), "server" !== e2.sidePagination && (e2.totalRows = u2.length), this.totalPages = 0, e2.totalRows && (e2.pageSize === e2.formatAllRows() && (e2.pageSize = e2.totalRows, h2 = true), this.totalPages = 1 + ~~((e2.totalRows - 1) / e2.pageSize), e2.totalPages = this.totalPages), this.totalPages > 0 && e2.pageNumber > this.totalPages && (e2.pageNumber = this.totalPages), this.pageFrom = (e2.pageNumber - 1) * e2.pageSize + 1, this.pageTo = e2.pageNumber * e2.pageSize, this.pageTo > e2.totalRows && (this.pageTo = e2.totalRows), this.options.pagination && "server" !== this.options.sidePagination && (this.options.totalNotFiltered = this.options.data.length), this.options.showExtendedPagination || (this.options.totalNotFiltered = void 0), (this.paginationParts.includes("pageInfo") || this.paginationParts.includes("pageInfoShort") || this.paginationParts.includes("pageSize")) && c2.push('<div class="'.concat(this.constants.classes.pull, "-").concat(e2.paginationDetailHAlign, ' pagination-detail">')), this.paginationParts.includes("pageInfo") || this.paginationParts.includes("pageInfoShort")) {
                var f2 = this.paginationParts.includes("pageInfoShort") ? e2.formatDetailPagination(e2.totalRows) : e2.formatShowingRows(this.pageFrom, this.pageTo, e2.totalRows, e2.totalNotFiltered);
                c2.push('<span class="pagination-info">\n      '.concat(f2, "\n      </span>"));
              }
              if (this.paginationParts.includes("pageSize")) {
                c2.push('<div class="page-list">');
                var p2 = ['<div class="'.concat(this.constants.classes.paginationDropdown, '">\n        <button class="').concat(this.constants.buttonsClass, ' dropdown-toggle" type="button" ').concat(this.constants.dataToggle, '="dropdown">\n        <span class="page-size">\n        ').concat(h2 ? e2.formatAllRows() : e2.pageSize, "\n        </span>\n        ").concat(this.constants.html.dropdownCaret, "\n        </button>\n        ").concat(this.constants.html.pageDropdown[0])];
                d2.forEach(function(i3, n3) {
                  var o3;
                  (!e2.smartDisplay || 0 === n3 || d2[n3 - 1] < e2.totalRows || i3 === e2.formatAllRows()) && (o3 = h2 ? i3 === e2.formatAllRows() ? t3.constants.classes.dropdownActive : "" : i3 === e2.pageSize ? t3.constants.classes.dropdownActive : "", p2.push(tv.sprintf(t3.constants.html.pageDropdownItem, o3, i3)));
                }), p2.push("".concat(this.constants.html.pageDropdown[1], "</div>")), c2.push(e2.formatRecordsPerPage(p2.join("")));
              }
              if ((this.paginationParts.includes("pageInfo") || this.paginationParts.includes("pageInfoShort") || this.paginationParts.includes("pageSize")) && c2.push("</div></div>"), this.paginationParts.includes("pageList")) {
                c2.push('<div class="'.concat(this.constants.classes.pull, "-").concat(e2.paginationHAlign, ' pagination">'), tv.sprintf(this.constants.html.pagination[0], tv.sprintf(" pagination-%s", e2.iconSize)), tv.sprintf(this.constants.html.paginationItem, " page-pre", e2.formatSRPaginationPreText(), e2.paginationPreText)), this.totalPages < e2.paginationSuccessivelySize ? (n2 = 1, o2 = this.totalPages) : o2 = (n2 = e2.pageNumber - e2.paginationPagesBySide) + 2 * e2.paginationPagesBySide, e2.pageNumber < e2.paginationSuccessivelySize - 1 && (o2 = e2.paginationSuccessivelySize), e2.paginationSuccessivelySize > this.totalPages - n2 && (n2 = n2 - (e2.paginationSuccessivelySize - (this.totalPages - n2)) + 1), n2 < 1 && (n2 = 1), o2 > this.totalPages && (o2 = this.totalPages);
                var g2 = Math.round(e2.paginationPagesBySide / 2), v2 = function(i3) {
                  var n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
                  return tv.sprintf(t3.constants.html.paginationItem, n3 + (i3 === e2.pageNumber ? " ".concat(t3.constants.classes.paginationActive) : ""), e2.formatSRPaginationPageText(i3), i3);
                };
                if (n2 > 1) {
                  var b2 = e2.paginationPagesBySide;
                  for (b2 >= n2 && (b2 = n2 - 1), i2 = 1; i2 <= b2; i2++)
                    c2.push(v2(i2));
                  n2 - 1 === b2 + 1 ? (i2 = n2 - 1, c2.push(v2(i2))) : n2 - 1 > b2 && (n2 - 2 * e2.paginationPagesBySide > e2.paginationPagesBySide && e2.paginationUseIntermediate ? (i2 = Math.round((n2 - g2) / 2 + g2), c2.push(v2(i2, " page-intermediate"))) : c2.push(tv.sprintf(this.constants.html.paginationItem, " page-first-separator disabled", "", "...")));
                }
                for (i2 = n2; i2 <= o2; i2++)
                  c2.push(v2(i2));
                if (this.totalPages > o2) {
                  var m2 = this.totalPages - (e2.paginationPagesBySide - 1);
                  for (o2 >= m2 && (m2 = o2 + 1), o2 + 1 === m2 - 1 ? (i2 = o2 + 1, c2.push(v2(i2))) : m2 > o2 + 1 && (this.totalPages - o2 > 2 * e2.paginationPagesBySide && e2.paginationUseIntermediate ? (i2 = Math.round((this.totalPages - g2 - o2) / 2 + o2), c2.push(v2(i2, " page-intermediate"))) : c2.push(tv.sprintf(this.constants.html.paginationItem, " page-last-separator disabled", "", "..."))), i2 = m2; i2 <= this.totalPages; i2++)
                    c2.push(v2(i2));
                }
                c2.push(tv.sprintf(this.constants.html.paginationItem, " page-next", e2.formatSRPaginationNextText(), e2.paginationNextText)), c2.push(this.constants.html.pagination[1], "</div>");
              }
              this.$pagination.html(c2.join(""));
              var y2 = ["bottom", "both"].includes(e2.paginationVAlign) ? " ".concat(this.constants.classes.dropup) : "";
              this.$pagination.last().find(".page-list > div").addClass(y2), e2.onlyInfoPagination || (a2 = this.$pagination.find(".page-list a"), r2 = this.$pagination.find(".page-pre"), s2 = this.$pagination.find(".page-next"), l2 = this.$pagination.find(".page-item").not(".page-next, .page-pre, .page-last-separator, .page-first-separator"), this.totalPages <= 1 && this.$pagination.find("div.pagination").hide(), e2.smartDisplay && (d2.length < 2 || e2.totalRows <= d2[0]) && this.$pagination.find("div.page-list").hide(), this.$pagination[this.getData().length ? "show" : "hide"](), e2.paginationLoop || (1 === e2.pageNumber && r2.addClass("disabled"), e2.pageNumber === this.totalPages && s2.addClass("disabled")), h2 && (e2.pageSize = e2.formatAllRows()), a2.off("click").on("click", function(e3) {
                return t3.onPageListChange(e3);
              }), r2.off("click").on("click", function(e3) {
                return t3.onPagePre(e3);
              }), s2.off("click").on("click", function(e3) {
                return t3.onPageNext(e3);
              }), l2.off("click").on("click", function(e3) {
                return t3.onPageNumber(e3);
              }));
            } else
              this.$pagination.hide();
          } }, { key: "updatePagination", value: function(t3) {
            t3 && i.default(t3.currentTarget).hasClass("disabled") || (this.options.maintainMetaData || this.resetRows(), this.initPagination(), this.trigger("page-change", this.options.pageNumber, this.options.pageSize), "server" === this.options.sidePagination ? this.initServer() : this.initBody());
          } }, { key: "onPageListChange", value: function(t3) {
            t3.preventDefault();
            var e2 = i.default(t3.currentTarget);
            return e2.parent().addClass(this.constants.classes.dropdownActive).siblings().removeClass(this.constants.classes.dropdownActive), this.options.pageSize = e2.text().toUpperCase() === this.options.formatAllRows().toUpperCase() ? this.options.formatAllRows() : +e2.text(), this.$toolbar.find(".page-size").text(this.options.pageSize), this.updatePagination(t3), false;
          } }, { key: "onPagePre", value: function(t3) {
            if (!i.default(t3.target).hasClass("disabled"))
              return t3.preventDefault(), this.options.pageNumber - 1 == 0 ? this.options.pageNumber = this.options.totalPages : this.options.pageNumber--, this.updatePagination(t3), false;
          } }, { key: "onPageNext", value: function(t3) {
            if (!i.default(t3.target).hasClass("disabled"))
              return t3.preventDefault(), this.options.pageNumber + 1 > this.options.totalPages ? this.options.pageNumber = 1 : this.options.pageNumber++, this.updatePagination(t3), false;
          } }, { key: "onPageNumber", value: function(t3) {
            if (t3.preventDefault(), this.options.pageNumber !== +i.default(t3.currentTarget).text())
              return this.options.pageNumber = +i.default(t3.currentTarget).text(), this.updatePagination(t3), false;
          } }, { key: "initRow", value: function(t3, e2, i2, o2) {
            var a2 = this, r2 = [], l2 = {}, c2 = [], h2 = "", u2 = {}, d2 = [];
            if (!(tv.findIndex(this.hiddenRows, t3) > -1)) {
              if ((l2 = tv.calculateObjectValue(this.options, this.options.rowStyle, [t3, e2], l2)) && l2.css)
                for (var f2 = 0, p2 = Object.entries(l2.css); f2 < p2.length; f2++) {
                  var g2 = s(p2[f2], 2), v2 = g2[0], b2 = g2[1];
                  c2.push("".concat(v2, ": ").concat(b2));
                }
              if (u2 = tv.calculateObjectValue(this.options, this.options.rowAttributes, [t3, e2], u2))
                for (var m2 = 0, y2 = Object.entries(u2); m2 < y2.length; m2++) {
                  var w2 = s(y2[m2], 2), S2 = w2[0], x2 = w2[1];
                  d2.push("".concat(S2, '="').concat(tv.escapeHTML(x2), '"'));
                }
              if (t3._data && !tv.isEmptyObject(t3._data))
                for (var k2 = 0, O2 = Object.entries(t3._data); k2 < O2.length; k2++) {
                  var C2 = s(O2[k2], 2), T2 = C2[0], P2 = C2[1];
                  if ("index" === T2)
                    return;
                  h2 += " data-".concat(T2, "='").concat("object" === n(P2) ? JSON.stringify(P2) : P2, "'");
                }
              r2.push("<tr", tv.sprintf(" %s", d2.length ? d2.join(" ") : void 0), tv.sprintf(' id="%s"', Array.isArray(t3) ? void 0 : t3._id), tv.sprintf(' class="%s"', l2.classes || (Array.isArray(t3) ? void 0 : t3._class)), tv.sprintf(' style="%s"', Array.isArray(t3) ? void 0 : t3._style), ' data-index="'.concat(e2, '"'), tv.sprintf(' data-uniqueid="%s"', tv.getItemField(t3, this.options.uniqueId, false)), tv.sprintf(' data-has-detail-view="%s"', this.options.detailView && tv.calculateObjectValue(null, this.options.detailFilter, [e2, t3]) ? "true" : void 0), tv.sprintf("%s", h2), ">"), this.options.cardView && r2.push('<td colspan="'.concat(this.header.fields.length, '"><div class="card-views">'));
              var I2 = "";
              return tv.hasDetailViewIcon(this.options) && (I2 = "<td>", tv.calculateObjectValue(null, this.options.detailFilter, [e2, t3]) && (I2 += '\n          <a class="detail-icon" href="#">\n          '.concat(tv.sprintf(this.constants.html.icon, this.options.iconsPrefix, this.options.icons.detailOpen), "\n          </a>\n        ")), I2 += "</td>"), I2 && "right" !== this.options.detailViewAlign && r2.push(I2), this.header.fields.forEach(function(i3, n2) {
                var o3 = a2.columns[n2], l3 = "", h3 = tv.getItemField(t3, i3, a2.options.escape, o3.escape), u3 = "", d3 = "", f3 = {}, p3 = "", g3 = a2.header.classes[n2], v3 = "", b3 = "", m3 = "", y3 = "", w3 = "", S3 = "";
                if ((!a2.fromHtml && !a2.autoMergeCells || void 0 !== h3 || o3.checkbox || o3.radio) && o3.visible && (!a2.options.cardView || o3.cardVisible)) {
                  if (o3.escape && (h3 = tv.escapeHTML(h3)), c2.concat([a2.header.styles[n2]]).length && (b3 += "".concat(c2.concat([a2.header.styles[n2]]).join("; "))), t3["_".concat(i3, "_style")] && (b3 += "".concat(t3["_".concat(i3, "_style")])), b3 && (v3 = ' style="'.concat(b3, '"')), t3["_".concat(i3, "_id")] && (p3 = tv.sprintf(' id="%s"', t3["_".concat(i3, "_id")])), t3["_".concat(i3, "_class")] && (g3 = tv.sprintf(' class="%s"', t3["_".concat(i3, "_class")])), t3["_".concat(i3, "_rowspan")] && (y3 = tv.sprintf(' rowspan="%s"', t3["_".concat(i3, "_rowspan")])), t3["_".concat(i3, "_colspan")] && (w3 = tv.sprintf(' colspan="%s"', t3["_".concat(i3, "_colspan")])), t3["_".concat(i3, "_title")] && (S3 = tv.sprintf(' title="%s"', t3["_".concat(i3, "_title")])), (f3 = tv.calculateObjectValue(a2.header, a2.header.cellStyles[n2], [h3, t3, e2, i3], f3)).classes && (g3 = ' class="'.concat(f3.classes, '"')), f3.css) {
                    for (var x3 = [], k3 = 0, O3 = Object.entries(f3.css); k3 < O3.length; k3++) {
                      var C3 = s(O3[k3], 2), T3 = C3[0], P3 = C3[1];
                      x3.push("".concat(T3, ": ").concat(P3));
                    }
                    v3 = ' style="'.concat(x3.concat(a2.header.styles[n2]).join("; "), '"');
                  }
                  if (u3 = tv.calculateObjectValue(o3, a2.header.formatters[n2], [h3, t3, e2, i3], h3), o3.checkbox || o3.radio || (u3 = null == u3 ? a2.options.undefinedText : u3), o3.searchable && a2.searchText && a2.options.searchHighlight && !o3.checkbox && !o3.radio) {
                    var I3 = "", A2 = new RegExp("(".concat(a2.searchText.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), ")"), "gim"), $3 = "<mark>$1</mark>";
                    if (u3 && /<(?=.*? .*?\/ ?>|br|hr|input|!--|wbr)[a-z]+.*?>|<([a-z]+).*?<\/\1>/i.test(u3)) {
                      var R2 = new DOMParser().parseFromString(u3.toString(), "text/html").documentElement.textContent, E2 = R2.replace(A2, $3);
                      R2 = R2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), I3 = u3.replace(new RegExp("(>\\s*)(".concat(R2, ")(\\s*)"), "gm"), "$1".concat(E2, "$3"));
                    } else
                      I3 = u3.toString().replace(A2, $3);
                    u3 = tv.calculateObjectValue(o3, o3.searchHighlightFormatter, [u3, a2.searchText], I3);
                  }
                  if (t3["_".concat(i3, "_data")] && !tv.isEmptyObject(t3["_".concat(i3, "_data")]))
                    for (var j2 = 0, F2 = Object.entries(t3["_".concat(i3, "_data")]); j2 < F2.length; j2++) {
                      var _2 = s(F2[j2], 2), N2 = _2[0], D2 = _2[1];
                      if ("index" === N2)
                        return;
                      m3 += " data-".concat(N2, '="').concat(D2, '"');
                    }
                  if (o3.checkbox || o3.radio) {
                    d3 = o3.checkbox ? "checkbox" : d3, d3 = o3.radio ? "radio" : d3;
                    var V2 = o3.class || "", B2 = tv.isObject(u3) && u3.hasOwnProperty("checked") ? u3.checked : (true === u3 || h3) && false !== u3, L4 = !o3.checkboxEnabled || u3 && u3.disabled;
                    l3 = [a2.options.cardView ? '<div class="card-view '.concat(V2, '">') : '<td class="bs-checkbox '.concat(V2, '"').concat(g3).concat(v3, ">"), '<label>\n            <input\n            data-index="'.concat(e2, '"\n            name="').concat(a2.options.selectItemName, '"\n            type="').concat(d3, '"\n            ').concat(tv.sprintf('value="%s"', t3[a2.options.idField]), "\n            ").concat(tv.sprintf('checked="%s"', B2 ? "checked" : void 0), "\n            ").concat(tv.sprintf('disabled="%s"', L4 ? "disabled" : void 0), " />\n            <span></span>\n            </label>"), a2.header.formatters[n2] && "string" == typeof u3 ? u3 : "", a2.options.cardView ? "</div>" : "</td>"].join(""), t3[a2.header.stateField] = true === u3 || !!h3 || u3 && u3.checked;
                  } else if (a2.options.cardView) {
                    var H2 = a2.options.showHeader ? '<span class="card-view-title '.concat(f3.classes || "", '"').concat(v3, ">").concat(tv.getFieldTitle(a2.columns, i3), "</span>") : "";
                    l3 = '<div class="card-view">'.concat(H2, '<span class="card-view-value ').concat(f3.classes || "", '"').concat(v3, ">").concat(u3, "</span></div>"), a2.options.smartDisplay && "" === u3 && (l3 = '<div class="card-view"></div>');
                  } else
                    l3 = "<td".concat(p3).concat(g3).concat(v3).concat(m3).concat(y3).concat(w3).concat(S3, ">").concat(u3, "</td>");
                  r2.push(l3);
                }
              }), I2 && "right" === this.options.detailViewAlign && r2.push(I2), this.options.cardView && r2.push("</div></td>"), r2.push("</tr>"), r2.join("");
            }
          } }, { key: "initBody", value: function(t3, e2) {
            var n2 = this, o2 = this.getData();
            this.trigger("pre-body", o2), this.$body = this.$el.find(">tbody"), this.$body.length || (this.$body = i.default("<tbody></tbody>").appendTo(this.$el)), this.options.pagination && "server" !== this.options.sidePagination || (this.pageFrom = 1, this.pageTo = o2.length);
            var a2 = [], r2 = i.default(document.createDocumentFragment()), s2 = false, l2 = [];
            this.autoMergeCells = tv.checkAutoMergeCells(o2.slice(this.pageFrom - 1, this.pageTo));
            for (var c2 = this.pageFrom - 1; c2 < this.pageTo; c2++) {
              var h2 = o2[c2], u2 = this.initRow(h2, c2, o2, r2);
              if (s2 = s2 || !!u2, u2 && "string" == typeof u2) {
                var d2 = this.options.uniqueId;
                if (d2 && h2.hasOwnProperty(d2)) {
                  var f2 = h2[d2], p2 = this.$body.find(tv.sprintf('> tr[data-uniqueid="%s"][data-has-detail-view]', f2)).next();
                  p2.is("tr.detail-view") && (l2.push(c2), e2 && f2 === e2 || (u2 += p2[0].outerHTML));
                }
                this.options.virtualScroll ? a2.push(u2) : r2.append(u2);
              }
            }
            s2 ? this.options.virtualScroll ? (this.virtualScroll && this.virtualScroll.destroy(), this.virtualScroll = new sv({ rows: a2, fixedScroll: t3, scrollEl: this.$tableBody[0], contentEl: this.$body[0], itemHeight: this.options.virtualScrollItemHeight, callback: function(t4, e3) {
              n2.fitHeader(), n2.initBodyEvent(), n2.trigger("virtual-scroll", t4, e3);
            } })) : this.$body.html(r2) : this.$body.html('<tr class="no-records-found">'.concat(tv.sprintf('<td colspan="%s">%s</td>', this.getVisibleFields().length + tv.getDetailViewIndexOffset(this.options), this.options.formatNoMatches()), "</tr>")), l2.forEach(function(t4) {
              n2.expandRow(t4);
            }), t3 || this.scrollTo(0), this.initBodyEvent(), this.initFooter(), this.resetView(), this.updateSelected(), "server" !== this.options.sidePagination && (this.options.totalRows = o2.length), this.trigger("post-body", o2);
          } }, { key: "initBodyEvent", value: function() {
            var t3 = this;
            this.$body.find("> tr[data-index] > td").off("click dblclick").on("click dblclick", function(e2) {
              var n2 = i.default(e2.currentTarget);
              if (!n2.find(".detail-icon").length) {
                var o2 = n2.parent(), a2 = i.default(e2.target).parents(".card-views").children(), r2 = i.default(e2.target).parents(".card-view"), s2 = o2.data("index"), l2 = t3.data[s2], c2 = t3.options.cardView ? a2.index(r2) : n2[0].cellIndex, h2 = t3.getVisibleFields()[c2 - tv.getDetailViewIndexOffset(t3.options)], u2 = t3.columns[t3.fieldsColumnsIndex[h2]], d2 = tv.getItemField(l2, h2, t3.options.escape, u2.escape);
                if (t3.trigger("click" === e2.type ? "click-cell" : "dbl-click-cell", h2, d2, l2, n2), t3.trigger("click" === e2.type ? "click-row" : "dbl-click-row", l2, o2, h2), "click" === e2.type && t3.options.clickToSelect && u2.clickToSelect && !tv.calculateObjectValue(t3.options, t3.options.ignoreClickToSelectOn, [e2.target])) {
                  var f2 = o2.find(tv.sprintf('[name="%s"]', t3.options.selectItemName));
                  f2.length && f2[0].click();
                }
                "click" === e2.type && t3.options.detailViewByClick && t3.toggleDetailView(s2, t3.header.detailFormatters[t3.fieldsColumnsIndex[h2]]);
              }
            }).off("mousedown").on("mousedown", function(e2) {
              t3.multipleSelectRowCtrlKey = e2.ctrlKey || e2.metaKey, t3.multipleSelectRowShiftKey = e2.shiftKey;
            }), this.$body.find("> tr[data-index] > td > .detail-icon").off("click").on("click", function(e2) {
              return e2.preventDefault(), t3.toggleDetailView(i.default(e2.currentTarget).parent().parent().data("index")), false;
            }), this.$selectItem = this.$body.find(tv.sprintf('[name="%s"]', this.options.selectItemName)), this.$selectItem.off("click").on("click", function(e2) {
              e2.stopImmediatePropagation();
              var n2 = i.default(e2.currentTarget);
              t3._toggleCheck(n2.prop("checked"), n2.data("index"));
            }), this.header.events.forEach(function(e2, n2) {
              var o2 = e2;
              if (o2) {
                if ("string" == typeof o2 && (o2 = tv.calculateObjectValue(null, o2)), !o2)
                  throw new Error("Unknown event in the scope: ".concat(e2));
                var a2 = t3.header.fields[n2], r2 = t3.getVisibleFields().indexOf(a2);
                if (-1 !== r2) {
                  r2 += tv.getDetailViewIndexOffset(t3.options);
                  var s2 = function(e3) {
                    if (!o2.hasOwnProperty(e3))
                      return "continue";
                    var n3 = o2[e3];
                    t3.$body.find(">tr:not(.no-records-found)").each(function(o3, s3) {
                      var l3 = i.default(s3), c2 = l3.find(t3.options.cardView ? ".card-views>.card-view" : ">td").eq(r2), h2 = e3.indexOf(" "), u2 = e3.substring(0, h2), d2 = e3.substring(h2 + 1);
                      c2.find(d2).off(u2).on(u2, function(e4) {
                        var i2 = l3.data("index"), o4 = t3.data[i2], r3 = o4[a2];
                        n3.apply(t3, [e4, r3, o4, i2]);
                      });
                    });
                  };
                  for (var l2 in o2)
                    s2(l2);
                }
              }
            });
          } }, { key: "initServer", value: function(t3, e2, n2) {
            var o2 = this, a2 = {}, r2 = this.header.fields.indexOf(this.options.sortName), s2 = { searchText: this.searchText, sortName: this.options.sortName, sortOrder: this.options.sortOrder };
            if (this.header.sortNames[r2] && (s2.sortName = this.header.sortNames[r2]), this.options.pagination && "server" === this.options.sidePagination && (s2.pageSize = this.options.pageSize === this.options.formatAllRows() ? this.options.totalRows : this.options.pageSize, s2.pageNumber = this.options.pageNumber), n2 || this.options.url || this.options.ajax) {
              if ("limit" === this.options.queryParamsType && (s2 = { search: s2.searchText, sort: s2.sortName, order: s2.sortOrder }, this.options.pagination && "server" === this.options.sidePagination && (s2.offset = this.options.pageSize === this.options.formatAllRows() ? 0 : this.options.pageSize * (this.options.pageNumber - 1), s2.limit = this.options.pageSize, 0 !== s2.limit && this.options.pageSize !== this.options.formatAllRows() || delete s2.limit)), this.options.search && "server" === this.options.sidePagination && this.columns.filter(function(t4) {
                return !t4.searchable;
              }).length) {
                s2.searchable = [];
                var l2, c2 = u(this.columns);
                try {
                  for (c2.s(); !(l2 = c2.n()).done; ) {
                    var h2 = l2.value;
                    !h2.checkbox && h2.searchable && (this.options.visibleSearch && h2.visible || !this.options.visibleSearch) && s2.searchable.push(h2.field);
                  }
                } catch (t4) {
                  c2.e(t4);
                } finally {
                  c2.f();
                }
              }
              if (tv.isEmptyObject(this.filterColumnsPartial) || (s2.filter = JSON.stringify(this.filterColumnsPartial, null)), i.default.extend(s2, e2 || {}), false !== (a2 = tv.calculateObjectValue(this.options, this.options.queryParams, [s2], a2))) {
                t3 || this.showLoading();
                var d2 = i.default.extend({}, tv.calculateObjectValue(null, this.options.ajaxOptions), { type: this.options.method, url: n2 || this.options.url, data: "application/json" === this.options.contentType && "post" === this.options.method ? JSON.stringify(a2) : a2, cache: this.options.cache, contentType: this.options.contentType, dataType: this.options.dataType, success: function(e3, i2, n3) {
                  var a3 = tv.calculateObjectValue(o2.options, o2.options.responseHandler, [e3, n3], e3);
                  o2.load(a3), o2.trigger("load-success", a3, n3 && n3.status, n3), t3 || o2.hideLoading(), "server" === o2.options.sidePagination && o2.options.pageNumber > 1 && a3[o2.options.totalField] > 0 && !a3[o2.options.dataField].length && o2.updatePagination();
                }, error: function(e3) {
                  if (e3 && 0 === e3.status && o2._xhrAbort)
                    o2._xhrAbort = false;
                  else {
                    var i2 = [];
                    "server" === o2.options.sidePagination && ((i2 = {})[o2.options.totalField] = 0, i2[o2.options.dataField] = []), o2.load(i2), o2.trigger("load-error", e3 && e3.status, e3), t3 || o2.hideLoading();
                  }
                } });
                return this.options.ajax ? tv.calculateObjectValue(this, this.options.ajax, [d2], null) : (this._xhr && 4 !== this._xhr.readyState && (this._xhrAbort = true, this._xhr.abort()), this._xhr = i.default.ajax(d2)), a2;
              }
            }
          } }, { key: "initSearchText", value: function() {
            if (this.options.search && (this.searchText = "", "" !== this.options.searchText)) {
              var t3 = tv.getSearchInput(this);
              t3.val(this.options.searchText), this.onSearch({ currentTarget: t3, firedByInitSearchText: true });
            }
          } }, { key: "getCaret", value: function() {
            var t3 = this;
            this.$header.find("th").each(function(e2, n2) {
              i.default(n2).find(".sortable").removeClass("desc asc").addClass(i.default(n2).data("field") === t3.options.sortName ? t3.options.sortOrder : "both");
            });
          } }, { key: "updateSelected", value: function() {
            var t3 = this.$selectItem.filter(":enabled").length && this.$selectItem.filter(":enabled").length === this.$selectItem.filter(":enabled").filter(":checked").length;
            this.$selectAll.add(this.$selectAll_).prop("checked", t3), this.$selectItem.each(function(t4, e2) {
              i.default(e2).closest("tr")[i.default(e2).prop("checked") ? "addClass" : "removeClass"]("selected");
            });
          } }, { key: "updateRows", value: function() {
            var t3 = this;
            this.$selectItem.each(function(e2, n2) {
              t3.data[i.default(n2).data("index")][t3.header.stateField] = i.default(n2).prop("checked");
            });
          } }, { key: "resetRows", value: function() {
            var t3, e2 = u(this.data);
            try {
              for (e2.s(); !(t3 = e2.n()).done; ) {
                var i2 = t3.value;
                this.$selectAll.prop("checked", false), this.$selectItem.prop("checked", false), this.header.stateField && (i2[this.header.stateField] = false);
              }
            } catch (t4) {
              e2.e(t4);
            } finally {
              e2.f();
            }
            this.initHiddenRows();
          } }, { key: "trigger", value: function(e2) {
            for (var n2, o2, a2 = "".concat(e2, ".bs.table"), r2 = arguments.length, s2 = new Array(r2 > 1 ? r2 - 1 : 0), l2 = 1; l2 < r2; l2++)
              s2[l2 - 1] = arguments[l2];
            (n2 = this.options)[t2.EVENTS[a2]].apply(n2, [].concat(s2, [this])), this.$el.trigger(i.default.Event(a2, { sender: this }), s2), (o2 = this.options).onAll.apply(o2, [a2].concat([].concat(s2, [this]))), this.$el.trigger(i.default.Event("all.bs.table", { sender: this }), [a2, s2]);
          } }, { key: "resetHeader", value: function() {
            var t3 = this;
            clearTimeout(this.timeoutId_), this.timeoutId_ = setTimeout(function() {
              return t3.fitHeader();
            }, this.$el.is(":hidden") ? 100 : 0);
          } }, { key: "fitHeader", value: function() {
            var t3 = this;
            if (this.$el.is(":hidden"))
              this.timeoutId_ = setTimeout(function() {
                return t3.fitHeader();
              }, 100);
            else {
              var e2 = this.$tableBody.get(0), n2 = this.hasScrollBar && e2.scrollHeight > e2.clientHeight + this.$header.outerHeight() ? tv.getScrollBarWidth() : 0;
              this.$el.css("margin-top", -this.$header.outerHeight());
              var o2 = i.default(":focus");
              if (o2.length > 0) {
                var a2 = o2.parents("th");
                if (a2.length > 0) {
                  var r2 = a2.attr("data-field");
                  if (void 0 !== r2) {
                    var s2 = this.$header.find("[data-field='".concat(r2, "']"));
                    s2.length > 0 && s2.find(":input").addClass("focus-temp");
                  }
                }
              }
              this.$header_ = this.$header.clone(true, true), this.$selectAll_ = this.$header_.find('[name="btSelectAll"]'), this.$tableHeader.css("margin-right", n2).find("table").css("width", this.$el.outerWidth()).html("").attr("class", this.$el.attr("class")).append(this.$header_), this.$tableLoading.css("width", this.$el.outerWidth());
              var l2 = i.default(".focus-temp:visible:eq(0)");
              l2.length > 0 && (l2.focus(), this.$header.find(".focus-temp").removeClass("focus-temp")), this.$header.find("th[data-field]").each(function(e3, n3) {
                t3.$header_.find(tv.sprintf('th[data-field="%s"]', i.default(n3).data("field"))).data(i.default(n3).data());
              });
              for (var c2 = this.getVisibleFields(), h2 = this.$header_.find("th"), u2 = this.$body.find(">tr:not(.no-records-found,.virtual-scroll-top)").eq(0); u2.length && u2.find('>td[colspan]:not([colspan="1"])').length; )
                u2 = u2.next();
              var d2 = u2.find("> *").length;
              u2.find("> *").each(function(e3, n3) {
                var o3 = i.default(n3);
                if (tv.hasDetailViewIcon(t3.options) && (0 === e3 && "right" !== t3.options.detailViewAlign || e3 === d2 - 1 && "right" === t3.options.detailViewAlign)) {
                  var a3 = h2.filter(".detail"), r3 = a3.innerWidth() - a3.find(".fht-cell").width();
                  a3.find(".fht-cell").width(o3.innerWidth() - r3);
                } else {
                  var s3 = e3 - tv.getDetailViewIndexOffset(t3.options), l3 = t3.$header_.find(tv.sprintf('th[data-field="%s"]', c2[s3]));
                  l3.length > 1 && (l3 = i.default(h2[o3[0].cellIndex]));
                  var u3 = l3.innerWidth() - l3.find(".fht-cell").width();
                  l3.find(".fht-cell").width(o3.innerWidth() - u3);
                }
              }), this.horizontalScroll(), this.trigger("post-header");
            }
          } }, { key: "initFooter", value: function() {
            if (this.options.showFooter && !this.options.cardView) {
              var t3 = this.getData(), e2 = [], i2 = "";
              tv.hasDetailViewIcon(this.options) && (i2 = '<th class="detail"><div class="th-inner"></div><div class="fht-cell"></div></th>'), i2 && "right" !== this.options.detailViewAlign && e2.push(i2);
              var n2, o2 = u(this.columns);
              try {
                for (o2.s(); !(n2 = o2.n()).done; ) {
                  var a2, r2, l2 = n2.value, c2 = [], h2 = {}, d2 = tv.sprintf(' class="%s"', l2.class);
                  if (!(!l2.visible || this.footerData && this.footerData.length > 0 && !(l2.field in this.footerData[0]))) {
                    if (this.options.cardView && !l2.cardVisible)
                      return;
                    if (a2 = tv.sprintf("text-align: %s; ", l2.falign ? l2.falign : l2.align), r2 = tv.sprintf("vertical-align: %s; ", l2.valign), (h2 = tv.calculateObjectValue(null, this.options.footerStyle, [l2])) && h2.css)
                      for (var f2 = 0, p2 = Object.entries(h2.css); f2 < p2.length; f2++) {
                        var g2 = s(p2[f2], 2), v2 = g2[0], b2 = g2[1];
                        c2.push("".concat(v2, ": ").concat(b2));
                      }
                    h2 && h2.classes && (d2 = tv.sprintf(' class="%s"', l2.class ? [l2.class, h2.classes].join(" ") : h2.classes)), e2.push("<th", d2, tv.sprintf(' style="%s"', a2 + r2 + c2.concat().join("; ")));
                    var m2 = 0;
                    this.footerData && this.footerData.length > 0 && (m2 = this.footerData[0]["_".concat(l2.field, "_colspan")] || 0), m2 && e2.push(' colspan="'.concat(m2, '" ')), e2.push(">"), e2.push('<div class="th-inner">');
                    var y2 = "";
                    this.footerData && this.footerData.length > 0 && (y2 = this.footerData[0][l2.field] || ""), e2.push(tv.calculateObjectValue(l2, l2.footerFormatter, [t3, y2], y2)), e2.push("</div>"), e2.push('<div class="fht-cell"></div>'), e2.push("</div>"), e2.push("</th>");
                  }
                }
              } catch (t4) {
                o2.e(t4);
              } finally {
                o2.f();
              }
              i2 && "right" === this.options.detailViewAlign && e2.push(i2), this.options.height || this.$tableFooter.length || (this.$el.append("<tfoot><tr></tr></tfoot>"), this.$tableFooter = this.$el.find("tfoot")), this.$tableFooter.find("tr").length || this.$tableFooter.html("<table><thead><tr></tr></thead></table>"), this.$tableFooter.find("tr").html(e2.join("")), this.trigger("post-footer", this.$tableFooter);
            }
          } }, { key: "fitFooter", value: function() {
            var t3 = this;
            if (this.$el.is(":hidden"))
              setTimeout(function() {
                return t3.fitFooter();
              }, 100);
            else {
              var e2 = this.$tableBody.get(0), n2 = this.hasScrollBar && e2.scrollHeight > e2.clientHeight + this.$header.outerHeight() ? tv.getScrollBarWidth() : 0;
              this.$tableFooter.css("margin-right", n2).find("table").css("width", this.$el.outerWidth()).attr("class", this.$el.attr("class"));
              var o2 = this.$tableFooter.find("th"), a2 = this.$body.find(">tr:first-child:not(.no-records-found)");
              for (o2.find(".fht-cell").width("auto"); a2.length && a2.find('>td[colspan]:not([colspan="1"])').length; )
                a2 = a2.next();
              var r2 = a2.find("> *").length;
              a2.find("> *").each(function(e3, n3) {
                var a3 = i.default(n3);
                if (tv.hasDetailViewIcon(t3.options) && (0 === e3 && "left" === t3.options.detailViewAlign || e3 === r2 - 1 && "right" === t3.options.detailViewAlign)) {
                  var s2 = o2.filter(".detail"), l2 = s2.innerWidth() - s2.find(".fht-cell").width();
                  s2.find(".fht-cell").width(a3.innerWidth() - l2);
                } else {
                  var c2 = o2.eq(e3), h2 = c2.innerWidth() - c2.find(".fht-cell").width();
                  c2.find(".fht-cell").width(a3.innerWidth() - h2);
                }
              }), this.horizontalScroll();
            }
          } }, { key: "horizontalScroll", value: function() {
            var t3 = this;
            this.$tableBody.off("scroll").on("scroll", function() {
              var e2 = t3.$tableBody.scrollLeft();
              t3.options.showHeader && t3.options.height && t3.$tableHeader.scrollLeft(e2), t3.options.showFooter && !t3.options.cardView && t3.$tableFooter.scrollLeft(e2), t3.trigger("scroll-body", t3.$tableBody);
            });
          } }, { key: "getVisibleFields", value: function() {
            var t3, e2 = [], i2 = u(this.header.fields);
            try {
              for (i2.s(); !(t3 = i2.n()).done; ) {
                var n2 = t3.value, o2 = this.columns[this.fieldsColumnsIndex[n2]];
                o2 && o2.visible && (!this.options.cardView || o2.cardVisible) && e2.push(n2);
              }
            } catch (t4) {
              i2.e(t4);
            } finally {
              i2.f();
            }
            return e2;
          } }, { key: "initHiddenRows", value: function() {
            this.hiddenRows = [];
          } }, { key: "getOptions", value: function() {
            var t3 = i.default.extend({}, this.options);
            return delete t3.data, i.default.extend(true, {}, t3);
          } }, { key: "refreshOptions", value: function(t3) {
            tv.compareObjects(this.options, t3, true) || (this.options = i.default.extend(this.options, t3), this.trigger("refresh-options", this.options), this.destroy(), this.init());
          } }, { key: "getData", value: function(t3) {
            var e2 = this, i2 = this.options.data;
            if (!(this.searchText || this.options.customSearch || void 0 !== this.options.sortName || this.enableCustomSort) && tv.isEmptyObject(this.filterColumns) && "function" != typeof this.options.filterOptions.filterAlgorithm && tv.isEmptyObject(this.filterColumnsPartial) || t3 && t3.unfiltered || (i2 = this.data), t3 && t3.useCurrentPage && (i2 = i2.slice(this.pageFrom - 1, this.pageTo)), t3 && !t3.includeHiddenRows) {
              var n2 = this.getHiddenRows();
              i2 = i2.filter(function(t4) {
                return -1 === tv.findIndex(n2, t4);
              });
            }
            return t3 && t3.formatted && i2.forEach(function(t4) {
              for (var i3 = 0, n3 = Object.entries(t4); i3 < n3.length; i3++) {
                var o2 = s(n3[i3], 2), a2 = o2[0], r2 = o2[1], l2 = e2.columns[e2.fieldsColumnsIndex[a2]];
                if (!l2)
                  return;
                t4[a2] = tv.calculateObjectValue(l2, e2.header.formatters[l2.fieldIndex], [r2, t4, t4.index, l2.field], r2);
              }
            }), i2;
          } }, { key: "getSelections", value: function() {
            var t3 = this;
            return (this.options.maintainMetaData ? this.options.data : this.data).filter(function(e2) {
              return true === e2[t3.header.stateField];
            });
          } }, { key: "load", value: function(t3) {
            var e2, i2 = t3;
            this.options.pagination && "server" === this.options.sidePagination && (this.options.totalRows = i2[this.options.totalField], this.options.totalNotFiltered = i2[this.options.totalNotFilteredField], this.footerData = i2[this.options.footerField] ? [i2[this.options.footerField]] : void 0), e2 = i2.fixedScroll, i2 = Array.isArray(i2) ? i2 : i2[this.options.dataField], this.initData(i2), this.initSearch(), this.initPagination(), this.initBody(e2);
          } }, { key: "append", value: function(t3) {
            this.initData(t3, "append"), this.initSearch(), this.initPagination(), this.initSort(), this.initBody(true);
          } }, { key: "prepend", value: function(t3) {
            this.initData(t3, "prepend"), this.initSearch(), this.initPagination(), this.initSort(), this.initBody(true);
          } }, { key: "remove", value: function(t3) {
            for (var e2 = 0, i2 = this.options.data.length - 1; i2 >= 0; i2--) {
              var n2 = this.options.data[i2];
              (n2.hasOwnProperty(t3.field) || "$index" === t3.field) && ((!n2.hasOwnProperty(t3.field) && "$index" === t3.field && t3.values.includes(i2) || t3.values.includes(n2[t3.field])) && (e2++, this.options.data.splice(i2, 1)));
            }
            e2 && ("server" === this.options.sidePagination && (this.options.totalRows -= e2, this.data = l(this.options.data)), this.initSearch(), this.initPagination(), this.initSort(), this.initBody(true));
          } }, { key: "removeAll", value: function() {
            this.options.data.length > 0 && (this.options.data.splice(0, this.options.data.length), this.initSearch(), this.initPagination(), this.initBody(true));
          } }, { key: "insertRow", value: function(t3) {
            t3.hasOwnProperty("index") && t3.hasOwnProperty("row") && (this.options.data.splice(t3.index, 0, t3.row), this.initSearch(), this.initPagination(), this.initSort(), this.initBody(true));
          } }, { key: "updateRow", value: function(t3) {
            var e2, n2 = u(Array.isArray(t3) ? t3 : [t3]);
            try {
              for (n2.s(); !(e2 = n2.n()).done; ) {
                var o2 = e2.value;
                o2.hasOwnProperty("index") && o2.hasOwnProperty("row") && (o2.hasOwnProperty("replace") && o2.replace ? this.options.data[o2.index] = o2.row : i.default.extend(this.options.data[o2.index], o2.row));
              }
            } catch (t4) {
              n2.e(t4);
            } finally {
              n2.f();
            }
            this.initSearch(), this.initPagination(), this.initSort(), this.initBody(true);
          } }, { key: "getRowByUniqueId", value: function(t3) {
            var e2, i2, n2, o2 = this.options.uniqueId, a2 = t3, r2 = null;
            for (e2 = this.options.data.length - 1; e2 >= 0; e2--) {
              if ((i2 = this.options.data[e2]).hasOwnProperty(o2))
                n2 = i2[o2];
              else {
                if (!i2._data || !i2._data.hasOwnProperty(o2))
                  continue;
                n2 = i2._data[o2];
              }
              if ("string" == typeof n2 ? a2 = a2.toString() : "number" == typeof n2 && (Number(n2) === n2 && n2 % 1 == 0 ? a2 = parseInt(a2, 10) : n2 === Number(n2) && 0 !== n2 && (a2 = parseFloat(a2))), n2 === a2) {
                r2 = i2;
                break;
              }
            }
            return r2;
          } }, { key: "updateByUniqueId", value: function(t3) {
            var e2, n2 = null, o2 = u(Array.isArray(t3) ? t3 : [t3]);
            try {
              for (o2.s(); !(e2 = o2.n()).done; ) {
                var a2 = e2.value;
                if (a2.hasOwnProperty("id") && a2.hasOwnProperty("row")) {
                  var r2 = this.options.data.indexOf(this.getRowByUniqueId(a2.id));
                  -1 !== r2 && (a2.hasOwnProperty("replace") && a2.replace ? this.options.data[r2] = a2.row : i.default.extend(this.options.data[r2], a2.row), n2 = a2.id);
                }
              }
            } catch (t4) {
              o2.e(t4);
            } finally {
              o2.f();
            }
            this.initSearch(), this.initPagination(), this.initSort(), this.initBody(true, n2);
          } }, { key: "removeByUniqueId", value: function(t3) {
            var e2 = this.options.data.length, i2 = this.getRowByUniqueId(t3);
            i2 && this.options.data.splice(this.options.data.indexOf(i2), 1), e2 !== this.options.data.length && ("server" === this.options.sidePagination && (this.options.totalRows -= 1, this.data = l(this.options.data)), this.initSearch(), this.initPagination(), this.initBody(true));
          } }, { key: "updateCell", value: function(t3) {
            t3.hasOwnProperty("index") && t3.hasOwnProperty("field") && t3.hasOwnProperty("value") && (this.data[t3.index][t3.field] = t3.value, false !== t3.reinit && (this.initSort(), this.initBody(true)));
          } }, { key: "updateCellByUniqueId", value: function(t3) {
            var e2 = this;
            (Array.isArray(t3) ? t3 : [t3]).forEach(function(t4) {
              var i2 = t4.id, n2 = t4.field, o2 = t4.value, a2 = e2.options.data.indexOf(e2.getRowByUniqueId(i2));
              -1 !== a2 && (e2.options.data[a2][n2] = o2);
            }), false !== t3.reinit && (this.initSort(), this.initBody(true));
          } }, { key: "showRow", value: function(t3) {
            this._toggleRow(t3, true);
          } }, { key: "hideRow", value: function(t3) {
            this._toggleRow(t3, false);
          } }, { key: "_toggleRow", value: function(t3, e2) {
            var i2;
            if (t3.hasOwnProperty("index") ? i2 = this.getData()[t3.index] : t3.hasOwnProperty("uniqueId") && (i2 = this.getRowByUniqueId(t3.uniqueId)), i2) {
              var n2 = tv.findIndex(this.hiddenRows, i2);
              e2 || -1 !== n2 ? e2 && n2 > -1 && this.hiddenRows.splice(n2, 1) : this.hiddenRows.push(i2), this.initBody(true), this.initPagination();
            }
          } }, { key: "getHiddenRows", value: function(t3) {
            if (t3)
              return this.initHiddenRows(), this.initBody(true), void this.initPagination();
            var e2, i2 = [], n2 = u(this.getData());
            try {
              for (n2.s(); !(e2 = n2.n()).done; ) {
                var o2 = e2.value;
                this.hiddenRows.includes(o2) && i2.push(o2);
              }
            } catch (t4) {
              n2.e(t4);
            } finally {
              n2.f();
            }
            return this.hiddenRows = i2, i2;
          } }, { key: "showColumn", value: function(t3) {
            var e2 = this;
            (Array.isArray(t3) ? t3 : [t3]).forEach(function(t4) {
              e2._toggleColumn(e2.fieldsColumnsIndex[t4], true, true);
            });
          } }, { key: "hideColumn", value: function(t3) {
            var e2 = this;
            (Array.isArray(t3) ? t3 : [t3]).forEach(function(t4) {
              e2._toggleColumn(e2.fieldsColumnsIndex[t4], false, true);
            });
          } }, { key: "_toggleColumn", value: function(t3, e2, i2) {
            if (-1 !== t3 && this.columns[t3].visible !== e2 && (this.columns[t3].visible = e2, this.initHeader(), this.initSearch(), this.initPagination(), this.initBody(), this.options.showColumns)) {
              var n2 = this.$toolbar.find('.keep-open input:not(".toggle-all")').prop("disabled", false);
              i2 && n2.filter(tv.sprintf('[value="%s"]', t3)).prop("checked", e2), n2.filter(":checked").length <= this.options.minimumCountColumns && n2.filter(":checked").prop("disabled", true);
            }
          } }, { key: "getVisibleColumns", value: function() {
            var t3 = this;
            return this.columns.filter(function(e2) {
              return e2.visible && !t3.isSelectionColumn(e2);
            });
          } }, { key: "getHiddenColumns", value: function() {
            return this.columns.filter(function(t3) {
              return !t3.visible;
            });
          } }, { key: "isSelectionColumn", value: function(t3) {
            return t3.radio || t3.checkbox;
          } }, { key: "showAllColumns", value: function() {
            this._toggleAllColumns(true);
          } }, { key: "hideAllColumns", value: function() {
            this._toggleAllColumns(false);
          } }, { key: "_toggleAllColumns", value: function(t3) {
            var e2, n2 = this, o2 = u(this.columns.slice().reverse());
            try {
              for (o2.s(); !(e2 = o2.n()).done; ) {
                var a2 = e2.value;
                if (a2.switchable) {
                  if (!t3 && this.options.showColumns && this.getVisibleColumns().filter(function(t4) {
                    return t4.switchable;
                  }).length === this.options.minimumCountColumns)
                    continue;
                  a2.visible = t3;
                }
              }
            } catch (t4) {
              o2.e(t4);
            } finally {
              o2.f();
            }
            if (this.initHeader(), this.initSearch(), this.initPagination(), this.initBody(), this.options.showColumns) {
              var r2 = this.$toolbar.find('.keep-open input[type="checkbox"]:not(".toggle-all")').prop("disabled", false);
              t3 ? r2.prop("checked", t3) : r2.get().reverse().forEach(function(e3) {
                r2.filter(":checked").length > n2.options.minimumCountColumns && i.default(e3).prop("checked", t3);
              }), r2.filter(":checked").length <= this.options.minimumCountColumns && r2.filter(":checked").prop("disabled", true);
            }
          } }, { key: "mergeCells", value: function(t3) {
            var e2, i2, n2 = t3.index, o2 = this.getVisibleFields().indexOf(t3.field), a2 = t3.rowspan || 1, r2 = t3.colspan || 1, s2 = this.$body.find(">tr[data-index]");
            o2 += tv.getDetailViewIndexOffset(this.options);
            var l2 = s2.eq(n2).find(">td").eq(o2);
            if (!(n2 < 0 || o2 < 0 || n2 >= this.data.length)) {
              for (e2 = n2; e2 < n2 + a2; e2++)
                for (i2 = o2; i2 < o2 + r2; i2++)
                  s2.eq(e2).find(">td").eq(i2).hide();
              l2.attr("rowspan", a2).attr("colspan", r2).show();
            }
          } }, { key: "checkAll", value: function() {
            this._toggleCheckAll(true);
          } }, { key: "uncheckAll", value: function() {
            this._toggleCheckAll(false);
          } }, { key: "_toggleCheckAll", value: function(t3) {
            var e2 = this.getSelections();
            this.$selectAll.add(this.$selectAll_).prop("checked", t3), this.$selectItem.filter(":enabled").prop("checked", t3), this.updateRows(), this.updateSelected();
            var i2 = this.getSelections();
            t3 ? this.trigger("check-all", i2, e2) : this.trigger("uncheck-all", i2, e2);
          } }, { key: "checkInvert", value: function() {
            var t3 = this.$selectItem.filter(":enabled"), e2 = t3.filter(":checked");
            t3.each(function(t4, e3) {
              i.default(e3).prop("checked", !i.default(e3).prop("checked"));
            }), this.updateRows(), this.updateSelected(), this.trigger("uncheck-some", e2), e2 = this.getSelections(), this.trigger("check-some", e2);
          } }, { key: "check", value: function(t3) {
            this._toggleCheck(true, t3);
          } }, { key: "uncheck", value: function(t3) {
            this._toggleCheck(false, t3);
          } }, { key: "_toggleCheck", value: function(t3, e2) {
            var i2 = this.$selectItem.filter('[data-index="'.concat(e2, '"]')), n2 = this.data[e2];
            if (i2.is(":radio") || this.options.singleSelect || this.options.multipleSelectRow && !this.multipleSelectRowCtrlKey && !this.multipleSelectRowShiftKey) {
              var o2, a2 = u(this.options.data);
              try {
                for (a2.s(); !(o2 = a2.n()).done; ) {
                  o2.value[this.header.stateField] = false;
                }
              } catch (t4) {
                a2.e(t4);
              } finally {
                a2.f();
              }
              this.$selectItem.filter(":checked").not(i2).prop("checked", false);
            }
            if (n2[this.header.stateField] = t3, this.options.multipleSelectRow) {
              if (this.multipleSelectRowShiftKey && this.multipleSelectRowLastSelectedIndex >= 0)
                for (var r2 = s(this.multipleSelectRowLastSelectedIndex < e2 ? [this.multipleSelectRowLastSelectedIndex, e2] : [e2, this.multipleSelectRowLastSelectedIndex], 2), l2 = r2[0], c2 = r2[1], h2 = l2 + 1; h2 < c2; h2++)
                  this.data[h2][this.header.stateField] = true, this.$selectItem.filter('[data-index="'.concat(h2, '"]')).prop("checked", true);
              this.multipleSelectRowCtrlKey = false, this.multipleSelectRowShiftKey = false, this.multipleSelectRowLastSelectedIndex = t3 ? e2 : -1;
            }
            i2.prop("checked", t3), this.updateSelected(), this.trigger(t3 ? "check" : "uncheck", this.data[e2], i2);
          } }, { key: "checkBy", value: function(t3) {
            this._toggleCheckBy(true, t3);
          } }, { key: "uncheckBy", value: function(t3) {
            this._toggleCheckBy(false, t3);
          } }, { key: "_toggleCheckBy", value: function(t3, e2) {
            var i2 = this;
            if (e2.hasOwnProperty("field") && e2.hasOwnProperty("values")) {
              var n2 = [];
              this.data.forEach(function(o2, a2) {
                if (!o2.hasOwnProperty(e2.field))
                  return false;
                if (e2.values.includes(o2[e2.field])) {
                  var r2 = i2.$selectItem.filter(":enabled").filter(tv.sprintf('[data-index="%s"]', a2)), s2 = !!e2.hasOwnProperty("onlyCurrentPage") && e2.onlyCurrentPage;
                  if (!(r2 = t3 ? r2.not(":checked") : r2.filter(":checked")).length && s2)
                    return;
                  r2.prop("checked", t3), o2[i2.header.stateField] = t3, n2.push(o2), i2.trigger(t3 ? "check" : "uncheck", o2, r2);
                }
              }), this.updateSelected(), this.trigger(t3 ? "check-some" : "uncheck-some", n2);
            }
          } }, { key: "refresh", value: function(t3) {
            t3 && t3.url && (this.options.url = t3.url), t3 && t3.pageNumber && (this.options.pageNumber = t3.pageNumber), t3 && t3.pageSize && (this.options.pageSize = t3.pageSize), this.trigger("refresh", this.initServer(t3 && t3.silent, t3 && t3.query, t3 && t3.url));
          } }, { key: "destroy", value: function() {
            this.$el.insertBefore(this.$container), i.default(this.options.toolbar).insertBefore(this.$el), this.$container.next().remove(), this.$container.remove(), this.$el.html(this.$el_.html()).css("margin-top", "0").attr("class", this.$el_.attr("class") || "");
            var t3 = tv.getEventName("resize.bootstrap-table", this.$el.attr("id"));
            i.default(window).off(t3);
          } }, { key: "resetView", value: function(t3) {
            var e2 = 0;
            if (t3 && t3.height && (this.options.height = t3.height), this.$tableContainer.toggleClass("has-card-view", this.options.cardView), this.options.height) {
              var i2 = this.$tableBody.get(0);
              this.hasScrollBar = i2.scrollWidth > i2.clientWidth;
            }
            if (!this.options.cardView && this.options.showHeader && this.options.height ? (this.$tableHeader.show(), this.resetHeader(), e2 += this.$header.outerHeight(true) + 1) : (this.$tableHeader.hide(), this.trigger("post-header")), !this.options.cardView && this.options.showFooter && (this.$tableFooter.show(), this.fitFooter(), this.options.height && (e2 += this.$tableFooter.outerHeight(true))), this.$container.hasClass("fullscreen"))
              this.$tableContainer.css("height", ""), this.$tableContainer.css("width", "");
            else if (this.options.height) {
              this.$tableBorder && (this.$tableBorder.css("width", ""), this.$tableBorder.css("height", ""));
              var n2 = this.$toolbar.outerHeight(true), o2 = this.$pagination.outerHeight(true), a2 = this.options.height - n2 - o2, r2 = this.$tableBody.find(">table"), s2 = r2.outerHeight();
              if (this.$tableContainer.css("height", "".concat(a2, "px")), this.$tableBorder && r2.is(":visible")) {
                var l2 = a2 - s2 - 2;
                this.hasScrollBar && (l2 -= tv.getScrollBarWidth()), this.$tableBorder.css("width", "".concat(r2.outerWidth(), "px")), this.$tableBorder.css("height", "".concat(l2, "px"));
              }
            }
            this.options.cardView ? (this.$el.css("margin-top", "0"), this.$tableContainer.css("padding-bottom", "0"), this.$tableFooter.hide()) : (this.getCaret(), this.$tableContainer.css("padding-bottom", "".concat(e2, "px"))), this.trigger("reset-view");
          } }, { key: "showLoading", value: function() {
            this.$tableLoading.toggleClass("open", true);
            var t3 = this.options.loadingFontSize;
            "auto" === this.options.loadingFontSize && (t3 = 0.04 * this.$tableLoading.width(), t3 = Math.max(12, t3), t3 = Math.min(32, t3), t3 = "".concat(t3, "px")), this.$tableLoading.find(".loading-text").css("font-size", t3);
          } }, { key: "hideLoading", value: function() {
            this.$tableLoading.toggleClass("open", false);
          } }, { key: "togglePagination", value: function() {
            this.options.pagination = !this.options.pagination;
            var t3 = this.options.showButtonIcons ? this.options.pagination ? this.options.icons.paginationSwitchDown : this.options.icons.paginationSwitchUp : "", e2 = this.options.showButtonText ? this.options.pagination ? this.options.formatPaginationSwitchUp() : this.options.formatPaginationSwitchDown() : "";
            this.$toolbar.find('button[name="paginationSwitch"]').html("".concat(tv.sprintf(this.constants.html.icon, this.options.iconsPrefix, t3), " ").concat(e2)), this.updatePagination(), this.trigger("toggle-pagination", this.options.pagination);
          } }, { key: "toggleFullscreen", value: function() {
            this.$el.closest(".bootstrap-table").toggleClass("fullscreen"), this.resetView();
          } }, { key: "toggleView", value: function() {
            this.options.cardView = !this.options.cardView, this.initHeader();
            var t3 = this.options.showButtonIcons ? this.options.cardView ? this.options.icons.toggleOn : this.options.icons.toggleOff : "", e2 = this.options.showButtonText ? this.options.cardView ? this.options.formatToggleOff() : this.options.formatToggleOn() : "";
            this.$toolbar.find('button[name="toggle"]').html("".concat(tv.sprintf(this.constants.html.icon, this.options.iconsPrefix, t3), " ").concat(e2)), this.initBody(), this.trigger("toggle", this.options.cardView);
          } }, { key: "resetSearch", value: function(t3) {
            var e2 = tv.getSearchInput(this), i2 = t3 || "";
            e2.val(i2), this.searchText = i2, this.onSearch({ currentTarget: e2 }, false);
          } }, { key: "filterBy", value: function(t3, e2) {
            this.filterOptions = tv.isEmptyObject(e2) ? this.options.filterOptions : i.default.extend(this.options.filterOptions, e2), this.filterColumns = tv.isEmptyObject(t3) ? {} : t3, this.options.pageNumber = 1, this.initSearch(), this.updatePagination();
          } }, { key: "scrollTo", value: function(t3) {
            var e2 = { unit: "px", value: 0 };
            "object" === n(t3) ? e2 = Object.assign(e2, t3) : "string" == typeof t3 && "bottom" === t3 ? e2.value = this.$tableBody[0].scrollHeight : "string" != typeof t3 && "number" != typeof t3 || (e2.value = t3);
            var o2 = e2.value;
            "rows" === e2.unit && (o2 = 0, this.$body.find("> tr:lt(".concat(e2.value, ")")).each(function(t4, e3) {
              o2 += i.default(e3).outerHeight(true);
            })), this.$tableBody.scrollTop(o2);
          } }, { key: "getScrollPosition", value: function() {
            return this.$tableBody.scrollTop();
          } }, { key: "selectPage", value: function(t3) {
            t3 > 0 && t3 <= this.options.totalPages && (this.options.pageNumber = t3, this.updatePagination());
          } }, { key: "prevPage", value: function() {
            this.options.pageNumber > 1 && (this.options.pageNumber--, this.updatePagination());
          } }, { key: "nextPage", value: function() {
            this.options.pageNumber < this.options.totalPages && (this.options.pageNumber++, this.updatePagination());
          } }, { key: "toggleDetailView", value: function(t3, e2) {
            this.$body.find(tv.sprintf('> tr[data-index="%s"]', t3)).next().is("tr.detail-view") ? this.collapseRow(t3) : this.expandRow(t3, e2), this.resetView();
          } }, { key: "expandRow", value: function(t3, e2) {
            var i2 = this.data[t3], n2 = this.$body.find(tv.sprintf('> tr[data-index="%s"][data-has-detail-view]', t3));
            if (this.options.detailViewIcon && n2.find("a.detail-icon").html(tv.sprintf(this.constants.html.icon, this.options.iconsPrefix, this.options.icons.detailClose)), !n2.next().is("tr.detail-view")) {
              n2.after(tv.sprintf('<tr class="detail-view"><td colspan="%s"></td></tr>', n2.children("td").length));
              var o2 = n2.next().find("td"), a2 = e2 || this.options.detailFormatter, r2 = tv.calculateObjectValue(this.options, a2, [t3, i2, o2], "");
              1 === o2.length && o2.append(r2), this.trigger("expand-row", t3, i2, o2);
            }
          } }, { key: "expandRowByUniqueId", value: function(t3) {
            var e2 = this.getRowByUniqueId(t3);
            e2 && this.expandRow(this.data.indexOf(e2));
          } }, { key: "collapseRow", value: function(t3) {
            var e2 = this.data[t3], i2 = this.$body.find(tv.sprintf('> tr[data-index="%s"][data-has-detail-view]', t3));
            i2.next().is("tr.detail-view") && (this.options.detailViewIcon && i2.find("a.detail-icon").html(tv.sprintf(this.constants.html.icon, this.options.iconsPrefix, this.options.icons.detailOpen)), this.trigger("collapse-row", t3, e2, i2.next()), i2.next().remove());
          } }, { key: "collapseRowByUniqueId", value: function(t3) {
            var e2 = this.getRowByUniqueId(t3);
            e2 && this.collapseRow(this.data.indexOf(e2));
          } }, { key: "expandAllRows", value: function() {
            for (var t3 = this.$body.find("> tr[data-index][data-has-detail-view]"), e2 = 0; e2 < t3.length; e2++)
              this.expandRow(i.default(t3[e2]).data("index"));
          } }, { key: "collapseAllRows", value: function() {
            for (var t3 = this.$body.find("> tr[data-index][data-has-detail-view]"), e2 = 0; e2 < t3.length; e2++)
              this.collapseRow(i.default(t3[e2]).data("index"));
          } }, { key: "updateColumnTitle", value: function(t3) {
            t3.hasOwnProperty("field") && t3.hasOwnProperty("title") && (this.columns[this.fieldsColumnsIndex[t3.field]].title = this.options.escape ? tv.escapeHTML(t3.title) : t3.title, this.columns[this.fieldsColumnsIndex[t3.field]].visible && (this.$header.find("th[data-field]").each(function(e2, n2) {
              if (i.default(n2).data("field") === t3.field)
                return i.default(i.default(n2).find(".th-inner")[0]).text(t3.title), false;
            }), this.resetView()));
          } }, { key: "updateFormatText", value: function(t3, e2) {
            /^format/.test(t3) && this.options[t3] && ("string" == typeof e2 ? this.options[t3] = function() {
              return e2;
            } : "function" == typeof e2 && (this.options[t3] = e2), this.initToolbar(), this.initPagination(), this.initBody());
          } }]), t2;
        }();
        return lv.VERSION = rv.VERSION, lv.DEFAULTS = rv.DEFAULTS, lv.LOCALES = rv.LOCALES, lv.COLUMN_DEFAULTS = rv.COLUMN_DEFAULTS, lv.METHODS = rv.METHODS, lv.EVENTS = rv.EVENTS, i.default.BootstrapTable = lv, i.default.fn.bootstrapTable = function(t2) {
          for (var e2 = arguments.length, o2 = new Array(e2 > 1 ? e2 - 1 : 0), a2 = 1; a2 < e2; a2++)
            o2[a2 - 1] = arguments[a2];
          var r2;
          return this.each(function(e3, a3) {
            var s2 = i.default(a3).data("bootstrap.table"), l2 = i.default.extend({}, lv.DEFAULTS, i.default(a3).data(), "object" === n(t2) && t2);
            if ("string" == typeof t2) {
              var c2;
              if (!rv.METHODS.includes(t2))
                throw new Error("Unknown method: ".concat(t2));
              if (!s2)
                return;
              r2 = (c2 = s2)[t2].apply(c2, o2), "destroy" === t2 && i.default(a3).removeData("bootstrap.table");
            }
            s2 || (s2 = new i.default.BootstrapTable(a3, l2), i.default(a3).data("bootstrap.table", s2), s2.init());
          }), void 0 === r2 ? this : r2;
        }, i.default.fn.bootstrapTable.Constructor = lv, i.default.fn.bootstrapTable.theme = rv.THEME, i.default.fn.bootstrapTable.VERSION = rv.VERSION, i.default.fn.bootstrapTable.defaults = lv.DEFAULTS, i.default.fn.bootstrapTable.columnDefaults = lv.COLUMN_DEFAULTS, i.default.fn.bootstrapTable.events = lv.EVENTS, i.default.fn.bootstrapTable.locales = lv.LOCALES, i.default.fn.bootstrapTable.methods = lv.METHODS, i.default.fn.bootstrapTable.utils = tv, i.default(function() {
          i.default('[data-toggle="table"]').bootstrapTable();
        }), lv;
      });
    }
  });

  // node_modules/bootstrap/dist/css/bootstrap.css
  var require_ = __commonJS({
    "node_modules/bootstrap/dist/css/bootstrap.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/bootstrap-table/dist/bootstrap-table.css
  var require_2 = __commonJS({
    "node_modules/bootstrap-table/dist/bootstrap-table.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/leaflet/dist/leaflet.css
  var require_3 = __commonJS({
    "node_modules/leaflet/dist/leaflet.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/@lezer/lr/dist/index.cjs
  var require_dist12 = __commonJS({
    "node_modules/@lezer/lr/dist/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var common = require_dist3();
      var Stack = class {
        constructor(p, stack, state, reducePos, pos, score, buffer, bufferBase, curContext, lookAhead = 0, parent) {
          this.p = p;
          this.stack = stack;
          this.state = state;
          this.reducePos = reducePos;
          this.pos = pos;
          this.score = score;
          this.buffer = buffer;
          this.bufferBase = bufferBase;
          this.curContext = curContext;
          this.lookAhead = lookAhead;
          this.parent = parent;
        }
        toString() {
          return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
        }
        static start(p, state, pos = 0) {
          let cx = p.parser.context;
          return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
        }
        get context() {
          return this.curContext ? this.curContext.context : null;
        }
        pushState(state, start) {
          this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
          this.state = state;
        }
        reduce(action) {
          let depth = action >> 19, type = action & 65535;
          let { parser } = this.p;
          let dPrec = parser.dynamicPrecedence(type);
          if (dPrec)
            this.score += dPrec;
          if (depth == 0) {
            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);
            if (type < parser.minRepeatTerm)
              this.storeNode(type, this.reducePos, this.reducePos, 4, true);
            this.reduceContext(type, this.reducePos);
            return;
          }
          let base = this.stack.length - (depth - 1) * 3 - (action & 262144 ? 6 : 0);
          let start = this.stack[base - 2];
          let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;
          if (type < parser.minRepeatTerm || action & 131072) {
            let pos = parser.stateFlag(this.state, 1) ? this.pos : this.reducePos;
            this.storeNode(type, start, pos, count + 4, true);
          }
          if (action & 262144) {
            this.state = this.stack[base];
          } else {
            let baseStateID = this.stack[base - 3];
            this.state = parser.getGoto(baseStateID, type, true);
          }
          while (this.stack.length > base)
            this.stack.pop();
          this.reduceContext(type, start);
        }
        storeNode(term, start, end, size = 4, isReduce = false) {
          if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
            let cur = this, top = this.buffer.length;
            if (top == 0 && cur.parent) {
              top = cur.bufferBase - cur.parent.bufferBase;
              cur = cur.parent;
            }
            if (top > 0 && cur.buffer[top - 4] == 0 && cur.buffer[top - 1] > -1) {
              if (start == end)
                return;
              if (cur.buffer[top - 2] >= start) {
                cur.buffer[top - 2] = end;
                return;
              }
            }
          }
          if (!isReduce || this.pos == end) {
            this.buffer.push(term, start, end, size);
          } else {
            let index = this.buffer.length;
            if (index > 0 && this.buffer[index - 4] != 0)
              while (index > 0 && this.buffer[index - 2] > end) {
                this.buffer[index] = this.buffer[index - 4];
                this.buffer[index + 1] = this.buffer[index - 3];
                this.buffer[index + 2] = this.buffer[index - 2];
                this.buffer[index + 3] = this.buffer[index - 1];
                index -= 4;
                if (size > 4)
                  size -= 4;
              }
            this.buffer[index] = term;
            this.buffer[index + 1] = start;
            this.buffer[index + 2] = end;
            this.buffer[index + 3] = size;
          }
        }
        shift(action, next, nextEnd) {
          let start = this.pos;
          if (action & 131072) {
            this.pushState(action & 65535, this.pos);
          } else if ((action & 262144) == 0) {
            let nextState = action, { parser } = this.p;
            if (nextEnd > this.pos || next <= parser.maxNode) {
              this.pos = nextEnd;
              if (!parser.stateFlag(nextState, 1))
                this.reducePos = nextEnd;
            }
            this.pushState(nextState, start);
            this.shiftContext(next, start);
            if (next <= parser.maxNode)
              this.buffer.push(next, start, nextEnd, 4);
          } else {
            this.pos = nextEnd;
            this.shiftContext(next, start);
            if (next <= this.p.parser.maxNode)
              this.buffer.push(next, start, nextEnd, 4);
          }
        }
        apply(action, next, nextEnd) {
          if (action & 65536)
            this.reduce(action);
          else
            this.shift(action, next, nextEnd);
        }
        useNode(value, next) {
          let index = this.p.reused.length - 1;
          if (index < 0 || this.p.reused[index] != value) {
            this.p.reused.push(value);
            index++;
          }
          let start = this.pos;
          this.reducePos = this.pos = start + value.length;
          this.pushState(next, start);
          this.buffer.push(index, start, this.reducePos, -1);
          if (this.curContext)
            this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
        }
        split() {
          let parent = this;
          let off = parent.buffer.length;
          while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
            off -= 4;
          let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;
          while (parent && base == parent.bufferBase)
            parent = parent.parent;
          return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);
        }
        recoverByDelete(next, nextEnd) {
          let isNode = next <= this.p.parser.maxNode;
          if (isNode)
            this.storeNode(next, this.pos, nextEnd, 4);
          this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
          this.pos = this.reducePos = nextEnd;
          this.score -= 190;
        }
        canShift(term) {
          for (let sim = new SimulatedStack(this); ; ) {
            let action = this.p.parser.stateSlot(sim.state, 4) || this.p.parser.hasAction(sim.state, term);
            if ((action & 65536) == 0)
              return true;
            if (action == 0)
              return false;
            sim.reduce(action);
          }
        }
        recoverByInsert(next) {
          if (this.stack.length >= 300)
            return [];
          let nextStates = this.p.parser.nextStates(this.state);
          if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
            let best = [];
            for (let i = 0, s; i < nextStates.length; i += 2) {
              if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
                best.push(nextStates[i], s);
            }
            if (this.stack.length < 120)
              for (let i = 0; best.length < 4 << 1 && i < nextStates.length; i += 2) {
                let s = nextStates[i + 1];
                if (!best.some((v, i2) => i2 & 1 && v == s))
                  best.push(nextStates[i], s);
              }
            nextStates = best;
          }
          let result = [];
          for (let i = 0; i < nextStates.length && result.length < 4; i += 2) {
            let s = nextStates[i + 1];
            if (s == this.state)
              continue;
            let stack = this.split();
            stack.pushState(s, this.pos);
            stack.storeNode(0, stack.pos, stack.pos, 4, true);
            stack.shiftContext(nextStates[i], this.pos);
            stack.score -= 200;
            result.push(stack);
          }
          return result;
        }
        forceReduce() {
          let reduce = this.p.parser.stateSlot(this.state, 5);
          if ((reduce & 65536) == 0)
            return false;
          let { parser } = this.p;
          if (!parser.validAction(this.state, reduce)) {
            let depth = reduce >> 19, term = reduce & 65535;
            let target = this.stack.length - depth * 3;
            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0)
              return false;
            this.storeNode(0, this.reducePos, this.reducePos, 4, true);
            this.score -= 100;
          }
          this.reducePos = this.pos;
          this.reduce(reduce);
          return true;
        }
        forceAll() {
          while (!this.p.parser.stateFlag(this.state, 2)) {
            if (!this.forceReduce()) {
              this.storeNode(0, this.pos, this.pos, 4, true);
              break;
            }
          }
          return this;
        }
        get deadEnd() {
          if (this.stack.length != 3)
            return false;
          let { parser } = this.p;
          return parser.data[parser.stateSlot(this.state, 1)] == 65535 && !parser.stateSlot(this.state, 4);
        }
        restart() {
          this.state = this.stack[0];
          this.stack.length = 0;
        }
        sameState(other) {
          if (this.state != other.state || this.stack.length != other.stack.length)
            return false;
          for (let i = 0; i < this.stack.length; i += 3)
            if (this.stack[i] != other.stack[i])
              return false;
          return true;
        }
        get parser() {
          return this.p.parser;
        }
        dialectEnabled(dialectID) {
          return this.p.parser.dialect.flags[dialectID];
        }
        shiftContext(term, start) {
          if (this.curContext)
            this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
        }
        reduceContext(term, start) {
          if (this.curContext)
            this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
        }
        emitContext() {
          let last = this.buffer.length - 1;
          if (last < 0 || this.buffer[last] != -3)
            this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);
        }
        emitLookAhead() {
          let last = this.buffer.length - 1;
          if (last < 0 || this.buffer[last] != -4)
            this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);
        }
        updateContext(context) {
          if (context != this.curContext.context) {
            let newCx = new StackContext(this.curContext.tracker, context);
            if (newCx.hash != this.curContext.hash)
              this.emitContext();
            this.curContext = newCx;
          }
        }
        setLookAhead(lookAhead) {
          if (lookAhead > this.lookAhead) {
            this.emitLookAhead();
            this.lookAhead = lookAhead;
          }
        }
        close() {
          if (this.curContext && this.curContext.tracker.strict)
            this.emitContext();
          if (this.lookAhead > 0)
            this.emitLookAhead();
        }
      };
      var StackContext = class {
        constructor(tracker, context) {
          this.tracker = tracker;
          this.context = context;
          this.hash = tracker.strict ? tracker.hash(context) : 0;
        }
      };
      var Recover;
      (function(Recover2) {
        Recover2[Recover2["Insert"] = 200] = "Insert";
        Recover2[Recover2["Delete"] = 190] = "Delete";
        Recover2[Recover2["Reduce"] = 100] = "Reduce";
        Recover2[Recover2["MaxNext"] = 4] = "MaxNext";
        Recover2[Recover2["MaxInsertStackDepth"] = 300] = "MaxInsertStackDepth";
        Recover2[Recover2["DampenInsertStackDepth"] = 120] = "DampenInsertStackDepth";
      })(Recover || (Recover = {}));
      var SimulatedStack = class {
        constructor(start) {
          this.start = start;
          this.state = start.state;
          this.stack = start.stack;
          this.base = this.stack.length;
        }
        reduce(action) {
          let term = action & 65535, depth = action >> 19;
          if (depth == 0) {
            if (this.stack == this.start.stack)
              this.stack = this.stack.slice();
            this.stack.push(this.state, 0, 0);
            this.base += 3;
          } else {
            this.base -= (depth - 1) * 3;
          }
          let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
          this.state = goto;
        }
      };
      var StackBufferCursor = class {
        constructor(stack, pos, index) {
          this.stack = stack;
          this.pos = pos;
          this.index = index;
          this.buffer = stack.buffer;
          if (this.index == 0)
            this.maybeNext();
        }
        static create(stack, pos = stack.bufferBase + stack.buffer.length) {
          return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
        }
        maybeNext() {
          let next = this.stack.parent;
          if (next != null) {
            this.index = this.stack.bufferBase - next.bufferBase;
            this.stack = next;
            this.buffer = next.buffer;
          }
        }
        get id() {
          return this.buffer[this.index - 4];
        }
        get start() {
          return this.buffer[this.index - 3];
        }
        get end() {
          return this.buffer[this.index - 2];
        }
        get size() {
          return this.buffer[this.index - 1];
        }
        next() {
          this.index -= 4;
          this.pos -= 4;
          if (this.index == 0)
            this.maybeNext();
        }
        fork() {
          return new StackBufferCursor(this.stack, this.pos, this.index);
        }
      };
      var CachedToken = class {
        constructor() {
          this.start = -1;
          this.value = -1;
          this.end = -1;
          this.extended = -1;
          this.lookAhead = 0;
          this.mask = 0;
          this.context = 0;
        }
      };
      var nullToken = new CachedToken();
      var InputStream = class {
        constructor(input, ranges) {
          this.input = input;
          this.ranges = ranges;
          this.chunk = "";
          this.chunkOff = 0;
          this.chunk2 = "";
          this.chunk2Pos = 0;
          this.next = -1;
          this.token = nullToken;
          this.rangeIndex = 0;
          this.pos = this.chunkPos = ranges[0].from;
          this.range = ranges[0];
          this.end = ranges[ranges.length - 1].to;
          this.readNext();
        }
        resolveOffset(offset, assoc) {
          let range = this.range, index = this.rangeIndex;
          let pos = this.pos + offset;
          while (pos < range.from) {
            if (!index)
              return null;
            let next = this.ranges[--index];
            pos -= range.from - next.to;
            range = next;
          }
          while (assoc < 0 ? pos > range.to : pos >= range.to) {
            if (index == this.ranges.length - 1)
              return null;
            let next = this.ranges[++index];
            pos += next.from - range.to;
            range = next;
          }
          return pos;
        }
        clipPos(pos) {
          if (pos >= this.range.from && pos < this.range.to)
            return pos;
          for (let range of this.ranges)
            if (range.to > pos)
              return Math.max(pos, range.from);
          return this.end;
        }
        peek(offset) {
          let idx = this.chunkOff + offset, pos, result;
          if (idx >= 0 && idx < this.chunk.length) {
            pos = this.pos + offset;
            result = this.chunk.charCodeAt(idx);
          } else {
            let resolved = this.resolveOffset(offset, 1);
            if (resolved == null)
              return -1;
            pos = resolved;
            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
              result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
            } else {
              let i = this.rangeIndex, range = this.range;
              while (range.to <= pos)
                range = this.ranges[++i];
              this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
              if (pos + this.chunk2.length > range.to)
                this.chunk2 = this.chunk2.slice(0, range.to - pos);
              result = this.chunk2.charCodeAt(0);
            }
          }
          if (pos >= this.token.lookAhead)
            this.token.lookAhead = pos + 1;
          return result;
        }
        acceptToken(token, endOffset = 0) {
          let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
          if (end == null || end < this.token.start)
            throw new RangeError("Token end out of bounds");
          this.token.value = token;
          this.token.end = end;
        }
        getChunk() {
          if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
            let { chunk, chunkPos } = this;
            this.chunk = this.chunk2;
            this.chunkPos = this.chunk2Pos;
            this.chunk2 = chunk;
            this.chunk2Pos = chunkPos;
            this.chunkOff = this.pos - this.chunkPos;
          } else {
            this.chunk2 = this.chunk;
            this.chunk2Pos = this.chunkPos;
            let nextChunk = this.input.chunk(this.pos);
            let end = this.pos + nextChunk.length;
            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
            this.chunkPos = this.pos;
            this.chunkOff = 0;
          }
        }
        readNext() {
          if (this.chunkOff >= this.chunk.length) {
            this.getChunk();
            if (this.chunkOff == this.chunk.length)
              return this.next = -1;
          }
          return this.next = this.chunk.charCodeAt(this.chunkOff);
        }
        advance(n = 1) {
          this.chunkOff += n;
          while (this.pos + n >= this.range.to) {
            if (this.rangeIndex == this.ranges.length - 1)
              return this.setDone();
            n -= this.range.to - this.pos;
            this.range = this.ranges[++this.rangeIndex];
            this.pos = this.range.from;
          }
          this.pos += n;
          if (this.pos >= this.token.lookAhead)
            this.token.lookAhead = this.pos + 1;
          return this.readNext();
        }
        setDone() {
          this.pos = this.chunkPos = this.end;
          this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
          this.chunk = "";
          return this.next = -1;
        }
        reset(pos, token) {
          if (token) {
            this.token = token;
            token.start = pos;
            token.lookAhead = pos + 1;
            token.value = token.extended = -1;
          } else {
            this.token = nullToken;
          }
          if (this.pos != pos) {
            this.pos = pos;
            if (pos == this.end) {
              this.setDone();
              return this;
            }
            while (pos < this.range.from)
              this.range = this.ranges[--this.rangeIndex];
            while (pos >= this.range.to)
              this.range = this.ranges[++this.rangeIndex];
            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
              this.chunkOff = pos - this.chunkPos;
            } else {
              this.chunk = "";
              this.chunkOff = 0;
            }
            this.readNext();
          }
          return this;
        }
        read(from, to) {
          if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
            return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
          if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
            return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
          if (from >= this.range.from && to <= this.range.to)
            return this.input.read(from, to);
          let result = "";
          for (let r of this.ranges) {
            if (r.from >= to)
              break;
            if (r.to > from)
              result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));
          }
          return result;
        }
      };
      var TokenGroup = class {
        constructor(data, id2) {
          this.data = data;
          this.id = id2;
        }
        token(input, stack) {
          readToken(this.data, input, stack, this.id);
        }
      };
      TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
      var ExternalTokenizer = class {
        constructor(token, options = {}) {
          this.token = token;
          this.contextual = !!options.contextual;
          this.fallback = !!options.fallback;
          this.extend = !!options.extend;
        }
      };
      function readToken(data, input, stack, group) {
        let state = 0, groupMask = 1 << group, { parser } = stack.p, { dialect } = parser;
        scan:
          for (; ; ) {
            if ((groupMask & data[state]) == 0)
              break;
            let accEnd = data[state + 1];
            for (let i = state + 3; i < accEnd; i += 2)
              if ((data[i + 1] & groupMask) > 0) {
                let term = data[i];
                if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || parser.overrides(term, input.token.value))) {
                  input.acceptToken(term);
                  break;
                }
              }
            let next = input.next, low = 0, high = data[state + 2];
            if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535) {
              state = data[accEnd + high * 3 - 1];
              continue scan;
            }
            for (; low < high; ) {
              let mid = low + high >> 1;
              let index = accEnd + mid + (mid << 1);
              let from = data[index], to = data[index + 1];
              if (next < from)
                high = mid;
              else if (next >= to)
                low = mid + 1;
              else {
                state = data[index + 2];
                input.advance();
                continue scan;
              }
            }
            break;
          }
      }
      function decodeArray(input, Type = Uint16Array) {
        if (typeof input != "string")
          return input;
        let array = null;
        for (let pos = 0, out = 0; pos < input.length; ) {
          let value = 0;
          for (; ; ) {
            let next = input.charCodeAt(pos++), stop = false;
            if (next == 126) {
              value = 65535;
              break;
            }
            if (next >= 92)
              next--;
            if (next >= 34)
              next--;
            let digit = next - 32;
            if (digit >= 46) {
              digit -= 46;
              stop = true;
            }
            value += digit;
            if (stop)
              break;
            value *= 46;
          }
          if (array)
            array[out++] = value;
          else
            array = new Type(value);
        }
        return array;
      }
      var verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
      var stackIDs = null;
      var Safety;
      (function(Safety2) {
        Safety2[Safety2["Margin"] = 25] = "Margin";
      })(Safety || (Safety = {}));
      function cutAt(tree, pos, side) {
        let cursor = tree.cursor(common.IterMode.IncludeAnonymous);
        cursor.moveTo(pos);
        for (; ; ) {
          if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
            for (; ; ) {
              if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
                return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25)) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25));
              if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
                break;
              if (!cursor.parent())
                return side < 0 ? 0 : tree.length;
            }
        }
      }
      var FragmentCursor = class {
        constructor(fragments, nodeSet) {
          this.fragments = fragments;
          this.nodeSet = nodeSet;
          this.i = 0;
          this.fragment = null;
          this.safeFrom = -1;
          this.safeTo = -1;
          this.trees = [];
          this.start = [];
          this.index = [];
          this.nextFragment();
        }
        nextFragment() {
          let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
          if (fr) {
            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
            while (this.trees.length) {
              this.trees.pop();
              this.start.pop();
              this.index.pop();
            }
            this.trees.push(fr.tree);
            this.start.push(-fr.offset);
            this.index.push(0);
            this.nextStart = this.safeFrom;
          } else {
            this.nextStart = 1e9;
          }
        }
        nodeAt(pos) {
          if (pos < this.nextStart)
            return null;
          while (this.fragment && this.safeTo <= pos)
            this.nextFragment();
          if (!this.fragment)
            return null;
          for (; ; ) {
            let last = this.trees.length - 1;
            if (last < 0) {
              this.nextFragment();
              return null;
            }
            let top = this.trees[last], index = this.index[last];
            if (index == top.children.length) {
              this.trees.pop();
              this.start.pop();
              this.index.pop();
              continue;
            }
            let next = top.children[index];
            let start = this.start[last] + top.positions[index];
            if (start > pos) {
              this.nextStart = start;
              return null;
            }
            if (next instanceof common.Tree) {
              if (start == pos) {
                if (start < this.safeFrom)
                  return null;
                let end = start + next.length;
                if (end <= this.safeTo) {
                  let lookAhead = next.prop(common.NodeProp.lookAhead);
                  if (!lookAhead || end + lookAhead < this.fragment.to)
                    return next;
                }
              }
              this.index[last]++;
              if (start + next.length >= Math.max(this.safeFrom, pos)) {
                this.trees.push(next);
                this.start.push(start);
                this.index.push(0);
              }
            } else {
              this.index[last]++;
              this.nextStart = start + next.length;
            }
          }
        }
      };
      var TokenCache = class {
        constructor(parser, stream) {
          this.stream = stream;
          this.tokens = [];
          this.mainToken = null;
          this.actions = [];
          this.tokens = parser.tokenizers.map((_) => new CachedToken());
        }
        getActions(stack) {
          let actionIndex = 0;
          let main = null;
          let { parser } = stack.p, { tokenizers } = parser;
          let mask = parser.stateSlot(stack.state, 3);
          let context = stack.curContext ? stack.curContext.hash : 0;
          let lookAhead = 0;
          for (let i = 0; i < tokenizers.length; i++) {
            if ((1 << i & mask) == 0)
              continue;
            let tokenizer = tokenizers[i], token = this.tokens[i];
            if (main && !tokenizer.fallback)
              continue;
            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
              this.updateCachedToken(token, tokenizer, stack);
              token.mask = mask;
              token.context = context;
            }
            if (token.lookAhead > token.end + 25)
              lookAhead = Math.max(token.lookAhead, lookAhead);
            if (token.value != 0) {
              let startIndex = actionIndex;
              if (token.extended > -1)
                actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
              actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
              if (!tokenizer.extend) {
                main = token;
                if (actionIndex > startIndex)
                  break;
              }
            }
          }
          while (this.actions.length > actionIndex)
            this.actions.pop();
          if (lookAhead)
            stack.setLookAhead(lookAhead);
          if (!main && stack.pos == this.stream.end) {
            main = new CachedToken();
            main.value = stack.p.parser.eofTerm;
            main.start = main.end = stack.pos;
            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
          }
          this.mainToken = main;
          return this.actions;
        }
        getMainToken(stack) {
          if (this.mainToken)
            return this.mainToken;
          let main = new CachedToken(), { pos, p } = stack;
          main.start = pos;
          main.end = Math.min(pos + 1, p.stream.end);
          main.value = pos == p.stream.end ? p.parser.eofTerm : 0;
          return main;
        }
        updateCachedToken(token, tokenizer, stack) {
          let start = this.stream.clipPos(stack.pos);
          tokenizer.token(this.stream.reset(start, token), stack);
          if (token.value > -1) {
            let { parser } = stack.p;
            for (let i = 0; i < parser.specialized.length; i++)
              if (parser.specialized[i] == token.value) {
                let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);
                if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
                  if ((result & 1) == 0)
                    token.value = result >> 1;
                  else
                    token.extended = result >> 1;
                  break;
                }
              }
          } else {
            token.value = 0;
            token.end = this.stream.clipPos(start + 1);
          }
        }
        putAction(action, token, end, index) {
          for (let i = 0; i < index; i += 3)
            if (this.actions[i] == action)
              return index;
          this.actions[index++] = action;
          this.actions[index++] = token;
          this.actions[index++] = end;
          return index;
        }
        addActions(stack, token, end, index) {
          let { state } = stack, { parser } = stack.p, { data } = parser;
          for (let set = 0; set < 2; set++) {
            for (let i = parser.stateSlot(state, set ? 2 : 1); ; i += 3) {
              if (data[i] == 65535) {
                if (data[i + 1] == 1) {
                  i = pair(data, i + 2);
                } else {
                  if (index == 0 && data[i + 1] == 2)
                    index = this.putAction(pair(data, i + 2), token, end, index);
                  break;
                }
              }
              if (data[i] == token)
                index = this.putAction(pair(data, i + 1), token, end, index);
            }
          }
          return index;
        }
      };
      var Rec;
      (function(Rec2) {
        Rec2[Rec2["Distance"] = 5] = "Distance";
        Rec2[Rec2["MaxRemainingPerStep"] = 3] = "MaxRemainingPerStep";
        Rec2[Rec2["MinBufferLengthPrune"] = 500] = "MinBufferLengthPrune";
        Rec2[Rec2["ForceReduceLimit"] = 10] = "ForceReduceLimit";
        Rec2[Rec2["CutDepth"] = 15e3] = "CutDepth";
        Rec2[Rec2["CutTo"] = 9e3] = "CutTo";
      })(Rec || (Rec = {}));
      var Parse = class {
        constructor(parser, input, fragments, ranges) {
          this.parser = parser;
          this.input = input;
          this.ranges = ranges;
          this.recovering = 0;
          this.nextStackID = 9812;
          this.minStackPos = 0;
          this.reused = [];
          this.stoppedAt = null;
          this.stream = new InputStream(input, ranges);
          this.tokens = new TokenCache(parser, this.stream);
          this.topTerm = parser.top[1];
          let { from } = ranges[0];
          this.stacks = [Stack.start(this, parser.top[0], from)];
          this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4 ? new FragmentCursor(fragments, parser.nodeSet) : null;
        }
        get parsedPos() {
          return this.minStackPos;
        }
        advance() {
          let stacks = this.stacks, pos = this.minStackPos;
          let newStacks = this.stacks = [];
          let stopped, stoppedTokens;
          for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i];
            for (; ; ) {
              this.tokens.mainToken = null;
              if (stack.pos > pos) {
                newStacks.push(stack);
              } else if (this.advanceStack(stack, newStacks, stacks)) {
                continue;
              } else {
                if (!stopped) {
                  stopped = [];
                  stoppedTokens = [];
                }
                stopped.push(stack);
                let tok = this.tokens.getMainToken(stack);
                stoppedTokens.push(tok.value, tok.end);
              }
              break;
            }
          }
          if (!newStacks.length) {
            let finished = stopped && findFinished(stopped);
            if (finished)
              return this.stackToTree(finished);
            if (this.parser.strict) {
              if (verbose && stopped)
                console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
              throw new SyntaxError("No parse at " + pos);
            }
            if (!this.recovering)
              this.recovering = 5;
          }
          if (this.recovering && stopped) {
            let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
            if (finished)
              return this.stackToTree(finished.forceAll());
          }
          if (this.recovering) {
            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
            if (newStacks.length > maxRemaining) {
              newStacks.sort((a, b) => b.score - a.score);
              while (newStacks.length > maxRemaining)
                newStacks.pop();
            }
            if (newStacks.some((s) => s.reducePos > pos))
              this.recovering--;
          } else if (newStacks.length > 1) {
            outer:
              for (let i = 0; i < newStacks.length - 1; i++) {
                let stack = newStacks[i];
                for (let j = i + 1; j < newStacks.length; j++) {
                  let other = newStacks[j];
                  if (stack.sameState(other) || stack.buffer.length > 500 && other.buffer.length > 500) {
                    if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
                      newStacks.splice(j--, 1);
                    } else {
                      newStacks.splice(i--, 1);
                      continue outer;
                    }
                  }
                }
              }
          }
          this.minStackPos = newStacks[0].pos;
          for (let i = 1; i < newStacks.length; i++)
            if (newStacks[i].pos < this.minStackPos)
              this.minStackPos = newStacks[i].pos;
          return null;
        }
        stopAt(pos) {
          if (this.stoppedAt != null && this.stoppedAt < pos)
            throw new RangeError("Can't move stoppedAt forward");
          this.stoppedAt = pos;
        }
        advanceStack(stack, stacks, split) {
          let start = stack.pos, { parser } = this;
          let base = verbose ? this.stackID(stack) + " -> " : "";
          if (this.stoppedAt != null && start > this.stoppedAt)
            return stack.forceReduce() ? stack : null;
          if (this.fragments) {
            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
            for (let cached = this.fragments.nodeAt(start); cached; ) {
              let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;
              if (match > -1 && cached.length && (!strictCx || (cached.prop(common.NodeProp.contextHash) || 0) == cxHash)) {
                stack.useNode(cached, match);
                if (verbose)
                  console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);
                return true;
              }
              if (!(cached instanceof common.Tree) || cached.children.length == 0 || cached.positions[0] > 0)
                break;
              let inner = cached.children[0];
              if (inner instanceof common.Tree && cached.positions[0] == 0)
                cached = inner;
              else
                break;
            }
          }
          let defaultReduce = parser.stateSlot(stack.state, 4);
          if (defaultReduce > 0) {
            stack.reduce(defaultReduce);
            if (verbose)
              console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535)})`);
            return true;
          }
          if (stack.stack.length >= 15e3) {
            while (stack.stack.length > 9e3 && stack.forceReduce()) {
            }
          }
          let actions = this.tokens.getActions(stack);
          for (let i = 0; i < actions.length; ) {
            let action = actions[i++], term = actions[i++], end = actions[i++];
            let last = i == actions.length || !split;
            let localStack = last ? stack : stack.split();
            localStack.apply(action, term, end);
            if (verbose)
              console.log(base + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? "shift" : `reduce of ${parser.getName(action & 65535)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
            if (last)
              return true;
            else if (localStack.pos > start)
              stacks.push(localStack);
            else
              split.push(localStack);
          }
          return false;
        }
        advanceFully(stack, newStacks) {
          let pos = stack.pos;
          for (; ; ) {
            if (!this.advanceStack(stack, null, null))
              return false;
            if (stack.pos > pos) {
              pushStackDedup(stack, newStacks);
              return true;
            }
          }
        }
        runRecovery(stacks, tokens, newStacks) {
          let finished = null, restarted = false;
          for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
            let base = verbose ? this.stackID(stack) + " -> " : "";
            if (stack.deadEnd) {
              if (restarted)
                continue;
              restarted = true;
              stack.restart();
              if (verbose)
                console.log(base + this.stackID(stack) + " (restarted)");
              let done = this.advanceFully(stack, newStacks);
              if (done)
                continue;
            }
            let force = stack.split(), forceBase = base;
            for (let j = 0; force.forceReduce() && j < 10; j++) {
              if (verbose)
                console.log(forceBase + this.stackID(force) + " (via force-reduce)");
              let done = this.advanceFully(force, newStacks);
              if (done)
                break;
              if (verbose)
                forceBase = this.stackID(force) + " -> ";
            }
            for (let insert of stack.recoverByInsert(token)) {
              if (verbose)
                console.log(base + this.stackID(insert) + " (via recover-insert)");
              this.advanceFully(insert, newStacks);
            }
            if (this.stream.end > stack.pos) {
              if (tokenEnd == stack.pos) {
                tokenEnd++;
                token = 0;
              }
              stack.recoverByDelete(token, tokenEnd);
              if (verbose)
                console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
              pushStackDedup(stack, newStacks);
            } else if (!finished || finished.score < stack.score) {
              finished = stack;
            }
          }
          return finished;
        }
        stackToTree(stack) {
          stack.close();
          return common.Tree.build({
            buffer: StackBufferCursor.create(stack),
            nodeSet: this.parser.nodeSet,
            topID: this.topTerm,
            maxBufferLength: this.parser.bufferLength,
            reused: this.reused,
            start: this.ranges[0].from,
            length: stack.pos - this.ranges[0].from,
            minRepeatType: this.parser.minRepeatTerm
          });
        }
        stackID(stack) {
          let id2 = (stackIDs || (stackIDs = /* @__PURE__ */ new WeakMap())).get(stack);
          if (!id2)
            stackIDs.set(stack, id2 = String.fromCodePoint(this.nextStackID++));
          return id2 + stack;
        }
      };
      function pushStackDedup(stack, newStacks) {
        for (let i = 0; i < newStacks.length; i++) {
          let other = newStacks[i];
          if (other.pos == stack.pos && other.sameState(stack)) {
            if (newStacks[i].score < stack.score)
              newStacks[i] = stack;
            return;
          }
        }
        newStacks.push(stack);
      }
      var Dialect = class {
        constructor(source, flags, disabled) {
          this.source = source;
          this.flags = flags;
          this.disabled = disabled;
        }
        allows(term) {
          return !this.disabled || this.disabled[term] == 0;
        }
      };
      var id = (x) => x;
      var ContextTracker = class {
        constructor(spec) {
          this.start = spec.start;
          this.shift = spec.shift || id;
          this.reduce = spec.reduce || id;
          this.reuse = spec.reuse || id;
          this.hash = spec.hash || (() => 0);
          this.strict = spec.strict !== false;
        }
      };
      var LRParser = class extends common.Parser {
        constructor(spec) {
          super();
          this.wrappers = [];
          if (spec.version != 14)
            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14})`);
          let nodeNames = spec.nodeNames.split(" ");
          this.minRepeatTerm = nodeNames.length;
          for (let i = 0; i < spec.repeatNodeCount; i++)
            nodeNames.push("");
          let topTerms = Object.keys(spec.topRules).map((r) => spec.topRules[r][1]);
          let nodeProps = [];
          for (let i = 0; i < nodeNames.length; i++)
            nodeProps.push([]);
          function setProp(nodeID, prop, value) {
            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
          }
          if (spec.nodeProps)
            for (let propSpec of spec.nodeProps) {
              let prop = propSpec[0];
              if (typeof prop == "string")
                prop = common.NodeProp[prop];
              for (let i = 1; i < propSpec.length; ) {
                let next = propSpec[i++];
                if (next >= 0) {
                  setProp(next, prop, propSpec[i++]);
                } else {
                  let value = propSpec[i + -next];
                  for (let j = -next; j > 0; j--)
                    setProp(propSpec[i++], prop, value);
                  i++;
                }
              }
            }
          this.nodeSet = new common.NodeSet(nodeNames.map((name, i) => common.NodeType.define({
            name: i >= this.minRepeatTerm ? void 0 : name,
            id: i,
            props: nodeProps[i],
            top: topTerms.indexOf(i) > -1,
            error: i == 0,
            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
          })));
          if (spec.propSources)
            this.nodeSet = this.nodeSet.extend(...spec.propSources);
          this.strict = false;
          this.bufferLength = common.DefaultBufferLength;
          let tokenArray = decodeArray(spec.tokenData);
          this.context = spec.context;
          this.specializerSpecs = spec.specialized || [];
          this.specialized = new Uint16Array(this.specializerSpecs.length);
          for (let i = 0; i < this.specializerSpecs.length; i++)
            this.specialized[i] = this.specializerSpecs[i].term;
          this.specializers = this.specializerSpecs.map(getSpecializer);
          this.states = decodeArray(spec.states, Uint32Array);
          this.data = decodeArray(spec.stateData);
          this.goto = decodeArray(spec.goto);
          this.maxTerm = spec.maxTerm;
          this.tokenizers = spec.tokenizers.map((value) => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
          this.topRules = spec.topRules;
          this.dialects = spec.dialects || {};
          this.dynamicPrecedences = spec.dynamicPrecedences || null;
          this.tokenPrecTable = spec.tokenPrec;
          this.termNames = spec.termNames || null;
          this.maxNode = this.nodeSet.types.length - 1;
          this.dialect = this.parseDialect();
          this.top = this.topRules[Object.keys(this.topRules)[0]];
        }
        createParse(input, fragments, ranges) {
          let parse = new Parse(this, input, fragments, ranges);
          for (let w of this.wrappers)
            parse = w(parse, input, fragments, ranges);
          return parse;
        }
        getGoto(state, term, loose = false) {
          let table = this.goto;
          if (term >= table[0])
            return -1;
          for (let pos = table[term + 1]; ; ) {
            let groupTag = table[pos++], last = groupTag & 1;
            let target = table[pos++];
            if (last && loose)
              return target;
            for (let end = pos + (groupTag >> 1); pos < end; pos++)
              if (table[pos] == state)
                return target;
            if (last)
              return -1;
          }
        }
        hasAction(state, terminal) {
          let data = this.data;
          for (let set = 0; set < 2; set++) {
            for (let i = this.stateSlot(state, set ? 2 : 1), next; ; i += 3) {
              if ((next = data[i]) == 65535) {
                if (data[i + 1] == 1)
                  next = data[i = pair(data, i + 2)];
                else if (data[i + 1] == 2)
                  return pair(data, i + 2);
                else
                  break;
              }
              if (next == terminal || next == 0)
                return pair(data, i + 1);
            }
          }
          return 0;
        }
        stateSlot(state, slot) {
          return this.states[state * 6 + slot];
        }
        stateFlag(state, flag) {
          return (this.stateSlot(state, 0) & flag) > 0;
        }
        validAction(state, action) {
          if (action == this.stateSlot(state, 4))
            return true;
          for (let i = this.stateSlot(state, 1); ; i += 3) {
            if (this.data[i] == 65535) {
              if (this.data[i + 1] == 1)
                i = pair(this.data, i + 2);
              else
                return false;
            }
            if (action == pair(this.data, i + 1))
              return true;
          }
        }
        nextStates(state) {
          let result = [];
          for (let i = this.stateSlot(state, 1); ; i += 3) {
            if (this.data[i] == 65535) {
              if (this.data[i + 1] == 1)
                i = pair(this.data, i + 2);
              else
                break;
            }
            if ((this.data[i + 2] & 65536 >> 16) == 0) {
              let value = this.data[i + 1];
              if (!result.some((v, i2) => i2 & 1 && v == value))
                result.push(this.data[i], value);
            }
          }
          return result;
        }
        overrides(token, prev) {
          let iPrev = findOffset(this.data, this.tokenPrecTable, prev);
          return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;
        }
        configure(config) {
          let copy = Object.assign(Object.create(LRParser.prototype), this);
          if (config.props)
            copy.nodeSet = this.nodeSet.extend(...config.props);
          if (config.top) {
            let info = this.topRules[config.top];
            if (!info)
              throw new RangeError(`Invalid top rule name ${config.top}`);
            copy.top = info;
          }
          if (config.tokenizers)
            copy.tokenizers = this.tokenizers.map((t) => {
              let found = config.tokenizers.find((r) => r.from == t);
              return found ? found.to : t;
            });
          if (config.specializers) {
            copy.specializers = this.specializers.slice();
            copy.specializerSpecs = this.specializerSpecs.map((s, i) => {
              let found = config.specializers.find((r) => r.from == s.external);
              if (!found)
                return s;
              let spec = Object.assign(Object.assign({}, s), { external: found.to });
              copy.specializers[i] = getSpecializer(spec);
              return spec;
            });
          }
          if (config.contextTracker)
            copy.context = config.contextTracker;
          if (config.dialect)
            copy.dialect = this.parseDialect(config.dialect);
          if (config.strict != null)
            copy.strict = config.strict;
          if (config.wrap)
            copy.wrappers = copy.wrappers.concat(config.wrap);
          if (config.bufferLength != null)
            copy.bufferLength = config.bufferLength;
          return copy;
        }
        hasWrappers() {
          return this.wrappers.length > 0;
        }
        getName(term) {
          return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
        }
        get eofTerm() {
          return this.maxNode + 1;
        }
        get topNode() {
          return this.nodeSet.types[this.top[1]];
        }
        dynamicPrecedence(term) {
          let prec = this.dynamicPrecedences;
          return prec == null ? 0 : prec[term] || 0;
        }
        parseDialect(dialect) {
          let values = Object.keys(this.dialects), flags = values.map(() => false);
          if (dialect)
            for (let part of dialect.split(" ")) {
              let id2 = values.indexOf(part);
              if (id2 >= 0)
                flags[id2] = true;
            }
          let disabled = null;
          for (let i = 0; i < values.length; i++)
            if (!flags[i]) {
              for (let j = this.dialects[values[i]], id2; (id2 = this.data[j++]) != 65535; )
                (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id2] = 1;
            }
          return new Dialect(dialect, flags, disabled);
        }
        static deserialize(spec) {
          return new LRParser(spec);
        }
      };
      function pair(data, off) {
        return data[off] | data[off + 1] << 16;
      }
      function findOffset(data, start, term) {
        for (let i = start, next; (next = data[i]) != 65535; i++)
          if (next == term)
            return i - start;
        return -1;
      }
      function findFinished(stacks) {
        let best = null;
        for (let stack of stacks) {
          let stopped = stack.p.stoppedAt;
          if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(stack.state, 2) && (!best || best.score < stack.score))
            best = stack;
        }
        return best;
      }
      function getSpecializer(spec) {
        if (spec.external) {
          let mask = spec.extend ? 1 : 0;
          return (value, stack) => spec.external(value, stack) << 1 | mask;
        }
        return spec.get;
      }
      exports.ContextTracker = ContextTracker;
      exports.ExternalTokenizer = ExternalTokenizer;
      exports.InputStream = InputStream;
      exports.LRParser = LRParser;
      exports.Stack = Stack;
    }
  });

  // node_modules/@codemirror/lang-sql/dist/index.cjs
  var require_dist13 = __commonJS({
    "node_modules/@codemirror/lang-sql/dist/index.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var language = require_dist5();
      var highlight = require_dist4();
      var lr = require_dist12();
      var autocomplete = require_dist9();
      var whitespace = 36;
      var LineComment = 1;
      var BlockComment = 2;
      var String$1 = 3;
      var Number2 = 4;
      var Bool = 5;
      var Null = 6;
      var ParenL = 7;
      var ParenR = 8;
      var BraceL = 9;
      var BraceR = 10;
      var BracketL = 11;
      var BracketR = 12;
      var Semi = 13;
      var Dot = 14;
      var Operator = 15;
      var Punctuation = 16;
      var SpecialVar = 17;
      var Identifier = 18;
      var QuotedIdentifier = 19;
      var Keyword = 20;
      var Type = 21;
      var Bits = 22;
      var Bytes = 23;
      var Builtin = 24;
      function isAlpha(ch) {
        return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 48 && ch <= 57;
      }
      function isHexDigit(ch) {
        return ch >= 48 && ch <= 57 || ch >= 97 && ch <= 102 || ch >= 65 && ch <= 70;
      }
      function readLiteral(input, endQuote, backslashEscapes) {
        for (let escaped = false; ; ) {
          if (input.next < 0)
            return;
          if (input.next == endQuote && !escaped) {
            input.advance();
            return;
          }
          escaped = backslashEscapes && !escaped && input.next == 92;
          input.advance();
        }
      }
      function readDoubleDollarLiteral(input) {
        for (; ; ) {
          if (input.next < 0 || input.peek(1) < 0)
            return;
          if (input.next == 36 && input.peek(1) == 36) {
            input.advance(2);
            return;
          }
          input.advance();
        }
      }
      function readWord(input, result) {
        for (; ; ) {
          if (input.next != 95 && !isAlpha(input.next))
            break;
          if (result != null)
            result += String.fromCharCode(input.next);
          input.advance();
        }
        return result;
      }
      function readWordOrQuoted(input) {
        if (input.next == 39 || input.next == 34 || input.next == 96) {
          let quote = input.next;
          input.advance();
          readLiteral(input, quote, false);
        } else {
          readWord(input);
        }
      }
      function readBits(input, endQuote) {
        while (input.next == 48 || input.next == 49)
          input.advance();
        if (endQuote && input.next == endQuote)
          input.advance();
      }
      function readNumber(input, sawDot) {
        for (; ; ) {
          if (input.next == 46) {
            if (sawDot)
              break;
            sawDot = true;
          } else if (input.next < 48 || input.next > 57) {
            break;
          }
          input.advance();
        }
        if (input.next == 69 || input.next == 101) {
          input.advance();
          if (input.next == 43 || input.next == 45)
            input.advance();
          while (input.next >= 48 && input.next <= 57)
            input.advance();
        }
      }
      function eol(input) {
        while (!(input.next < 0 || input.next == 10))
          input.advance();
      }
      function inString(ch, str) {
        for (let i = 0; i < str.length; i++)
          if (str.charCodeAt(i) == ch)
            return true;
        return false;
      }
      var Space = " 	\r\n";
      function keywords(keywords2, types, builtin) {
        let result = /* @__PURE__ */ Object.create(null);
        result["true"] = result["false"] = Bool;
        result["null"] = result["unknown"] = Null;
        for (let kw of keywords2.split(" "))
          if (kw)
            result[kw] = Keyword;
        for (let tp of types.split(" "))
          if (tp)
            result[tp] = Type;
        for (let kw of (builtin || "").split(" "))
          if (kw)
            result[kw] = Builtin;
        return result;
      }
      var SQLTypes = "array binary bit boolean char character clob date decimal double float int integer interval large national nchar nclob numeric object precision real smallint time timestamp varchar varying ";
      var SQLKeywords = "absolute action add after all allocate alter and any are as asc assertion at authorization before begin between both breadth by call cascade cascaded case cast catalog check close collate collation column commit condition connect connection constraint constraints constructor continue corresponding count create cross cube current current_date current_default_transform_group current_transform_group_for_type current_path current_role current_time current_timestamp current_user cursor cycle data day deallocate declare default deferrable deferred delete depth deref desc describe descriptor deterministic diagnostics disconnect distinct do domain drop dynamic each else elseif end end-exec equals escape except exception exec execute exists exit external fetch first for foreign found from free full function general get global go goto grant group grouping handle having hold hour identity if immediate in indicator initially inner inout input insert intersect into is isolation join key language last lateral leading leave left level like limit local localtime localtimestamp locator loop map match method minute modifies module month names natural nesting new next no none not of old on only open option or order ordinality out outer output overlaps pad parameter partial path prepare preserve primary prior privileges procedure public read reads recursive redo ref references referencing relative release repeat resignal restrict result return returns revoke right role rollback rollup routine row rows savepoint schema scroll search second section select session session_user set sets signal similar size some space specific specifictype sql sqlexception sqlstate sqlwarning start state static system_user table temporary then timezone_hour timezone_minute to trailing transaction translation treat trigger under undo union unique unnest until update usage user using value values view when whenever where while with without work write year zone ";
      var defaults = {
        backslashEscapes: false,
        hashComments: false,
        spaceAfterDashes: false,
        slashComments: false,
        doubleQuotedStrings: false,
        doubleDollarStrings: false,
        unquotedBitLiterals: false,
        treatBitsAsBytes: false,
        charSetCasts: false,
        operatorChars: "*+-%<>!=&|~^/",
        specialVar: "?",
        identifierQuotes: '"',
        words: keywords(SQLKeywords, SQLTypes)
      };
      function dialect(spec, kws, types, builtin) {
        let dialect2 = {};
        for (let prop in defaults)
          dialect2[prop] = (spec.hasOwnProperty(prop) ? spec : defaults)[prop];
        if (kws)
          dialect2.words = keywords(kws, types || "", builtin);
        return dialect2;
      }
      function tokensFor(d) {
        return new lr.ExternalTokenizer((input) => {
          var _a;
          let { next } = input;
          input.advance();
          if (inString(next, Space)) {
            while (inString(input.next, Space))
              input.advance();
            input.acceptToken(whitespace);
          } else if (next == 36 && input.next == 36 && d.doubleDollarStrings) {
            readDoubleDollarLiteral(input);
            input.acceptToken(String$1);
          } else if (next == 39 || next == 34 && d.doubleQuotedStrings) {
            readLiteral(input, next, d.backslashEscapes);
            input.acceptToken(String$1);
          } else if (next == 35 && d.hashComments || next == 47 && input.next == 47 && d.slashComments) {
            eol(input);
            input.acceptToken(LineComment);
          } else if (next == 45 && input.next == 45 && (!d.spaceAfterDashes || input.peek(2) == 32)) {
            eol(input);
            input.acceptToken(LineComment);
          } else if (next == 47 && input.next == 42) {
            input.advance();
            for (let prev = -1, depth = 1; ; ) {
              if (input.next < 0)
                break;
              input.advance();
              if (prev == 42 && input.next == 47) {
                depth--;
                if (!depth) {
                  input.advance();
                  break;
                }
                prev = -1;
              } else if (prev == 47 && input.next == 42) {
                depth++;
                prev = -1;
              } else {
                prev = input.next;
              }
            }
            input.acceptToken(BlockComment);
          } else if ((next == 101 || next == 69) && input.next == 39) {
            input.advance();
            readLiteral(input, 39, true);
          } else if ((next == 110 || next == 78) && input.next == 39 && d.charSetCasts) {
            input.advance();
            readLiteral(input, 39, d.backslashEscapes);
            input.acceptToken(String$1);
          } else if (next == 95 && d.charSetCasts) {
            for (let i = 0; ; i++) {
              if (input.next == 39 && i > 1) {
                input.advance();
                readLiteral(input, 39, d.backslashEscapes);
                input.acceptToken(String$1);
                break;
              }
              if (!isAlpha(input.next))
                break;
              input.advance();
            }
          } else if (next == 40) {
            input.acceptToken(ParenL);
          } else if (next == 41) {
            input.acceptToken(ParenR);
          } else if (next == 123) {
            input.acceptToken(BraceL);
          } else if (next == 125) {
            input.acceptToken(BraceR);
          } else if (next == 91) {
            input.acceptToken(BracketL);
          } else if (next == 93) {
            input.acceptToken(BracketR);
          } else if (next == 59) {
            input.acceptToken(Semi);
          } else if (d.unquotedBitLiterals && next == 48 && input.next == 98) {
            input.advance();
            readBits(input);
            input.acceptToken(Bits);
          } else if ((next == 98 || next == 66) && (input.next == 39 || input.next == 34)) {
            const quoteStyle = input.next;
            input.advance();
            if (d.treatBitsAsBytes) {
              readLiteral(input, quoteStyle, d.backslashEscapes);
              input.acceptToken(Bytes);
            } else {
              readBits(input, quoteStyle);
              input.acceptToken(Bits);
            }
          } else if (next == 48 && (input.next == 120 || input.next == 88) || (next == 120 || next == 88) && input.next == 39) {
            let quoted = input.next == 39;
            input.advance();
            while (isHexDigit(input.next))
              input.advance();
            if (quoted && input.next == 39)
              input.advance();
            input.acceptToken(Number2);
          } else if (next == 46 && input.next >= 48 && input.next <= 57) {
            readNumber(input, true);
            input.acceptToken(Number2);
          } else if (next == 46) {
            input.acceptToken(Dot);
          } else if (next >= 48 && next <= 57) {
            readNumber(input, false);
            input.acceptToken(Number2);
          } else if (inString(next, d.operatorChars)) {
            while (inString(input.next, d.operatorChars))
              input.advance();
            input.acceptToken(Operator);
          } else if (inString(next, d.specialVar)) {
            if (input.next == next)
              input.advance();
            readWordOrQuoted(input);
            input.acceptToken(SpecialVar);
          } else if (inString(next, d.identifierQuotes)) {
            readLiteral(input, next, false);
            input.acceptToken(QuotedIdentifier);
          } else if (next == 58 || next == 44) {
            input.acceptToken(Punctuation);
          } else if (isAlpha(next)) {
            let word = readWord(input, String.fromCharCode(next));
            input.acceptToken((_a = d.words[word.toLowerCase()]) !== null && _a !== void 0 ? _a : Identifier);
          }
        });
      }
      var tokens = tokensFor(defaults);
      var parser$1 = lr.LRParser.deserialize({
        version: 14,
        states: "%dQ]QQOOO#wQRO'#DSO$OQQO'#CwO%eQQO'#CxO%lQQO'#CyO%sQQO'#CzOOQQ'#DS'#DSOOQQ'#C}'#C}O'UQRO'#C{OOQQ'#Cv'#CvOOQQ'#C|'#C|Q]QQOOQOQQOOO'`QQO,59cO'kQQO,59cO'pQQO'#DSOOQQ,59d,59dO'}QQO,59dOOQQ,59e,59eO(UQQO,59eOOQQ,59f,59fO(]QQO,59fOOQQ-E6{-E6{OOQQ,59b,59bOOQQ-E6z-E6zOOQQ'#DO'#DOOOQQ1G.}1G.}O'`QQO1G.}OOQQ1G/O1G/OOOQQ1G/P1G/POOQQ1G/Q1G/QP(dQQO'#C}POQQ-E6|-E6|OOQQ7+$i7+$i",
        stateData: "(k~OtOSPOSQOS~ORUOSUOTUOUUOVROXSOZTO]XO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O^]ORvXSvXTvXUvXVvXXvXZvX]vX_vX`vXavXbvXcvXdvXevXfvXgvXhvX~OsvX~P!jOa^Ob^Oc^O~ORUOSUOTUOUUOVROXSOZTO^QO_UO`UOa_Ob_Oc_OdUOeUOfUOgUOhUO~OW`O~P$ZOYbO~P$ZO[dO~P$ZORUOSUOTUOUUOVROXSOZTO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O]gOsoX~P%zOaiObiOciO~O^kO~OWvXYvX[vX~P!jOWlO~P$ZOYmO~P$ZO[nO~P$ZO]gO~P$ZO",
        goto: "#[wPPPPPPPPPPPPPPPPPPPPPPPPPPx||||!Y!^!d!xPPP#OTYOZeUORSTWZaceoT[OZQZORhZSWOZQaRQcSQeTZfWaceoQj]RqkeVORSTWZaceo",
        nodeNames: "\u26A0 LineComment BlockComment String Number Bool Null ( ) [ ] { } ; . Operator Punctuation SpecialVar Identifier QuotedIdentifier Keyword Type Bits Bytes Builtin Script Statement CompositeIdentifier Parens Braces Brackets Statement",
        maxTerm: 38,
        skippedNodes: [0, 1, 2],
        repeatNodeCount: 3,
        tokenData: "RORO",
        tokenizers: [0, tokens],
        topRules: { "Script": [0, 25] },
        tokenPrec: 0
      });
      function tokenBefore(tree) {
        let cursor = tree.cursor().moveTo(tree.from, -1);
        while (/Comment/.test(cursor.name))
          cursor.moveTo(cursor.from, -1);
        return cursor.node;
      }
      function stripQuotes(name) {
        let quoted = /^[`'"](.*)[`'"]$/.exec(name);
        return quoted ? quoted[1] : name;
      }
      function isIdentifierOrSchema(state, node) {
        return node.name == "Identifier" || node.name == "QuotedIdentifier" || node.name == "Keyword" && /^public$/i.test(state.sliceDoc(node.from, node.to));
      }
      function parentsFor(state, node) {
        for (let path = []; ; ) {
          if (!node || node.name != ".")
            return path;
          let name = tokenBefore(node);
          if (!name || !isIdentifierOrSchema(state, name))
            return path;
          path.unshift(stripQuotes(state.sliceDoc(name.from, name.to)));
          node = tokenBefore(name);
        }
      }
      function sourceContext(state, startPos) {
        let pos = language.syntaxTree(state).resolveInner(startPos, -1);
        if (pos.name == "Identifier" || pos.name == "QuotedIdentifier") {
          return {
            from: pos.from,
            quoted: pos.name == "QuotedIdentifier" ? state.sliceDoc(pos.from, pos.from + 1) : null,
            parents: parentsFor(state, tokenBefore(pos))
          };
        }
        if (pos.name == ".") {
          return {
            from: startPos,
            quoted: null,
            parents: parentsFor(state, pos)
          };
        } else {
          return { from: startPos, quoted: null, parents: [], empty: true };
        }
      }
      function maybeQuoteCompletions(quote, completions) {
        if (!quote)
          return completions;
        return completions.map((c) => Object.assign(Object.assign({}, c), { label: quote + c.label + quote, apply: void 0 }));
      }
      var Span = /^\w*$/;
      var QuotedSpan = /^[`'"]?\w*[`'"]?$/;
      var CompletionLevel = class {
        constructor() {
          this.list = [];
          this.children = void 0;
        }
        child(name) {
          let children = this.children || (this.children = /* @__PURE__ */ Object.create(null));
          return children[name] || (children[name] = new CompletionLevel());
        }
        childCompletions(type) {
          return this.children ? Object.keys(this.children).filter((x) => x).map((name) => ({ label: name, type })) : [];
        }
      };
      function completeFromSchema(schema, tables, defaultTableName, defaultSchemaName) {
        let top = new CompletionLevel();
        let defaultSchema = top.child(defaultSchemaName || "");
        for (let table in schema) {
          let dot = table.indexOf(".");
          let schemaCompletions = dot > -1 ? top.child(table.slice(0, dot)) : defaultSchema;
          let tableCompletions = schemaCompletions.child(dot > -1 ? table.slice(dot + 1) : table);
          tableCompletions.list = schema[table].map((val) => typeof val == "string" ? { label: val, type: "property" } : val);
        }
        defaultSchema.list = (tables || defaultSchema.childCompletions("type")).concat(defaultTableName ? defaultSchema.child(defaultTableName).list : []);
        for (let sName in top.children) {
          let schema2 = top.child(sName);
          if (!schema2.list.length)
            schema2.list = schema2.childCompletions("type");
        }
        top.list = defaultSchema.list.concat(top.childCompletions("type"));
        return (context) => {
          let { parents, from, quoted, empty } = sourceContext(context.state, context.pos);
          if (empty && !context.explicit)
            return null;
          let level = top;
          for (let name of parents) {
            while (!level.children || !level.children[name]) {
              if (level == top)
                level = defaultSchema;
              else if (level == defaultSchema && defaultTableName)
                level = level.child(defaultTableName);
              else
                return null;
            }
            level = level.child(name);
          }
          let quoteAfter = quoted && context.state.sliceDoc(context.pos, context.pos + 1) == quoted;
          return {
            from,
            to: quoteAfter ? context.pos + 1 : void 0,
            options: maybeQuoteCompletions(quoted, level.list),
            validFor: quoted ? QuotedSpan : Span
          };
        };
      }
      function completeKeywords(keywords2, upperCase) {
        let completions = Object.keys(keywords2).map((keyword) => ({
          label: upperCase ? keyword.toUpperCase() : keyword,
          type: keywords2[keyword] == Type ? "type" : keywords2[keyword] == Keyword ? "keyword" : "variable",
          boost: -1
        }));
        return autocomplete.ifNotIn(["QuotedIdentifier", "SpecialVar", "String", "LineComment", "BlockComment", "."], autocomplete.completeFromList(completions));
      }
      var parser = parser$1.configure({
        props: [
          language.indentNodeProp.add({
            Statement: language.continuedIndent()
          }),
          language.foldNodeProp.add({
            Statement(tree) {
              return { from: tree.firstChild.to, to: tree.to };
            },
            BlockComment(tree) {
              return { from: tree.from + 2, to: tree.to - 2 };
            }
          }),
          highlight.styleTags({
            Keyword: highlight.tags.keyword,
            Type: highlight.tags.typeName,
            Builtin: highlight.tags.standard(highlight.tags.name),
            Bits: highlight.tags.number,
            Bytes: highlight.tags.string,
            Bool: highlight.tags.bool,
            Null: highlight.tags.null,
            Number: highlight.tags.number,
            String: highlight.tags.string,
            Identifier: highlight.tags.name,
            QuotedIdentifier: highlight.tags.special(highlight.tags.string),
            SpecialVar: highlight.tags.special(highlight.tags.name),
            LineComment: highlight.tags.lineComment,
            BlockComment: highlight.tags.blockComment,
            Operator: highlight.tags.operator,
            "Semi Punctuation": highlight.tags.punctuation,
            "( )": highlight.tags.paren,
            "{ }": highlight.tags.brace,
            "[ ]": highlight.tags.squareBracket
          })
        ]
      });
      var SQLDialect = class {
        constructor(dialect2, language2) {
          this.dialect = dialect2;
          this.language = language2;
        }
        get extension() {
          return this.language.extension;
        }
        static define(spec) {
          let d = dialect(spec, spec.keywords, spec.types, spec.builtin);
          let language$1 = language.LRLanguage.define({
            parser: parser.configure({
              tokenizers: [{ from: tokens, to: tokensFor(d) }]
            }),
            languageData: {
              commentTokens: { line: "--", block: { open: "/*", close: "*/" } },
              closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] }
            }
          });
          return new SQLDialect(d, language$1);
        }
      };
      function keywordCompletionSource(dialect2, upperCase = false) {
        return completeKeywords(dialect2.dialect.words, upperCase);
      }
      function keywordCompletion(dialect2, upperCase = false) {
        return dialect2.language.data.of({
          autocomplete: keywordCompletionSource(dialect2, upperCase)
        });
      }
      function schemaCompletionSource(config) {
        return config.schema ? completeFromSchema(config.schema, config.tables, config.defaultTable, config.defaultSchema) : () => null;
      }
      function schemaCompletion(config) {
        return config.schema ? (config.dialect || StandardSQL).language.data.of({
          autocomplete: schemaCompletionSource(config)
        }) : [];
      }
      function sql2(config = {}) {
        let lang = config.dialect || StandardSQL;
        return new language.LanguageSupport(lang.language, [schemaCompletion(config), keywordCompletion(lang, !!config.upperCaseKeywords)]);
      }
      var StandardSQL = SQLDialect.define({});
      var PostgreSQL = SQLDialect.define({
        charSetCasts: true,
        doubleDollarQuotedStrings: true,
        operatorChars: "+-*/<>=~!@#%^&|`?",
        specialVar: "",
        keywords: SQLKeywords + "a abort abs absent access according ada admin aggregate alias also always analyse analyze array_agg array_max_cardinality asensitive assert assignment asymmetric atomic attach attribute attributes avg backward base64 begin_frame begin_partition bernoulli bit_length blocked bom c cache called cardinality catalog_name ceil ceiling chain char_length character_length character_set_catalog character_set_name character_set_schema characteristics characters checkpoint class class_origin cluster coalesce cobol collation_catalog collation_name collation_schema collect column_name columns command_function command_function_code comment comments committed concurrently condition_number configuration conflict connection_name constant constraint_catalog constraint_name constraint_schema contains content control conversion convert copy corr cost covar_pop covar_samp csv cume_dist current_catalog current_row current_schema cursor_name database datalink datatype datetime_interval_code datetime_interval_precision db debug defaults defined definer degree delimiter delimiters dense_rank depends derived detach detail dictionary disable discard dispatch dlnewcopy dlpreviouscopy dlurlcomplete dlurlcompleteonly dlurlcompletewrite dlurlpath dlurlpathonly dlurlpathwrite dlurlscheme dlurlserver dlvalue document dump dynamic_function dynamic_function_code element elsif empty enable encoding encrypted end_frame end_partition endexec enforced enum errcode error event every exclude excluding exclusive exp explain expression extension extract family file filter final first_value flag floor following force foreach fortran forward frame_row freeze fs functions fusion g generated granted greatest groups handler header hex hierarchy hint id ignore ilike immediately immutable implementation implicit import include including increment indent index indexes info inherit inherits inline insensitive instance instantiable instead integrity intersection invoker isnull k key_member key_type label lag last_value lead leakproof least length library like_regex link listen ln load location lock locked log logged lower m mapping matched materialized max max_cardinality maxvalue member merge message message_length message_octet_length message_text min minvalue mod mode more move multiset mumps name namespace nfc nfd nfkc nfkd nil normalize normalized nothing notice notify notnull nowait nth_value ntile nullable nullif nulls number occurrences_regex octet_length octets off offset oids operator options ordering others over overlay overriding owned owner p parallel parameter_mode parameter_name parameter_ordinal_position parameter_specific_catalog parameter_specific_name parameter_specific_schema parser partition pascal passing passthrough password percent percent_rank percentile_cont percentile_disc perform period permission pg_context pg_datatype_name pg_exception_context pg_exception_detail pg_exception_hint placing plans pli policy portion position position_regex power precedes preceding prepared print_strict_params procedural procedures program publication query quote raise range rank reassign recheck recovery refresh regr_avgx regr_avgy regr_count regr_intercept regr_r2 regr_slope regr_sxx regr_sxy regr_syy reindex rename repeatable replace replica requiring reset respect restart restore result_oid returned_cardinality returned_length returned_octet_length returned_sqlstate returning reverse routine_catalog routine_name routine_schema routines row_count row_number rowtype rule scale schema_name schemas scope scope_catalog scope_name scope_schema security selective self sensitive sequence sequences serializable server server_name setof share show simple skip slice snapshot source specific_name sqlcode sqlerror sqrt stable stacked standalone statement statistics stddev_pop stddev_samp stdin stdout storage strict strip structure style subclass_origin submultiset subscription substring substring_regex succeeds sum symmetric sysid system system_time t table_name tables tablesample tablespace temp template ties token top_level_count transaction_active transactions_committed transactions_rolled_back transform transforms translate translate_regex trigger_catalog trigger_name trigger_schema trim trim_array truncate trusted type types uescape unbounded uncommitted unencrypted unlink unlisten unlogged unnamed untyped upper uri use_column use_variable user_defined_type_catalog user_defined_type_code user_defined_type_name user_defined_type_schema vacuum valid validate validator value_of var_pop var_samp varbinary variable_conflict variadic verbose version versioning views volatile warning whitespace width_bucket window within wrapper xmlagg xmlattributes xmlbinary xmlcast xmlcomment xmlconcat xmldeclaration xmldocument xmlelement xmlexists xmlforest xmliterate xmlnamespaces xmlparse xmlpi xmlquery xmlroot xmlschema xmlserialize xmltable xmltext xmlvalidate yes",
        types: SQLTypes + "bigint int8 bigserial serial8 varbit bool box bytea cidr circle precision float8 inet int4 json jsonb line lseg macaddr macaddr8 money numeric pg_lsn point polygon float4 int2 smallserial serial2 serial serial4 text timetz timestamptz tsquery tsvector txid_snapshot uuid xml"
      });
      var MySQLKeywords = "accessible algorithm analyze asensitive authors auto_increment autocommit avg avg_row_length binlog btree cache catalog_name chain change changed checkpoint checksum class_origin client_statistics coalesce code collations columns comment committed completion concurrent consistent contains contributors convert database databases day_hour day_microsecond day_minute day_second delay_key_write delayed delimiter des_key_file dev_pop dev_samp deviance directory disable discard distinctrow div dual dumpfile enable enclosed ends engine engines enum errors escaped even event events every explain extended fast field fields flush force found_rows fulltext grants handler hash high_priority hosts hour_microsecond hour_minute hour_second ignore ignore_server_ids import index index_statistics infile innodb insensitive insert_method install invoker iterate keys kill linear lines list load lock logs low_priority master master_heartbeat_period master_ssl_verify_server_cert masters max max_rows maxvalue message_text middleint migrate min min_rows minute_microsecond minute_second mod mode modify mutex mysql_errno no_write_to_binlog offline offset one online optimize optionally outfile pack_keys parser partition partitions password phase plugin plugins prev processlist profile profiles purge query quick range read_write rebuild recover regexp relaylog remove rename reorganize repair repeatable replace require resume rlike row_format rtree schedule schema_name schemas second_microsecond security sensitive separator serializable server share show slave slow snapshot soname spatial sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result ssl starting starts std stddev stddev_pop stddev_samp storage straight_join subclass_origin sum suspend table_name table_statistics tables tablespace terminated triggers truncate uncommitted uninstall unlock upgrade use use_frm user_resources user_statistics utc_date utc_time utc_timestamp variables views warnings xa xor year_month zerofill";
      var MySQLTypes = SQLTypes + "bool blob long longblob longtext medium mediumblob mediumint mediumtext tinyblob tinyint tinytext text bigint int1 int2 int3 int4 int8 float4 float8 varbinary varcharacter precision datetime unsigned signed";
      var MySQLBuiltin = "charset clear edit ego help nopager notee nowarning pager print prompt quit rehash source status system tee";
      var MySQL = SQLDialect.define({
        operatorChars: "*+-%<>!=&|^",
        charSetCasts: true,
        doubleQuotedStrings: true,
        unquotedBitLiterals: true,
        hashComments: true,
        spaceAfterDashes: true,
        specialVar: "@?",
        identifierQuotes: "`",
        keywords: SQLKeywords + "group_concat " + MySQLKeywords,
        types: MySQLTypes,
        builtin: MySQLBuiltin
      });
      var MariaSQL = SQLDialect.define({
        operatorChars: "*+-%<>!=&|^",
        charSetCasts: true,
        doubleQuotedStrings: true,
        unquotedBitLiterals: true,
        hashComments: true,
        spaceAfterDashes: true,
        specialVar: "@?",
        identifierQuotes: "`",
        keywords: SQLKeywords + "always generated groupby_concat hard persistent shutdown soft virtual " + MySQLKeywords,
        types: MySQLTypes,
        builtin: MySQLBuiltin
      });
      var MSSQL = SQLDialect.define({
        keywords: SQLKeywords + "trigger proc view index for add constraint key primary foreign collate clustered nonclustered declare exec go if use index holdlock nolock nowait paglock pivot readcommitted readcommittedlock readpast readuncommitted repeatableread rowlock serializable snapshot tablock tablockx unpivot updlock with",
        types: SQLTypes + "bigint smallint smallmoney tinyint money real text nvarchar ntext varbinary image hierarchyid uniqueidentifier sql_variant xml",
        builtin: "binary_checksum checksum connectionproperty context_info current_request_id error_line error_message error_number error_procedure error_severity error_state formatmessage get_filestream_transaction_context getansinull host_id host_name isnull isnumeric min_active_rowversion newid newsequentialid rowcount_big xact_state object_id",
        operatorChars: "*+-%<>!=^&|/",
        specialVar: "@"
      });
      var SQLite = SQLDialect.define({
        keywords: SQLKeywords + "abort analyze attach autoincrement conflict database detach exclusive fail glob ignore index indexed instead isnull notnull offset plan pragma query raise regexp reindex rename replace temp vacuum virtual",
        types: SQLTypes + "bool blob long longblob longtext medium mediumblob mediumint mediumtext tinyblob tinyint tinytext text bigint int2 int8 unsigned signed real",
        builtin: "auth backup bail changes clone databases dbinfo dump echo eqp explain fullschema headers help import imposter indexes iotrace lint load log mode nullvalue once print prompt quit restore save scanstats separator shell show stats system tables testcase timeout timer trace vfsinfo vfslist vfsname width",
        operatorChars: "*+-%<>!=&|/~",
        identifierQuotes: '`"',
        specialVar: "@:?$"
      });
      var Cassandra = SQLDialect.define({
        keywords: "add all allow alter and any apply as asc authorize batch begin by clustering columnfamily compact consistency count create custom delete desc distinct drop each_quorum exists filtering from grant if in index insert into key keyspace keyspaces level limit local_one local_quorum modify nan norecursive nosuperuser not of on one order password permission permissions primary quorum rename revoke schema select set storage superuser table three to token truncate ttl two type unlogged update use user users using values where with writetime infinity NaN",
        types: SQLTypes + "ascii bigint blob counter frozen inet list map static text timeuuid tuple uuid varint",
        slashComments: true
      });
      var PLSQL = SQLDialect.define({
        keywords: SQLKeywords + "abort accept access add all alter and any arraylen as asc assert assign at attributes audit authorization avg base_table begin between binary_integer body by case cast char_base check close cluster clusters colauth column comment commit compress connected constant constraint crash create current currval cursor data_base database dba deallocate debugoff debugon declare default definition delay delete desc digits dispose distinct do drop else elseif elsif enable end entry exception exception_init exchange exclusive exists external fast fetch file for force form from function generic goto grant group having identified if immediate in increment index indexes indicator initial initrans insert interface intersect into is key level library like limited local lock log logging loop master maxextents maxtrans member minextents minus mislabel mode modify multiset new next no noaudit nocompress nologging noparallel not nowait number_base of off offline on online only option or order out package parallel partition pctfree pctincrease pctused pls_integer positive positiven pragma primary prior private privileges procedure public raise range raw rebuild record ref references refresh rename replace resource restrict return returning returns reverse revoke rollback row rowid rowlabel rownum rows run savepoint schema segment select separate set share snapshot some space split sql start statement storage subtype successful synonym tabauth table tables tablespace task terminate then to trigger truncate type union unique unlimited unrecoverable unusable update use using validate value values variable view views when whenever where while with work",
        builtin: "appinfo arraysize autocommit autoprint autorecovery autotrace blockterminator break btitle cmdsep colsep compatibility compute concat copycommit copytypecheck define echo editfile embedded feedback flagger flush heading headsep instance linesize lno loboffset logsource longchunksize markup native newpage numformat numwidth pagesize pause pno recsep recsepchar repfooter repheader serveroutput shiftinout show showmode spool sqlblanklines sqlcase sqlcode sqlcontinue sqlnumber sqlpluscompatibility sqlprefix sqlprompt sqlterminator suffix tab term termout timing trimout trimspool ttitle underline verify version wrap",
        types: SQLTypes + "ascii bfile bfilename bigserial bit blob dec long number nvarchar nvarchar2 serial smallint string text uid varchar2 xml",
        operatorChars: "*/+-%<>!=~",
        doubleQuotedStrings: true,
        charSetCasts: true
      });
      exports.Cassandra = Cassandra;
      exports.MSSQL = MSSQL;
      exports.MariaSQL = MariaSQL;
      exports.MySQL = MySQL;
      exports.PLSQL = PLSQL;
      exports.PostgreSQL = PostgreSQL;
      exports.SQLDialect = SQLDialect;
      exports.SQLite = SQLite;
      exports.StandardSQL = StandardSQL;
      exports.keywordCompletion = keywordCompletion;
      exports.keywordCompletionSource = keywordCompletionSource;
      exports.schemaCompletion = schemaCompletion;
      exports.schemaCompletionSource = schemaCompletionSource;
      exports.sql = sql2;
    }
  });

  // assets/js/app.js
  var $ = require_jquery();
  var Papa = require_papaparse_min();
  var L2 = require_leaflet_src();
  var { EditorView } = require_dist11();
  var { saveAs } = require_FileSaver_min();
  var bootstrap2 = require_bootstrap();
  require_bootstrap_table_min();
  require_();
  require_2();
  require_3();
  var { syntaxHighlighting, defaultHighlightStyle } = require_dist5();
  var { sql } = require_dist13();
  var MODALS = {};
  function modal(selector, options) {
    if (MODALS[selector]) {
      return MODALS[selector];
    }
    MODALS[selector] = new bootstrap2.Modal(document.querySelector(selector), options);
    return MODALS[selector];
  }
  function editorFromTextArea(textarea, extensions) {
    let view = new EditorView({ doc: textarea.value, extensions });
    textarea.parentNode.insertBefore(view.dom, textarea);
    textarea.style.display = "none";
    if (textarea.form)
      textarea.form.addEventListener("submit", () => {
        textarea.value = view.state.doc.toString();
      });
    return view;
  }
  function getCode() {
    return app.editor.state.doc.toString();
  }
  function setCode(code) {
    app.editor.dispatch({
      changes: { from: 0, to: app.editor.state.doc.length, insert: code }
    });
  }
  $(document).ready(function() {
    app.init();
    app.authModule.init();
    app.mapModule.init();
    app.queryModule.init();
  });
  var app = {
    editor: null,
    currentFields: null,
    currentRows: null,
    currentGeometryColumn: null,
    init: function() {
      this.bindUIActions();
      this.buildEditor();
      app.authModule.checkLogin();
    },
    bindUIActions: function() {
      $("#about-btn").click(function() {
        modal("#aboutModal").show();
        $(".navbar-collapse.in").collapse("hide");
        return false;
      });
      $(window).resize(function() {
        $("#table").bootstrapTable("resetView", {
          height: $(window).height() - 70
        });
      });
    },
    buildEditor: function() {
      app.editor = editorFromTextArea($("#query")[0], [
        sql(),
        syntaxHighlighting(defaultHighlightStyle),
        EditorView.updateListener.of((viewUpdate) => {
          if (viewUpdate.docChanged) {
          }
        })
      ]);
      console.log("apppppp", app.editor);
    },
    authModule: {
      init: function() {
        this.bindUIActions();
      },
      setupSession: function(token) {
        sessionStorage.setItem("fulcrum_query_token", btoa(token));
        setCode("SELECT * FROM tables;");
        $("#saved-queries-select").val("SELECT * FROM tables;");
        app.queryModule.executeQuery(1, {});
        app.queryModule.fetchQueries();
        modal("#loginModal").hide();
        $("#logout-btn").removeClass("hide");
      },
      bindUIActions: function() {
        function validateCredentials() {
          var $email = $("#email");
          var $password = $("#password");
          $email.val($email.val().trim());
          $password.val($password.val().trim());
          if (!($email.val().length && $password.val().length)) {
            alert("Please enter email and password");
          } else {
            app.authModule.login();
          }
          return false;
        }
        function validateToken() {
          var token = $("#token").val().trim();
          var instance = $("#instance").val();
          $.ajax({
            type: "GET",
            url: `${instance}/forms.json?page=1&per_page=1&schema=false`,
            contentType: "application/json",
            dataType: "json",
            headers: {
              "X-ApiToken": token
            },
            statusCode: {
              401: function() {
                alert("Invalid token, please try again.");
              }
            },
            success: function(data) {
              app.authModule.setupSession(token);
            }
          });
          return false;
        }
        $("#login-btn").click(validateCredentials);
        $(".login-form").on("submit", validateCredentials);
        $(".token-form").on("submit", validateToken);
        $("#logout-btn").click(function() {
          app.authModule.logout();
          return false;
        });
      },
      checkLogin: function() {
        if (!sessionStorage.getItem("fulcrum_query_token")) {
          modal("#loginModal").show();
          $(".modal-backdrop").css("opacity", "1");
        } else {
          $("#logout-btn").removeClass("hide");
          modal("#loginModal").hide();
          $(".modal-backdrop").css("opacity", "0.5");
          app.queryModule.fetchQueries();
          app.queryModule.initialQuery();
        }
      },
      login: function() {
        var username = $("#email").val();
        var password = $("#password").val();
        var instance = $("#instance").val();
        $.ajax({
          type: "GET",
          url: `${instance}/users.json`,
          contentType: "application/json",
          dataType: "json",
          headers: {
            "Authorization": "Basic " + btoa(username + ":" + password)
          },
          statusCode: {
            401: function() {
              alert("Incorrect credentials, please try again.");
            }
          },
          success: function(data) {
            $orgSelect = $("#context-select");
            contexts = $(data.user.contexts).sort(function(a, b) {
              return a.name.toLowerCase() > b.name.toLowerCase() ? 1 : -1;
            });
            contexts.each(function(i, context) {
              $orgSelect.append($("<option></option>").attr("value", context.id).prop("disabled", context.role.can_manage_authorizations ? false : true).text(context.name + (context.role.can_manage_authorizations ? "" : " (role does not have ability to manage API tokens)")));
            });
            $(".login-form :input").attr("disabled", "disabled");
            $(".org-picker-form").show();
          }
        });
      },
      logout: function() {
        sessionStorage.removeItem("fulcrum_query_token");
        location.reload();
      }
    },
    mapModule: {
      init: function() {
        this.buildMap();
        this.bindUIActions();
      },
      bindUIActions: function() {
        $("#map-btn").click(function() {
          if (app.currentRows && app.currentGeometryColumn) {
            modal("#mapModal").on("shown.bs.modal", function() {
              app.mapModule.map.invalidateSize();
              app.mapModule.mapData();
            });
            modal("#mapModal").show();
          } else {
            alert("Table must include geometry column!");
          }
          $(".navbar-collapse.in").collapse("hide");
          return false;
        });
      },
      points: L2.geoJson(null, {
        pointToLayer: function(feature, latlng) {
          return L2.marker(latlng, {
            icon: L2.icon({
              iconUrl: "assets/img/map-marker.png",
              iconSize: [30, 40],
              iconAnchor: [15, 32],
              popupAnchor: [0, -29]
            }),
            title: feature.properties._title ? feature.properties._title : "",
            riseOnHover: true
          });
        },
        onEachFeature: function(feature, layer) {
          if (feature.properties) {
            delete feature.properties.state;
            var attributes = [];
            $.each(feature.properties, function(index, property) {
              if (!property) {
                property = "";
              }
              if (typeof property == "string" && (JSON.stringify(property).indexOf("http") === true || JSON.stringify(property).indexOf("https") === true)) {
                property = "<a href='" + property + "' target='_blank'>" + property + "</a>";
              }
              attributes.push("<strong>" + index + "</strong>: " + property);
            });
            layer.bindPopup(attributes.join("<br>"), {
              maxHeight: 200,
              maxWidth: $("#map").width() / 2
            });
          }
        }
      }),
      basemap: L2.tileLayer("https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}.@2xpng", {
        attribution: '\xA9 <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, \xA9 <a href="https://carto.com/attribution">CARTO</a>'
      }),
      buildMap: function() {
        app.mapModule.map = L2.map("map", {
          layers: [app.mapModule.basemap, app.mapModule.points]
        }).fitWorld();
      },
      mapData: function() {
        var features = [];
        app.currentRows.forEach(function(row) {
          if (row[app.currentGeometryColumn]) {
            var properties = Object.assign({}, row);
            features.push({
              "type": "Feature",
              "properties": properties,
              "geometry": row[app.currentGeometryColumn]
            });
          }
        });
        var geojson = {
          "type": "FeatureCollection",
          "features": features
        };
        app.mapModule.points.clearLayers();
        app.mapModule.points.addData(geojson);
        app.mapModule.map.fitBounds(app.mapModule.points.getBounds());
      }
    },
    queryModule: {
      init: function() {
        this.bindUIActions();
      },
      bindUIActions: function() {
        $("#csv-upload-input").change(function(evt) {
          var file = evt.target.files[0];
          Papa.parse(file, {
            skipEmptyLines: true,
            header: true,
            dynamicTyping: true,
            complete: function(results) {
              localStorage.setItem("fulcrum_queries", JSON.stringify(results.data));
              app.queryModule.fetchQueries();
              setCode($("#saved-queries-select option:first-child").val());
              alert("Queries imported successfully!");
            }
          });
        });
        $("#sqlModal").on("shown.bs.modal", function(e) {
          app.editor.refresh();
        });
        $(".search > input").keyup(function() {
          $("#feature-count").html($("#table").bootstrapTable("getData").length + " records");
        });
        $("#saved-queries-select").change(function() {
          setCode($("#saved-queries-select").val());
        });
        $(".org-picker-form").submit(function() {
          var username = $("#email").val();
          var password = $("#password").val();
          var instance = $("#instance").val();
          var data = {
            authorization: {
              organization_id: $("#context-select").val(),
              note: "Fulcrum Query Utility",
              timeout: 60 * 60 * 24
            }
          };
          $.ajax({
            type: "POST",
            url: `${instance}/authorizations`,
            contentType: "application/json",
            data: JSON.stringify(data),
            dataType: "json",
            headers: {
              "Authorization": "Basic " + btoa(username + ":" + password)
            },
            statusCode: {
              401: function() {
                alert("Incorrect credentials, please try again.");
              }
            },
            success: function(data2) {
              app.authModule.setupSession(data2.authorization.token);
            }
          });
          return false;
        });
        $(".launch-query-btn").click(function() {
          modal("#sqlModal").show();
          return false;
        });
        $("#execute-query-btn").click(function() {
          app.queryModule.executeQuery(1, {});
          return false;
        });
        $("#save-query-btn").click(function() {
          if (getCode() !== "SELECT * FROM tables;") {
            app.queryModule.saveQuery();
          }
          return false;
        });
        $("#delete-query-btn").click(function() {
          if ($("#saved-queries-select option:selected").index() === 0) {
            alert("This query cannot be deleted!");
          } else {
            var ok = confirm("Are you sure you want to delete the following query: " + $("#saved-queries-select option:selected").text() + "?");
            if (ok === true) {
              app.queryModule.deleteQuery();
            }
            $("[data-toggle='dropdown']").parent().removeClass("open");
            return false;
          }
        });
        $("#export-queries-btn").click(function() {
          app.queryModule.exportQueries();
          $("[data-toggle='dropdown']").parent().removeClass("open");
          return false;
        });
        $("#import-queries-btn").click(function() {
          app.queryModule.importQueries();
          $("[data-toggle='dropdown']").parent().removeClass("open");
          return false;
        });
        $("#download-csv-btn").click(function() {
          var data = JSON.parse(JSON.stringify($("#table").bootstrapTable("getData")));
          for (var i = 0; i < data.length; i++) {
            for (var prop in data[i]) {
              if ($.type(data[i][prop]) === "object") {
                data[i][prop] = JSON.stringify(data[i][prop]);
              }
            }
          }
          var csv = Papa.unparse(data);
          var blob = new Blob([csv], {
            type: "text/csv"
          });
          saveAs(blob, "records.csv");
          $("[data-toggle='dropdown']").parent().removeClass("open");
          return false;
        });
        $("#download-json-btn").click(function() {
          var data = $("#table").bootstrapTable("getData");
          var json = JSON.stringify(data);
          var blob = new Blob([json], {
            type: "application/json"
          });
          saveAs(blob, "records.json");
          $("[data-toggle='dropdown']").parent().removeClass("open");
          return false;
        });
        $("#delete-records-btn").click(function() {
          var count = $("#table").bootstrapTable("getSelections").length;
          if (count > 0) {
            var response = confirm("Are you absolutely sure you want to permanently delete " + count + (count == 1 ? " record" : " records") + " from the Fulcrum database?\nThis cannot be undone!");
            if (response === true) {
              app.queryModule.deleteRecords();
            }
          }
          return false;
        });
      },
      fetchQueries: function() {
        if (localStorage.getItem("fulcrum_queries")) {
          var queries = JSON.parse(localStorage.getItem("fulcrum_queries"));
          queries = queries.filter(function(query) {
            return query.organization == $("#context-select option:selected").text();
          });
          queries = queries.sort(function(a, b) {
            return a.name.toLowerCase() > b.name.toLowerCase() ? 1 : -1;
          });
          $("#saved-queries-select").empty();
          $("#saved-queries-select").append($("<option></option>").attr("value", "SELECT * FROM tables;").text("All tables"));
          $.each(queries, function(index, value) {
            $("#saved-queries-select").append($("<option></option>").attr("value", value.query).attr("id", value.id).text(value.name));
          });
        }
      },
      executeQuery: function(page, result) {
        var query = getCode();
        var instance = $("#instance").val();
        if (query.length > 0) {
          $("#loading").show();
          $.ajax({
            type: "POST",
            url: `${instance}/query?per_page=10000&page=` + page,
            data: JSON.stringify({
              "q": query,
              "format": "json"
            }),
            contentType: "application/json",
            headers: {
              "X-ApiToken": atob(sessionStorage.getItem("fulcrum_query_token"))
            },
            success: function(data, status, xhr) {
              if (page == 1) {
                result = data;
                app.queryModule.executeQuery(page + 1, result);
              }
              if (data.rows.length == 0) {
                app.queryModule.parseQueryResponse(result);
              } else if (page != 1) {
                data.rows.forEach((x) => result.rows.push(x));
                app.queryModule.executeQuery(page + 1, result);
              }
            },
            error: function(jqXHR, textStatus, error) {
              app.currentFields = null;
              app.currentRows = null;
              $("#loading").hide();
              $("#error-alert").show();
              $("#error-message").html(jqXHR.responseText);
              modal("#sqlModal").show();
            },
            statusCode: {
              401: function() {
                alert("Session authorization expired");
                app.authModule.logout();
              }
            }
          });
        } else {
          alert("Query required!");
        }
      },
      saveQuery: function() {
        var name = prompt("Query name");
        if (name !== null) {
          var query = getCode();
          var queries;
          if (localStorage.getItem("fulcrum_queries")) {
            queries = JSON.parse(localStorage.getItem("fulcrum_queries"));
          } else {
            queries = [];
          }
          queries.push({
            "id": Date.now(),
            "organization": $("#context-select option:selected").text(),
            "name": name,
            "query": query
          });
          localStorage.setItem("fulcrum_queries", JSON.stringify(queries));
          app.queryModule.fetchQueries();
          $("#saved-queries-select").val(query);
        } else {
          alert("Query name is required!");
        }
      },
      deleteQuery: function() {
        var queries = JSON.parse(localStorage.getItem("fulcrum_queries"));
        queries = queries.filter(function(query) {
          return query.id != $("#saved-queries-select option:selected").attr("id");
        });
        localStorage.setItem("fulcrum_queries", JSON.stringify(queries));
        app.queryModule.fetchQueries();
        $("#saved-queries-select").val($("#saved-queries-select option:first-child").val());
        setCode($("#saved-queries-select option:first-child").val());
      },
      exportQueries: function() {
        var queries = JSON.parse(localStorage.getItem("fulcrum_queries"));
        queries = queries.sort(function(a, b) {
          return a.name.toLowerCase() > b.name.toLowerCase() ? 1 : -1;
        });
        var csv = Papa.unparse(queries);
        var blob = new Blob([csv], {
          type: "text/csv;charset=utf-8"
        });
        saveAs(blob, "queries.csv");
      },
      importQueries: function() {
        var ok = confirm("Imported queries will delete/overwrite any existing queries. Are you sure you want to proceed?");
        if (ok === true) {
          $("#csv-upload-input").trigger("click");
        }
      },
      initialQuery: function() {
        var urlParams = {};
        if (location.search) {
          var parts = location.search.substring(1).split("&");
          for (var i = 0; i < parts.length; i++) {
            var nv = parts[i].split("=");
            if (!nv[0])
              continue;
            urlParams[nv[0]] = nv[1] || true;
          }
        }
        if (urlParams.q) {
          setCode(decodeURI(urlParams.q));
          modal("#sqlModal").show();
          app.queryModule.executeQuery(1, {});
        } else {
          var savedQuery = sessionStorage.getItem("fulcrum_query_value");
          if (savedQuery) {
            setCode(savedQuery);
          } else {
            setCode("SELECT * FROM tables;");
            $("#saved-queries-select").val("SELECT * FROM tables;");
          }
          app.queryModule.executeQuery(1, {});
        }
      },
      urlFormatter: function(value, row, index) {
        if (value && value.length > 0) {
          value = value.replace(/</g, "&lt;").replace(/>/g, "&gt;");
          if (value.includes("type=photo")) {
            return "<img src='" + value + "'/>";
          } else {
            return "<a href='" + value + "' target='_blank'>" + value + "</a>";
          }
        } else {
          return "";
        }
      },
      fulcrumFormatter: function(value, row, index) {
        if (value && value.length > 0) {
          value = value.replace(/</g, "&lt;").replace(/>/g, "&gt;");
          return "<a href='https://web.fulcrumapp.com/records/" + value + "' target='_blank'>" + value + "</a>";
        } else {
          return "";
        }
      },
      stringFormatter: function(value, row, index) {
        if (value && value.length > 0) {
          value = value.replace(/</g, "&lt;").replace(/>/g, "&gt;");
          return value;
        }
      },
      geomFormatter: function(value, row, index) {
        if (value) {
          return JSON.stringify(value);
        } else {
          return "";
        }
      },
      parseQueryResponse: function(json) {
        var columns = [];
        app.currentFields = json.fields;
        app.currentRows = json.rows;
        app.currentGeometryColumn = null;
        json.fields.forEach(function(value, index) {
          if (value.type === "geometry" && app.currentGeometryColumn === null) {
            app.currentGeometryColumn = value.name;
            value.formatter = app.queryModule.geomFormatter;
          } else if (value.type == "string" || value.type == "unknown") {
            if (value.name == "_record_id" || value.name == "fulcrum_id") {
              value.formatter = app.queryModule.fulcrumFormatter;
              columns.push({
                field: "state",
                checkbox: true
              });
            } else {
              for (var i = 0; i < json.rows.length; i++) {
                if (json.rows[i][value.name] && JSON.stringify(json.rows[i][value.name]).indexOf("http") === 1) {
                  value.formatter = app.queryModule.urlFormatter;
                  if (JSON.stringify(json.rows[i][value.name]).includes("type=photo")) {
                    value.width = 250;
                  }
                } else {
                  value.formatter = app.queryModule.stringFormatter;
                }
              }
            }
          }
          columns.push({
            field: value.name,
            title: value.name,
            align: "left",
            valign: "middle",
            sortable: true,
            width: value.width ? value.width : "",
            formatter: value.formatter ? value.formatter : ""
          });
        });
        $("#table").bootstrapTable();
        $("#table").bootstrapTable("refreshOptions", {
          data: json.rows,
          virtualScroll: true,
          pagination: true,
          pageSize: 250,
          pageList: [100, 250, 500, 1e3],
          paginationUseIntermediate: true,
          columns,
          undefinedText: "",
          cache: false,
          height: "fit",
          toolbar: "#toolbar",
          showColumns: true,
          showToggle: true,
          search: true,
          trimOnSearch: false,
          striped: false,
          onSearch: function(e) {
            $("#feature-count").html($("#table").bootstrapTable("getData").length + " records");
          },
          onCheck: function(e) {
            $("#delete-records-btn").show();
            $("#delete-count").html($("#table").bootstrapTable("getSelections").length);
          },
          onCheckAll: function(e) {
            $("#delete-records-btn").show();
            $("#delete-count").html($("#table").bootstrapTable("getSelections").length);
          },
          onUncheck: function(e) {
            if ($("#table").bootstrapTable("getSelections").length === 0) {
              $("#delete-records-btn").hide();
            }
            $("#delete-count").html($("#table").bootstrapTable("getSelections").length);
          },
          onUncheckAll: function(e) {
            $("#delete-records-btn").hide();
          }
        });
        $("#table").bootstrapTable("resetView", {
          height: $(window).height() - 70
        });
        $("#feature-count").html($("#table").bootstrapTable("getData").length + " records");
        $("#toolbar").show();
        $("#error-alert").hide();
        $("#loading").hide();
      },
      deleteRecords: function() {
        var instance = $("#instance").val();
        var selections = $("#table").bootstrapTable("getSelections");
        var id = null, field = null;
        var deleted = 0;
        var notfound = [];
        var unauthorized = [];
        $.each(selections, function(index, value) {
          if (value._record_id) {
            field = "_record_id";
            id = value._record_id;
          } else if (value.fulcrum_id) {
            field = "fulcrum_id";
            id = value._record_id;
          }
          $.ajax({
            async: false,
            url: `${instance}/records/${id}.json`,
            type: "DELETE",
            contentType: "application/json",
            dataType: "json",
            headers: {
              "X-ApiToken": atob(sessionStorage.getItem("fulcrum_query_token"))
            },
            statusCode: {
              401: function() {
                unauthorized.push(id);
              },
              404: function() {
                notfound.push(id);
              },
              204: function() {
                $("#table").bootstrapTable("remove", {
                  field,
                  values: [id]
                });
                $("#feature-count").html($("#table").bootstrapTable("getData").length + " records");
                $("#delete-records-btn").hide();
                deleted++;
              }
            }
          });
        });
        if (unauthorized.length > 0) {
          alert("You were unauthorized to delete the following records: " + unauthorized.join("\n"));
        }
        if (notfound.length > 0) {
          alert("The following records were not found in your account: " + notfound.join("\n"));
        }
        if (deleted > 0) {
          alert(deleted + (deleted == 1 ? " record" : " records") + " deleted!");
        }
      }
    }
  };
})();
/* @license
Papa Parse
v5.3.2
https://github.com/mholt/PapaParse
License: MIT
*/
/* @preserve
 * Leaflet 1.8.0, a JS library for interactive maps. https://leafletjs.com
 * (c) 2010-2022 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */
/*!
  * Bootstrap v5.2.0 (https://getbootstrap.com/)
  * Copyright 2011-2022 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
/*!
 * jQuery JavaScript Library v3.6.0
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2021-03-02T17:08Z
 */
/**
  * bootstrap-table - An extended table to integration with some of the most widely used CSS frameworks. (Supports Bootstrap, Semantic UI, Bulma, Material Design, Foundation)
  *
  * @version v1.20.2
  * @homepage https://bootstrap-table.com
  * @author wenzhixin <wenzhixin2010@gmail.com> (http://wenzhixin.net.cn/)
  * @license MIT
  */
